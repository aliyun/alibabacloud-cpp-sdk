// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_BTRIPOPEN20220520_H_
#define ALIBABACLOUD_BTRIPOPEN20220520_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_BtripOpen20220520 {
class ModuleFlightItemListBestPriceItemFlightRuleInfosValue : public Darabonba::Model {
public:
  shared_ptr<string> refundChangeRuleDesc{};
  shared_ptr<string> baggageDesc{};

  ModuleFlightItemListBestPriceItemFlightRuleInfosValue() {}

  explicit ModuleFlightItemListBestPriceItemFlightRuleInfosValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (refundChangeRuleDesc) {
      res["refund_change_rule_desc"] = boost::any(*refundChangeRuleDesc);
    }
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("refund_change_rule_desc") != m.end() && !m["refund_change_rule_desc"].empty()) {
      refundChangeRuleDesc = make_shared<string>(boost::any_cast<string>(m["refund_change_rule_desc"]));
    }
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      baggageDesc = make_shared<string>(boost::any_cast<string>(m["baggage_desc"]));
    }
  }


  virtual ~ModuleFlightItemListBestPriceItemFlightRuleInfosValue() = default;
};
class ModuleFlightItemListBestPriceItemShoppingItemMapValueSearchPricePriceShowInfo : public Darabonba::Model {
public:
  shared_ptr<string> discountInfo{};
  shared_ptr<double> discountNum{};
  shared_ptr<bool> showTicketPrice{};

  ModuleFlightItemListBestPriceItemShoppingItemMapValueSearchPricePriceShowInfo() {}

  explicit ModuleFlightItemListBestPriceItemShoppingItemMapValueSearchPricePriceShowInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountInfo) {
      res["discount_info"] = boost::any(*discountInfo);
    }
    if (discountNum) {
      res["discount_num"] = boost::any(*discountNum);
    }
    if (showTicketPrice) {
      res["show_ticket_price"] = boost::any(*showTicketPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("discount_info") != m.end() && !m["discount_info"].empty()) {
      discountInfo = make_shared<string>(boost::any_cast<string>(m["discount_info"]));
    }
    if (m.find("discount_num") != m.end() && !m["discount_num"].empty()) {
      discountNum = make_shared<double>(boost::any_cast<double>(m["discount_num"]));
    }
    if (m.find("show_ticket_price") != m.end() && !m["show_ticket_price"].empty()) {
      showTicketPrice = make_shared<bool>(boost::any_cast<bool>(m["show_ticket_price"]));
    }
  }


  virtual ~ModuleFlightItemListBestPriceItemShoppingItemMapValueSearchPricePriceShowInfo() = default;
};
class ModuleFlightItemListBestPriceItemShoppingItemMapValueSearchPrice : public Darabonba::Model {
public:
  shared_ptr<long> floorPrice{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> sellPrice{};
  shared_ptr<long> originalSellPrice{};
  shared_ptr<long> baseTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> tax{};
  shared_ptr<long> supplyPrice{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> firstStandardPrice{};
  shared_ptr<long> businessStandardPrice{};
  shared_ptr<long> commonStandardPrice{};
  shared_ptr<long> interTicketPrice{};
  shared_ptr<long> subtractedPrice{};
  shared_ptr<long> originCommonPrice{};
  shared_ptr<long> dynamicPromotionPrice{};
  shared_ptr<long> installmentNum{};
  shared_ptr<double> installmentPrice{};
  shared_ptr<long> competitionDynamicPrice{};
  shared_ptr<long> competitionPromotionPrice{};
  shared_ptr<long> minBeforeControlPriceOfNormal{};
  shared_ptr<ModuleFlightItemListBestPriceItemShoppingItemMapValueSearchPricePriceShowInfo> priceShowInfo{};

  ModuleFlightItemListBestPriceItemShoppingItemMapValueSearchPrice() {}

  explicit ModuleFlightItemListBestPriceItemShoppingItemMapValueSearchPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (floorPrice) {
      res["floor_price"] = boost::any(*floorPrice);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (sellPrice) {
      res["sell_price"] = boost::any(*sellPrice);
    }
    if (originalSellPrice) {
      res["original_sell_price"] = boost::any(*originalSellPrice);
    }
    if (baseTotalPrice) {
      res["base_total_price"] = boost::any(*baseTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (tax) {
      res["tax"] = boost::any(*tax);
    }
    if (supplyPrice) {
      res["supply_price"] = boost::any(*supplyPrice);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (firstStandardPrice) {
      res["first_standard_price"] = boost::any(*firstStandardPrice);
    }
    if (businessStandardPrice) {
      res["business_standard_price"] = boost::any(*businessStandardPrice);
    }
    if (commonStandardPrice) {
      res["common_standard_price"] = boost::any(*commonStandardPrice);
    }
    if (interTicketPrice) {
      res["inter_ticket_price"] = boost::any(*interTicketPrice);
    }
    if (subtractedPrice) {
      res["subtracted_price"] = boost::any(*subtractedPrice);
    }
    if (originCommonPrice) {
      res["origin_common_price"] = boost::any(*originCommonPrice);
    }
    if (dynamicPromotionPrice) {
      res["dynamic_promotion_price"] = boost::any(*dynamicPromotionPrice);
    }
    if (installmentNum) {
      res["installment_num"] = boost::any(*installmentNum);
    }
    if (installmentPrice) {
      res["installment_price"] = boost::any(*installmentPrice);
    }
    if (competitionDynamicPrice) {
      res["competition_dynamic_price"] = boost::any(*competitionDynamicPrice);
    }
    if (competitionPromotionPrice) {
      res["competition_promotion_price"] = boost::any(*competitionPromotionPrice);
    }
    if (minBeforeControlPriceOfNormal) {
      res["min_before_control_price_of_normal"] = boost::any(*minBeforeControlPriceOfNormal);
    }
    if (priceShowInfo) {
      res["price_show_info"] = priceShowInfo ? boost::any(priceShowInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("floor_price") != m.end() && !m["floor_price"].empty()) {
      floorPrice = make_shared<long>(boost::any_cast<long>(m["floor_price"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("sell_price") != m.end() && !m["sell_price"].empty()) {
      sellPrice = make_shared<long>(boost::any_cast<long>(m["sell_price"]));
    }
    if (m.find("original_sell_price") != m.end() && !m["original_sell_price"].empty()) {
      originalSellPrice = make_shared<long>(boost::any_cast<long>(m["original_sell_price"]));
    }
    if (m.find("base_total_price") != m.end() && !m["base_total_price"].empty()) {
      baseTotalPrice = make_shared<long>(boost::any_cast<long>(m["base_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("tax") != m.end() && !m["tax"].empty()) {
      tax = make_shared<long>(boost::any_cast<long>(m["tax"]));
    }
    if (m.find("supply_price") != m.end() && !m["supply_price"].empty()) {
      supplyPrice = make_shared<long>(boost::any_cast<long>(m["supply_price"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("first_standard_price") != m.end() && !m["first_standard_price"].empty()) {
      firstStandardPrice = make_shared<long>(boost::any_cast<long>(m["first_standard_price"]));
    }
    if (m.find("business_standard_price") != m.end() && !m["business_standard_price"].empty()) {
      businessStandardPrice = make_shared<long>(boost::any_cast<long>(m["business_standard_price"]));
    }
    if (m.find("common_standard_price") != m.end() && !m["common_standard_price"].empty()) {
      commonStandardPrice = make_shared<long>(boost::any_cast<long>(m["common_standard_price"]));
    }
    if (m.find("inter_ticket_price") != m.end() && !m["inter_ticket_price"].empty()) {
      interTicketPrice = make_shared<long>(boost::any_cast<long>(m["inter_ticket_price"]));
    }
    if (m.find("subtracted_price") != m.end() && !m["subtracted_price"].empty()) {
      subtractedPrice = make_shared<long>(boost::any_cast<long>(m["subtracted_price"]));
    }
    if (m.find("origin_common_price") != m.end() && !m["origin_common_price"].empty()) {
      originCommonPrice = make_shared<long>(boost::any_cast<long>(m["origin_common_price"]));
    }
    if (m.find("dynamic_promotion_price") != m.end() && !m["dynamic_promotion_price"].empty()) {
      dynamicPromotionPrice = make_shared<long>(boost::any_cast<long>(m["dynamic_promotion_price"]));
    }
    if (m.find("installment_num") != m.end() && !m["installment_num"].empty()) {
      installmentNum = make_shared<long>(boost::any_cast<long>(m["installment_num"]));
    }
    if (m.find("installment_price") != m.end() && !m["installment_price"].empty()) {
      installmentPrice = make_shared<double>(boost::any_cast<double>(m["installment_price"]));
    }
    if (m.find("competition_dynamic_price") != m.end() && !m["competition_dynamic_price"].empty()) {
      competitionDynamicPrice = make_shared<long>(boost::any_cast<long>(m["competition_dynamic_price"]));
    }
    if (m.find("competition_promotion_price") != m.end() && !m["competition_promotion_price"].empty()) {
      competitionPromotionPrice = make_shared<long>(boost::any_cast<long>(m["competition_promotion_price"]));
    }
    if (m.find("min_before_control_price_of_normal") != m.end() && !m["min_before_control_price_of_normal"].empty()) {
      minBeforeControlPriceOfNormal = make_shared<long>(boost::any_cast<long>(m["min_before_control_price_of_normal"]));
    }
    if (m.find("price_show_info") != m.end() && !m["price_show_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_show_info"].type()) {
        ModuleFlightItemListBestPriceItemShoppingItemMapValueSearchPricePriceShowInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_show_info"]));
        priceShowInfo = make_shared<ModuleFlightItemListBestPriceItemShoppingItemMapValueSearchPricePriceShowInfo>(model1);
      }
    }
  }


  virtual ~ModuleFlightItemListBestPriceItemShoppingItemMapValueSearchPrice() = default;
};
class ModuleFlightItemListBestPriceItemShoppingItemMapValueCabinQuantityValue : public Darabonba::Model {
public:
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<string> cabinClassMemo{};
  shared_ptr<string> specification{};
  shared_ptr<string> quantity{};
  shared_ptr<vector<string>> linkCabins{};
  shared_ptr<bool> reshopChangeCabin{};
  shared_ptr<long> childCabinType{};
  shared_ptr<string> infantBasicCabin{};
  shared_ptr<long> innerCabinClass{};

  ModuleFlightItemListBestPriceItemShoppingItemMapValueCabinQuantityValue() {}

  explicit ModuleFlightItemListBestPriceItemShoppingItemMapValueCabinQuantityValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabin_class_name"] = boost::any(*cabinClassName);
    }
    if (cabinClassMemo) {
      res["cabin_class_memo"] = boost::any(*cabinClassMemo);
    }
    if (specification) {
      res["specification"] = boost::any(*specification);
    }
    if (quantity) {
      res["quantity"] = boost::any(*quantity);
    }
    if (linkCabins) {
      res["link_cabins"] = boost::any(*linkCabins);
    }
    if (reshopChangeCabin) {
      res["reshop_change_cabin"] = boost::any(*reshopChangeCabin);
    }
    if (childCabinType) {
      res["child_cabin_type"] = boost::any(*childCabinType);
    }
    if (infantBasicCabin) {
      res["infant_basic_cabin"] = boost::any(*infantBasicCabin);
    }
    if (innerCabinClass) {
      res["inner_cabin_class"] = boost::any(*innerCabinClass);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_class_name") != m.end() && !m["cabin_class_name"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabin_class_name"]));
    }
    if (m.find("cabin_class_memo") != m.end() && !m["cabin_class_memo"].empty()) {
      cabinClassMemo = make_shared<string>(boost::any_cast<string>(m["cabin_class_memo"]));
    }
    if (m.find("specification") != m.end() && !m["specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["specification"]));
    }
    if (m.find("quantity") != m.end() && !m["quantity"].empty()) {
      quantity = make_shared<string>(boost::any_cast<string>(m["quantity"]));
    }
    if (m.find("link_cabins") != m.end() && !m["link_cabins"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["link_cabins"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["link_cabins"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      linkCabins = make_shared<vector<string>>(toVec1);
    }
    if (m.find("reshop_change_cabin") != m.end() && !m["reshop_change_cabin"].empty()) {
      reshopChangeCabin = make_shared<bool>(boost::any_cast<bool>(m["reshop_change_cabin"]));
    }
    if (m.find("child_cabin_type") != m.end() && !m["child_cabin_type"].empty()) {
      childCabinType = make_shared<long>(boost::any_cast<long>(m["child_cabin_type"]));
    }
    if (m.find("infant_basic_cabin") != m.end() && !m["infant_basic_cabin"].empty()) {
      infantBasicCabin = make_shared<string>(boost::any_cast<string>(m["infant_basic_cabin"]));
    }
    if (m.find("inner_cabin_class") != m.end() && !m["inner_cabin_class"].empty()) {
      innerCabinClass = make_shared<long>(boost::any_cast<long>(m["inner_cabin_class"]));
    }
  }


  virtual ~ModuleFlightItemListBestPriceItemShoppingItemMapValueCabinQuantityValue() = default;
};
class ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValuePriceShowInfo : public Darabonba::Model {
public:
  shared_ptr<string> discountInfo{};
  shared_ptr<double> discountNum{};
  shared_ptr<bool> showTicketPrice{};

  ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValuePriceShowInfo() {}

  explicit ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValuePriceShowInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountInfo) {
      res["discount_info"] = boost::any(*discountInfo);
    }
    if (discountNum) {
      res["discount_num"] = boost::any(*discountNum);
    }
    if (showTicketPrice) {
      res["show_ticket_price"] = boost::any(*showTicketPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("discount_info") != m.end() && !m["discount_info"].empty()) {
      discountInfo = make_shared<string>(boost::any_cast<string>(m["discount_info"]));
    }
    if (m.find("discount_num") != m.end() && !m["discount_num"].empty()) {
      discountNum = make_shared<double>(boost::any_cast<double>(m["discount_num"]));
    }
    if (m.find("show_ticket_price") != m.end() && !m["show_ticket_price"].empty()) {
      showTicketPrice = make_shared<bool>(boost::any_cast<bool>(m["show_ticket_price"]));
    }
  }


  virtual ~ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValuePriceShowInfo() = default;
};
class ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValue : public Darabonba::Model {
public:
  shared_ptr<long> floorPrice{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> sellPrice{};
  shared_ptr<long> originalSellPrice{};
  shared_ptr<long> baseTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> tax{};
  shared_ptr<long> supplyPrice{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> firstStandardPrice{};
  shared_ptr<long> businessStandardPrice{};
  shared_ptr<long> commonStandardPrice{};
  shared_ptr<long> interTicketPrice{};
  shared_ptr<long> subtractedPrice{};
  shared_ptr<long> originCommonPrice{};
  shared_ptr<long> dynamicPromotionPrice{};
  shared_ptr<long> installmentNum{};
  shared_ptr<double> installmentPrice{};
  shared_ptr<long> competitionDynamicPrice{};
  shared_ptr<long> competitionPromotionPrice{};
  shared_ptr<long> minBeforeControlPriceOfNormal{};
  shared_ptr<ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValuePriceShowInfo> priceShowInfo{};

  ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValue() {}

  explicit ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (floorPrice) {
      res["floor_price"] = boost::any(*floorPrice);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (sellPrice) {
      res["sell_price"] = boost::any(*sellPrice);
    }
    if (originalSellPrice) {
      res["original_sell_price"] = boost::any(*originalSellPrice);
    }
    if (baseTotalPrice) {
      res["base_total_price"] = boost::any(*baseTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (tax) {
      res["tax"] = boost::any(*tax);
    }
    if (supplyPrice) {
      res["supply_price"] = boost::any(*supplyPrice);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (firstStandardPrice) {
      res["first_standard_price"] = boost::any(*firstStandardPrice);
    }
    if (businessStandardPrice) {
      res["business_standard_price"] = boost::any(*businessStandardPrice);
    }
    if (commonStandardPrice) {
      res["common_standard_price"] = boost::any(*commonStandardPrice);
    }
    if (interTicketPrice) {
      res["inter_ticket_price"] = boost::any(*interTicketPrice);
    }
    if (subtractedPrice) {
      res["subtracted_price"] = boost::any(*subtractedPrice);
    }
    if (originCommonPrice) {
      res["origin_common_price"] = boost::any(*originCommonPrice);
    }
    if (dynamicPromotionPrice) {
      res["dynamic_promotion_price"] = boost::any(*dynamicPromotionPrice);
    }
    if (installmentNum) {
      res["installment_num"] = boost::any(*installmentNum);
    }
    if (installmentPrice) {
      res["installment_price"] = boost::any(*installmentPrice);
    }
    if (competitionDynamicPrice) {
      res["competition_dynamic_price"] = boost::any(*competitionDynamicPrice);
    }
    if (competitionPromotionPrice) {
      res["competition_promotion_price"] = boost::any(*competitionPromotionPrice);
    }
    if (minBeforeControlPriceOfNormal) {
      res["min_before_control_price_of_normal"] = boost::any(*minBeforeControlPriceOfNormal);
    }
    if (priceShowInfo) {
      res["price_show_info"] = priceShowInfo ? boost::any(priceShowInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("floor_price") != m.end() && !m["floor_price"].empty()) {
      floorPrice = make_shared<long>(boost::any_cast<long>(m["floor_price"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("sell_price") != m.end() && !m["sell_price"].empty()) {
      sellPrice = make_shared<long>(boost::any_cast<long>(m["sell_price"]));
    }
    if (m.find("original_sell_price") != m.end() && !m["original_sell_price"].empty()) {
      originalSellPrice = make_shared<long>(boost::any_cast<long>(m["original_sell_price"]));
    }
    if (m.find("base_total_price") != m.end() && !m["base_total_price"].empty()) {
      baseTotalPrice = make_shared<long>(boost::any_cast<long>(m["base_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("tax") != m.end() && !m["tax"].empty()) {
      tax = make_shared<long>(boost::any_cast<long>(m["tax"]));
    }
    if (m.find("supply_price") != m.end() && !m["supply_price"].empty()) {
      supplyPrice = make_shared<long>(boost::any_cast<long>(m["supply_price"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("first_standard_price") != m.end() && !m["first_standard_price"].empty()) {
      firstStandardPrice = make_shared<long>(boost::any_cast<long>(m["first_standard_price"]));
    }
    if (m.find("business_standard_price") != m.end() && !m["business_standard_price"].empty()) {
      businessStandardPrice = make_shared<long>(boost::any_cast<long>(m["business_standard_price"]));
    }
    if (m.find("common_standard_price") != m.end() && !m["common_standard_price"].empty()) {
      commonStandardPrice = make_shared<long>(boost::any_cast<long>(m["common_standard_price"]));
    }
    if (m.find("inter_ticket_price") != m.end() && !m["inter_ticket_price"].empty()) {
      interTicketPrice = make_shared<long>(boost::any_cast<long>(m["inter_ticket_price"]));
    }
    if (m.find("subtracted_price") != m.end() && !m["subtracted_price"].empty()) {
      subtractedPrice = make_shared<long>(boost::any_cast<long>(m["subtracted_price"]));
    }
    if (m.find("origin_common_price") != m.end() && !m["origin_common_price"].empty()) {
      originCommonPrice = make_shared<long>(boost::any_cast<long>(m["origin_common_price"]));
    }
    if (m.find("dynamic_promotion_price") != m.end() && !m["dynamic_promotion_price"].empty()) {
      dynamicPromotionPrice = make_shared<long>(boost::any_cast<long>(m["dynamic_promotion_price"]));
    }
    if (m.find("installment_num") != m.end() && !m["installment_num"].empty()) {
      installmentNum = make_shared<long>(boost::any_cast<long>(m["installment_num"]));
    }
    if (m.find("installment_price") != m.end() && !m["installment_price"].empty()) {
      installmentPrice = make_shared<double>(boost::any_cast<double>(m["installment_price"]));
    }
    if (m.find("competition_dynamic_price") != m.end() && !m["competition_dynamic_price"].empty()) {
      competitionDynamicPrice = make_shared<long>(boost::any_cast<long>(m["competition_dynamic_price"]));
    }
    if (m.find("competition_promotion_price") != m.end() && !m["competition_promotion_price"].empty()) {
      competitionPromotionPrice = make_shared<long>(boost::any_cast<long>(m["competition_promotion_price"]));
    }
    if (m.find("min_before_control_price_of_normal") != m.end() && !m["min_before_control_price_of_normal"].empty()) {
      minBeforeControlPriceOfNormal = make_shared<long>(boost::any_cast<long>(m["min_before_control_price_of_normal"]));
    }
    if (m.find("price_show_info") != m.end() && !m["price_show_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_show_info"].type()) {
        ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValuePriceShowInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_show_info"]));
        priceShowInfo = make_shared<ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValuePriceShowInfo>(model1);
      }
    }
  }


  virtual ~ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValue() = default;
};
class ModuleFlightItemListBestPriceItemShoppingItemMapValue : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<map<string, ModuleFlightItemListBestPriceItemShoppingItemMapValueCabinQuantityValue>> cabinQuantity{};
  shared_ptr<ModuleFlightItemListBestPriceItemShoppingItemMapValueSearchPrice> searchPrice{};
  shared_ptr<map<string, ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValue>> segmentPrice{};

  ModuleFlightItemListBestPriceItemShoppingItemMapValue() {}

  explicit ModuleFlightItemListBestPriceItemShoppingItemMapValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (cabinQuantity) {
      map<string, boost::any> temp1;
      for(auto item1:*cabinQuantity){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["cabin_quantity"] = boost::any(temp1);
    }
    if (searchPrice) {
      res["search_price"] = searchPrice ? boost::any(searchPrice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segmentPrice) {
      map<string, boost::any> temp1;
      for(auto item1:*segmentPrice){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["segment_price"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("cabin_quantity") != m.end() && !m["cabin_quantity"].empty()) {
      if (typeid(map<string, boost::any>) == m["cabin_quantity"].type()) {
        map<string, ModuleFlightItemListBestPriceItemShoppingItemMapValueCabinQuantityValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["cabin_quantity"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleFlightItemListBestPriceItemShoppingItemMapValueCabinQuantityValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        cabinQuantity = make_shared<map<string, ModuleFlightItemListBestPriceItemShoppingItemMapValueCabinQuantityValue>>(expect1);
      }
    }
    if (m.find("search_price") != m.end() && !m["search_price"].empty()) {
      if (typeid(map<string, boost::any>) == m["search_price"].type()) {
        ModuleFlightItemListBestPriceItemShoppingItemMapValueSearchPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["search_price"]));
        searchPrice = make_shared<ModuleFlightItemListBestPriceItemShoppingItemMapValueSearchPrice>(model1);
      }
    }
    if (m.find("segment_price") != m.end() && !m["segment_price"].empty()) {
      if (typeid(map<string, boost::any>) == m["segment_price"].type()) {
        map<string, ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["segment_price"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        segmentPrice = make_shared<map<string, ModuleFlightItemListBestPriceItemShoppingItemMapValueSegmentPriceValue>>(expect1);
      }
    }
  }


  virtual ~ModuleFlightItemListBestPriceItemShoppingItemMapValue() = default;
};
class ModuleFlightItemListBestPriceItemSubItemPositionMapValue : public Darabonba::Model {
public:
  shared_ptr<long> journeyIndex{};
  shared_ptr<long> segmentIndex{};

  ModuleFlightItemListBestPriceItemSubItemPositionMapValue() {}

  explicit ModuleFlightItemListBestPriceItemSubItemPositionMapValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (journeyIndex) {
      res["journey_index"] = boost::any(*journeyIndex);
    }
    if (segmentIndex) {
      res["segment_index"] = boost::any(*segmentIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("journey_index") != m.end() && !m["journey_index"].empty()) {
      journeyIndex = make_shared<long>(boost::any_cast<long>(m["journey_index"]));
    }
    if (m.find("segment_index") != m.end() && !m["segment_index"].empty()) {
      segmentIndex = make_shared<long>(boost::any_cast<long>(m["segment_index"]));
    }
  }


  virtual ~ModuleFlightItemListBestPriceItemSubItemPositionMapValue() = default;
};
class ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSearchPricePriceShowInfo : public Darabonba::Model {
public:
  shared_ptr<string> discountInfo{};
  shared_ptr<double> discountNum{};
  shared_ptr<bool> showTicketPrice{};

  ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSearchPricePriceShowInfo() {}

  explicit ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSearchPricePriceShowInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountInfo) {
      res["discount_info"] = boost::any(*discountInfo);
    }
    if (discountNum) {
      res["discount_num"] = boost::any(*discountNum);
    }
    if (showTicketPrice) {
      res["show_ticket_price"] = boost::any(*showTicketPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("discount_info") != m.end() && !m["discount_info"].empty()) {
      discountInfo = make_shared<string>(boost::any_cast<string>(m["discount_info"]));
    }
    if (m.find("discount_num") != m.end() && !m["discount_num"].empty()) {
      discountNum = make_shared<double>(boost::any_cast<double>(m["discount_num"]));
    }
    if (m.find("show_ticket_price") != m.end() && !m["show_ticket_price"].empty()) {
      showTicketPrice = make_shared<bool>(boost::any_cast<bool>(m["show_ticket_price"]));
    }
  }


  virtual ~ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSearchPricePriceShowInfo() = default;
};
class ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSearchPrice : public Darabonba::Model {
public:
  shared_ptr<long> floorPrice{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> sellPrice{};
  shared_ptr<long> originalSellPrice{};
  shared_ptr<long> baseTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> tax{};
  shared_ptr<long> supplyPrice{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> firstStandardPrice{};
  shared_ptr<long> businessStandardPrice{};
  shared_ptr<long> commonStandardPrice{};
  shared_ptr<long> interTicketPrice{};
  shared_ptr<long> subtractedPrice{};
  shared_ptr<long> originCommonPrice{};
  shared_ptr<long> dynamicPromotionPrice{};
  shared_ptr<long> installmentNum{};
  shared_ptr<double> installmentPrice{};
  shared_ptr<long> competitionDynamicPrice{};
  shared_ptr<long> competitionPromotionPrice{};
  shared_ptr<long> minBeforeControlPriceOfNormal{};
  shared_ptr<ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSearchPricePriceShowInfo> priceShowInfo{};

  ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSearchPrice() {}

  explicit ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSearchPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (floorPrice) {
      res["floor_price"] = boost::any(*floorPrice);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (sellPrice) {
      res["sell_price"] = boost::any(*sellPrice);
    }
    if (originalSellPrice) {
      res["original_sell_price"] = boost::any(*originalSellPrice);
    }
    if (baseTotalPrice) {
      res["base_total_price"] = boost::any(*baseTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (tax) {
      res["tax"] = boost::any(*tax);
    }
    if (supplyPrice) {
      res["supply_price"] = boost::any(*supplyPrice);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (firstStandardPrice) {
      res["first_standard_price"] = boost::any(*firstStandardPrice);
    }
    if (businessStandardPrice) {
      res["business_standard_price"] = boost::any(*businessStandardPrice);
    }
    if (commonStandardPrice) {
      res["common_standard_price"] = boost::any(*commonStandardPrice);
    }
    if (interTicketPrice) {
      res["inter_ticket_price"] = boost::any(*interTicketPrice);
    }
    if (subtractedPrice) {
      res["subtracted_price"] = boost::any(*subtractedPrice);
    }
    if (originCommonPrice) {
      res["origin_common_price"] = boost::any(*originCommonPrice);
    }
    if (dynamicPromotionPrice) {
      res["dynamic_promotion_price"] = boost::any(*dynamicPromotionPrice);
    }
    if (installmentNum) {
      res["installment_num"] = boost::any(*installmentNum);
    }
    if (installmentPrice) {
      res["installment_price"] = boost::any(*installmentPrice);
    }
    if (competitionDynamicPrice) {
      res["competition_dynamic_price"] = boost::any(*competitionDynamicPrice);
    }
    if (competitionPromotionPrice) {
      res["competition_promotion_price"] = boost::any(*competitionPromotionPrice);
    }
    if (minBeforeControlPriceOfNormal) {
      res["min_before_control_price_of_normal"] = boost::any(*minBeforeControlPriceOfNormal);
    }
    if (priceShowInfo) {
      res["price_show_info"] = priceShowInfo ? boost::any(priceShowInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("floor_price") != m.end() && !m["floor_price"].empty()) {
      floorPrice = make_shared<long>(boost::any_cast<long>(m["floor_price"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("sell_price") != m.end() && !m["sell_price"].empty()) {
      sellPrice = make_shared<long>(boost::any_cast<long>(m["sell_price"]));
    }
    if (m.find("original_sell_price") != m.end() && !m["original_sell_price"].empty()) {
      originalSellPrice = make_shared<long>(boost::any_cast<long>(m["original_sell_price"]));
    }
    if (m.find("base_total_price") != m.end() && !m["base_total_price"].empty()) {
      baseTotalPrice = make_shared<long>(boost::any_cast<long>(m["base_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("tax") != m.end() && !m["tax"].empty()) {
      tax = make_shared<long>(boost::any_cast<long>(m["tax"]));
    }
    if (m.find("supply_price") != m.end() && !m["supply_price"].empty()) {
      supplyPrice = make_shared<long>(boost::any_cast<long>(m["supply_price"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("first_standard_price") != m.end() && !m["first_standard_price"].empty()) {
      firstStandardPrice = make_shared<long>(boost::any_cast<long>(m["first_standard_price"]));
    }
    if (m.find("business_standard_price") != m.end() && !m["business_standard_price"].empty()) {
      businessStandardPrice = make_shared<long>(boost::any_cast<long>(m["business_standard_price"]));
    }
    if (m.find("common_standard_price") != m.end() && !m["common_standard_price"].empty()) {
      commonStandardPrice = make_shared<long>(boost::any_cast<long>(m["common_standard_price"]));
    }
    if (m.find("inter_ticket_price") != m.end() && !m["inter_ticket_price"].empty()) {
      interTicketPrice = make_shared<long>(boost::any_cast<long>(m["inter_ticket_price"]));
    }
    if (m.find("subtracted_price") != m.end() && !m["subtracted_price"].empty()) {
      subtractedPrice = make_shared<long>(boost::any_cast<long>(m["subtracted_price"]));
    }
    if (m.find("origin_common_price") != m.end() && !m["origin_common_price"].empty()) {
      originCommonPrice = make_shared<long>(boost::any_cast<long>(m["origin_common_price"]));
    }
    if (m.find("dynamic_promotion_price") != m.end() && !m["dynamic_promotion_price"].empty()) {
      dynamicPromotionPrice = make_shared<long>(boost::any_cast<long>(m["dynamic_promotion_price"]));
    }
    if (m.find("installment_num") != m.end() && !m["installment_num"].empty()) {
      installmentNum = make_shared<long>(boost::any_cast<long>(m["installment_num"]));
    }
    if (m.find("installment_price") != m.end() && !m["installment_price"].empty()) {
      installmentPrice = make_shared<double>(boost::any_cast<double>(m["installment_price"]));
    }
    if (m.find("competition_dynamic_price") != m.end() && !m["competition_dynamic_price"].empty()) {
      competitionDynamicPrice = make_shared<long>(boost::any_cast<long>(m["competition_dynamic_price"]));
    }
    if (m.find("competition_promotion_price") != m.end() && !m["competition_promotion_price"].empty()) {
      competitionPromotionPrice = make_shared<long>(boost::any_cast<long>(m["competition_promotion_price"]));
    }
    if (m.find("min_before_control_price_of_normal") != m.end() && !m["min_before_control_price_of_normal"].empty()) {
      minBeforeControlPriceOfNormal = make_shared<long>(boost::any_cast<long>(m["min_before_control_price_of_normal"]));
    }
    if (m.find("price_show_info") != m.end() && !m["price_show_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_show_info"].type()) {
        ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSearchPricePriceShowInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_show_info"]));
        priceShowInfo = make_shared<ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSearchPricePriceShowInfo>(model1);
      }
    }
  }


  virtual ~ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSearchPrice() = default;
};
class ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueCabinQuantityValue : public Darabonba::Model {
public:
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<string> cabinClassMemo{};
  shared_ptr<string> specification{};
  shared_ptr<string> quantity{};
  shared_ptr<vector<string>> linkCabins{};
  shared_ptr<bool> reshopChangeCabin{};
  shared_ptr<long> childCabinType{};
  shared_ptr<string> infantBasicCabin{};
  shared_ptr<long> innerCabinClass{};

  ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueCabinQuantityValue() {}

  explicit ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueCabinQuantityValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabin_class_name"] = boost::any(*cabinClassName);
    }
    if (cabinClassMemo) {
      res["cabin_class_memo"] = boost::any(*cabinClassMemo);
    }
    if (specification) {
      res["specification"] = boost::any(*specification);
    }
    if (quantity) {
      res["quantity"] = boost::any(*quantity);
    }
    if (linkCabins) {
      res["link_cabins"] = boost::any(*linkCabins);
    }
    if (reshopChangeCabin) {
      res["reshop_change_cabin"] = boost::any(*reshopChangeCabin);
    }
    if (childCabinType) {
      res["child_cabin_type"] = boost::any(*childCabinType);
    }
    if (infantBasicCabin) {
      res["infant_basic_cabin"] = boost::any(*infantBasicCabin);
    }
    if (innerCabinClass) {
      res["inner_cabin_class"] = boost::any(*innerCabinClass);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_class_name") != m.end() && !m["cabin_class_name"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabin_class_name"]));
    }
    if (m.find("cabin_class_memo") != m.end() && !m["cabin_class_memo"].empty()) {
      cabinClassMemo = make_shared<string>(boost::any_cast<string>(m["cabin_class_memo"]));
    }
    if (m.find("specification") != m.end() && !m["specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["specification"]));
    }
    if (m.find("quantity") != m.end() && !m["quantity"].empty()) {
      quantity = make_shared<string>(boost::any_cast<string>(m["quantity"]));
    }
    if (m.find("link_cabins") != m.end() && !m["link_cabins"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["link_cabins"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["link_cabins"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      linkCabins = make_shared<vector<string>>(toVec1);
    }
    if (m.find("reshop_change_cabin") != m.end() && !m["reshop_change_cabin"].empty()) {
      reshopChangeCabin = make_shared<bool>(boost::any_cast<bool>(m["reshop_change_cabin"]));
    }
    if (m.find("child_cabin_type") != m.end() && !m["child_cabin_type"].empty()) {
      childCabinType = make_shared<long>(boost::any_cast<long>(m["child_cabin_type"]));
    }
    if (m.find("infant_basic_cabin") != m.end() && !m["infant_basic_cabin"].empty()) {
      infantBasicCabin = make_shared<string>(boost::any_cast<string>(m["infant_basic_cabin"]));
    }
    if (m.find("inner_cabin_class") != m.end() && !m["inner_cabin_class"].empty()) {
      innerCabinClass = make_shared<long>(boost::any_cast<long>(m["inner_cabin_class"]));
    }
  }


  virtual ~ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueCabinQuantityValue() = default;
};
class ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo : public Darabonba::Model {
public:
  shared_ptr<string> discountInfo{};
  shared_ptr<double> discountNum{};
  shared_ptr<bool> showTicketPrice{};

  ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo() {}

  explicit ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountInfo) {
      res["discount_info"] = boost::any(*discountInfo);
    }
    if (discountNum) {
      res["discount_num"] = boost::any(*discountNum);
    }
    if (showTicketPrice) {
      res["show_ticket_price"] = boost::any(*showTicketPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("discount_info") != m.end() && !m["discount_info"].empty()) {
      discountInfo = make_shared<string>(boost::any_cast<string>(m["discount_info"]));
    }
    if (m.find("discount_num") != m.end() && !m["discount_num"].empty()) {
      discountNum = make_shared<double>(boost::any_cast<double>(m["discount_num"]));
    }
    if (m.find("show_ticket_price") != m.end() && !m["show_ticket_price"].empty()) {
      showTicketPrice = make_shared<bool>(boost::any_cast<bool>(m["show_ticket_price"]));
    }
  }


  virtual ~ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo() = default;
};
class ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValue : public Darabonba::Model {
public:
  shared_ptr<long> floorPrice{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> sellPrice{};
  shared_ptr<long> originalSellPrice{};
  shared_ptr<long> baseTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> tax{};
  shared_ptr<long> supplyPrice{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> firstStandardPrice{};
  shared_ptr<long> businessStandardPrice{};
  shared_ptr<long> commonStandardPrice{};
  shared_ptr<long> interTicketPrice{};
  shared_ptr<long> subtractedPrice{};
  shared_ptr<long> originCommonPrice{};
  shared_ptr<long> dynamicPromotionPrice{};
  shared_ptr<long> installmentNum{};
  shared_ptr<double> installmentPrice{};
  shared_ptr<long> competitionDynamicPrice{};
  shared_ptr<long> competitionPromotionPrice{};
  shared_ptr<long> minBeforeControlPriceOfNormal{};
  shared_ptr<ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo> priceShowInfo{};

  ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValue() {}

  explicit ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (floorPrice) {
      res["floor_price"] = boost::any(*floorPrice);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (sellPrice) {
      res["sell_price"] = boost::any(*sellPrice);
    }
    if (originalSellPrice) {
      res["original_sell_price"] = boost::any(*originalSellPrice);
    }
    if (baseTotalPrice) {
      res["base_total_price"] = boost::any(*baseTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (tax) {
      res["tax"] = boost::any(*tax);
    }
    if (supplyPrice) {
      res["supply_price"] = boost::any(*supplyPrice);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (firstStandardPrice) {
      res["first_standard_price"] = boost::any(*firstStandardPrice);
    }
    if (businessStandardPrice) {
      res["business_standard_price"] = boost::any(*businessStandardPrice);
    }
    if (commonStandardPrice) {
      res["common_standard_price"] = boost::any(*commonStandardPrice);
    }
    if (interTicketPrice) {
      res["inter_ticket_price"] = boost::any(*interTicketPrice);
    }
    if (subtractedPrice) {
      res["subtracted_price"] = boost::any(*subtractedPrice);
    }
    if (originCommonPrice) {
      res["origin_common_price"] = boost::any(*originCommonPrice);
    }
    if (dynamicPromotionPrice) {
      res["dynamic_promotion_price"] = boost::any(*dynamicPromotionPrice);
    }
    if (installmentNum) {
      res["installment_num"] = boost::any(*installmentNum);
    }
    if (installmentPrice) {
      res["installment_price"] = boost::any(*installmentPrice);
    }
    if (competitionDynamicPrice) {
      res["competition_dynamic_price"] = boost::any(*competitionDynamicPrice);
    }
    if (competitionPromotionPrice) {
      res["competition_promotion_price"] = boost::any(*competitionPromotionPrice);
    }
    if (minBeforeControlPriceOfNormal) {
      res["min_before_control_price_of_normal"] = boost::any(*minBeforeControlPriceOfNormal);
    }
    if (priceShowInfo) {
      res["price_show_info"] = priceShowInfo ? boost::any(priceShowInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("floor_price") != m.end() && !m["floor_price"].empty()) {
      floorPrice = make_shared<long>(boost::any_cast<long>(m["floor_price"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("sell_price") != m.end() && !m["sell_price"].empty()) {
      sellPrice = make_shared<long>(boost::any_cast<long>(m["sell_price"]));
    }
    if (m.find("original_sell_price") != m.end() && !m["original_sell_price"].empty()) {
      originalSellPrice = make_shared<long>(boost::any_cast<long>(m["original_sell_price"]));
    }
    if (m.find("base_total_price") != m.end() && !m["base_total_price"].empty()) {
      baseTotalPrice = make_shared<long>(boost::any_cast<long>(m["base_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("tax") != m.end() && !m["tax"].empty()) {
      tax = make_shared<long>(boost::any_cast<long>(m["tax"]));
    }
    if (m.find("supply_price") != m.end() && !m["supply_price"].empty()) {
      supplyPrice = make_shared<long>(boost::any_cast<long>(m["supply_price"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("first_standard_price") != m.end() && !m["first_standard_price"].empty()) {
      firstStandardPrice = make_shared<long>(boost::any_cast<long>(m["first_standard_price"]));
    }
    if (m.find("business_standard_price") != m.end() && !m["business_standard_price"].empty()) {
      businessStandardPrice = make_shared<long>(boost::any_cast<long>(m["business_standard_price"]));
    }
    if (m.find("common_standard_price") != m.end() && !m["common_standard_price"].empty()) {
      commonStandardPrice = make_shared<long>(boost::any_cast<long>(m["common_standard_price"]));
    }
    if (m.find("inter_ticket_price") != m.end() && !m["inter_ticket_price"].empty()) {
      interTicketPrice = make_shared<long>(boost::any_cast<long>(m["inter_ticket_price"]));
    }
    if (m.find("subtracted_price") != m.end() && !m["subtracted_price"].empty()) {
      subtractedPrice = make_shared<long>(boost::any_cast<long>(m["subtracted_price"]));
    }
    if (m.find("origin_common_price") != m.end() && !m["origin_common_price"].empty()) {
      originCommonPrice = make_shared<long>(boost::any_cast<long>(m["origin_common_price"]));
    }
    if (m.find("dynamic_promotion_price") != m.end() && !m["dynamic_promotion_price"].empty()) {
      dynamicPromotionPrice = make_shared<long>(boost::any_cast<long>(m["dynamic_promotion_price"]));
    }
    if (m.find("installment_num") != m.end() && !m["installment_num"].empty()) {
      installmentNum = make_shared<long>(boost::any_cast<long>(m["installment_num"]));
    }
    if (m.find("installment_price") != m.end() && !m["installment_price"].empty()) {
      installmentPrice = make_shared<double>(boost::any_cast<double>(m["installment_price"]));
    }
    if (m.find("competition_dynamic_price") != m.end() && !m["competition_dynamic_price"].empty()) {
      competitionDynamicPrice = make_shared<long>(boost::any_cast<long>(m["competition_dynamic_price"]));
    }
    if (m.find("competition_promotion_price") != m.end() && !m["competition_promotion_price"].empty()) {
      competitionPromotionPrice = make_shared<long>(boost::any_cast<long>(m["competition_promotion_price"]));
    }
    if (m.find("min_before_control_price_of_normal") != m.end() && !m["min_before_control_price_of_normal"].empty()) {
      minBeforeControlPriceOfNormal = make_shared<long>(boost::any_cast<long>(m["min_before_control_price_of_normal"]));
    }
    if (m.find("price_show_info") != m.end() && !m["price_show_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_show_info"].type()) {
        ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_show_info"]));
        priceShowInfo = make_shared<ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo>(model1);
      }
    }
  }


  virtual ~ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValue() = default;
};
class ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValue : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<map<string, ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueCabinQuantityValue>> cabinQuantity{};
  shared_ptr<ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSearchPrice> searchPrice{};
  shared_ptr<map<string, ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValue>> segmentPrice{};

  ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValue() {}

  explicit ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (cabinQuantity) {
      map<string, boost::any> temp1;
      for(auto item1:*cabinQuantity){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["cabin_quantity"] = boost::any(temp1);
    }
    if (searchPrice) {
      res["search_price"] = searchPrice ? boost::any(searchPrice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segmentPrice) {
      map<string, boost::any> temp1;
      for(auto item1:*segmentPrice){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["segment_price"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("cabin_quantity") != m.end() && !m["cabin_quantity"].empty()) {
      if (typeid(map<string, boost::any>) == m["cabin_quantity"].type()) {
        map<string, ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueCabinQuantityValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["cabin_quantity"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueCabinQuantityValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        cabinQuantity = make_shared<map<string, ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueCabinQuantityValue>>(expect1);
      }
    }
    if (m.find("search_price") != m.end() && !m["search_price"].empty()) {
      if (typeid(map<string, boost::any>) == m["search_price"].type()) {
        ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSearchPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["search_price"]));
        searchPrice = make_shared<ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSearchPrice>(model1);
      }
    }
    if (m.find("segment_price") != m.end() && !m["segment_price"].empty()) {
      if (typeid(map<string, boost::any>) == m["segment_price"].type()) {
        map<string, ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["segment_price"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        segmentPrice = make_shared<map<string, ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValueSegmentPriceValue>>(expect1);
      }
    }
  }


  virtual ~ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValue() = default;
};
class ModuleFlightItemListItemListFlightRuleInfosValue : public Darabonba::Model {
public:
  shared_ptr<string> refundChangeRuleDesc{};
  shared_ptr<string> baggageDesc{};

  ModuleFlightItemListItemListFlightRuleInfosValue() {}

  explicit ModuleFlightItemListItemListFlightRuleInfosValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (refundChangeRuleDesc) {
      res["refund_change_rule_desc"] = boost::any(*refundChangeRuleDesc);
    }
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("refund_change_rule_desc") != m.end() && !m["refund_change_rule_desc"].empty()) {
      refundChangeRuleDesc = make_shared<string>(boost::any_cast<string>(m["refund_change_rule_desc"]));
    }
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      baggageDesc = make_shared<string>(boost::any_cast<string>(m["baggage_desc"]));
    }
  }


  virtual ~ModuleFlightItemListItemListFlightRuleInfosValue() = default;
};
class ModuleFlightItemListItemListShoppingItemMapValueSearchPricePriceShowInfo : public Darabonba::Model {
public:
  shared_ptr<string> discountInfo{};
  shared_ptr<double> discountNum{};
  shared_ptr<bool> showTicketPrice{};

  ModuleFlightItemListItemListShoppingItemMapValueSearchPricePriceShowInfo() {}

  explicit ModuleFlightItemListItemListShoppingItemMapValueSearchPricePriceShowInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountInfo) {
      res["discount_info"] = boost::any(*discountInfo);
    }
    if (discountNum) {
      res["discount_num"] = boost::any(*discountNum);
    }
    if (showTicketPrice) {
      res["show_ticket_price"] = boost::any(*showTicketPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("discount_info") != m.end() && !m["discount_info"].empty()) {
      discountInfo = make_shared<string>(boost::any_cast<string>(m["discount_info"]));
    }
    if (m.find("discount_num") != m.end() && !m["discount_num"].empty()) {
      discountNum = make_shared<double>(boost::any_cast<double>(m["discount_num"]));
    }
    if (m.find("show_ticket_price") != m.end() && !m["show_ticket_price"].empty()) {
      showTicketPrice = make_shared<bool>(boost::any_cast<bool>(m["show_ticket_price"]));
    }
  }


  virtual ~ModuleFlightItemListItemListShoppingItemMapValueSearchPricePriceShowInfo() = default;
};
class ModuleFlightItemListItemListShoppingItemMapValueSearchPrice : public Darabonba::Model {
public:
  shared_ptr<long> floorPrice{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> sellPrice{};
  shared_ptr<long> originalSellPrice{};
  shared_ptr<long> baseTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> tax{};
  shared_ptr<long> supplyPrice{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> firstStandardPrice{};
  shared_ptr<long> businessStandardPrice{};
  shared_ptr<long> commonStandardPrice{};
  shared_ptr<long> interTicketPrice{};
  shared_ptr<long> subtractedPrice{};
  shared_ptr<long> originCommonPrice{};
  shared_ptr<long> dynamicPromotionPrice{};
  shared_ptr<long> installmentNum{};
  shared_ptr<double> installmentPrice{};
  shared_ptr<long> competitionDynamicPrice{};
  shared_ptr<long> competitionPromotionPrice{};
  shared_ptr<long> minBeforeControlPriceOfNormal{};
  shared_ptr<ModuleFlightItemListItemListShoppingItemMapValueSearchPricePriceShowInfo> priceShowInfo{};

  ModuleFlightItemListItemListShoppingItemMapValueSearchPrice() {}

  explicit ModuleFlightItemListItemListShoppingItemMapValueSearchPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (floorPrice) {
      res["floor_price"] = boost::any(*floorPrice);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (sellPrice) {
      res["sell_price"] = boost::any(*sellPrice);
    }
    if (originalSellPrice) {
      res["original_sell_price"] = boost::any(*originalSellPrice);
    }
    if (baseTotalPrice) {
      res["base_total_price"] = boost::any(*baseTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (tax) {
      res["tax"] = boost::any(*tax);
    }
    if (supplyPrice) {
      res["supply_price"] = boost::any(*supplyPrice);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (firstStandardPrice) {
      res["first_standard_price"] = boost::any(*firstStandardPrice);
    }
    if (businessStandardPrice) {
      res["business_standard_price"] = boost::any(*businessStandardPrice);
    }
    if (commonStandardPrice) {
      res["common_standard_price"] = boost::any(*commonStandardPrice);
    }
    if (interTicketPrice) {
      res["inter_ticket_price"] = boost::any(*interTicketPrice);
    }
    if (subtractedPrice) {
      res["subtracted_price"] = boost::any(*subtractedPrice);
    }
    if (originCommonPrice) {
      res["origin_common_price"] = boost::any(*originCommonPrice);
    }
    if (dynamicPromotionPrice) {
      res["dynamic_promotion_price"] = boost::any(*dynamicPromotionPrice);
    }
    if (installmentNum) {
      res["installment_num"] = boost::any(*installmentNum);
    }
    if (installmentPrice) {
      res["installment_price"] = boost::any(*installmentPrice);
    }
    if (competitionDynamicPrice) {
      res["competition_dynamic_price"] = boost::any(*competitionDynamicPrice);
    }
    if (competitionPromotionPrice) {
      res["competition_promotion_price"] = boost::any(*competitionPromotionPrice);
    }
    if (minBeforeControlPriceOfNormal) {
      res["min_before_control_price_of_normal"] = boost::any(*minBeforeControlPriceOfNormal);
    }
    if (priceShowInfo) {
      res["price_show_info"] = priceShowInfo ? boost::any(priceShowInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("floor_price") != m.end() && !m["floor_price"].empty()) {
      floorPrice = make_shared<long>(boost::any_cast<long>(m["floor_price"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("sell_price") != m.end() && !m["sell_price"].empty()) {
      sellPrice = make_shared<long>(boost::any_cast<long>(m["sell_price"]));
    }
    if (m.find("original_sell_price") != m.end() && !m["original_sell_price"].empty()) {
      originalSellPrice = make_shared<long>(boost::any_cast<long>(m["original_sell_price"]));
    }
    if (m.find("base_total_price") != m.end() && !m["base_total_price"].empty()) {
      baseTotalPrice = make_shared<long>(boost::any_cast<long>(m["base_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("tax") != m.end() && !m["tax"].empty()) {
      tax = make_shared<long>(boost::any_cast<long>(m["tax"]));
    }
    if (m.find("supply_price") != m.end() && !m["supply_price"].empty()) {
      supplyPrice = make_shared<long>(boost::any_cast<long>(m["supply_price"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("first_standard_price") != m.end() && !m["first_standard_price"].empty()) {
      firstStandardPrice = make_shared<long>(boost::any_cast<long>(m["first_standard_price"]));
    }
    if (m.find("business_standard_price") != m.end() && !m["business_standard_price"].empty()) {
      businessStandardPrice = make_shared<long>(boost::any_cast<long>(m["business_standard_price"]));
    }
    if (m.find("common_standard_price") != m.end() && !m["common_standard_price"].empty()) {
      commonStandardPrice = make_shared<long>(boost::any_cast<long>(m["common_standard_price"]));
    }
    if (m.find("inter_ticket_price") != m.end() && !m["inter_ticket_price"].empty()) {
      interTicketPrice = make_shared<long>(boost::any_cast<long>(m["inter_ticket_price"]));
    }
    if (m.find("subtracted_price") != m.end() && !m["subtracted_price"].empty()) {
      subtractedPrice = make_shared<long>(boost::any_cast<long>(m["subtracted_price"]));
    }
    if (m.find("origin_common_price") != m.end() && !m["origin_common_price"].empty()) {
      originCommonPrice = make_shared<long>(boost::any_cast<long>(m["origin_common_price"]));
    }
    if (m.find("dynamic_promotion_price") != m.end() && !m["dynamic_promotion_price"].empty()) {
      dynamicPromotionPrice = make_shared<long>(boost::any_cast<long>(m["dynamic_promotion_price"]));
    }
    if (m.find("installment_num") != m.end() && !m["installment_num"].empty()) {
      installmentNum = make_shared<long>(boost::any_cast<long>(m["installment_num"]));
    }
    if (m.find("installment_price") != m.end() && !m["installment_price"].empty()) {
      installmentPrice = make_shared<double>(boost::any_cast<double>(m["installment_price"]));
    }
    if (m.find("competition_dynamic_price") != m.end() && !m["competition_dynamic_price"].empty()) {
      competitionDynamicPrice = make_shared<long>(boost::any_cast<long>(m["competition_dynamic_price"]));
    }
    if (m.find("competition_promotion_price") != m.end() && !m["competition_promotion_price"].empty()) {
      competitionPromotionPrice = make_shared<long>(boost::any_cast<long>(m["competition_promotion_price"]));
    }
    if (m.find("min_before_control_price_of_normal") != m.end() && !m["min_before_control_price_of_normal"].empty()) {
      minBeforeControlPriceOfNormal = make_shared<long>(boost::any_cast<long>(m["min_before_control_price_of_normal"]));
    }
    if (m.find("price_show_info") != m.end() && !m["price_show_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_show_info"].type()) {
        ModuleFlightItemListItemListShoppingItemMapValueSearchPricePriceShowInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_show_info"]));
        priceShowInfo = make_shared<ModuleFlightItemListItemListShoppingItemMapValueSearchPricePriceShowInfo>(model1);
      }
    }
  }


  virtual ~ModuleFlightItemListItemListShoppingItemMapValueSearchPrice() = default;
};
class ModuleFlightItemListItemListShoppingItemMapValueCabinQuantityValue : public Darabonba::Model {
public:
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<string> cabinClassMemo{};
  shared_ptr<string> specification{};
  shared_ptr<string> quantity{};
  shared_ptr<vector<string>> linkCabins{};
  shared_ptr<bool> reshopChangeCabin{};
  shared_ptr<long> childCabinType{};
  shared_ptr<string> infantBasicCabin{};
  shared_ptr<long> innerCabinClass{};

  ModuleFlightItemListItemListShoppingItemMapValueCabinQuantityValue() {}

  explicit ModuleFlightItemListItemListShoppingItemMapValueCabinQuantityValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabin_class_name"] = boost::any(*cabinClassName);
    }
    if (cabinClassMemo) {
      res["cabin_class_memo"] = boost::any(*cabinClassMemo);
    }
    if (specification) {
      res["specification"] = boost::any(*specification);
    }
    if (quantity) {
      res["quantity"] = boost::any(*quantity);
    }
    if (linkCabins) {
      res["link_cabins"] = boost::any(*linkCabins);
    }
    if (reshopChangeCabin) {
      res["reshop_change_cabin"] = boost::any(*reshopChangeCabin);
    }
    if (childCabinType) {
      res["child_cabin_type"] = boost::any(*childCabinType);
    }
    if (infantBasicCabin) {
      res["infant_basic_cabin"] = boost::any(*infantBasicCabin);
    }
    if (innerCabinClass) {
      res["inner_cabin_class"] = boost::any(*innerCabinClass);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_class_name") != m.end() && !m["cabin_class_name"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabin_class_name"]));
    }
    if (m.find("cabin_class_memo") != m.end() && !m["cabin_class_memo"].empty()) {
      cabinClassMemo = make_shared<string>(boost::any_cast<string>(m["cabin_class_memo"]));
    }
    if (m.find("specification") != m.end() && !m["specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["specification"]));
    }
    if (m.find("quantity") != m.end() && !m["quantity"].empty()) {
      quantity = make_shared<string>(boost::any_cast<string>(m["quantity"]));
    }
    if (m.find("link_cabins") != m.end() && !m["link_cabins"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["link_cabins"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["link_cabins"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      linkCabins = make_shared<vector<string>>(toVec1);
    }
    if (m.find("reshop_change_cabin") != m.end() && !m["reshop_change_cabin"].empty()) {
      reshopChangeCabin = make_shared<bool>(boost::any_cast<bool>(m["reshop_change_cabin"]));
    }
    if (m.find("child_cabin_type") != m.end() && !m["child_cabin_type"].empty()) {
      childCabinType = make_shared<long>(boost::any_cast<long>(m["child_cabin_type"]));
    }
    if (m.find("infant_basic_cabin") != m.end() && !m["infant_basic_cabin"].empty()) {
      infantBasicCabin = make_shared<string>(boost::any_cast<string>(m["infant_basic_cabin"]));
    }
    if (m.find("inner_cabin_class") != m.end() && !m["inner_cabin_class"].empty()) {
      innerCabinClass = make_shared<long>(boost::any_cast<long>(m["inner_cabin_class"]));
    }
  }


  virtual ~ModuleFlightItemListItemListShoppingItemMapValueCabinQuantityValue() = default;
};
class ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValuePriceShowInfo : public Darabonba::Model {
public:
  shared_ptr<string> discountInfo{};
  shared_ptr<double> discountNum{};
  shared_ptr<bool> showTicketPrice{};

  ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValuePriceShowInfo() {}

  explicit ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValuePriceShowInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountInfo) {
      res["discount_info"] = boost::any(*discountInfo);
    }
    if (discountNum) {
      res["discount_num"] = boost::any(*discountNum);
    }
    if (showTicketPrice) {
      res["show_ticket_price"] = boost::any(*showTicketPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("discount_info") != m.end() && !m["discount_info"].empty()) {
      discountInfo = make_shared<string>(boost::any_cast<string>(m["discount_info"]));
    }
    if (m.find("discount_num") != m.end() && !m["discount_num"].empty()) {
      discountNum = make_shared<double>(boost::any_cast<double>(m["discount_num"]));
    }
    if (m.find("show_ticket_price") != m.end() && !m["show_ticket_price"].empty()) {
      showTicketPrice = make_shared<bool>(boost::any_cast<bool>(m["show_ticket_price"]));
    }
  }


  virtual ~ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValuePriceShowInfo() = default;
};
class ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValue : public Darabonba::Model {
public:
  shared_ptr<long> floorPrice{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> sellPrice{};
  shared_ptr<long> originalSellPrice{};
  shared_ptr<long> baseTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> tax{};
  shared_ptr<long> supplyPrice{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> firstStandardPrice{};
  shared_ptr<long> businessStandardPrice{};
  shared_ptr<long> commonStandardPrice{};
  shared_ptr<long> interTicketPrice{};
  shared_ptr<long> subtractedPrice{};
  shared_ptr<long> originCommonPrice{};
  shared_ptr<long> dynamicPromotionPrice{};
  shared_ptr<long> installmentNum{};
  shared_ptr<double> installmentPrice{};
  shared_ptr<long> competitionDynamicPrice{};
  shared_ptr<long> competitionPromotionPrice{};
  shared_ptr<long> minBeforeControlPriceOfNormal{};
  shared_ptr<ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValuePriceShowInfo> priceShowInfo{};

  ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValue() {}

  explicit ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (floorPrice) {
      res["floor_price"] = boost::any(*floorPrice);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (sellPrice) {
      res["sell_price"] = boost::any(*sellPrice);
    }
    if (originalSellPrice) {
      res["original_sell_price"] = boost::any(*originalSellPrice);
    }
    if (baseTotalPrice) {
      res["base_total_price"] = boost::any(*baseTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (tax) {
      res["tax"] = boost::any(*tax);
    }
    if (supplyPrice) {
      res["supply_price"] = boost::any(*supplyPrice);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (firstStandardPrice) {
      res["first_standard_price"] = boost::any(*firstStandardPrice);
    }
    if (businessStandardPrice) {
      res["business_standard_price"] = boost::any(*businessStandardPrice);
    }
    if (commonStandardPrice) {
      res["common_standard_price"] = boost::any(*commonStandardPrice);
    }
    if (interTicketPrice) {
      res["inter_ticket_price"] = boost::any(*interTicketPrice);
    }
    if (subtractedPrice) {
      res["subtracted_price"] = boost::any(*subtractedPrice);
    }
    if (originCommonPrice) {
      res["origin_common_price"] = boost::any(*originCommonPrice);
    }
    if (dynamicPromotionPrice) {
      res["dynamic_promotion_price"] = boost::any(*dynamicPromotionPrice);
    }
    if (installmentNum) {
      res["installment_num"] = boost::any(*installmentNum);
    }
    if (installmentPrice) {
      res["installment_price"] = boost::any(*installmentPrice);
    }
    if (competitionDynamicPrice) {
      res["competition_dynamic_price"] = boost::any(*competitionDynamicPrice);
    }
    if (competitionPromotionPrice) {
      res["competition_promotion_price"] = boost::any(*competitionPromotionPrice);
    }
    if (minBeforeControlPriceOfNormal) {
      res["min_before_control_price_of_normal"] = boost::any(*minBeforeControlPriceOfNormal);
    }
    if (priceShowInfo) {
      res["price_show_info"] = priceShowInfo ? boost::any(priceShowInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("floor_price") != m.end() && !m["floor_price"].empty()) {
      floorPrice = make_shared<long>(boost::any_cast<long>(m["floor_price"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("sell_price") != m.end() && !m["sell_price"].empty()) {
      sellPrice = make_shared<long>(boost::any_cast<long>(m["sell_price"]));
    }
    if (m.find("original_sell_price") != m.end() && !m["original_sell_price"].empty()) {
      originalSellPrice = make_shared<long>(boost::any_cast<long>(m["original_sell_price"]));
    }
    if (m.find("base_total_price") != m.end() && !m["base_total_price"].empty()) {
      baseTotalPrice = make_shared<long>(boost::any_cast<long>(m["base_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("tax") != m.end() && !m["tax"].empty()) {
      tax = make_shared<long>(boost::any_cast<long>(m["tax"]));
    }
    if (m.find("supply_price") != m.end() && !m["supply_price"].empty()) {
      supplyPrice = make_shared<long>(boost::any_cast<long>(m["supply_price"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("first_standard_price") != m.end() && !m["first_standard_price"].empty()) {
      firstStandardPrice = make_shared<long>(boost::any_cast<long>(m["first_standard_price"]));
    }
    if (m.find("business_standard_price") != m.end() && !m["business_standard_price"].empty()) {
      businessStandardPrice = make_shared<long>(boost::any_cast<long>(m["business_standard_price"]));
    }
    if (m.find("common_standard_price") != m.end() && !m["common_standard_price"].empty()) {
      commonStandardPrice = make_shared<long>(boost::any_cast<long>(m["common_standard_price"]));
    }
    if (m.find("inter_ticket_price") != m.end() && !m["inter_ticket_price"].empty()) {
      interTicketPrice = make_shared<long>(boost::any_cast<long>(m["inter_ticket_price"]));
    }
    if (m.find("subtracted_price") != m.end() && !m["subtracted_price"].empty()) {
      subtractedPrice = make_shared<long>(boost::any_cast<long>(m["subtracted_price"]));
    }
    if (m.find("origin_common_price") != m.end() && !m["origin_common_price"].empty()) {
      originCommonPrice = make_shared<long>(boost::any_cast<long>(m["origin_common_price"]));
    }
    if (m.find("dynamic_promotion_price") != m.end() && !m["dynamic_promotion_price"].empty()) {
      dynamicPromotionPrice = make_shared<long>(boost::any_cast<long>(m["dynamic_promotion_price"]));
    }
    if (m.find("installment_num") != m.end() && !m["installment_num"].empty()) {
      installmentNum = make_shared<long>(boost::any_cast<long>(m["installment_num"]));
    }
    if (m.find("installment_price") != m.end() && !m["installment_price"].empty()) {
      installmentPrice = make_shared<double>(boost::any_cast<double>(m["installment_price"]));
    }
    if (m.find("competition_dynamic_price") != m.end() && !m["competition_dynamic_price"].empty()) {
      competitionDynamicPrice = make_shared<long>(boost::any_cast<long>(m["competition_dynamic_price"]));
    }
    if (m.find("competition_promotion_price") != m.end() && !m["competition_promotion_price"].empty()) {
      competitionPromotionPrice = make_shared<long>(boost::any_cast<long>(m["competition_promotion_price"]));
    }
    if (m.find("min_before_control_price_of_normal") != m.end() && !m["min_before_control_price_of_normal"].empty()) {
      minBeforeControlPriceOfNormal = make_shared<long>(boost::any_cast<long>(m["min_before_control_price_of_normal"]));
    }
    if (m.find("price_show_info") != m.end() && !m["price_show_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_show_info"].type()) {
        ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValuePriceShowInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_show_info"]));
        priceShowInfo = make_shared<ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValuePriceShowInfo>(model1);
      }
    }
  }


  virtual ~ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValue() = default;
};
class ModuleFlightItemListItemListShoppingItemMapValue : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<map<string, ModuleFlightItemListItemListShoppingItemMapValueCabinQuantityValue>> cabinQuantity{};
  shared_ptr<ModuleFlightItemListItemListShoppingItemMapValueSearchPrice> searchPrice{};
  shared_ptr<map<string, ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValue>> segmentPrice{};

  ModuleFlightItemListItemListShoppingItemMapValue() {}

  explicit ModuleFlightItemListItemListShoppingItemMapValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (cabinQuantity) {
      map<string, boost::any> temp1;
      for(auto item1:*cabinQuantity){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["cabin_quantity"] = boost::any(temp1);
    }
    if (searchPrice) {
      res["search_price"] = searchPrice ? boost::any(searchPrice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segmentPrice) {
      map<string, boost::any> temp1;
      for(auto item1:*segmentPrice){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["segment_price"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("cabin_quantity") != m.end() && !m["cabin_quantity"].empty()) {
      if (typeid(map<string, boost::any>) == m["cabin_quantity"].type()) {
        map<string, ModuleFlightItemListItemListShoppingItemMapValueCabinQuantityValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["cabin_quantity"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleFlightItemListItemListShoppingItemMapValueCabinQuantityValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        cabinQuantity = make_shared<map<string, ModuleFlightItemListItemListShoppingItemMapValueCabinQuantityValue>>(expect1);
      }
    }
    if (m.find("search_price") != m.end() && !m["search_price"].empty()) {
      if (typeid(map<string, boost::any>) == m["search_price"].type()) {
        ModuleFlightItemListItemListShoppingItemMapValueSearchPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["search_price"]));
        searchPrice = make_shared<ModuleFlightItemListItemListShoppingItemMapValueSearchPrice>(model1);
      }
    }
    if (m.find("segment_price") != m.end() && !m["segment_price"].empty()) {
      if (typeid(map<string, boost::any>) == m["segment_price"].type()) {
        map<string, ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["segment_price"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        segmentPrice = make_shared<map<string, ModuleFlightItemListItemListShoppingItemMapValueSegmentPriceValue>>(expect1);
      }
    }
  }


  virtual ~ModuleFlightItemListItemListShoppingItemMapValue() = default;
};
class ModuleFlightItemListItemListSubItemPositionMapValue : public Darabonba::Model {
public:
  shared_ptr<long> journeyIndex{};
  shared_ptr<long> segmentIndex{};

  ModuleFlightItemListItemListSubItemPositionMapValue() {}

  explicit ModuleFlightItemListItemListSubItemPositionMapValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (journeyIndex) {
      res["journey_index"] = boost::any(*journeyIndex);
    }
    if (segmentIndex) {
      res["segment_index"] = boost::any(*segmentIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("journey_index") != m.end() && !m["journey_index"].empty()) {
      journeyIndex = make_shared<long>(boost::any_cast<long>(m["journey_index"]));
    }
    if (m.find("segment_index") != m.end() && !m["segment_index"].empty()) {
      segmentIndex = make_shared<long>(boost::any_cast<long>(m["segment_index"]));
    }
  }


  virtual ~ModuleFlightItemListItemListSubItemPositionMapValue() = default;
};
class ModuleFlightItemListItemListSubItemsShoppingItemMapValueSearchPricePriceShowInfo : public Darabonba::Model {
public:
  shared_ptr<string> discountInfo{};
  shared_ptr<double> discountNum{};
  shared_ptr<bool> showTicketPrice{};

  ModuleFlightItemListItemListSubItemsShoppingItemMapValueSearchPricePriceShowInfo() {}

  explicit ModuleFlightItemListItemListSubItemsShoppingItemMapValueSearchPricePriceShowInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountInfo) {
      res["discount_info"] = boost::any(*discountInfo);
    }
    if (discountNum) {
      res["discount_num"] = boost::any(*discountNum);
    }
    if (showTicketPrice) {
      res["show_ticket_price"] = boost::any(*showTicketPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("discount_info") != m.end() && !m["discount_info"].empty()) {
      discountInfo = make_shared<string>(boost::any_cast<string>(m["discount_info"]));
    }
    if (m.find("discount_num") != m.end() && !m["discount_num"].empty()) {
      discountNum = make_shared<double>(boost::any_cast<double>(m["discount_num"]));
    }
    if (m.find("show_ticket_price") != m.end() && !m["show_ticket_price"].empty()) {
      showTicketPrice = make_shared<bool>(boost::any_cast<bool>(m["show_ticket_price"]));
    }
  }


  virtual ~ModuleFlightItemListItemListSubItemsShoppingItemMapValueSearchPricePriceShowInfo() = default;
};
class ModuleFlightItemListItemListSubItemsShoppingItemMapValueSearchPrice : public Darabonba::Model {
public:
  shared_ptr<long> floorPrice{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> sellPrice{};
  shared_ptr<long> originalSellPrice{};
  shared_ptr<long> baseTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> tax{};
  shared_ptr<long> supplyPrice{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> firstStandardPrice{};
  shared_ptr<long> businessStandardPrice{};
  shared_ptr<long> commonStandardPrice{};
  shared_ptr<long> interTicketPrice{};
  shared_ptr<long> subtractedPrice{};
  shared_ptr<long> originCommonPrice{};
  shared_ptr<long> dynamicPromotionPrice{};
  shared_ptr<long> installmentNum{};
  shared_ptr<double> installmentPrice{};
  shared_ptr<long> competitionDynamicPrice{};
  shared_ptr<long> competitionPromotionPrice{};
  shared_ptr<long> minBeforeControlPriceOfNormal{};
  shared_ptr<ModuleFlightItemListItemListSubItemsShoppingItemMapValueSearchPricePriceShowInfo> priceShowInfo{};

  ModuleFlightItemListItemListSubItemsShoppingItemMapValueSearchPrice() {}

  explicit ModuleFlightItemListItemListSubItemsShoppingItemMapValueSearchPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (floorPrice) {
      res["floor_price"] = boost::any(*floorPrice);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (sellPrice) {
      res["sell_price"] = boost::any(*sellPrice);
    }
    if (originalSellPrice) {
      res["original_sell_price"] = boost::any(*originalSellPrice);
    }
    if (baseTotalPrice) {
      res["base_total_price"] = boost::any(*baseTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (tax) {
      res["tax"] = boost::any(*tax);
    }
    if (supplyPrice) {
      res["supply_price"] = boost::any(*supplyPrice);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (firstStandardPrice) {
      res["first_standard_price"] = boost::any(*firstStandardPrice);
    }
    if (businessStandardPrice) {
      res["business_standard_price"] = boost::any(*businessStandardPrice);
    }
    if (commonStandardPrice) {
      res["common_standard_price"] = boost::any(*commonStandardPrice);
    }
    if (interTicketPrice) {
      res["inter_ticket_price"] = boost::any(*interTicketPrice);
    }
    if (subtractedPrice) {
      res["subtracted_price"] = boost::any(*subtractedPrice);
    }
    if (originCommonPrice) {
      res["origin_common_price"] = boost::any(*originCommonPrice);
    }
    if (dynamicPromotionPrice) {
      res["dynamic_promotion_price"] = boost::any(*dynamicPromotionPrice);
    }
    if (installmentNum) {
      res["installment_num"] = boost::any(*installmentNum);
    }
    if (installmentPrice) {
      res["installment_price"] = boost::any(*installmentPrice);
    }
    if (competitionDynamicPrice) {
      res["competition_dynamic_price"] = boost::any(*competitionDynamicPrice);
    }
    if (competitionPromotionPrice) {
      res["competition_promotion_price"] = boost::any(*competitionPromotionPrice);
    }
    if (minBeforeControlPriceOfNormal) {
      res["min_before_control_price_of_normal"] = boost::any(*minBeforeControlPriceOfNormal);
    }
    if (priceShowInfo) {
      res["price_show_info"] = priceShowInfo ? boost::any(priceShowInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("floor_price") != m.end() && !m["floor_price"].empty()) {
      floorPrice = make_shared<long>(boost::any_cast<long>(m["floor_price"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("sell_price") != m.end() && !m["sell_price"].empty()) {
      sellPrice = make_shared<long>(boost::any_cast<long>(m["sell_price"]));
    }
    if (m.find("original_sell_price") != m.end() && !m["original_sell_price"].empty()) {
      originalSellPrice = make_shared<long>(boost::any_cast<long>(m["original_sell_price"]));
    }
    if (m.find("base_total_price") != m.end() && !m["base_total_price"].empty()) {
      baseTotalPrice = make_shared<long>(boost::any_cast<long>(m["base_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("tax") != m.end() && !m["tax"].empty()) {
      tax = make_shared<long>(boost::any_cast<long>(m["tax"]));
    }
    if (m.find("supply_price") != m.end() && !m["supply_price"].empty()) {
      supplyPrice = make_shared<long>(boost::any_cast<long>(m["supply_price"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("first_standard_price") != m.end() && !m["first_standard_price"].empty()) {
      firstStandardPrice = make_shared<long>(boost::any_cast<long>(m["first_standard_price"]));
    }
    if (m.find("business_standard_price") != m.end() && !m["business_standard_price"].empty()) {
      businessStandardPrice = make_shared<long>(boost::any_cast<long>(m["business_standard_price"]));
    }
    if (m.find("common_standard_price") != m.end() && !m["common_standard_price"].empty()) {
      commonStandardPrice = make_shared<long>(boost::any_cast<long>(m["common_standard_price"]));
    }
    if (m.find("inter_ticket_price") != m.end() && !m["inter_ticket_price"].empty()) {
      interTicketPrice = make_shared<long>(boost::any_cast<long>(m["inter_ticket_price"]));
    }
    if (m.find("subtracted_price") != m.end() && !m["subtracted_price"].empty()) {
      subtractedPrice = make_shared<long>(boost::any_cast<long>(m["subtracted_price"]));
    }
    if (m.find("origin_common_price") != m.end() && !m["origin_common_price"].empty()) {
      originCommonPrice = make_shared<long>(boost::any_cast<long>(m["origin_common_price"]));
    }
    if (m.find("dynamic_promotion_price") != m.end() && !m["dynamic_promotion_price"].empty()) {
      dynamicPromotionPrice = make_shared<long>(boost::any_cast<long>(m["dynamic_promotion_price"]));
    }
    if (m.find("installment_num") != m.end() && !m["installment_num"].empty()) {
      installmentNum = make_shared<long>(boost::any_cast<long>(m["installment_num"]));
    }
    if (m.find("installment_price") != m.end() && !m["installment_price"].empty()) {
      installmentPrice = make_shared<double>(boost::any_cast<double>(m["installment_price"]));
    }
    if (m.find("competition_dynamic_price") != m.end() && !m["competition_dynamic_price"].empty()) {
      competitionDynamicPrice = make_shared<long>(boost::any_cast<long>(m["competition_dynamic_price"]));
    }
    if (m.find("competition_promotion_price") != m.end() && !m["competition_promotion_price"].empty()) {
      competitionPromotionPrice = make_shared<long>(boost::any_cast<long>(m["competition_promotion_price"]));
    }
    if (m.find("min_before_control_price_of_normal") != m.end() && !m["min_before_control_price_of_normal"].empty()) {
      minBeforeControlPriceOfNormal = make_shared<long>(boost::any_cast<long>(m["min_before_control_price_of_normal"]));
    }
    if (m.find("price_show_info") != m.end() && !m["price_show_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_show_info"].type()) {
        ModuleFlightItemListItemListSubItemsShoppingItemMapValueSearchPricePriceShowInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_show_info"]));
        priceShowInfo = make_shared<ModuleFlightItemListItemListSubItemsShoppingItemMapValueSearchPricePriceShowInfo>(model1);
      }
    }
  }


  virtual ~ModuleFlightItemListItemListSubItemsShoppingItemMapValueSearchPrice() = default;
};
class ModuleFlightItemListItemListSubItemsShoppingItemMapValueCabinQuantityValue : public Darabonba::Model {
public:
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<string> cabinClassMemo{};
  shared_ptr<string> specification{};
  shared_ptr<string> quantity{};
  shared_ptr<vector<string>> linkCabins{};
  shared_ptr<bool> reshopChangeCabin{};
  shared_ptr<long> childCabinType{};
  shared_ptr<string> infantBasicCabin{};
  shared_ptr<long> innerCabinClass{};

  ModuleFlightItemListItemListSubItemsShoppingItemMapValueCabinQuantityValue() {}

  explicit ModuleFlightItemListItemListSubItemsShoppingItemMapValueCabinQuantityValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabin_class_name"] = boost::any(*cabinClassName);
    }
    if (cabinClassMemo) {
      res["cabin_class_memo"] = boost::any(*cabinClassMemo);
    }
    if (specification) {
      res["specification"] = boost::any(*specification);
    }
    if (quantity) {
      res["quantity"] = boost::any(*quantity);
    }
    if (linkCabins) {
      res["link_cabins"] = boost::any(*linkCabins);
    }
    if (reshopChangeCabin) {
      res["reshop_change_cabin"] = boost::any(*reshopChangeCabin);
    }
    if (childCabinType) {
      res["child_cabin_type"] = boost::any(*childCabinType);
    }
    if (infantBasicCabin) {
      res["infant_basic_cabin"] = boost::any(*infantBasicCabin);
    }
    if (innerCabinClass) {
      res["inner_cabin_class"] = boost::any(*innerCabinClass);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_class_name") != m.end() && !m["cabin_class_name"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabin_class_name"]));
    }
    if (m.find("cabin_class_memo") != m.end() && !m["cabin_class_memo"].empty()) {
      cabinClassMemo = make_shared<string>(boost::any_cast<string>(m["cabin_class_memo"]));
    }
    if (m.find("specification") != m.end() && !m["specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["specification"]));
    }
    if (m.find("quantity") != m.end() && !m["quantity"].empty()) {
      quantity = make_shared<string>(boost::any_cast<string>(m["quantity"]));
    }
    if (m.find("link_cabins") != m.end() && !m["link_cabins"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["link_cabins"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["link_cabins"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      linkCabins = make_shared<vector<string>>(toVec1);
    }
    if (m.find("reshop_change_cabin") != m.end() && !m["reshop_change_cabin"].empty()) {
      reshopChangeCabin = make_shared<bool>(boost::any_cast<bool>(m["reshop_change_cabin"]));
    }
    if (m.find("child_cabin_type") != m.end() && !m["child_cabin_type"].empty()) {
      childCabinType = make_shared<long>(boost::any_cast<long>(m["child_cabin_type"]));
    }
    if (m.find("infant_basic_cabin") != m.end() && !m["infant_basic_cabin"].empty()) {
      infantBasicCabin = make_shared<string>(boost::any_cast<string>(m["infant_basic_cabin"]));
    }
    if (m.find("inner_cabin_class") != m.end() && !m["inner_cabin_class"].empty()) {
      innerCabinClass = make_shared<long>(boost::any_cast<long>(m["inner_cabin_class"]));
    }
  }


  virtual ~ModuleFlightItemListItemListSubItemsShoppingItemMapValueCabinQuantityValue() = default;
};
class ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo : public Darabonba::Model {
public:
  shared_ptr<string> discountInfo{};
  shared_ptr<double> discountNum{};
  shared_ptr<bool> showTicketPrice{};

  ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo() {}

  explicit ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountInfo) {
      res["discount_info"] = boost::any(*discountInfo);
    }
    if (discountNum) {
      res["discount_num"] = boost::any(*discountNum);
    }
    if (showTicketPrice) {
      res["show_ticket_price"] = boost::any(*showTicketPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("discount_info") != m.end() && !m["discount_info"].empty()) {
      discountInfo = make_shared<string>(boost::any_cast<string>(m["discount_info"]));
    }
    if (m.find("discount_num") != m.end() && !m["discount_num"].empty()) {
      discountNum = make_shared<double>(boost::any_cast<double>(m["discount_num"]));
    }
    if (m.find("show_ticket_price") != m.end() && !m["show_ticket_price"].empty()) {
      showTicketPrice = make_shared<bool>(boost::any_cast<bool>(m["show_ticket_price"]));
    }
  }


  virtual ~ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo() = default;
};
class ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValue : public Darabonba::Model {
public:
  shared_ptr<long> floorPrice{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> sellPrice{};
  shared_ptr<long> originalSellPrice{};
  shared_ptr<long> baseTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> tax{};
  shared_ptr<long> supplyPrice{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> firstStandardPrice{};
  shared_ptr<long> businessStandardPrice{};
  shared_ptr<long> commonStandardPrice{};
  shared_ptr<long> interTicketPrice{};
  shared_ptr<long> subtractedPrice{};
  shared_ptr<long> originCommonPrice{};
  shared_ptr<long> dynamicPromotionPrice{};
  shared_ptr<long> installmentNum{};
  shared_ptr<double> installmentPrice{};
  shared_ptr<long> competitionDynamicPrice{};
  shared_ptr<long> competitionPromotionPrice{};
  shared_ptr<long> minBeforeControlPriceOfNormal{};
  shared_ptr<ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo> priceShowInfo{};

  ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValue() {}

  explicit ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (floorPrice) {
      res["floor_price"] = boost::any(*floorPrice);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (sellPrice) {
      res["sell_price"] = boost::any(*sellPrice);
    }
    if (originalSellPrice) {
      res["original_sell_price"] = boost::any(*originalSellPrice);
    }
    if (baseTotalPrice) {
      res["base_total_price"] = boost::any(*baseTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (tax) {
      res["tax"] = boost::any(*tax);
    }
    if (supplyPrice) {
      res["supply_price"] = boost::any(*supplyPrice);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (firstStandardPrice) {
      res["first_standard_price"] = boost::any(*firstStandardPrice);
    }
    if (businessStandardPrice) {
      res["business_standard_price"] = boost::any(*businessStandardPrice);
    }
    if (commonStandardPrice) {
      res["common_standard_price"] = boost::any(*commonStandardPrice);
    }
    if (interTicketPrice) {
      res["inter_ticket_price"] = boost::any(*interTicketPrice);
    }
    if (subtractedPrice) {
      res["subtracted_price"] = boost::any(*subtractedPrice);
    }
    if (originCommonPrice) {
      res["origin_common_price"] = boost::any(*originCommonPrice);
    }
    if (dynamicPromotionPrice) {
      res["dynamic_promotion_price"] = boost::any(*dynamicPromotionPrice);
    }
    if (installmentNum) {
      res["installment_num"] = boost::any(*installmentNum);
    }
    if (installmentPrice) {
      res["installment_price"] = boost::any(*installmentPrice);
    }
    if (competitionDynamicPrice) {
      res["competition_dynamic_price"] = boost::any(*competitionDynamicPrice);
    }
    if (competitionPromotionPrice) {
      res["competition_promotion_price"] = boost::any(*competitionPromotionPrice);
    }
    if (minBeforeControlPriceOfNormal) {
      res["min_before_control_price_of_normal"] = boost::any(*minBeforeControlPriceOfNormal);
    }
    if (priceShowInfo) {
      res["price_show_info"] = priceShowInfo ? boost::any(priceShowInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("floor_price") != m.end() && !m["floor_price"].empty()) {
      floorPrice = make_shared<long>(boost::any_cast<long>(m["floor_price"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("sell_price") != m.end() && !m["sell_price"].empty()) {
      sellPrice = make_shared<long>(boost::any_cast<long>(m["sell_price"]));
    }
    if (m.find("original_sell_price") != m.end() && !m["original_sell_price"].empty()) {
      originalSellPrice = make_shared<long>(boost::any_cast<long>(m["original_sell_price"]));
    }
    if (m.find("base_total_price") != m.end() && !m["base_total_price"].empty()) {
      baseTotalPrice = make_shared<long>(boost::any_cast<long>(m["base_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("tax") != m.end() && !m["tax"].empty()) {
      tax = make_shared<long>(boost::any_cast<long>(m["tax"]));
    }
    if (m.find("supply_price") != m.end() && !m["supply_price"].empty()) {
      supplyPrice = make_shared<long>(boost::any_cast<long>(m["supply_price"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("first_standard_price") != m.end() && !m["first_standard_price"].empty()) {
      firstStandardPrice = make_shared<long>(boost::any_cast<long>(m["first_standard_price"]));
    }
    if (m.find("business_standard_price") != m.end() && !m["business_standard_price"].empty()) {
      businessStandardPrice = make_shared<long>(boost::any_cast<long>(m["business_standard_price"]));
    }
    if (m.find("common_standard_price") != m.end() && !m["common_standard_price"].empty()) {
      commonStandardPrice = make_shared<long>(boost::any_cast<long>(m["common_standard_price"]));
    }
    if (m.find("inter_ticket_price") != m.end() && !m["inter_ticket_price"].empty()) {
      interTicketPrice = make_shared<long>(boost::any_cast<long>(m["inter_ticket_price"]));
    }
    if (m.find("subtracted_price") != m.end() && !m["subtracted_price"].empty()) {
      subtractedPrice = make_shared<long>(boost::any_cast<long>(m["subtracted_price"]));
    }
    if (m.find("origin_common_price") != m.end() && !m["origin_common_price"].empty()) {
      originCommonPrice = make_shared<long>(boost::any_cast<long>(m["origin_common_price"]));
    }
    if (m.find("dynamic_promotion_price") != m.end() && !m["dynamic_promotion_price"].empty()) {
      dynamicPromotionPrice = make_shared<long>(boost::any_cast<long>(m["dynamic_promotion_price"]));
    }
    if (m.find("installment_num") != m.end() && !m["installment_num"].empty()) {
      installmentNum = make_shared<long>(boost::any_cast<long>(m["installment_num"]));
    }
    if (m.find("installment_price") != m.end() && !m["installment_price"].empty()) {
      installmentPrice = make_shared<double>(boost::any_cast<double>(m["installment_price"]));
    }
    if (m.find("competition_dynamic_price") != m.end() && !m["competition_dynamic_price"].empty()) {
      competitionDynamicPrice = make_shared<long>(boost::any_cast<long>(m["competition_dynamic_price"]));
    }
    if (m.find("competition_promotion_price") != m.end() && !m["competition_promotion_price"].empty()) {
      competitionPromotionPrice = make_shared<long>(boost::any_cast<long>(m["competition_promotion_price"]));
    }
    if (m.find("min_before_control_price_of_normal") != m.end() && !m["min_before_control_price_of_normal"].empty()) {
      minBeforeControlPriceOfNormal = make_shared<long>(boost::any_cast<long>(m["min_before_control_price_of_normal"]));
    }
    if (m.find("price_show_info") != m.end() && !m["price_show_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_show_info"].type()) {
        ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_show_info"]));
        priceShowInfo = make_shared<ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo>(model1);
      }
    }
  }


  virtual ~ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValue() = default;
};
class ModuleFlightItemListItemListSubItemsShoppingItemMapValue : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<map<string, ModuleFlightItemListItemListSubItemsShoppingItemMapValueCabinQuantityValue>> cabinQuantity{};
  shared_ptr<ModuleFlightItemListItemListSubItemsShoppingItemMapValueSearchPrice> searchPrice{};
  shared_ptr<map<string, ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValue>> segmentPrice{};

  ModuleFlightItemListItemListSubItemsShoppingItemMapValue() {}

  explicit ModuleFlightItemListItemListSubItemsShoppingItemMapValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (cabinQuantity) {
      map<string, boost::any> temp1;
      for(auto item1:*cabinQuantity){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["cabin_quantity"] = boost::any(temp1);
    }
    if (searchPrice) {
      res["search_price"] = searchPrice ? boost::any(searchPrice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segmentPrice) {
      map<string, boost::any> temp1;
      for(auto item1:*segmentPrice){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["segment_price"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("cabin_quantity") != m.end() && !m["cabin_quantity"].empty()) {
      if (typeid(map<string, boost::any>) == m["cabin_quantity"].type()) {
        map<string, ModuleFlightItemListItemListSubItemsShoppingItemMapValueCabinQuantityValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["cabin_quantity"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleFlightItemListItemListSubItemsShoppingItemMapValueCabinQuantityValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        cabinQuantity = make_shared<map<string, ModuleFlightItemListItemListSubItemsShoppingItemMapValueCabinQuantityValue>>(expect1);
      }
    }
    if (m.find("search_price") != m.end() && !m["search_price"].empty()) {
      if (typeid(map<string, boost::any>) == m["search_price"].type()) {
        ModuleFlightItemListItemListSubItemsShoppingItemMapValueSearchPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["search_price"]));
        searchPrice = make_shared<ModuleFlightItemListItemListSubItemsShoppingItemMapValueSearchPrice>(model1);
      }
    }
    if (m.find("segment_price") != m.end() && !m["segment_price"].empty()) {
      if (typeid(map<string, boost::any>) == m["segment_price"].type()) {
        map<string, ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["segment_price"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        segmentPrice = make_shared<map<string, ModuleFlightItemListItemListSubItemsShoppingItemMapValueSegmentPriceValue>>(expect1);
      }
    }
  }


  virtual ~ModuleFlightItemListItemListSubItemsShoppingItemMapValue() = default;
};
class ModuleAgentInfoAttributeShowInfoMapValue : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};
  shared_ptr<string> text{};

  ModuleAgentInfoAttributeShowInfoMapValue() {}

  explicit ModuleAgentInfoAttributeShowInfoMapValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
  }


  virtual ~ModuleAgentInfoAttributeShowInfoMapValue() = default;
};
class ModuleItemListFlightRuleInfosValue : public Darabonba::Model {
public:
  shared_ptr<string> refundChangeRuleDesc{};
  shared_ptr<string> baggageDesc{};

  ModuleItemListFlightRuleInfosValue() {}

  explicit ModuleItemListFlightRuleInfosValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (refundChangeRuleDesc) {
      res["refund_change_rule_desc"] = boost::any(*refundChangeRuleDesc);
    }
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("refund_change_rule_desc") != m.end() && !m["refund_change_rule_desc"].empty()) {
      refundChangeRuleDesc = make_shared<string>(boost::any_cast<string>(m["refund_change_rule_desc"]));
    }
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      baggageDesc = make_shared<string>(boost::any_cast<string>(m["baggage_desc"]));
    }
  }


  virtual ~ModuleItemListFlightRuleInfosValue() = default;
};
class ModuleItemListShoppingItemMapValueSearchPricePriceShowInfo : public Darabonba::Model {
public:
  shared_ptr<string> discountInfo{};
  shared_ptr<double> discountNum{};
  shared_ptr<bool> showTicketPrice{};

  ModuleItemListShoppingItemMapValueSearchPricePriceShowInfo() {}

  explicit ModuleItemListShoppingItemMapValueSearchPricePriceShowInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountInfo) {
      res["discount_info"] = boost::any(*discountInfo);
    }
    if (discountNum) {
      res["discount_num"] = boost::any(*discountNum);
    }
    if (showTicketPrice) {
      res["show_ticket_price"] = boost::any(*showTicketPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("discount_info") != m.end() && !m["discount_info"].empty()) {
      discountInfo = make_shared<string>(boost::any_cast<string>(m["discount_info"]));
    }
    if (m.find("discount_num") != m.end() && !m["discount_num"].empty()) {
      discountNum = make_shared<double>(boost::any_cast<double>(m["discount_num"]));
    }
    if (m.find("show_ticket_price") != m.end() && !m["show_ticket_price"].empty()) {
      showTicketPrice = make_shared<bool>(boost::any_cast<bool>(m["show_ticket_price"]));
    }
  }


  virtual ~ModuleItemListShoppingItemMapValueSearchPricePriceShowInfo() = default;
};
class ModuleItemListShoppingItemMapValueSearchPrice : public Darabonba::Model {
public:
  shared_ptr<long> floorPrice{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> sellPrice{};
  shared_ptr<long> originalSellPrice{};
  shared_ptr<long> baseTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> tax{};
  shared_ptr<long> supplyPrice{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> firstStandardPrice{};
  shared_ptr<long> businessStandardPrice{};
  shared_ptr<long> commonStandardPrice{};
  shared_ptr<long> interTicketPrice{};
  shared_ptr<long> subtractedPrice{};
  shared_ptr<long> originCommonPrice{};
  shared_ptr<long> dynamicPromotionPrice{};
  shared_ptr<long> installmentNum{};
  shared_ptr<double> installmentPrice{};
  shared_ptr<long> competitionDynamicPrice{};
  shared_ptr<long> competitionPromotionPrice{};
  shared_ptr<long> minBeforeControlPriceOfNormal{};
  shared_ptr<ModuleItemListShoppingItemMapValueSearchPricePriceShowInfo> priceShowInfo{};

  ModuleItemListShoppingItemMapValueSearchPrice() {}

  explicit ModuleItemListShoppingItemMapValueSearchPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (floorPrice) {
      res["floor_price"] = boost::any(*floorPrice);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (sellPrice) {
      res["sell_price"] = boost::any(*sellPrice);
    }
    if (originalSellPrice) {
      res["original_sell_price"] = boost::any(*originalSellPrice);
    }
    if (baseTotalPrice) {
      res["base_total_price"] = boost::any(*baseTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (tax) {
      res["tax"] = boost::any(*tax);
    }
    if (supplyPrice) {
      res["supply_price"] = boost::any(*supplyPrice);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (firstStandardPrice) {
      res["first_standard_price"] = boost::any(*firstStandardPrice);
    }
    if (businessStandardPrice) {
      res["business_standard_price"] = boost::any(*businessStandardPrice);
    }
    if (commonStandardPrice) {
      res["common_standard_price"] = boost::any(*commonStandardPrice);
    }
    if (interTicketPrice) {
      res["inter_ticket_price"] = boost::any(*interTicketPrice);
    }
    if (subtractedPrice) {
      res["subtracted_price"] = boost::any(*subtractedPrice);
    }
    if (originCommonPrice) {
      res["origin_common_price"] = boost::any(*originCommonPrice);
    }
    if (dynamicPromotionPrice) {
      res["dynamic_promotion_price"] = boost::any(*dynamicPromotionPrice);
    }
    if (installmentNum) {
      res["installment_num"] = boost::any(*installmentNum);
    }
    if (installmentPrice) {
      res["installment_price"] = boost::any(*installmentPrice);
    }
    if (competitionDynamicPrice) {
      res["competition_dynamic_price"] = boost::any(*competitionDynamicPrice);
    }
    if (competitionPromotionPrice) {
      res["competition_promotion_price"] = boost::any(*competitionPromotionPrice);
    }
    if (minBeforeControlPriceOfNormal) {
      res["min_before_control_price_of_normal"] = boost::any(*minBeforeControlPriceOfNormal);
    }
    if (priceShowInfo) {
      res["price_show_info"] = priceShowInfo ? boost::any(priceShowInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("floor_price") != m.end() && !m["floor_price"].empty()) {
      floorPrice = make_shared<long>(boost::any_cast<long>(m["floor_price"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("sell_price") != m.end() && !m["sell_price"].empty()) {
      sellPrice = make_shared<long>(boost::any_cast<long>(m["sell_price"]));
    }
    if (m.find("original_sell_price") != m.end() && !m["original_sell_price"].empty()) {
      originalSellPrice = make_shared<long>(boost::any_cast<long>(m["original_sell_price"]));
    }
    if (m.find("base_total_price") != m.end() && !m["base_total_price"].empty()) {
      baseTotalPrice = make_shared<long>(boost::any_cast<long>(m["base_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("tax") != m.end() && !m["tax"].empty()) {
      tax = make_shared<long>(boost::any_cast<long>(m["tax"]));
    }
    if (m.find("supply_price") != m.end() && !m["supply_price"].empty()) {
      supplyPrice = make_shared<long>(boost::any_cast<long>(m["supply_price"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("first_standard_price") != m.end() && !m["first_standard_price"].empty()) {
      firstStandardPrice = make_shared<long>(boost::any_cast<long>(m["first_standard_price"]));
    }
    if (m.find("business_standard_price") != m.end() && !m["business_standard_price"].empty()) {
      businessStandardPrice = make_shared<long>(boost::any_cast<long>(m["business_standard_price"]));
    }
    if (m.find("common_standard_price") != m.end() && !m["common_standard_price"].empty()) {
      commonStandardPrice = make_shared<long>(boost::any_cast<long>(m["common_standard_price"]));
    }
    if (m.find("inter_ticket_price") != m.end() && !m["inter_ticket_price"].empty()) {
      interTicketPrice = make_shared<long>(boost::any_cast<long>(m["inter_ticket_price"]));
    }
    if (m.find("subtracted_price") != m.end() && !m["subtracted_price"].empty()) {
      subtractedPrice = make_shared<long>(boost::any_cast<long>(m["subtracted_price"]));
    }
    if (m.find("origin_common_price") != m.end() && !m["origin_common_price"].empty()) {
      originCommonPrice = make_shared<long>(boost::any_cast<long>(m["origin_common_price"]));
    }
    if (m.find("dynamic_promotion_price") != m.end() && !m["dynamic_promotion_price"].empty()) {
      dynamicPromotionPrice = make_shared<long>(boost::any_cast<long>(m["dynamic_promotion_price"]));
    }
    if (m.find("installment_num") != m.end() && !m["installment_num"].empty()) {
      installmentNum = make_shared<long>(boost::any_cast<long>(m["installment_num"]));
    }
    if (m.find("installment_price") != m.end() && !m["installment_price"].empty()) {
      installmentPrice = make_shared<double>(boost::any_cast<double>(m["installment_price"]));
    }
    if (m.find("competition_dynamic_price") != m.end() && !m["competition_dynamic_price"].empty()) {
      competitionDynamicPrice = make_shared<long>(boost::any_cast<long>(m["competition_dynamic_price"]));
    }
    if (m.find("competition_promotion_price") != m.end() && !m["competition_promotion_price"].empty()) {
      competitionPromotionPrice = make_shared<long>(boost::any_cast<long>(m["competition_promotion_price"]));
    }
    if (m.find("min_before_control_price_of_normal") != m.end() && !m["min_before_control_price_of_normal"].empty()) {
      minBeforeControlPriceOfNormal = make_shared<long>(boost::any_cast<long>(m["min_before_control_price_of_normal"]));
    }
    if (m.find("price_show_info") != m.end() && !m["price_show_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_show_info"].type()) {
        ModuleItemListShoppingItemMapValueSearchPricePriceShowInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_show_info"]));
        priceShowInfo = make_shared<ModuleItemListShoppingItemMapValueSearchPricePriceShowInfo>(model1);
      }
    }
  }


  virtual ~ModuleItemListShoppingItemMapValueSearchPrice() = default;
};
class ModuleItemListShoppingItemMapValueCabinQuantityValue : public Darabonba::Model {
public:
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<string> cabinClassMemo{};
  shared_ptr<string> specification{};
  shared_ptr<string> quantity{};
  shared_ptr<vector<string>> linkCabins{};
  shared_ptr<bool> reshopChangeCabin{};
  shared_ptr<long> childCabinType{};
  shared_ptr<string> infantBasicCabin{};
  shared_ptr<long> innerCabinClass{};

  ModuleItemListShoppingItemMapValueCabinQuantityValue() {}

  explicit ModuleItemListShoppingItemMapValueCabinQuantityValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabin_class_name"] = boost::any(*cabinClassName);
    }
    if (cabinClassMemo) {
      res["cabin_class_memo"] = boost::any(*cabinClassMemo);
    }
    if (specification) {
      res["specification"] = boost::any(*specification);
    }
    if (quantity) {
      res["quantity"] = boost::any(*quantity);
    }
    if (linkCabins) {
      res["link_cabins"] = boost::any(*linkCabins);
    }
    if (reshopChangeCabin) {
      res["reshop_change_cabin"] = boost::any(*reshopChangeCabin);
    }
    if (childCabinType) {
      res["child_cabin_type"] = boost::any(*childCabinType);
    }
    if (infantBasicCabin) {
      res["infant_basic_cabin"] = boost::any(*infantBasicCabin);
    }
    if (innerCabinClass) {
      res["inner_cabin_class"] = boost::any(*innerCabinClass);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_class_name") != m.end() && !m["cabin_class_name"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabin_class_name"]));
    }
    if (m.find("cabin_class_memo") != m.end() && !m["cabin_class_memo"].empty()) {
      cabinClassMemo = make_shared<string>(boost::any_cast<string>(m["cabin_class_memo"]));
    }
    if (m.find("specification") != m.end() && !m["specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["specification"]));
    }
    if (m.find("quantity") != m.end() && !m["quantity"].empty()) {
      quantity = make_shared<string>(boost::any_cast<string>(m["quantity"]));
    }
    if (m.find("link_cabins") != m.end() && !m["link_cabins"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["link_cabins"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["link_cabins"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      linkCabins = make_shared<vector<string>>(toVec1);
    }
    if (m.find("reshop_change_cabin") != m.end() && !m["reshop_change_cabin"].empty()) {
      reshopChangeCabin = make_shared<bool>(boost::any_cast<bool>(m["reshop_change_cabin"]));
    }
    if (m.find("child_cabin_type") != m.end() && !m["child_cabin_type"].empty()) {
      childCabinType = make_shared<long>(boost::any_cast<long>(m["child_cabin_type"]));
    }
    if (m.find("infant_basic_cabin") != m.end() && !m["infant_basic_cabin"].empty()) {
      infantBasicCabin = make_shared<string>(boost::any_cast<string>(m["infant_basic_cabin"]));
    }
    if (m.find("inner_cabin_class") != m.end() && !m["inner_cabin_class"].empty()) {
      innerCabinClass = make_shared<long>(boost::any_cast<long>(m["inner_cabin_class"]));
    }
  }


  virtual ~ModuleItemListShoppingItemMapValueCabinQuantityValue() = default;
};
class ModuleItemListShoppingItemMapValueSegmentPriceValuePriceShowInfo : public Darabonba::Model {
public:
  shared_ptr<string> discountInfo{};
  shared_ptr<double> discountNum{};
  shared_ptr<bool> showTicketPrice{};

  ModuleItemListShoppingItemMapValueSegmentPriceValuePriceShowInfo() {}

  explicit ModuleItemListShoppingItemMapValueSegmentPriceValuePriceShowInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountInfo) {
      res["discount_info"] = boost::any(*discountInfo);
    }
    if (discountNum) {
      res["discount_num"] = boost::any(*discountNum);
    }
    if (showTicketPrice) {
      res["show_ticket_price"] = boost::any(*showTicketPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("discount_info") != m.end() && !m["discount_info"].empty()) {
      discountInfo = make_shared<string>(boost::any_cast<string>(m["discount_info"]));
    }
    if (m.find("discount_num") != m.end() && !m["discount_num"].empty()) {
      discountNum = make_shared<double>(boost::any_cast<double>(m["discount_num"]));
    }
    if (m.find("show_ticket_price") != m.end() && !m["show_ticket_price"].empty()) {
      showTicketPrice = make_shared<bool>(boost::any_cast<bool>(m["show_ticket_price"]));
    }
  }


  virtual ~ModuleItemListShoppingItemMapValueSegmentPriceValuePriceShowInfo() = default;
};
class ModuleItemListShoppingItemMapValueSegmentPriceValue : public Darabonba::Model {
public:
  shared_ptr<long> floorPrice{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> sellPrice{};
  shared_ptr<long> originalSellPrice{};
  shared_ptr<long> baseTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> tax{};
  shared_ptr<long> supplyPrice{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> firstStandardPrice{};
  shared_ptr<long> businessStandardPrice{};
  shared_ptr<long> commonStandardPrice{};
  shared_ptr<long> interTicketPrice{};
  shared_ptr<long> subtractedPrice{};
  shared_ptr<long> originCommonPrice{};
  shared_ptr<long> dynamicPromotionPrice{};
  shared_ptr<long> installmentNum{};
  shared_ptr<double> installmentPrice{};
  shared_ptr<long> competitionDynamicPrice{};
  shared_ptr<long> competitionPromotionPrice{};
  shared_ptr<long> minBeforeControlPriceOfNormal{};
  shared_ptr<ModuleItemListShoppingItemMapValueSegmentPriceValuePriceShowInfo> priceShowInfo{};

  ModuleItemListShoppingItemMapValueSegmentPriceValue() {}

  explicit ModuleItemListShoppingItemMapValueSegmentPriceValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (floorPrice) {
      res["floor_price"] = boost::any(*floorPrice);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (sellPrice) {
      res["sell_price"] = boost::any(*sellPrice);
    }
    if (originalSellPrice) {
      res["original_sell_price"] = boost::any(*originalSellPrice);
    }
    if (baseTotalPrice) {
      res["base_total_price"] = boost::any(*baseTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (tax) {
      res["tax"] = boost::any(*tax);
    }
    if (supplyPrice) {
      res["supply_price"] = boost::any(*supplyPrice);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (firstStandardPrice) {
      res["first_standard_price"] = boost::any(*firstStandardPrice);
    }
    if (businessStandardPrice) {
      res["business_standard_price"] = boost::any(*businessStandardPrice);
    }
    if (commonStandardPrice) {
      res["common_standard_price"] = boost::any(*commonStandardPrice);
    }
    if (interTicketPrice) {
      res["inter_ticket_price"] = boost::any(*interTicketPrice);
    }
    if (subtractedPrice) {
      res["subtracted_price"] = boost::any(*subtractedPrice);
    }
    if (originCommonPrice) {
      res["origin_common_price"] = boost::any(*originCommonPrice);
    }
    if (dynamicPromotionPrice) {
      res["dynamic_promotion_price"] = boost::any(*dynamicPromotionPrice);
    }
    if (installmentNum) {
      res["installment_num"] = boost::any(*installmentNum);
    }
    if (installmentPrice) {
      res["installment_price"] = boost::any(*installmentPrice);
    }
    if (competitionDynamicPrice) {
      res["competition_dynamic_price"] = boost::any(*competitionDynamicPrice);
    }
    if (competitionPromotionPrice) {
      res["competition_promotion_price"] = boost::any(*competitionPromotionPrice);
    }
    if (minBeforeControlPriceOfNormal) {
      res["min_before_control_price_of_normal"] = boost::any(*minBeforeControlPriceOfNormal);
    }
    if (priceShowInfo) {
      res["price_show_info"] = priceShowInfo ? boost::any(priceShowInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("floor_price") != m.end() && !m["floor_price"].empty()) {
      floorPrice = make_shared<long>(boost::any_cast<long>(m["floor_price"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("sell_price") != m.end() && !m["sell_price"].empty()) {
      sellPrice = make_shared<long>(boost::any_cast<long>(m["sell_price"]));
    }
    if (m.find("original_sell_price") != m.end() && !m["original_sell_price"].empty()) {
      originalSellPrice = make_shared<long>(boost::any_cast<long>(m["original_sell_price"]));
    }
    if (m.find("base_total_price") != m.end() && !m["base_total_price"].empty()) {
      baseTotalPrice = make_shared<long>(boost::any_cast<long>(m["base_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("tax") != m.end() && !m["tax"].empty()) {
      tax = make_shared<long>(boost::any_cast<long>(m["tax"]));
    }
    if (m.find("supply_price") != m.end() && !m["supply_price"].empty()) {
      supplyPrice = make_shared<long>(boost::any_cast<long>(m["supply_price"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("first_standard_price") != m.end() && !m["first_standard_price"].empty()) {
      firstStandardPrice = make_shared<long>(boost::any_cast<long>(m["first_standard_price"]));
    }
    if (m.find("business_standard_price") != m.end() && !m["business_standard_price"].empty()) {
      businessStandardPrice = make_shared<long>(boost::any_cast<long>(m["business_standard_price"]));
    }
    if (m.find("common_standard_price") != m.end() && !m["common_standard_price"].empty()) {
      commonStandardPrice = make_shared<long>(boost::any_cast<long>(m["common_standard_price"]));
    }
    if (m.find("inter_ticket_price") != m.end() && !m["inter_ticket_price"].empty()) {
      interTicketPrice = make_shared<long>(boost::any_cast<long>(m["inter_ticket_price"]));
    }
    if (m.find("subtracted_price") != m.end() && !m["subtracted_price"].empty()) {
      subtractedPrice = make_shared<long>(boost::any_cast<long>(m["subtracted_price"]));
    }
    if (m.find("origin_common_price") != m.end() && !m["origin_common_price"].empty()) {
      originCommonPrice = make_shared<long>(boost::any_cast<long>(m["origin_common_price"]));
    }
    if (m.find("dynamic_promotion_price") != m.end() && !m["dynamic_promotion_price"].empty()) {
      dynamicPromotionPrice = make_shared<long>(boost::any_cast<long>(m["dynamic_promotion_price"]));
    }
    if (m.find("installment_num") != m.end() && !m["installment_num"].empty()) {
      installmentNum = make_shared<long>(boost::any_cast<long>(m["installment_num"]));
    }
    if (m.find("installment_price") != m.end() && !m["installment_price"].empty()) {
      installmentPrice = make_shared<double>(boost::any_cast<double>(m["installment_price"]));
    }
    if (m.find("competition_dynamic_price") != m.end() && !m["competition_dynamic_price"].empty()) {
      competitionDynamicPrice = make_shared<long>(boost::any_cast<long>(m["competition_dynamic_price"]));
    }
    if (m.find("competition_promotion_price") != m.end() && !m["competition_promotion_price"].empty()) {
      competitionPromotionPrice = make_shared<long>(boost::any_cast<long>(m["competition_promotion_price"]));
    }
    if (m.find("min_before_control_price_of_normal") != m.end() && !m["min_before_control_price_of_normal"].empty()) {
      minBeforeControlPriceOfNormal = make_shared<long>(boost::any_cast<long>(m["min_before_control_price_of_normal"]));
    }
    if (m.find("price_show_info") != m.end() && !m["price_show_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_show_info"].type()) {
        ModuleItemListShoppingItemMapValueSegmentPriceValuePriceShowInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_show_info"]));
        priceShowInfo = make_shared<ModuleItemListShoppingItemMapValueSegmentPriceValuePriceShowInfo>(model1);
      }
    }
  }


  virtual ~ModuleItemListShoppingItemMapValueSegmentPriceValue() = default;
};
class ModuleItemListShoppingItemMapValue : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<map<string, ModuleItemListShoppingItemMapValueCabinQuantityValue>> cabinQuantity{};
  shared_ptr<ModuleItemListShoppingItemMapValueSearchPrice> searchPrice{};
  shared_ptr<map<string, ModuleItemListShoppingItemMapValueSegmentPriceValue>> segmentPrice{};

  ModuleItemListShoppingItemMapValue() {}

  explicit ModuleItemListShoppingItemMapValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (cabinQuantity) {
      map<string, boost::any> temp1;
      for(auto item1:*cabinQuantity){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["cabin_quantity"] = boost::any(temp1);
    }
    if (searchPrice) {
      res["search_price"] = searchPrice ? boost::any(searchPrice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segmentPrice) {
      map<string, boost::any> temp1;
      for(auto item1:*segmentPrice){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["segment_price"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("cabin_quantity") != m.end() && !m["cabin_quantity"].empty()) {
      if (typeid(map<string, boost::any>) == m["cabin_quantity"].type()) {
        map<string, ModuleItemListShoppingItemMapValueCabinQuantityValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["cabin_quantity"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleItemListShoppingItemMapValueCabinQuantityValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        cabinQuantity = make_shared<map<string, ModuleItemListShoppingItemMapValueCabinQuantityValue>>(expect1);
      }
    }
    if (m.find("search_price") != m.end() && !m["search_price"].empty()) {
      if (typeid(map<string, boost::any>) == m["search_price"].type()) {
        ModuleItemListShoppingItemMapValueSearchPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["search_price"]));
        searchPrice = make_shared<ModuleItemListShoppingItemMapValueSearchPrice>(model1);
      }
    }
    if (m.find("segment_price") != m.end() && !m["segment_price"].empty()) {
      if (typeid(map<string, boost::any>) == m["segment_price"].type()) {
        map<string, ModuleItemListShoppingItemMapValueSegmentPriceValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["segment_price"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleItemListShoppingItemMapValueSegmentPriceValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        segmentPrice = make_shared<map<string, ModuleItemListShoppingItemMapValueSegmentPriceValue>>(expect1);
      }
    }
  }


  virtual ~ModuleItemListShoppingItemMapValue() = default;
};
class ModuleItemListSubItemPositionMapValue : public Darabonba::Model {
public:
  shared_ptr<long> journeyIndex{};
  shared_ptr<long> segmentIndex{};

  ModuleItemListSubItemPositionMapValue() {}

  explicit ModuleItemListSubItemPositionMapValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (journeyIndex) {
      res["journey_index"] = boost::any(*journeyIndex);
    }
    if (segmentIndex) {
      res["segment_index"] = boost::any(*segmentIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("journey_index") != m.end() && !m["journey_index"].empty()) {
      journeyIndex = make_shared<long>(boost::any_cast<long>(m["journey_index"]));
    }
    if (m.find("segment_index") != m.end() && !m["segment_index"].empty()) {
      segmentIndex = make_shared<long>(boost::any_cast<long>(m["segment_index"]));
    }
  }


  virtual ~ModuleItemListSubItemPositionMapValue() = default;
};
class ModuleItemListSubItemsShoppingItemMapValueSearchPricePriceShowInfo : public Darabonba::Model {
public:
  shared_ptr<string> discountInfo{};
  shared_ptr<double> discountNum{};
  shared_ptr<bool> showTicketPrice{};

  ModuleItemListSubItemsShoppingItemMapValueSearchPricePriceShowInfo() {}

  explicit ModuleItemListSubItemsShoppingItemMapValueSearchPricePriceShowInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountInfo) {
      res["discount_info"] = boost::any(*discountInfo);
    }
    if (discountNum) {
      res["discount_num"] = boost::any(*discountNum);
    }
    if (showTicketPrice) {
      res["show_ticket_price"] = boost::any(*showTicketPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("discount_info") != m.end() && !m["discount_info"].empty()) {
      discountInfo = make_shared<string>(boost::any_cast<string>(m["discount_info"]));
    }
    if (m.find("discount_num") != m.end() && !m["discount_num"].empty()) {
      discountNum = make_shared<double>(boost::any_cast<double>(m["discount_num"]));
    }
    if (m.find("show_ticket_price") != m.end() && !m["show_ticket_price"].empty()) {
      showTicketPrice = make_shared<bool>(boost::any_cast<bool>(m["show_ticket_price"]));
    }
  }


  virtual ~ModuleItemListSubItemsShoppingItemMapValueSearchPricePriceShowInfo() = default;
};
class ModuleItemListSubItemsShoppingItemMapValueSearchPrice : public Darabonba::Model {
public:
  shared_ptr<long> floorPrice{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> sellPrice{};
  shared_ptr<long> originalSellPrice{};
  shared_ptr<long> baseTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> tax{};
  shared_ptr<long> supplyPrice{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> firstStandardPrice{};
  shared_ptr<long> businessStandardPrice{};
  shared_ptr<long> commonStandardPrice{};
  shared_ptr<long> interTicketPrice{};
  shared_ptr<long> subtractedPrice{};
  shared_ptr<long> originCommonPrice{};
  shared_ptr<long> dynamicPromotionPrice{};
  shared_ptr<long> installmentNum{};
  shared_ptr<double> installmentPrice{};
  shared_ptr<long> competitionDynamicPrice{};
  shared_ptr<long> competitionPromotionPrice{};
  shared_ptr<long> minBeforeControlPriceOfNormal{};
  shared_ptr<ModuleItemListSubItemsShoppingItemMapValueSearchPricePriceShowInfo> priceShowInfo{};

  ModuleItemListSubItemsShoppingItemMapValueSearchPrice() {}

  explicit ModuleItemListSubItemsShoppingItemMapValueSearchPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (floorPrice) {
      res["floor_price"] = boost::any(*floorPrice);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (sellPrice) {
      res["sell_price"] = boost::any(*sellPrice);
    }
    if (originalSellPrice) {
      res["original_sell_price"] = boost::any(*originalSellPrice);
    }
    if (baseTotalPrice) {
      res["base_total_price"] = boost::any(*baseTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (tax) {
      res["tax"] = boost::any(*tax);
    }
    if (supplyPrice) {
      res["supply_price"] = boost::any(*supplyPrice);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (firstStandardPrice) {
      res["first_standard_price"] = boost::any(*firstStandardPrice);
    }
    if (businessStandardPrice) {
      res["business_standard_price"] = boost::any(*businessStandardPrice);
    }
    if (commonStandardPrice) {
      res["common_standard_price"] = boost::any(*commonStandardPrice);
    }
    if (interTicketPrice) {
      res["inter_ticket_price"] = boost::any(*interTicketPrice);
    }
    if (subtractedPrice) {
      res["subtracted_price"] = boost::any(*subtractedPrice);
    }
    if (originCommonPrice) {
      res["origin_common_price"] = boost::any(*originCommonPrice);
    }
    if (dynamicPromotionPrice) {
      res["dynamic_promotion_price"] = boost::any(*dynamicPromotionPrice);
    }
    if (installmentNum) {
      res["installment_num"] = boost::any(*installmentNum);
    }
    if (installmentPrice) {
      res["installment_price"] = boost::any(*installmentPrice);
    }
    if (competitionDynamicPrice) {
      res["competition_dynamic_price"] = boost::any(*competitionDynamicPrice);
    }
    if (competitionPromotionPrice) {
      res["competition_promotion_price"] = boost::any(*competitionPromotionPrice);
    }
    if (minBeforeControlPriceOfNormal) {
      res["min_before_control_price_of_normal"] = boost::any(*minBeforeControlPriceOfNormal);
    }
    if (priceShowInfo) {
      res["price_show_info"] = priceShowInfo ? boost::any(priceShowInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("floor_price") != m.end() && !m["floor_price"].empty()) {
      floorPrice = make_shared<long>(boost::any_cast<long>(m["floor_price"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("sell_price") != m.end() && !m["sell_price"].empty()) {
      sellPrice = make_shared<long>(boost::any_cast<long>(m["sell_price"]));
    }
    if (m.find("original_sell_price") != m.end() && !m["original_sell_price"].empty()) {
      originalSellPrice = make_shared<long>(boost::any_cast<long>(m["original_sell_price"]));
    }
    if (m.find("base_total_price") != m.end() && !m["base_total_price"].empty()) {
      baseTotalPrice = make_shared<long>(boost::any_cast<long>(m["base_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("tax") != m.end() && !m["tax"].empty()) {
      tax = make_shared<long>(boost::any_cast<long>(m["tax"]));
    }
    if (m.find("supply_price") != m.end() && !m["supply_price"].empty()) {
      supplyPrice = make_shared<long>(boost::any_cast<long>(m["supply_price"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("first_standard_price") != m.end() && !m["first_standard_price"].empty()) {
      firstStandardPrice = make_shared<long>(boost::any_cast<long>(m["first_standard_price"]));
    }
    if (m.find("business_standard_price") != m.end() && !m["business_standard_price"].empty()) {
      businessStandardPrice = make_shared<long>(boost::any_cast<long>(m["business_standard_price"]));
    }
    if (m.find("common_standard_price") != m.end() && !m["common_standard_price"].empty()) {
      commonStandardPrice = make_shared<long>(boost::any_cast<long>(m["common_standard_price"]));
    }
    if (m.find("inter_ticket_price") != m.end() && !m["inter_ticket_price"].empty()) {
      interTicketPrice = make_shared<long>(boost::any_cast<long>(m["inter_ticket_price"]));
    }
    if (m.find("subtracted_price") != m.end() && !m["subtracted_price"].empty()) {
      subtractedPrice = make_shared<long>(boost::any_cast<long>(m["subtracted_price"]));
    }
    if (m.find("origin_common_price") != m.end() && !m["origin_common_price"].empty()) {
      originCommonPrice = make_shared<long>(boost::any_cast<long>(m["origin_common_price"]));
    }
    if (m.find("dynamic_promotion_price") != m.end() && !m["dynamic_promotion_price"].empty()) {
      dynamicPromotionPrice = make_shared<long>(boost::any_cast<long>(m["dynamic_promotion_price"]));
    }
    if (m.find("installment_num") != m.end() && !m["installment_num"].empty()) {
      installmentNum = make_shared<long>(boost::any_cast<long>(m["installment_num"]));
    }
    if (m.find("installment_price") != m.end() && !m["installment_price"].empty()) {
      installmentPrice = make_shared<double>(boost::any_cast<double>(m["installment_price"]));
    }
    if (m.find("competition_dynamic_price") != m.end() && !m["competition_dynamic_price"].empty()) {
      competitionDynamicPrice = make_shared<long>(boost::any_cast<long>(m["competition_dynamic_price"]));
    }
    if (m.find("competition_promotion_price") != m.end() && !m["competition_promotion_price"].empty()) {
      competitionPromotionPrice = make_shared<long>(boost::any_cast<long>(m["competition_promotion_price"]));
    }
    if (m.find("min_before_control_price_of_normal") != m.end() && !m["min_before_control_price_of_normal"].empty()) {
      minBeforeControlPriceOfNormal = make_shared<long>(boost::any_cast<long>(m["min_before_control_price_of_normal"]));
    }
    if (m.find("price_show_info") != m.end() && !m["price_show_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_show_info"].type()) {
        ModuleItemListSubItemsShoppingItemMapValueSearchPricePriceShowInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_show_info"]));
        priceShowInfo = make_shared<ModuleItemListSubItemsShoppingItemMapValueSearchPricePriceShowInfo>(model1);
      }
    }
  }


  virtual ~ModuleItemListSubItemsShoppingItemMapValueSearchPrice() = default;
};
class ModuleItemListSubItemsShoppingItemMapValueCabinQuantityValue : public Darabonba::Model {
public:
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<string> cabinClassMemo{};
  shared_ptr<string> specification{};
  shared_ptr<string> quantity{};
  shared_ptr<vector<string>> linkCabins{};
  shared_ptr<bool> reshopChangeCabin{};
  shared_ptr<long> childCabinType{};
  shared_ptr<string> infantBasicCabin{};
  shared_ptr<long> innerCabinClass{};

  ModuleItemListSubItemsShoppingItemMapValueCabinQuantityValue() {}

  explicit ModuleItemListSubItemsShoppingItemMapValueCabinQuantityValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabin_class_name"] = boost::any(*cabinClassName);
    }
    if (cabinClassMemo) {
      res["cabin_class_memo"] = boost::any(*cabinClassMemo);
    }
    if (specification) {
      res["specification"] = boost::any(*specification);
    }
    if (quantity) {
      res["quantity"] = boost::any(*quantity);
    }
    if (linkCabins) {
      res["link_cabins"] = boost::any(*linkCabins);
    }
    if (reshopChangeCabin) {
      res["reshop_change_cabin"] = boost::any(*reshopChangeCabin);
    }
    if (childCabinType) {
      res["child_cabin_type"] = boost::any(*childCabinType);
    }
    if (infantBasicCabin) {
      res["infant_basic_cabin"] = boost::any(*infantBasicCabin);
    }
    if (innerCabinClass) {
      res["inner_cabin_class"] = boost::any(*innerCabinClass);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_class_name") != m.end() && !m["cabin_class_name"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabin_class_name"]));
    }
    if (m.find("cabin_class_memo") != m.end() && !m["cabin_class_memo"].empty()) {
      cabinClassMemo = make_shared<string>(boost::any_cast<string>(m["cabin_class_memo"]));
    }
    if (m.find("specification") != m.end() && !m["specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["specification"]));
    }
    if (m.find("quantity") != m.end() && !m["quantity"].empty()) {
      quantity = make_shared<string>(boost::any_cast<string>(m["quantity"]));
    }
    if (m.find("link_cabins") != m.end() && !m["link_cabins"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["link_cabins"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["link_cabins"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      linkCabins = make_shared<vector<string>>(toVec1);
    }
    if (m.find("reshop_change_cabin") != m.end() && !m["reshop_change_cabin"].empty()) {
      reshopChangeCabin = make_shared<bool>(boost::any_cast<bool>(m["reshop_change_cabin"]));
    }
    if (m.find("child_cabin_type") != m.end() && !m["child_cabin_type"].empty()) {
      childCabinType = make_shared<long>(boost::any_cast<long>(m["child_cabin_type"]));
    }
    if (m.find("infant_basic_cabin") != m.end() && !m["infant_basic_cabin"].empty()) {
      infantBasicCabin = make_shared<string>(boost::any_cast<string>(m["infant_basic_cabin"]));
    }
    if (m.find("inner_cabin_class") != m.end() && !m["inner_cabin_class"].empty()) {
      innerCabinClass = make_shared<long>(boost::any_cast<long>(m["inner_cabin_class"]));
    }
  }


  virtual ~ModuleItemListSubItemsShoppingItemMapValueCabinQuantityValue() = default;
};
class ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo : public Darabonba::Model {
public:
  shared_ptr<string> discountInfo{};
  shared_ptr<double> discountNum{};
  shared_ptr<bool> showTicketPrice{};

  ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo() {}

  explicit ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountInfo) {
      res["discount_info"] = boost::any(*discountInfo);
    }
    if (discountNum) {
      res["discount_num"] = boost::any(*discountNum);
    }
    if (showTicketPrice) {
      res["show_ticket_price"] = boost::any(*showTicketPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("discount_info") != m.end() && !m["discount_info"].empty()) {
      discountInfo = make_shared<string>(boost::any_cast<string>(m["discount_info"]));
    }
    if (m.find("discount_num") != m.end() && !m["discount_num"].empty()) {
      discountNum = make_shared<double>(boost::any_cast<double>(m["discount_num"]));
    }
    if (m.find("show_ticket_price") != m.end() && !m["show_ticket_price"].empty()) {
      showTicketPrice = make_shared<bool>(boost::any_cast<bool>(m["show_ticket_price"]));
    }
  }


  virtual ~ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo() = default;
};
class ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValue : public Darabonba::Model {
public:
  shared_ptr<long> floorPrice{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> sellPrice{};
  shared_ptr<long> originalSellPrice{};
  shared_ptr<long> baseTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> tax{};
  shared_ptr<long> supplyPrice{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> firstStandardPrice{};
  shared_ptr<long> businessStandardPrice{};
  shared_ptr<long> commonStandardPrice{};
  shared_ptr<long> interTicketPrice{};
  shared_ptr<long> subtractedPrice{};
  shared_ptr<long> originCommonPrice{};
  shared_ptr<long> dynamicPromotionPrice{};
  shared_ptr<long> installmentNum{};
  shared_ptr<double> installmentPrice{};
  shared_ptr<long> competitionDynamicPrice{};
  shared_ptr<long> competitionPromotionPrice{};
  shared_ptr<long> minBeforeControlPriceOfNormal{};
  shared_ptr<ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo> priceShowInfo{};

  ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValue() {}

  explicit ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (floorPrice) {
      res["floor_price"] = boost::any(*floorPrice);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (sellPrice) {
      res["sell_price"] = boost::any(*sellPrice);
    }
    if (originalSellPrice) {
      res["original_sell_price"] = boost::any(*originalSellPrice);
    }
    if (baseTotalPrice) {
      res["base_total_price"] = boost::any(*baseTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (tax) {
      res["tax"] = boost::any(*tax);
    }
    if (supplyPrice) {
      res["supply_price"] = boost::any(*supplyPrice);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (firstStandardPrice) {
      res["first_standard_price"] = boost::any(*firstStandardPrice);
    }
    if (businessStandardPrice) {
      res["business_standard_price"] = boost::any(*businessStandardPrice);
    }
    if (commonStandardPrice) {
      res["common_standard_price"] = boost::any(*commonStandardPrice);
    }
    if (interTicketPrice) {
      res["inter_ticket_price"] = boost::any(*interTicketPrice);
    }
    if (subtractedPrice) {
      res["subtracted_price"] = boost::any(*subtractedPrice);
    }
    if (originCommonPrice) {
      res["origin_common_price"] = boost::any(*originCommonPrice);
    }
    if (dynamicPromotionPrice) {
      res["dynamic_promotion_price"] = boost::any(*dynamicPromotionPrice);
    }
    if (installmentNum) {
      res["installment_num"] = boost::any(*installmentNum);
    }
    if (installmentPrice) {
      res["installment_price"] = boost::any(*installmentPrice);
    }
    if (competitionDynamicPrice) {
      res["competition_dynamic_price"] = boost::any(*competitionDynamicPrice);
    }
    if (competitionPromotionPrice) {
      res["competition_promotion_price"] = boost::any(*competitionPromotionPrice);
    }
    if (minBeforeControlPriceOfNormal) {
      res["min_before_control_price_of_normal"] = boost::any(*minBeforeControlPriceOfNormal);
    }
    if (priceShowInfo) {
      res["price_show_info"] = priceShowInfo ? boost::any(priceShowInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("floor_price") != m.end() && !m["floor_price"].empty()) {
      floorPrice = make_shared<long>(boost::any_cast<long>(m["floor_price"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("sell_price") != m.end() && !m["sell_price"].empty()) {
      sellPrice = make_shared<long>(boost::any_cast<long>(m["sell_price"]));
    }
    if (m.find("original_sell_price") != m.end() && !m["original_sell_price"].empty()) {
      originalSellPrice = make_shared<long>(boost::any_cast<long>(m["original_sell_price"]));
    }
    if (m.find("base_total_price") != m.end() && !m["base_total_price"].empty()) {
      baseTotalPrice = make_shared<long>(boost::any_cast<long>(m["base_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("tax") != m.end() && !m["tax"].empty()) {
      tax = make_shared<long>(boost::any_cast<long>(m["tax"]));
    }
    if (m.find("supply_price") != m.end() && !m["supply_price"].empty()) {
      supplyPrice = make_shared<long>(boost::any_cast<long>(m["supply_price"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("first_standard_price") != m.end() && !m["first_standard_price"].empty()) {
      firstStandardPrice = make_shared<long>(boost::any_cast<long>(m["first_standard_price"]));
    }
    if (m.find("business_standard_price") != m.end() && !m["business_standard_price"].empty()) {
      businessStandardPrice = make_shared<long>(boost::any_cast<long>(m["business_standard_price"]));
    }
    if (m.find("common_standard_price") != m.end() && !m["common_standard_price"].empty()) {
      commonStandardPrice = make_shared<long>(boost::any_cast<long>(m["common_standard_price"]));
    }
    if (m.find("inter_ticket_price") != m.end() && !m["inter_ticket_price"].empty()) {
      interTicketPrice = make_shared<long>(boost::any_cast<long>(m["inter_ticket_price"]));
    }
    if (m.find("subtracted_price") != m.end() && !m["subtracted_price"].empty()) {
      subtractedPrice = make_shared<long>(boost::any_cast<long>(m["subtracted_price"]));
    }
    if (m.find("origin_common_price") != m.end() && !m["origin_common_price"].empty()) {
      originCommonPrice = make_shared<long>(boost::any_cast<long>(m["origin_common_price"]));
    }
    if (m.find("dynamic_promotion_price") != m.end() && !m["dynamic_promotion_price"].empty()) {
      dynamicPromotionPrice = make_shared<long>(boost::any_cast<long>(m["dynamic_promotion_price"]));
    }
    if (m.find("installment_num") != m.end() && !m["installment_num"].empty()) {
      installmentNum = make_shared<long>(boost::any_cast<long>(m["installment_num"]));
    }
    if (m.find("installment_price") != m.end() && !m["installment_price"].empty()) {
      installmentPrice = make_shared<double>(boost::any_cast<double>(m["installment_price"]));
    }
    if (m.find("competition_dynamic_price") != m.end() && !m["competition_dynamic_price"].empty()) {
      competitionDynamicPrice = make_shared<long>(boost::any_cast<long>(m["competition_dynamic_price"]));
    }
    if (m.find("competition_promotion_price") != m.end() && !m["competition_promotion_price"].empty()) {
      competitionPromotionPrice = make_shared<long>(boost::any_cast<long>(m["competition_promotion_price"]));
    }
    if (m.find("min_before_control_price_of_normal") != m.end() && !m["min_before_control_price_of_normal"].empty()) {
      minBeforeControlPriceOfNormal = make_shared<long>(boost::any_cast<long>(m["min_before_control_price_of_normal"]));
    }
    if (m.find("price_show_info") != m.end() && !m["price_show_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_show_info"].type()) {
        ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_show_info"]));
        priceShowInfo = make_shared<ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValuePriceShowInfo>(model1);
      }
    }
  }


  virtual ~ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValue() = default;
};
class ModuleItemListSubItemsShoppingItemMapValue : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<map<string, ModuleItemListSubItemsShoppingItemMapValueCabinQuantityValue>> cabinQuantity{};
  shared_ptr<ModuleItemListSubItemsShoppingItemMapValueSearchPrice> searchPrice{};
  shared_ptr<map<string, ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValue>> segmentPrice{};

  ModuleItemListSubItemsShoppingItemMapValue() {}

  explicit ModuleItemListSubItemsShoppingItemMapValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (cabinQuantity) {
      map<string, boost::any> temp1;
      for(auto item1:*cabinQuantity){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["cabin_quantity"] = boost::any(temp1);
    }
    if (searchPrice) {
      res["search_price"] = searchPrice ? boost::any(searchPrice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segmentPrice) {
      map<string, boost::any> temp1;
      for(auto item1:*segmentPrice){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["segment_price"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("cabin_quantity") != m.end() && !m["cabin_quantity"].empty()) {
      if (typeid(map<string, boost::any>) == m["cabin_quantity"].type()) {
        map<string, ModuleItemListSubItemsShoppingItemMapValueCabinQuantityValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["cabin_quantity"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleItemListSubItemsShoppingItemMapValueCabinQuantityValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        cabinQuantity = make_shared<map<string, ModuleItemListSubItemsShoppingItemMapValueCabinQuantityValue>>(expect1);
      }
    }
    if (m.find("search_price") != m.end() && !m["search_price"].empty()) {
      if (typeid(map<string, boost::any>) == m["search_price"].type()) {
        ModuleItemListSubItemsShoppingItemMapValueSearchPrice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["search_price"]));
        searchPrice = make_shared<ModuleItemListSubItemsShoppingItemMapValueSearchPrice>(model1);
      }
    }
    if (m.find("segment_price") != m.end() && !m["segment_price"].empty()) {
      if (typeid(map<string, boost::any>) == m["segment_price"].type()) {
        map<string, ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["segment_price"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        segmentPrice = make_shared<map<string, ModuleItemListSubItemsShoppingItemMapValueSegmentPriceValue>>(expect1);
      }
    }
  }


  virtual ~ModuleItemListSubItemsShoppingItemMapValue() = default;
};
class AccessTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appSecret{};

  AccessTokenRequest() {}

  explicit AccessTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appSecret) {
      res["app_secret"] = boost::any(*appSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("app_secret") != m.end() && !m["app_secret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["app_secret"]));
    }
  }


  virtual ~AccessTokenRequest() = default;
};
class AccessTokenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> expire{};
  shared_ptr<string> token{};

  AccessTokenResponseBodyData() {}

  explicit AccessTokenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expire) {
      res["expire"] = boost::any(*expire);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("expire") != m.end() && !m["expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["expire"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~AccessTokenResponseBodyData() = default;
};
class AccessTokenResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> expire{};
  shared_ptr<long> start{};
  shared_ptr<string> token{};

  AccessTokenResponseBodyModule() {}

  explicit AccessTokenResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expire) {
      res["expire"] = boost::any(*expire);
    }
    if (start) {
      res["start"] = boost::any(*start);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("expire") != m.end() && !m["expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["expire"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["start"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~AccessTokenResponseBodyModule() = default;
};
class AccessTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<AccessTokenResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<AccessTokenResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  AccessTokenResponseBody() {}

  explicit AccessTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        AccessTokenResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<AccessTokenResponseBodyData>(model1);
      }
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        AccessTokenResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<AccessTokenResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~AccessTokenResponseBody() = default;
};
class AccessTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AccessTokenResponseBody> body{};

  AccessTokenResponse() {}

  explicit AccessTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AccessTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AccessTokenResponseBody>(model1);
      }
    }
  }


  virtual ~AccessTokenResponse() = default;
};
class AddInvoiceEntityHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  AddInvoiceEntityHeaders() {}

  explicit AddInvoiceEntityHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~AddInvoiceEntityHeaders() = default;
};
class AddInvoiceEntityRequestEntities : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> entityName{};
  shared_ptr<string> entityType{};

  AddInvoiceEntityRequestEntities() {}

  explicit AddInvoiceEntityRequestEntities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["entity_id"] = boost::any(*entityId);
    }
    if (entityName) {
      res["entity_name"] = boost::any(*entityName);
    }
    if (entityType) {
      res["entity_type"] = boost::any(*entityType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_id") != m.end() && !m["entity_id"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["entity_id"]));
    }
    if (m.find("entity_name") != m.end() && !m["entity_name"].empty()) {
      entityName = make_shared<string>(boost::any_cast<string>(m["entity_name"]));
    }
    if (m.find("entity_type") != m.end() && !m["entity_type"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["entity_type"]));
    }
  }


  virtual ~AddInvoiceEntityRequestEntities() = default;
};
class AddInvoiceEntityRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddInvoiceEntityRequestEntities>> entities{};
  shared_ptr<string> thirdPartId{};

  AddInvoiceEntityRequest() {}

  explicit AddInvoiceEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entities) {
      vector<boost::any> temp1;
      for(auto item1:*entities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entities"] = boost::any(temp1);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entities") != m.end() && !m["entities"].empty()) {
      if (typeid(vector<boost::any>) == m["entities"].type()) {
        vector<AddInvoiceEntityRequestEntities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddInvoiceEntityRequestEntities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entities = make_shared<vector<AddInvoiceEntityRequestEntities>>(expect1);
      }
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~AddInvoiceEntityRequest() = default;
};
class AddInvoiceEntityShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> entitiesShrink{};
  shared_ptr<string> thirdPartId{};

  AddInvoiceEntityShrinkRequest() {}

  explicit AddInvoiceEntityShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entitiesShrink) {
      res["entities"] = boost::any(*entitiesShrink);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entities") != m.end() && !m["entities"].empty()) {
      entitiesShrink = make_shared<string>(boost::any_cast<string>(m["entities"]));
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~AddInvoiceEntityShrinkRequest() = default;
};
class AddInvoiceEntityResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> addNum{};
  shared_ptr<long> selectedUserNum{};

  AddInvoiceEntityResponseBodyModule() {}

  explicit AddInvoiceEntityResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addNum) {
      res["add_num"] = boost::any(*addNum);
    }
    if (selectedUserNum) {
      res["selected_user_num"] = boost::any(*selectedUserNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("add_num") != m.end() && !m["add_num"].empty()) {
      addNum = make_shared<long>(boost::any_cast<long>(m["add_num"]));
    }
    if (m.find("selected_user_num") != m.end() && !m["selected_user_num"].empty()) {
      selectedUserNum = make_shared<long>(boost::any_cast<long>(m["selected_user_num"]));
    }
  }


  virtual ~AddInvoiceEntityResponseBodyModule() = default;
};
class AddInvoiceEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<AddInvoiceEntityResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  AddInvoiceEntityResponseBody() {}

  explicit AddInvoiceEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        AddInvoiceEntityResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<AddInvoiceEntityResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~AddInvoiceEntityResponseBody() = default;
};
class AddInvoiceEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddInvoiceEntityResponseBody> body{};

  AddInvoiceEntityResponse() {}

  explicit AddInvoiceEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddInvoiceEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddInvoiceEntityResponseBody>(model1);
      }
    }
  }


  virtual ~AddInvoiceEntityResponse() = default;
};
class AddressGetHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  AddressGetHeaders() {}

  explicit AddressGetHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~AddressGetHeaders() = default;
};
class AddressGetRequest : public Darabonba::Model {
public:
  shared_ptr<long> actionType{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> carScenesCode{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depDate{};
  shared_ptr<string> itineraryId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> phone{};
  shared_ptr<string> subCorpId{};
  shared_ptr<string> taobaoCallbackUrl{};
  shared_ptr<long> type{};
  shared_ptr<string> userId{};

  AddressGetRequest() {}

  explicit AddressGetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionType) {
      res["action_type"] = boost::any(*actionType);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (carScenesCode) {
      res["car_scenes_code"] = boost::any(*carScenesCode);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (orderId) {
      res["order_Id"] = boost::any(*orderId);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    if (taobaoCallbackUrl) {
      res["taobao_callback_url"] = boost::any(*taobaoCallbackUrl);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action_type") != m.end() && !m["action_type"].empty()) {
      actionType = make_shared<long>(boost::any_cast<long>(m["action_type"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("car_scenes_code") != m.end() && !m["car_scenes_code"].empty()) {
      carScenesCode = make_shared<string>(boost::any_cast<string>(m["car_scenes_code"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("order_Id") != m.end() && !m["order_Id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_Id"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
    if (m.find("taobao_callback_url") != m.end() && !m["taobao_callback_url"].empty()) {
      taobaoCallbackUrl = make_shared<string>(boost::any_cast<string>(m["taobao_callback_url"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~AddressGetRequest() = default;
};
class AddressGetResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> url{};

  AddressGetResponseBodyModule() {}

  explicit AddressGetResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~AddressGetResponseBodyModule() = default;
};
class AddressGetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<AddressGetResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  AddressGetResponseBody() {}

  explicit AddressGetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        AddressGetResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<AddressGetResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~AddressGetResponseBody() = default;
};
class AddressGetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddressGetResponseBody> body{};

  AddressGetResponse() {}

  explicit AddressGetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddressGetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddressGetResponseBody>(model1);
      }
    }
  }


  virtual ~AddressGetResponse() = default;
};
class AirportSearchHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  AirportSearchHeaders() {}

  explicit AirportSearchHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~AirportSearchHeaders() = default;
};
class AirportSearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> type{};

  AirportSearchRequest() {}

  explicit AirportSearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["keyword"] = boost::any(*keyword);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("keyword") != m.end() && !m["keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["keyword"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~AirportSearchRequest() = default;
};
class AirportSearchResponseBodyModuleCities : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> distance{};
  shared_ptr<string> name{};
  shared_ptr<string> travelName{};

  AirportSearchResponseBodyModuleCities() {}

  explicit AirportSearchResponseBodyModuleCities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (distance) {
      res["distance"] = boost::any(*distance);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (travelName) {
      res["travel_name"] = boost::any(*travelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("distance") != m.end() && !m["distance"].empty()) {
      distance = make_shared<long>(boost::any_cast<long>(m["distance"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("travel_name") != m.end() && !m["travel_name"].empty()) {
      travelName = make_shared<string>(boost::any_cast<string>(m["travel_name"]));
    }
  }


  virtual ~AirportSearchResponseBodyModuleCities() = default;
};
class AirportSearchResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<AirportSearchResponseBodyModuleCities>> cities{};
  shared_ptr<bool> nearby{};

  AirportSearchResponseBodyModule() {}

  explicit AirportSearchResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cities) {
      vector<boost::any> temp1;
      for(auto item1:*cities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cities"] = boost::any(temp1);
    }
    if (nearby) {
      res["nearby"] = boost::any(*nearby);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cities") != m.end() && !m["cities"].empty()) {
      if (typeid(vector<boost::any>) == m["cities"].type()) {
        vector<AirportSearchResponseBodyModuleCities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AirportSearchResponseBodyModuleCities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cities = make_shared<vector<AirportSearchResponseBodyModuleCities>>(expect1);
      }
    }
    if (m.find("nearby") != m.end() && !m["nearby"].empty()) {
      nearby = make_shared<bool>(boost::any_cast<bool>(m["nearby"]));
    }
  }


  virtual ~AirportSearchResponseBodyModule() = default;
};
class AirportSearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<AirportSearchResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  AirportSearchResponseBody() {}

  explicit AirportSearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        AirportSearchResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<AirportSearchResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~AirportSearchResponseBody() = default;
};
class AirportSearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AirportSearchResponseBody> body{};

  AirportSearchResponse() {}

  explicit AirportSearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AirportSearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AirportSearchResponseBody>(model1);
      }
    }
  }


  virtual ~AirportSearchResponse() = default;
};
class AllBaseCityInfoQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripAccessToken{};

  AllBaseCityInfoQueryHeaders() {}

  explicit AllBaseCityInfoQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripAccessToken) {
      res["x-acs-btrip-access-token"] = boost::any(*xAcsBtripAccessToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-access-token") != m.end() && !m["x-acs-btrip-access-token"].empty()) {
      xAcsBtripAccessToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-access-token"]));
    }
  }


  virtual ~AllBaseCityInfoQueryHeaders() = default;
};
class AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList : public Darabonba::Model {
public:
  shared_ptr<string> adcode{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityLevel{};
  shared_ptr<string> cityName{};
  shared_ptr<string> cnNameTree{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> otherNameList{};

  AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList() {}

  explicit AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adcode) {
      res["adcode"] = boost::any(*adcode);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityLevel) {
      res["city_level"] = boost::any(*cityLevel);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (cnNameTree) {
      res["cn_name_tree"] = boost::any(*cnNameTree);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (otherNameList) {
      res["other_name_list"] = boost::any(*otherNameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("adcode") != m.end() && !m["adcode"].empty()) {
      adcode = make_shared<string>(boost::any_cast<string>(m["adcode"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_level") != m.end() && !m["city_level"].empty()) {
      cityLevel = make_shared<string>(boost::any_cast<string>(m["city_level"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("cn_name_tree") != m.end() && !m["cn_name_tree"].empty()) {
      cnNameTree = make_shared<string>(boost::any_cast<string>(m["cn_name_tree"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("other_name_list") != m.end() && !m["other_name_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["other_name_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["other_name_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      otherNameList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList() = default;
};
class AllBaseCityInfoQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList>> allCityBaseInfoList{};

  AllBaseCityInfoQueryResponseBodyModule() {}

  explicit AllBaseCityInfoQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allCityBaseInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*allCityBaseInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["all_city_base_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_city_base_info_list") != m.end() && !m["all_city_base_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["all_city_base_info_list"].type()) {
        vector<AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["all_city_base_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        allCityBaseInfoList = make_shared<vector<AllBaseCityInfoQueryResponseBodyModuleAllCityBaseInfoList>>(expect1);
      }
    }
  }


  virtual ~AllBaseCityInfoQueryResponseBodyModule() = default;
};
class AllBaseCityInfoQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<AllBaseCityInfoQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  AllBaseCityInfoQueryResponseBody() {}

  explicit AllBaseCityInfoQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        AllBaseCityInfoQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<AllBaseCityInfoQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~AllBaseCityInfoQueryResponseBody() = default;
};
class AllBaseCityInfoQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AllBaseCityInfoQueryResponseBody> body{};

  AllBaseCityInfoQueryResponse() {}

  explicit AllBaseCityInfoQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AllBaseCityInfoQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AllBaseCityInfoQueryResponseBody>(model1);
      }
    }
  }


  virtual ~AllBaseCityInfoQueryResponse() = default;
};
class ApplyAddHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ApplyAddHeaders() {}

  explicit ApplyAddHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ApplyAddHeaders() = default;
};
class ApplyAddRequestCarRule : public Darabonba::Model {
public:
  shared_ptr<string> scenarioTemplateId{};
  shared_ptr<string> scenarioTemplateName{};

  ApplyAddRequestCarRule() {}

  explicit ApplyAddRequestCarRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scenarioTemplateId) {
      res["scenario_template_id"] = boost::any(*scenarioTemplateId);
    }
    if (scenarioTemplateName) {
      res["scenario_template_name"] = boost::any(*scenarioTemplateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scenario_template_id") != m.end() && !m["scenario_template_id"].empty()) {
      scenarioTemplateId = make_shared<string>(boost::any_cast<string>(m["scenario_template_id"]));
    }
    if (m.find("scenario_template_name") != m.end() && !m["scenario_template_name"].empty()) {
      scenarioTemplateName = make_shared<string>(boost::any_cast<string>(m["scenario_template_name"]));
    }
  }


  virtual ~ApplyAddRequestCarRule() = default;
};
class ApplyAddRequestExternalTravelerList : public Darabonba::Model {
public:
  shared_ptr<string> userName{};

  ApplyAddRequestExternalTravelerList() {}

  explicit ApplyAddRequestExternalTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyAddRequestExternalTravelerList() = default;
};
class ApplyAddRequestExternalTravelerStandardHotelCitys : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> fee{};

  ApplyAddRequestExternalTravelerStandardHotelCitys() {}

  explicit ApplyAddRequestExternalTravelerStandardHotelCitys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
  }


  virtual ~ApplyAddRequestExternalTravelerStandardHotelCitys() = default;
};
class ApplyAddRequestExternalTravelerStandard : public Darabonba::Model {
public:
  shared_ptr<long> businessDiscount{};
  shared_ptr<long> economyDiscount{};
  shared_ptr<long> firstDiscount{};
  shared_ptr<string> flightCabins{};
  shared_ptr<vector<ApplyAddRequestExternalTravelerStandardHotelCitys>> hotelCitys{};
  shared_ptr<string> internationalFlightCabins{};
  shared_ptr<long> premiumEconomyDiscount{};
  shared_ptr<long> reserveType{};
  shared_ptr<string> trainSeats{};

  ApplyAddRequestExternalTravelerStandard() {}

  explicit ApplyAddRequestExternalTravelerStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessDiscount) {
      res["business_discount"] = boost::any(*businessDiscount);
    }
    if (economyDiscount) {
      res["economy_discount"] = boost::any(*economyDiscount);
    }
    if (firstDiscount) {
      res["first_discount"] = boost::any(*firstDiscount);
    }
    if (flightCabins) {
      res["flight_cabins"] = boost::any(*flightCabins);
    }
    if (hotelCitys) {
      vector<boost::any> temp1;
      for(auto item1:*hotelCitys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_citys"] = boost::any(temp1);
    }
    if (internationalFlightCabins) {
      res["international_flight_cabins"] = boost::any(*internationalFlightCabins);
    }
    if (premiumEconomyDiscount) {
      res["premium_economy_discount"] = boost::any(*premiumEconomyDiscount);
    }
    if (reserveType) {
      res["reserve_type"] = boost::any(*reserveType);
    }
    if (trainSeats) {
      res["train_seats"] = boost::any(*trainSeats);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("business_discount") != m.end() && !m["business_discount"].empty()) {
      businessDiscount = make_shared<long>(boost::any_cast<long>(m["business_discount"]));
    }
    if (m.find("economy_discount") != m.end() && !m["economy_discount"].empty()) {
      economyDiscount = make_shared<long>(boost::any_cast<long>(m["economy_discount"]));
    }
    if (m.find("first_discount") != m.end() && !m["first_discount"].empty()) {
      firstDiscount = make_shared<long>(boost::any_cast<long>(m["first_discount"]));
    }
    if (m.find("flight_cabins") != m.end() && !m["flight_cabins"].empty()) {
      flightCabins = make_shared<string>(boost::any_cast<string>(m["flight_cabins"]));
    }
    if (m.find("hotel_citys") != m.end() && !m["hotel_citys"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_citys"].type()) {
        vector<ApplyAddRequestExternalTravelerStandardHotelCitys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_citys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestExternalTravelerStandardHotelCitys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelCitys = make_shared<vector<ApplyAddRequestExternalTravelerStandardHotelCitys>>(expect1);
      }
    }
    if (m.find("international_flight_cabins") != m.end() && !m["international_flight_cabins"].empty()) {
      internationalFlightCabins = make_shared<string>(boost::any_cast<string>(m["international_flight_cabins"]));
    }
    if (m.find("premium_economy_discount") != m.end() && !m["premium_economy_discount"].empty()) {
      premiumEconomyDiscount = make_shared<long>(boost::any_cast<long>(m["premium_economy_discount"]));
    }
    if (m.find("reserve_type") != m.end() && !m["reserve_type"].empty()) {
      reserveType = make_shared<long>(boost::any_cast<long>(m["reserve_type"]));
    }
    if (m.find("train_seats") != m.end() && !m["train_seats"].empty()) {
      trainSeats = make_shared<string>(boost::any_cast<string>(m["train_seats"]));
    }
  }


  virtual ~ApplyAddRequestExternalTravelerStandard() = default;
};
class ApplyAddRequestHotelShare : public Darabonba::Model {
public:
  shared_ptr<string> param{};
  shared_ptr<string> type{};

  ApplyAddRequestHotelShare() {}

  explicit ApplyAddRequestHotelShare(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (param) {
      res["param"] = boost::any(*param);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("param") != m.end() && !m["param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["param"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ApplyAddRequestHotelShare() = default;
};
class ApplyAddRequestItineraryListItineraryTravelStandard : public Darabonba::Model {
public:
  shared_ptr<long> hotelAvailableNightsPerDay{};

  ApplyAddRequestItineraryListItineraryTravelStandard() {}

  explicit ApplyAddRequestItineraryListItineraryTravelStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelAvailableNightsPerDay) {
      res["hotel_available_nights_per_day"] = boost::any(*hotelAvailableNightsPerDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_available_nights_per_day") != m.end() && !m["hotel_available_nights_per_day"].empty()) {
      hotelAvailableNightsPerDay = make_shared<long>(boost::any_cast<long>(m["hotel_available_nights_per_day"]));
    }
  }


  virtual ~ApplyAddRequestItineraryListItineraryTravelStandard() = default;
};
class ApplyAddRequestItineraryList : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrDate{};
  shared_ptr<long> costCenterId{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<long> invoiceId{};
  shared_ptr<string> itineraryId{};
  shared_ptr<ApplyAddRequestItineraryListItineraryTravelStandard> itineraryTravelStandard{};
  shared_ptr<bool> needHotel{};
  shared_ptr<bool> needTraffic{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<string> thirdpartCostCenterId{};
  shared_ptr<long> trafficType{};
  shared_ptr<long> tripWay{};

  ApplyAddRequestItineraryList() {}

  explicit ApplyAddRequestItineraryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceId) {
      res["invoice_id"] = boost::any(*invoiceId);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (itineraryTravelStandard) {
      res["itinerary_travel_standard"] = itineraryTravelStandard ? boost::any(itineraryTravelStandard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (needHotel) {
      res["need_hotel"] = boost::any(*needHotel);
    }
    if (needTraffic) {
      res["need_traffic"] = boost::any(*needTraffic);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (thirdpartCostCenterId) {
      res["thirdpart_cost_center_id"] = boost::any(*thirdpartCostCenterId);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    if (tripWay) {
      res["trip_way"] = boost::any(*tripWay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_id") != m.end() && !m["invoice_id"].empty()) {
      invoiceId = make_shared<long>(boost::any_cast<long>(m["invoice_id"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("itinerary_travel_standard") != m.end() && !m["itinerary_travel_standard"].empty()) {
      if (typeid(map<string, boost::any>) == m["itinerary_travel_standard"].type()) {
        ApplyAddRequestItineraryListItineraryTravelStandard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["itinerary_travel_standard"]));
        itineraryTravelStandard = make_shared<ApplyAddRequestItineraryListItineraryTravelStandard>(model1);
      }
    }
    if (m.find("need_hotel") != m.end() && !m["need_hotel"].empty()) {
      needHotel = make_shared<bool>(boost::any_cast<bool>(m["need_hotel"]));
    }
    if (m.find("need_traffic") != m.end() && !m["need_traffic"].empty()) {
      needTraffic = make_shared<bool>(boost::any_cast<bool>(m["need_traffic"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("thirdpart_cost_center_id") != m.end() && !m["thirdpart_cost_center_id"].empty()) {
      thirdpartCostCenterId = make_shared<string>(boost::any_cast<string>(m["thirdpart_cost_center_id"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
    if (m.find("trip_way") != m.end() && !m["trip_way"].empty()) {
      tripWay = make_shared<long>(boost::any_cast<long>(m["trip_way"]));
    }
  }


  virtual ~ApplyAddRequestItineraryList() = default;
};
class ApplyAddRequestItinerarySetListItineraryTravelStandard : public Darabonba::Model {
public:
  shared_ptr<long> hotelAvailableNightsPerDay{};

  ApplyAddRequestItinerarySetListItineraryTravelStandard() {}

  explicit ApplyAddRequestItinerarySetListItineraryTravelStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelAvailableNightsPerDay) {
      res["hotel_available_nights_per_day"] = boost::any(*hotelAvailableNightsPerDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_available_nights_per_day") != m.end() && !m["hotel_available_nights_per_day"].empty()) {
      hotelAvailableNightsPerDay = make_shared<long>(boost::any_cast<long>(m["hotel_available_nights_per_day"]));
    }
  }


  virtual ~ApplyAddRequestItinerarySetListItineraryTravelStandard() = default;
};
class ApplyAddRequestItinerarySetList : public Darabonba::Model {
public:
  shared_ptr<string> arrDate{};
  shared_ptr<string> cityCodeSet{};
  shared_ptr<string> citySet{};
  shared_ptr<long> costCenterId{};
  shared_ptr<string> depDate{};
  shared_ptr<long> invoiceId{};
  shared_ptr<string> itineraryId{};
  shared_ptr<ApplyAddRequestItinerarySetListItineraryTravelStandard> itineraryTravelStandard{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<string> thirdpartCostCenterId{};
  shared_ptr<long> trafficType{};

  ApplyAddRequestItinerarySetList() {}

  explicit ApplyAddRequestItinerarySetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (cityCodeSet) {
      res["city_code_set"] = boost::any(*cityCodeSet);
    }
    if (citySet) {
      res["city_set"] = boost::any(*citySet);
    }
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceId) {
      res["invoice_id"] = boost::any(*invoiceId);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (itineraryTravelStandard) {
      res["itinerary_travel_standard"] = itineraryTravelStandard ? boost::any(itineraryTravelStandard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (thirdpartCostCenterId) {
      res["thirdpart_cost_center_id"] = boost::any(*thirdpartCostCenterId);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("city_code_set") != m.end() && !m["city_code_set"].empty()) {
      cityCodeSet = make_shared<string>(boost::any_cast<string>(m["city_code_set"]));
    }
    if (m.find("city_set") != m.end() && !m["city_set"].empty()) {
      citySet = make_shared<string>(boost::any_cast<string>(m["city_set"]));
    }
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_id") != m.end() && !m["invoice_id"].empty()) {
      invoiceId = make_shared<long>(boost::any_cast<long>(m["invoice_id"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("itinerary_travel_standard") != m.end() && !m["itinerary_travel_standard"].empty()) {
      if (typeid(map<string, boost::any>) == m["itinerary_travel_standard"].type()) {
        ApplyAddRequestItinerarySetListItineraryTravelStandard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["itinerary_travel_standard"]));
        itineraryTravelStandard = make_shared<ApplyAddRequestItinerarySetListItineraryTravelStandard>(model1);
      }
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("thirdpart_cost_center_id") != m.end() && !m["thirdpart_cost_center_id"].empty()) {
      thirdpartCostCenterId = make_shared<string>(boost::any_cast<string>(m["thirdpart_cost_center_id"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
  }


  virtual ~ApplyAddRequestItinerarySetList() = default;
};
class ApplyAddRequestTravelerList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyAddRequestTravelerList() {}

  explicit ApplyAddRequestTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyAddRequestTravelerList() = default;
};
class ApplyAddRequestTravelerStandardCarCitySet : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};

  ApplyAddRequestTravelerStandardCarCitySet() {}

  explicit ApplyAddRequestTravelerStandardCarCitySet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
  }


  virtual ~ApplyAddRequestTravelerStandardCarCitySet() = default;
};
class ApplyAddRequestTravelerStandardHotelCitys : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> fee{};

  ApplyAddRequestTravelerStandardHotelCitys() {}

  explicit ApplyAddRequestTravelerStandardHotelCitys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
  }


  virtual ~ApplyAddRequestTravelerStandardHotelCitys() = default;
};
class ApplyAddRequestTravelerStandard : public Darabonba::Model {
public:
  shared_ptr<long> businessDiscount{};
  shared_ptr<vector<ApplyAddRequestTravelerStandardCarCitySet>> carCitySet{};
  shared_ptr<long> economyDiscount{};
  shared_ptr<long> firstDiscount{};
  shared_ptr<string> flightCabins{};
  shared_ptr<vector<ApplyAddRequestTravelerStandardHotelCitys>> hotelCitys{};
  shared_ptr<string> internationalFlightCabins{};
  shared_ptr<long> premiumEconomyDiscount{};
  shared_ptr<long> reserveType{};
  shared_ptr<string> trainSeats{};
  shared_ptr<string> userId{};

  ApplyAddRequestTravelerStandard() {}

  explicit ApplyAddRequestTravelerStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessDiscount) {
      res["business_discount"] = boost::any(*businessDiscount);
    }
    if (carCitySet) {
      vector<boost::any> temp1;
      for(auto item1:*carCitySet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["car_city_set"] = boost::any(temp1);
    }
    if (economyDiscount) {
      res["economy_discount"] = boost::any(*economyDiscount);
    }
    if (firstDiscount) {
      res["first_discount"] = boost::any(*firstDiscount);
    }
    if (flightCabins) {
      res["flight_cabins"] = boost::any(*flightCabins);
    }
    if (hotelCitys) {
      vector<boost::any> temp1;
      for(auto item1:*hotelCitys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_citys"] = boost::any(temp1);
    }
    if (internationalFlightCabins) {
      res["international_flight_cabins"] = boost::any(*internationalFlightCabins);
    }
    if (premiumEconomyDiscount) {
      res["premium_economy_discount"] = boost::any(*premiumEconomyDiscount);
    }
    if (reserveType) {
      res["reserve_type"] = boost::any(*reserveType);
    }
    if (trainSeats) {
      res["train_seats"] = boost::any(*trainSeats);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("business_discount") != m.end() && !m["business_discount"].empty()) {
      businessDiscount = make_shared<long>(boost::any_cast<long>(m["business_discount"]));
    }
    if (m.find("car_city_set") != m.end() && !m["car_city_set"].empty()) {
      if (typeid(vector<boost::any>) == m["car_city_set"].type()) {
        vector<ApplyAddRequestTravelerStandardCarCitySet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["car_city_set"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestTravelerStandardCarCitySet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        carCitySet = make_shared<vector<ApplyAddRequestTravelerStandardCarCitySet>>(expect1);
      }
    }
    if (m.find("economy_discount") != m.end() && !m["economy_discount"].empty()) {
      economyDiscount = make_shared<long>(boost::any_cast<long>(m["economy_discount"]));
    }
    if (m.find("first_discount") != m.end() && !m["first_discount"].empty()) {
      firstDiscount = make_shared<long>(boost::any_cast<long>(m["first_discount"]));
    }
    if (m.find("flight_cabins") != m.end() && !m["flight_cabins"].empty()) {
      flightCabins = make_shared<string>(boost::any_cast<string>(m["flight_cabins"]));
    }
    if (m.find("hotel_citys") != m.end() && !m["hotel_citys"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_citys"].type()) {
        vector<ApplyAddRequestTravelerStandardHotelCitys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_citys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestTravelerStandardHotelCitys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelCitys = make_shared<vector<ApplyAddRequestTravelerStandardHotelCitys>>(expect1);
      }
    }
    if (m.find("international_flight_cabins") != m.end() && !m["international_flight_cabins"].empty()) {
      internationalFlightCabins = make_shared<string>(boost::any_cast<string>(m["international_flight_cabins"]));
    }
    if (m.find("premium_economy_discount") != m.end() && !m["premium_economy_discount"].empty()) {
      premiumEconomyDiscount = make_shared<long>(boost::any_cast<long>(m["premium_economy_discount"]));
    }
    if (m.find("reserve_type") != m.end() && !m["reserve_type"].empty()) {
      reserveType = make_shared<long>(boost::any_cast<long>(m["reserve_type"]));
    }
    if (m.find("train_seats") != m.end() && !m["train_seats"].empty()) {
      trainSeats = make_shared<string>(boost::any_cast<string>(m["train_seats"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~ApplyAddRequestTravelerStandard() = default;
};
class ApplyAddRequest : public Darabonba::Model {
public:
  shared_ptr<long> budget{};
  shared_ptr<long> budgetMerge{};
  shared_ptr<ApplyAddRequestCarRule> carRule{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> extendField{};
  shared_ptr<vector<ApplyAddRequestExternalTravelerList>> externalTravelerList{};
  shared_ptr<ApplyAddRequestExternalTravelerStandard> externalTravelerStandard{};
  shared_ptr<long> flightBudget{};
  shared_ptr<long> hotelBudget{};
  shared_ptr<ApplyAddRequestHotelShare> hotelShare{};
  shared_ptr<string> internationalFlightCabins{};
  shared_ptr<vector<ApplyAddRequestItineraryList>> itineraryList{};
  shared_ptr<long> itineraryRule{};
  shared_ptr<vector<ApplyAddRequestItinerarySetList>> itinerarySetList{};
  shared_ptr<long> limitTraveler{};
  shared_ptr<long> status{};
  shared_ptr<string> subCorpId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartBusinessId{};
  shared_ptr<string> thirdpartDepartId{};
  shared_ptr<long> togetherBookRule{};
  shared_ptr<long> trainBudget{};
  shared_ptr<vector<ApplyAddRequestTravelerList>> travelerList{};
  shared_ptr<vector<ApplyAddRequestTravelerStandard>> travelerStandard{};
  shared_ptr<string> tripCause{};
  shared_ptr<long> tripDay{};
  shared_ptr<string> tripTitle{};
  shared_ptr<long> type{};
  shared_ptr<string> unionNo{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> vehicleBudget{};

  ApplyAddRequest() {}

  explicit ApplyAddRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (budget) {
      res["budget"] = boost::any(*budget);
    }
    if (budgetMerge) {
      res["budget_merge"] = boost::any(*budgetMerge);
    }
    if (carRule) {
      res["car_rule"] = carRule ? boost::any(carRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (extendField) {
      res["extend_field"] = boost::any(*extendField);
    }
    if (externalTravelerList) {
      vector<boost::any> temp1;
      for(auto item1:*externalTravelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["external_traveler_list"] = boost::any(temp1);
    }
    if (externalTravelerStandard) {
      res["external_traveler_standard"] = externalTravelerStandard ? boost::any(externalTravelerStandard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightBudget) {
      res["flight_budget"] = boost::any(*flightBudget);
    }
    if (hotelBudget) {
      res["hotel_budget"] = boost::any(*hotelBudget);
    }
    if (hotelShare) {
      res["hotel_share"] = hotelShare ? boost::any(hotelShare->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (internationalFlightCabins) {
      res["international_flight_cabins"] = boost::any(*internationalFlightCabins);
    }
    if (itineraryList) {
      vector<boost::any> temp1;
      for(auto item1:*itineraryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_list"] = boost::any(temp1);
    }
    if (itineraryRule) {
      res["itinerary_rule"] = boost::any(*itineraryRule);
    }
    if (itinerarySetList) {
      vector<boost::any> temp1;
      for(auto item1:*itinerarySetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_set_list"] = boost::any(temp1);
    }
    if (limitTraveler) {
      res["limit_traveler"] = boost::any(*limitTraveler);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    if (thirdpartDepartId) {
      res["thirdpart_depart_id"] = boost::any(*thirdpartDepartId);
    }
    if (togetherBookRule) {
      res["together_book_rule"] = boost::any(*togetherBookRule);
    }
    if (trainBudget) {
      res["train_budget"] = boost::any(*trainBudget);
    }
    if (travelerList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_list"] = boost::any(temp1);
    }
    if (travelerStandard) {
      vector<boost::any> temp1;
      for(auto item1:*travelerStandard){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_standard"] = boost::any(temp1);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (tripDay) {
      res["trip_day"] = boost::any(*tripDay);
    }
    if (tripTitle) {
      res["trip_title"] = boost::any(*tripTitle);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (unionNo) {
      res["union_no"] = boost::any(*unionNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (vehicleBudget) {
      res["vehicle_budget"] = boost::any(*vehicleBudget);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("budget") != m.end() && !m["budget"].empty()) {
      budget = make_shared<long>(boost::any_cast<long>(m["budget"]));
    }
    if (m.find("budget_merge") != m.end() && !m["budget_merge"].empty()) {
      budgetMerge = make_shared<long>(boost::any_cast<long>(m["budget_merge"]));
    }
    if (m.find("car_rule") != m.end() && !m["car_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["car_rule"].type()) {
        ApplyAddRequestCarRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["car_rule"]));
        carRule = make_shared<ApplyAddRequestCarRule>(model1);
      }
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("extend_field") != m.end() && !m["extend_field"].empty()) {
      extendField = make_shared<string>(boost::any_cast<string>(m["extend_field"]));
    }
    if (m.find("external_traveler_list") != m.end() && !m["external_traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["external_traveler_list"].type()) {
        vector<ApplyAddRequestExternalTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["external_traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestExternalTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        externalTravelerList = make_shared<vector<ApplyAddRequestExternalTravelerList>>(expect1);
      }
    }
    if (m.find("external_traveler_standard") != m.end() && !m["external_traveler_standard"].empty()) {
      if (typeid(map<string, boost::any>) == m["external_traveler_standard"].type()) {
        ApplyAddRequestExternalTravelerStandard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["external_traveler_standard"]));
        externalTravelerStandard = make_shared<ApplyAddRequestExternalTravelerStandard>(model1);
      }
    }
    if (m.find("flight_budget") != m.end() && !m["flight_budget"].empty()) {
      flightBudget = make_shared<long>(boost::any_cast<long>(m["flight_budget"]));
    }
    if (m.find("hotel_budget") != m.end() && !m["hotel_budget"].empty()) {
      hotelBudget = make_shared<long>(boost::any_cast<long>(m["hotel_budget"]));
    }
    if (m.find("hotel_share") != m.end() && !m["hotel_share"].empty()) {
      if (typeid(map<string, boost::any>) == m["hotel_share"].type()) {
        ApplyAddRequestHotelShare model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["hotel_share"]));
        hotelShare = make_shared<ApplyAddRequestHotelShare>(model1);
      }
    }
    if (m.find("international_flight_cabins") != m.end() && !m["international_flight_cabins"].empty()) {
      internationalFlightCabins = make_shared<string>(boost::any_cast<string>(m["international_flight_cabins"]));
    }
    if (m.find("itinerary_list") != m.end() && !m["itinerary_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_list"].type()) {
        vector<ApplyAddRequestItineraryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestItineraryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itineraryList = make_shared<vector<ApplyAddRequestItineraryList>>(expect1);
      }
    }
    if (m.find("itinerary_rule") != m.end() && !m["itinerary_rule"].empty()) {
      itineraryRule = make_shared<long>(boost::any_cast<long>(m["itinerary_rule"]));
    }
    if (m.find("itinerary_set_list") != m.end() && !m["itinerary_set_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_set_list"].type()) {
        vector<ApplyAddRequestItinerarySetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_set_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestItinerarySetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itinerarySetList = make_shared<vector<ApplyAddRequestItinerarySetList>>(expect1);
      }
    }
    if (m.find("limit_traveler") != m.end() && !m["limit_traveler"].empty()) {
      limitTraveler = make_shared<long>(boost::any_cast<long>(m["limit_traveler"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
    if (m.find("thirdpart_depart_id") != m.end() && !m["thirdpart_depart_id"].empty()) {
      thirdpartDepartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_depart_id"]));
    }
    if (m.find("together_book_rule") != m.end() && !m["together_book_rule"].empty()) {
      togetherBookRule = make_shared<long>(boost::any_cast<long>(m["together_book_rule"]));
    }
    if (m.find("train_budget") != m.end() && !m["train_budget"].empty()) {
      trainBudget = make_shared<long>(boost::any_cast<long>(m["train_budget"]));
    }
    if (m.find("traveler_list") != m.end() && !m["traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_list"].type()) {
        vector<ApplyAddRequestTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerList = make_shared<vector<ApplyAddRequestTravelerList>>(expect1);
      }
    }
    if (m.find("traveler_standard") != m.end() && !m["traveler_standard"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_standard"].type()) {
        vector<ApplyAddRequestTravelerStandard> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_standard"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyAddRequestTravelerStandard model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerStandard = make_shared<vector<ApplyAddRequestTravelerStandard>>(expect1);
      }
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("trip_day") != m.end() && !m["trip_day"].empty()) {
      tripDay = make_shared<long>(boost::any_cast<long>(m["trip_day"]));
    }
    if (m.find("trip_title") != m.end() && !m["trip_title"].empty()) {
      tripTitle = make_shared<string>(boost::any_cast<string>(m["trip_title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("union_no") != m.end() && !m["union_no"].empty()) {
      unionNo = make_shared<string>(boost::any_cast<string>(m["union_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("vehicle_budget") != m.end() && !m["vehicle_budget"].empty()) {
      vehicleBudget = make_shared<long>(boost::any_cast<long>(m["vehicle_budget"]));
    }
  }


  virtual ~ApplyAddRequest() = default;
};
class ApplyAddShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> budget{};
  shared_ptr<long> budgetMerge{};
  shared_ptr<string> carRuleShrink{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> extendField{};
  shared_ptr<string> externalTravelerListShrink{};
  shared_ptr<string> externalTravelerStandardShrink{};
  shared_ptr<long> flightBudget{};
  shared_ptr<long> hotelBudget{};
  shared_ptr<string> hotelShareShrink{};
  shared_ptr<string> internationalFlightCabins{};
  shared_ptr<string> itineraryListShrink{};
  shared_ptr<long> itineraryRule{};
  shared_ptr<string> itinerarySetListShrink{};
  shared_ptr<long> limitTraveler{};
  shared_ptr<long> status{};
  shared_ptr<string> subCorpId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartBusinessId{};
  shared_ptr<string> thirdpartDepartId{};
  shared_ptr<long> togetherBookRule{};
  shared_ptr<long> trainBudget{};
  shared_ptr<string> travelerListShrink{};
  shared_ptr<string> travelerStandardShrink{};
  shared_ptr<string> tripCause{};
  shared_ptr<long> tripDay{};
  shared_ptr<string> tripTitle{};
  shared_ptr<long> type{};
  shared_ptr<string> unionNo{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> vehicleBudget{};

  ApplyAddShrinkRequest() {}

  explicit ApplyAddShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (budget) {
      res["budget"] = boost::any(*budget);
    }
    if (budgetMerge) {
      res["budget_merge"] = boost::any(*budgetMerge);
    }
    if (carRuleShrink) {
      res["car_rule"] = boost::any(*carRuleShrink);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (extendField) {
      res["extend_field"] = boost::any(*extendField);
    }
    if (externalTravelerListShrink) {
      res["external_traveler_list"] = boost::any(*externalTravelerListShrink);
    }
    if (externalTravelerStandardShrink) {
      res["external_traveler_standard"] = boost::any(*externalTravelerStandardShrink);
    }
    if (flightBudget) {
      res["flight_budget"] = boost::any(*flightBudget);
    }
    if (hotelBudget) {
      res["hotel_budget"] = boost::any(*hotelBudget);
    }
    if (hotelShareShrink) {
      res["hotel_share"] = boost::any(*hotelShareShrink);
    }
    if (internationalFlightCabins) {
      res["international_flight_cabins"] = boost::any(*internationalFlightCabins);
    }
    if (itineraryListShrink) {
      res["itinerary_list"] = boost::any(*itineraryListShrink);
    }
    if (itineraryRule) {
      res["itinerary_rule"] = boost::any(*itineraryRule);
    }
    if (itinerarySetListShrink) {
      res["itinerary_set_list"] = boost::any(*itinerarySetListShrink);
    }
    if (limitTraveler) {
      res["limit_traveler"] = boost::any(*limitTraveler);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    if (thirdpartDepartId) {
      res["thirdpart_depart_id"] = boost::any(*thirdpartDepartId);
    }
    if (togetherBookRule) {
      res["together_book_rule"] = boost::any(*togetherBookRule);
    }
    if (trainBudget) {
      res["train_budget"] = boost::any(*trainBudget);
    }
    if (travelerListShrink) {
      res["traveler_list"] = boost::any(*travelerListShrink);
    }
    if (travelerStandardShrink) {
      res["traveler_standard"] = boost::any(*travelerStandardShrink);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (tripDay) {
      res["trip_day"] = boost::any(*tripDay);
    }
    if (tripTitle) {
      res["trip_title"] = boost::any(*tripTitle);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (unionNo) {
      res["union_no"] = boost::any(*unionNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (vehicleBudget) {
      res["vehicle_budget"] = boost::any(*vehicleBudget);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("budget") != m.end() && !m["budget"].empty()) {
      budget = make_shared<long>(boost::any_cast<long>(m["budget"]));
    }
    if (m.find("budget_merge") != m.end() && !m["budget_merge"].empty()) {
      budgetMerge = make_shared<long>(boost::any_cast<long>(m["budget_merge"]));
    }
    if (m.find("car_rule") != m.end() && !m["car_rule"].empty()) {
      carRuleShrink = make_shared<string>(boost::any_cast<string>(m["car_rule"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("extend_field") != m.end() && !m["extend_field"].empty()) {
      extendField = make_shared<string>(boost::any_cast<string>(m["extend_field"]));
    }
    if (m.find("external_traveler_list") != m.end() && !m["external_traveler_list"].empty()) {
      externalTravelerListShrink = make_shared<string>(boost::any_cast<string>(m["external_traveler_list"]));
    }
    if (m.find("external_traveler_standard") != m.end() && !m["external_traveler_standard"].empty()) {
      externalTravelerStandardShrink = make_shared<string>(boost::any_cast<string>(m["external_traveler_standard"]));
    }
    if (m.find("flight_budget") != m.end() && !m["flight_budget"].empty()) {
      flightBudget = make_shared<long>(boost::any_cast<long>(m["flight_budget"]));
    }
    if (m.find("hotel_budget") != m.end() && !m["hotel_budget"].empty()) {
      hotelBudget = make_shared<long>(boost::any_cast<long>(m["hotel_budget"]));
    }
    if (m.find("hotel_share") != m.end() && !m["hotel_share"].empty()) {
      hotelShareShrink = make_shared<string>(boost::any_cast<string>(m["hotel_share"]));
    }
    if (m.find("international_flight_cabins") != m.end() && !m["international_flight_cabins"].empty()) {
      internationalFlightCabins = make_shared<string>(boost::any_cast<string>(m["international_flight_cabins"]));
    }
    if (m.find("itinerary_list") != m.end() && !m["itinerary_list"].empty()) {
      itineraryListShrink = make_shared<string>(boost::any_cast<string>(m["itinerary_list"]));
    }
    if (m.find("itinerary_rule") != m.end() && !m["itinerary_rule"].empty()) {
      itineraryRule = make_shared<long>(boost::any_cast<long>(m["itinerary_rule"]));
    }
    if (m.find("itinerary_set_list") != m.end() && !m["itinerary_set_list"].empty()) {
      itinerarySetListShrink = make_shared<string>(boost::any_cast<string>(m["itinerary_set_list"]));
    }
    if (m.find("limit_traveler") != m.end() && !m["limit_traveler"].empty()) {
      limitTraveler = make_shared<long>(boost::any_cast<long>(m["limit_traveler"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
    if (m.find("thirdpart_depart_id") != m.end() && !m["thirdpart_depart_id"].empty()) {
      thirdpartDepartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_depart_id"]));
    }
    if (m.find("together_book_rule") != m.end() && !m["together_book_rule"].empty()) {
      togetherBookRule = make_shared<long>(boost::any_cast<long>(m["together_book_rule"]));
    }
    if (m.find("train_budget") != m.end() && !m["train_budget"].empty()) {
      trainBudget = make_shared<long>(boost::any_cast<long>(m["train_budget"]));
    }
    if (m.find("traveler_list") != m.end() && !m["traveler_list"].empty()) {
      travelerListShrink = make_shared<string>(boost::any_cast<string>(m["traveler_list"]));
    }
    if (m.find("traveler_standard") != m.end() && !m["traveler_standard"].empty()) {
      travelerStandardShrink = make_shared<string>(boost::any_cast<string>(m["traveler_standard"]));
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("trip_day") != m.end() && !m["trip_day"].empty()) {
      tripDay = make_shared<long>(boost::any_cast<long>(m["trip_day"]));
    }
    if (m.find("trip_title") != m.end() && !m["trip_title"].empty()) {
      tripTitle = make_shared<string>(boost::any_cast<string>(m["trip_title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("union_no") != m.end() && !m["union_no"].empty()) {
      unionNo = make_shared<string>(boost::any_cast<string>(m["union_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("vehicle_budget") != m.end() && !m["vehicle_budget"].empty()) {
      vehicleBudget = make_shared<long>(boost::any_cast<long>(m["vehicle_budget"]));
    }
  }


  virtual ~ApplyAddShrinkRequest() = default;
};
class ApplyAddResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartBusinessId{};

  ApplyAddResponseBodyModule() {}

  explicit ApplyAddResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
  }


  virtual ~ApplyAddResponseBodyModule() = default;
};
class ApplyAddResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<ApplyAddResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ApplyAddResponseBody() {}

  explicit ApplyAddResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        ApplyAddResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<ApplyAddResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ApplyAddResponseBody() = default;
};
class ApplyAddResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyAddResponseBody> body{};

  ApplyAddResponse() {}

  explicit ApplyAddResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyAddResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyAddResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyAddResponse() = default;
};
class ApplyApproveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ApplyApproveHeaders() {}

  explicit ApplyApproveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ApplyApproveHeaders() = default;
};
class ApplyApproveRequest : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> note{};
  shared_ptr<string> operateTime{};
  shared_ptr<long> status{};
  shared_ptr<string> subCorpId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyApproveRequest() {}

  explicit ApplyApproveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (note) {
      res["note"] = boost::any(*note);
    }
    if (operateTime) {
      res["operate_time"] = boost::any(*operateTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("note") != m.end() && !m["note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["note"]));
    }
    if (m.find("operate_time") != m.end() && !m["operate_time"].empty()) {
      operateTime = make_shared<string>(boost::any_cast<string>(m["operate_time"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyApproveRequest() = default;
};
class ApplyApproveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ApplyApproveResponseBody() {}

  explicit ApplyApproveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ApplyApproveResponseBody() = default;
};
class ApplyApproveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyApproveResponseBody> body{};

  ApplyApproveResponse() {}

  explicit ApplyApproveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyApproveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyApproveResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyApproveResponse() = default;
};
class ApplyInvoiceTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ApplyInvoiceTaskHeaders() {}

  explicit ApplyInvoiceTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ApplyInvoiceTaskHeaders() = default;
};
class ApplyInvoiceTaskRequestInvoiceTaskList : public Darabonba::Model {
public:
  shared_ptr<string> contact{};
  shared_ptr<string> email{};
  shared_ptr<string> flightInvoiceFee{};
  shared_ptr<string> fuPointInvoiceFee{};
  shared_ptr<string> hotelNormalInvoiceFee{};
  shared_ptr<string> hotelSpecialInvoiceFee{};
  shared_ptr<string> internationalFlightInvoiceFee{};
  shared_ptr<string> invoiceThirdPartId{};
  shared_ptr<string> mailAddress{};
  shared_ptr<string> mailCity{};
  shared_ptr<string> mailFullAddress{};
  shared_ptr<string> mailProvince{};
  shared_ptr<string> penaltyFee{};
  shared_ptr<string> remark{};
  shared_ptr<string> serviceFee{};
  shared_ptr<string> telephone{};
  shared_ptr<string> trainInvoiceFee{};
  shared_ptr<string> vehicleInvoiceFee{};

  ApplyInvoiceTaskRequestInvoiceTaskList() {}

  explicit ApplyInvoiceTaskRequestInvoiceTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contact) {
      res["contact"] = boost::any(*contact);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (flightInvoiceFee) {
      res["flight_invoice_fee"] = boost::any(*flightInvoiceFee);
    }
    if (fuPointInvoiceFee) {
      res["fu_point_invoice_fee"] = boost::any(*fuPointInvoiceFee);
    }
    if (hotelNormalInvoiceFee) {
      res["hotel_normal_invoice_fee"] = boost::any(*hotelNormalInvoiceFee);
    }
    if (hotelSpecialInvoiceFee) {
      res["hotel_special_invoice_fee"] = boost::any(*hotelSpecialInvoiceFee);
    }
    if (internationalFlightInvoiceFee) {
      res["international_flight_invoice_fee"] = boost::any(*internationalFlightInvoiceFee);
    }
    if (invoiceThirdPartId) {
      res["invoice_third_part_id"] = boost::any(*invoiceThirdPartId);
    }
    if (mailAddress) {
      res["mail_address"] = boost::any(*mailAddress);
    }
    if (mailCity) {
      res["mail_city"] = boost::any(*mailCity);
    }
    if (mailFullAddress) {
      res["mail_full_address"] = boost::any(*mailFullAddress);
    }
    if (mailProvince) {
      res["mail_province"] = boost::any(*mailProvince);
    }
    if (penaltyFee) {
      res["penalty_fee"] = boost::any(*penaltyFee);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (telephone) {
      res["telephone"] = boost::any(*telephone);
    }
    if (trainInvoiceFee) {
      res["train_invoice_fee"] = boost::any(*trainInvoiceFee);
    }
    if (vehicleInvoiceFee) {
      res["vehicle_invoice_fee"] = boost::any(*vehicleInvoiceFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contact") != m.end() && !m["contact"].empty()) {
      contact = make_shared<string>(boost::any_cast<string>(m["contact"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("flight_invoice_fee") != m.end() && !m["flight_invoice_fee"].empty()) {
      flightInvoiceFee = make_shared<string>(boost::any_cast<string>(m["flight_invoice_fee"]));
    }
    if (m.find("fu_point_invoice_fee") != m.end() && !m["fu_point_invoice_fee"].empty()) {
      fuPointInvoiceFee = make_shared<string>(boost::any_cast<string>(m["fu_point_invoice_fee"]));
    }
    if (m.find("hotel_normal_invoice_fee") != m.end() && !m["hotel_normal_invoice_fee"].empty()) {
      hotelNormalInvoiceFee = make_shared<string>(boost::any_cast<string>(m["hotel_normal_invoice_fee"]));
    }
    if (m.find("hotel_special_invoice_fee") != m.end() && !m["hotel_special_invoice_fee"].empty()) {
      hotelSpecialInvoiceFee = make_shared<string>(boost::any_cast<string>(m["hotel_special_invoice_fee"]));
    }
    if (m.find("international_flight_invoice_fee") != m.end() && !m["international_flight_invoice_fee"].empty()) {
      internationalFlightInvoiceFee = make_shared<string>(boost::any_cast<string>(m["international_flight_invoice_fee"]));
    }
    if (m.find("invoice_third_part_id") != m.end() && !m["invoice_third_part_id"].empty()) {
      invoiceThirdPartId = make_shared<string>(boost::any_cast<string>(m["invoice_third_part_id"]));
    }
    if (m.find("mail_address") != m.end() && !m["mail_address"].empty()) {
      mailAddress = make_shared<string>(boost::any_cast<string>(m["mail_address"]));
    }
    if (m.find("mail_city") != m.end() && !m["mail_city"].empty()) {
      mailCity = make_shared<string>(boost::any_cast<string>(m["mail_city"]));
    }
    if (m.find("mail_full_address") != m.end() && !m["mail_full_address"].empty()) {
      mailFullAddress = make_shared<string>(boost::any_cast<string>(m["mail_full_address"]));
    }
    if (m.find("mail_province") != m.end() && !m["mail_province"].empty()) {
      mailProvince = make_shared<string>(boost::any_cast<string>(m["mail_province"]));
    }
    if (m.find("penalty_fee") != m.end() && !m["penalty_fee"].empty()) {
      penaltyFee = make_shared<string>(boost::any_cast<string>(m["penalty_fee"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<string>(boost::any_cast<string>(m["service_fee"]));
    }
    if (m.find("telephone") != m.end() && !m["telephone"].empty()) {
      telephone = make_shared<string>(boost::any_cast<string>(m["telephone"]));
    }
    if (m.find("train_invoice_fee") != m.end() && !m["train_invoice_fee"].empty()) {
      trainInvoiceFee = make_shared<string>(boost::any_cast<string>(m["train_invoice_fee"]));
    }
    if (m.find("vehicle_invoice_fee") != m.end() && !m["vehicle_invoice_fee"].empty()) {
      vehicleInvoiceFee = make_shared<string>(boost::any_cast<string>(m["vehicle_invoice_fee"]));
    }
  }


  virtual ~ApplyInvoiceTaskRequestInvoiceTaskList() = default;
};
class ApplyInvoiceTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> billDate{};
  shared_ptr<vector<ApplyInvoiceTaskRequestInvoiceTaskList>> invoiceTaskList{};

  ApplyInvoiceTaskRequest() {}

  explicit ApplyInvoiceTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (invoiceTaskList) {
      vector<boost::any> temp1;
      for(auto item1:*invoiceTaskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["invoice_task_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("invoice_task_list") != m.end() && !m["invoice_task_list"].empty()) {
      if (typeid(vector<boost::any>) == m["invoice_task_list"].type()) {
        vector<ApplyInvoiceTaskRequestInvoiceTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["invoice_task_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyInvoiceTaskRequestInvoiceTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invoiceTaskList = make_shared<vector<ApplyInvoiceTaskRequestInvoiceTaskList>>(expect1);
      }
    }
  }


  virtual ~ApplyInvoiceTaskRequest() = default;
};
class ApplyInvoiceTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> billDate{};
  shared_ptr<string> invoiceTaskListShrink{};

  ApplyInvoiceTaskShrinkRequest() {}

  explicit ApplyInvoiceTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (invoiceTaskListShrink) {
      res["invoice_task_list"] = boost::any(*invoiceTaskListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("invoice_task_list") != m.end() && !m["invoice_task_list"].empty()) {
      invoiceTaskListShrink = make_shared<string>(boost::any_cast<string>(m["invoice_task_list"]));
    }
  }


  virtual ~ApplyInvoiceTaskShrinkRequest() = default;
};
class ApplyInvoiceTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ApplyInvoiceTaskResponseBody() {}

  explicit ApplyInvoiceTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ApplyInvoiceTaskResponseBody() = default;
};
class ApplyInvoiceTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyInvoiceTaskResponseBody> body{};

  ApplyInvoiceTaskResponse() {}

  explicit ApplyInvoiceTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyInvoiceTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyInvoiceTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyInvoiceTaskResponse() = default;
};
class ApplyListQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ApplyListQueryHeaders() {}

  explicit ApplyListQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ApplyListQueryHeaders() = default;
};
class ApplyListQueryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allApply{};
  shared_ptr<string> departId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> gmtModified{};
  shared_ptr<bool> onlyShangLvApply{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> subCorpId{};
  shared_ptr<long> type{};
  shared_ptr<string> unionNo{};
  shared_ptr<string> userId{};

  ApplyListQueryRequest() {}

  explicit ApplyListQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allApply) {
      res["all_apply"] = boost::any(*allApply);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (onlyShangLvApply) {
      res["only_shang_lv_apply"] = boost::any(*onlyShangLvApply);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (unionNo) {
      res["union_no"] = boost::any(*unionNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_apply") != m.end() && !m["all_apply"].empty()) {
      allApply = make_shared<bool>(boost::any_cast<bool>(m["all_apply"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("only_shang_lv_apply") != m.end() && !m["only_shang_lv_apply"].empty()) {
      onlyShangLvApply = make_shared<bool>(boost::any_cast<bool>(m["only_shang_lv_apply"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("union_no") != m.end() && !m["union_no"].empty()) {
      unionNo = make_shared<string>(boost::any_cast<string>(m["union_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~ApplyListQueryRequest() = default;
};
class ApplyListQueryResponseBodyModuleListApproverList : public Darabonba::Model {
public:
  shared_ptr<string> note{};
  shared_ptr<string> operateTime{};
  shared_ptr<long> order{};
  shared_ptr<long> status{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyListQueryResponseBodyModuleListApproverList() {}

  explicit ApplyListQueryResponseBodyModuleListApproverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (note) {
      res["note"] = boost::any(*note);
    }
    if (operateTime) {
      res["operate_time"] = boost::any(*operateTime);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["status_desc"] = boost::any(*statusDesc);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("note") != m.end() && !m["note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["note"]));
    }
    if (m.find("operate_time") != m.end() && !m["operate_time"].empty()) {
      operateTime = make_shared<string>(boost::any_cast<string>(m["operate_time"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["order"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("status_desc") != m.end() && !m["status_desc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["status_desc"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyListQueryResponseBodyModuleListApproverList() = default;
};
class ApplyListQueryResponseBodyModuleListCarRule : public Darabonba::Model {
public:
  shared_ptr<string> scenarioTemplateId{};
  shared_ptr<string> scenarioTemplateName{};

  ApplyListQueryResponseBodyModuleListCarRule() {}

  explicit ApplyListQueryResponseBodyModuleListCarRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scenarioTemplateId) {
      res["scenario_template_id"] = boost::any(*scenarioTemplateId);
    }
    if (scenarioTemplateName) {
      res["scenario_template_name"] = boost::any(*scenarioTemplateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scenario_template_id") != m.end() && !m["scenario_template_id"].empty()) {
      scenarioTemplateId = make_shared<string>(boost::any_cast<string>(m["scenario_template_id"]));
    }
    if (m.find("scenario_template_name") != m.end() && !m["scenario_template_name"].empty()) {
      scenarioTemplateName = make_shared<string>(boost::any_cast<string>(m["scenario_template_name"]));
    }
  }


  virtual ~ApplyListQueryResponseBodyModuleListCarRule() = default;
};
class ApplyListQueryResponseBodyModuleListExternalTravelerList : public Darabonba::Model {
public:
  shared_ptr<string> userName{};

  ApplyListQueryResponseBodyModuleListExternalTravelerList() {}

  explicit ApplyListQueryResponseBodyModuleListExternalTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyListQueryResponseBodyModuleListExternalTravelerList() = default;
};
class ApplyListQueryResponseBodyModuleListItineraryList : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depDate{};
  shared_ptr<string> invoiceName{};
  shared_ptr<string> itineraryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<long> trafficType{};
  shared_ptr<long> tripWay{};

  ApplyListQueryResponseBodyModuleListItineraryList() {}

  explicit ApplyListQueryResponseBodyModuleListItineraryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceName) {
      res["invoice_name"] = boost::any(*invoiceName);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    if (tripWay) {
      res["trip_way"] = boost::any(*tripWay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_name") != m.end() && !m["invoice_name"].empty()) {
      invoiceName = make_shared<string>(boost::any_cast<string>(m["invoice_name"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
    if (m.find("trip_way") != m.end() && !m["trip_way"].empty()) {
      tripWay = make_shared<long>(boost::any_cast<long>(m["trip_way"]));
    }
  }


  virtual ~ApplyListQueryResponseBodyModuleListItineraryList() = default;
};
class ApplyListQueryResponseBodyModuleListItinerarySetList : public Darabonba::Model {
public:
  shared_ptr<string> arrDate{};
  shared_ptr<string> cityCodeSet{};
  shared_ptr<string> citySet{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> depDate{};
  shared_ptr<string> invoiceName{};
  shared_ptr<string> itineraryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<long> trafficType{};

  ApplyListQueryResponseBodyModuleListItinerarySetList() {}

  explicit ApplyListQueryResponseBodyModuleListItinerarySetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (cityCodeSet) {
      res["city_code_set"] = boost::any(*cityCodeSet);
    }
    if (citySet) {
      res["city_set"] = boost::any(*citySet);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceName) {
      res["invoice_name"] = boost::any(*invoiceName);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("city_code_set") != m.end() && !m["city_code_set"].empty()) {
      cityCodeSet = make_shared<string>(boost::any_cast<string>(m["city_code_set"]));
    }
    if (m.find("city_set") != m.end() && !m["city_set"].empty()) {
      citySet = make_shared<string>(boost::any_cast<string>(m["city_set"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_name") != m.end() && !m["invoice_name"].empty()) {
      invoiceName = make_shared<string>(boost::any_cast<string>(m["invoice_name"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
  }


  virtual ~ApplyListQueryResponseBodyModuleListItinerarySetList() = default;
};
class ApplyListQueryResponseBodyModuleListTravelerListCarCitySet : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};

  ApplyListQueryResponseBodyModuleListTravelerListCarCitySet() {}

  explicit ApplyListQueryResponseBodyModuleListTravelerListCarCitySet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
  }


  virtual ~ApplyListQueryResponseBodyModuleListTravelerListCarCitySet() = default;
};
class ApplyListQueryResponseBodyModuleListTravelerList : public Darabonba::Model {
public:
  shared_ptr<vector<ApplyListQueryResponseBodyModuleListTravelerListCarCitySet>> carCitySet{};
  shared_ptr<string> jobNo{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyListQueryResponseBodyModuleListTravelerList() {}

  explicit ApplyListQueryResponseBodyModuleListTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (carCitySet) {
      vector<boost::any> temp1;
      for(auto item1:*carCitySet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["car_city_set"] = boost::any(temp1);
    }
    if (jobNo) {
      res["job_no"] = boost::any(*jobNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("car_city_set") != m.end() && !m["car_city_set"].empty()) {
      if (typeid(vector<boost::any>) == m["car_city_set"].type()) {
        vector<ApplyListQueryResponseBodyModuleListTravelerListCarCitySet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["car_city_set"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyListQueryResponseBodyModuleListTravelerListCarCitySet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        carCitySet = make_shared<vector<ApplyListQueryResponseBodyModuleListTravelerListCarCitySet>>(expect1);
      }
    }
    if (m.find("job_no") != m.end() && !m["job_no"].empty()) {
      jobNo = make_shared<string>(boost::any_cast<string>(m["job_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyListQueryResponseBodyModuleListTravelerList() = default;
};
class ApplyListQueryResponseBodyModuleList : public Darabonba::Model {
public:
  shared_ptr<string> applyShowId{};
  shared_ptr<vector<ApplyListQueryResponseBodyModuleListApproverList>> approverList{};
  shared_ptr<ApplyListQueryResponseBodyModuleListCarRule> carRule{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<vector<ApplyListQueryResponseBodyModuleListExternalTravelerList>> externalTravelerList{};
  shared_ptr<string> flowCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<vector<ApplyListQueryResponseBodyModuleListItineraryList>> itineraryList{};
  shared_ptr<long> itineraryRule{};
  shared_ptr<vector<ApplyListQueryResponseBodyModuleListItinerarySetList>> itinerarySetList{};
  shared_ptr<string> jobNo{};
  shared_ptr<long> status{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> thirdpartBusinessId{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<vector<ApplyListQueryResponseBodyModuleListTravelerList>> travelerList{};
  shared_ptr<string> tripCause{};
  shared_ptr<long> tripDay{};
  shared_ptr<string> tripTitle{};
  shared_ptr<long> type{};
  shared_ptr<string> unionNo{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyListQueryResponseBodyModuleList() {}

  explicit ApplyListQueryResponseBodyModuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyShowId) {
      res["apply_show_id"] = boost::any(*applyShowId);
    }
    if (approverList) {
      vector<boost::any> temp1;
      for(auto item1:*approverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["approver_list"] = boost::any(temp1);
    }
    if (carRule) {
      res["car_rule"] = carRule ? boost::any(carRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (externalTravelerList) {
      vector<boost::any> temp1;
      for(auto item1:*externalTravelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["external_traveler_list"] = boost::any(temp1);
    }
    if (flowCode) {
      res["flow_code"] = boost::any(*flowCode);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (itineraryList) {
      vector<boost::any> temp1;
      for(auto item1:*itineraryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_list"] = boost::any(temp1);
    }
    if (itineraryRule) {
      res["itinerary_rule"] = boost::any(*itineraryRule);
    }
    if (itinerarySetList) {
      vector<boost::any> temp1;
      for(auto item1:*itinerarySetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_set_list"] = boost::any(temp1);
    }
    if (jobNo) {
      res["job_no"] = boost::any(*jobNo);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["status_desc"] = boost::any(*statusDesc);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (travelerList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_list"] = boost::any(temp1);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (tripDay) {
      res["trip_day"] = boost::any(*tripDay);
    }
    if (tripTitle) {
      res["trip_title"] = boost::any(*tripTitle);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (unionNo) {
      res["union_no"] = boost::any(*unionNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_show_id") != m.end() && !m["apply_show_id"].empty()) {
      applyShowId = make_shared<string>(boost::any_cast<string>(m["apply_show_id"]));
    }
    if (m.find("approver_list") != m.end() && !m["approver_list"].empty()) {
      if (typeid(vector<boost::any>) == m["approver_list"].type()) {
        vector<ApplyListQueryResponseBodyModuleListApproverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["approver_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyListQueryResponseBodyModuleListApproverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        approverList = make_shared<vector<ApplyListQueryResponseBodyModuleListApproverList>>(expect1);
      }
    }
    if (m.find("car_rule") != m.end() && !m["car_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["car_rule"].type()) {
        ApplyListQueryResponseBodyModuleListCarRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["car_rule"]));
        carRule = make_shared<ApplyListQueryResponseBodyModuleListCarRule>(model1);
      }
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("external_traveler_list") != m.end() && !m["external_traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["external_traveler_list"].type()) {
        vector<ApplyListQueryResponseBodyModuleListExternalTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["external_traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyListQueryResponseBodyModuleListExternalTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        externalTravelerList = make_shared<vector<ApplyListQueryResponseBodyModuleListExternalTravelerList>>(expect1);
      }
    }
    if (m.find("flow_code") != m.end() && !m["flow_code"].empty()) {
      flowCode = make_shared<string>(boost::any_cast<string>(m["flow_code"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("itinerary_list") != m.end() && !m["itinerary_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_list"].type()) {
        vector<ApplyListQueryResponseBodyModuleListItineraryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyListQueryResponseBodyModuleListItineraryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itineraryList = make_shared<vector<ApplyListQueryResponseBodyModuleListItineraryList>>(expect1);
      }
    }
    if (m.find("itinerary_rule") != m.end() && !m["itinerary_rule"].empty()) {
      itineraryRule = make_shared<long>(boost::any_cast<long>(m["itinerary_rule"]));
    }
    if (m.find("itinerary_set_list") != m.end() && !m["itinerary_set_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_set_list"].type()) {
        vector<ApplyListQueryResponseBodyModuleListItinerarySetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_set_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyListQueryResponseBodyModuleListItinerarySetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itinerarySetList = make_shared<vector<ApplyListQueryResponseBodyModuleListItinerarySetList>>(expect1);
      }
    }
    if (m.find("job_no") != m.end() && !m["job_no"].empty()) {
      jobNo = make_shared<string>(boost::any_cast<string>(m["job_no"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("status_desc") != m.end() && !m["status_desc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["status_desc"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("traveler_list") != m.end() && !m["traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_list"].type()) {
        vector<ApplyListQueryResponseBodyModuleListTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyListQueryResponseBodyModuleListTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerList = make_shared<vector<ApplyListQueryResponseBodyModuleListTravelerList>>(expect1);
      }
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("trip_day") != m.end() && !m["trip_day"].empty()) {
      tripDay = make_shared<long>(boost::any_cast<long>(m["trip_day"]));
    }
    if (m.find("trip_title") != m.end() && !m["trip_title"].empty()) {
      tripTitle = make_shared<string>(boost::any_cast<string>(m["trip_title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("union_no") != m.end() && !m["union_no"].empty()) {
      unionNo = make_shared<string>(boost::any_cast<string>(m["union_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyListQueryResponseBodyModuleList() = default;
};
class ApplyListQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<ApplyListQueryResponseBodyModuleList>> moduleList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ApplyListQueryResponseBody() {}

  explicit ApplyListQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (moduleList) {
      vector<boost::any> temp1;
      for(auto item1:*moduleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module_list"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module_list") != m.end() && !m["module_list"].empty()) {
      if (typeid(vector<boost::any>) == m["module_list"].type()) {
        vector<ApplyListQueryResponseBodyModuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyListQueryResponseBodyModuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        moduleList = make_shared<vector<ApplyListQueryResponseBodyModuleList>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ApplyListQueryResponseBody() = default;
};
class ApplyListQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyListQueryResponseBody> body{};

  ApplyListQueryResponse() {}

  explicit ApplyListQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyListQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyListQueryResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyListQueryResponse() = default;
};
class ApplyModifyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ApplyModifyHeaders() {}

  explicit ApplyModifyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ApplyModifyHeaders() = default;
};
class ApplyModifyRequestCarRule : public Darabonba::Model {
public:
  shared_ptr<string> scenarioTemplateId{};
  shared_ptr<string> scenarioTemplateName{};

  ApplyModifyRequestCarRule() {}

  explicit ApplyModifyRequestCarRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scenarioTemplateId) {
      res["scenario_template_id"] = boost::any(*scenarioTemplateId);
    }
    if (scenarioTemplateName) {
      res["scenario_template_name"] = boost::any(*scenarioTemplateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scenario_template_id") != m.end() && !m["scenario_template_id"].empty()) {
      scenarioTemplateId = make_shared<string>(boost::any_cast<string>(m["scenario_template_id"]));
    }
    if (m.find("scenario_template_name") != m.end() && !m["scenario_template_name"].empty()) {
      scenarioTemplateName = make_shared<string>(boost::any_cast<string>(m["scenario_template_name"]));
    }
  }


  virtual ~ApplyModifyRequestCarRule() = default;
};
class ApplyModifyRequestExternalTravelerList : public Darabonba::Model {
public:
  shared_ptr<string> userName{};

  ApplyModifyRequestExternalTravelerList() {}

  explicit ApplyModifyRequestExternalTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyModifyRequestExternalTravelerList() = default;
};
class ApplyModifyRequestExternalTravelerStandardHotelCitys : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> fee{};

  ApplyModifyRequestExternalTravelerStandardHotelCitys() {}

  explicit ApplyModifyRequestExternalTravelerStandardHotelCitys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
  }


  virtual ~ApplyModifyRequestExternalTravelerStandardHotelCitys() = default;
};
class ApplyModifyRequestExternalTravelerStandard : public Darabonba::Model {
public:
  shared_ptr<long> businessDiscount{};
  shared_ptr<long> economyDiscount{};
  shared_ptr<long> firstDiscount{};
  shared_ptr<string> flightCabins{};
  shared_ptr<vector<ApplyModifyRequestExternalTravelerStandardHotelCitys>> hotelCitys{};
  shared_ptr<long> premiumEconomyDiscount{};
  shared_ptr<long> reserveType{};
  shared_ptr<string> trainSeats{};

  ApplyModifyRequestExternalTravelerStandard() {}

  explicit ApplyModifyRequestExternalTravelerStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessDiscount) {
      res["business_discount"] = boost::any(*businessDiscount);
    }
    if (economyDiscount) {
      res["economy_discount"] = boost::any(*economyDiscount);
    }
    if (firstDiscount) {
      res["first_discount"] = boost::any(*firstDiscount);
    }
    if (flightCabins) {
      res["flight_cabins"] = boost::any(*flightCabins);
    }
    if (hotelCitys) {
      vector<boost::any> temp1;
      for(auto item1:*hotelCitys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_citys"] = boost::any(temp1);
    }
    if (premiumEconomyDiscount) {
      res["premium_economy_discount"] = boost::any(*premiumEconomyDiscount);
    }
    if (reserveType) {
      res["reserve_type"] = boost::any(*reserveType);
    }
    if (trainSeats) {
      res["train_seats"] = boost::any(*trainSeats);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("business_discount") != m.end() && !m["business_discount"].empty()) {
      businessDiscount = make_shared<long>(boost::any_cast<long>(m["business_discount"]));
    }
    if (m.find("economy_discount") != m.end() && !m["economy_discount"].empty()) {
      economyDiscount = make_shared<long>(boost::any_cast<long>(m["economy_discount"]));
    }
    if (m.find("first_discount") != m.end() && !m["first_discount"].empty()) {
      firstDiscount = make_shared<long>(boost::any_cast<long>(m["first_discount"]));
    }
    if (m.find("flight_cabins") != m.end() && !m["flight_cabins"].empty()) {
      flightCabins = make_shared<string>(boost::any_cast<string>(m["flight_cabins"]));
    }
    if (m.find("hotel_citys") != m.end() && !m["hotel_citys"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_citys"].type()) {
        vector<ApplyModifyRequestExternalTravelerStandardHotelCitys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_citys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestExternalTravelerStandardHotelCitys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelCitys = make_shared<vector<ApplyModifyRequestExternalTravelerStandardHotelCitys>>(expect1);
      }
    }
    if (m.find("premium_economy_discount") != m.end() && !m["premium_economy_discount"].empty()) {
      premiumEconomyDiscount = make_shared<long>(boost::any_cast<long>(m["premium_economy_discount"]));
    }
    if (m.find("reserve_type") != m.end() && !m["reserve_type"].empty()) {
      reserveType = make_shared<long>(boost::any_cast<long>(m["reserve_type"]));
    }
    if (m.find("train_seats") != m.end() && !m["train_seats"].empty()) {
      trainSeats = make_shared<string>(boost::any_cast<string>(m["train_seats"]));
    }
  }


  virtual ~ApplyModifyRequestExternalTravelerStandard() = default;
};
class ApplyModifyRequestHotelShare : public Darabonba::Model {
public:
  shared_ptr<string> param{};
  shared_ptr<string> type{};

  ApplyModifyRequestHotelShare() {}

  explicit ApplyModifyRequestHotelShare(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (param) {
      res["param"] = boost::any(*param);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("param") != m.end() && !m["param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["param"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ApplyModifyRequestHotelShare() = default;
};
class ApplyModifyRequestItineraryListItineraryTravelStandard : public Darabonba::Model {
public:
  shared_ptr<long> hotelAvailableNightsPerDay{};

  ApplyModifyRequestItineraryListItineraryTravelStandard() {}

  explicit ApplyModifyRequestItineraryListItineraryTravelStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelAvailableNightsPerDay) {
      res["hotel_available_nights_per_day"] = boost::any(*hotelAvailableNightsPerDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_available_nights_per_day") != m.end() && !m["hotel_available_nights_per_day"].empty()) {
      hotelAvailableNightsPerDay = make_shared<long>(boost::any_cast<long>(m["hotel_available_nights_per_day"]));
    }
  }


  virtual ~ApplyModifyRequestItineraryListItineraryTravelStandard() = default;
};
class ApplyModifyRequestItineraryList : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrDate{};
  shared_ptr<long> costCenterId{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<long> invoiceId{};
  shared_ptr<string> itineraryId{};
  shared_ptr<ApplyModifyRequestItineraryListItineraryTravelStandard> itineraryTravelStandard{};
  shared_ptr<bool> needHotel{};
  shared_ptr<bool> needTraffic{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<string> thirdpartCostCenterId{};
  shared_ptr<long> trafficType{};
  shared_ptr<long> tripWay{};

  ApplyModifyRequestItineraryList() {}

  explicit ApplyModifyRequestItineraryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceId) {
      res["invoice_id"] = boost::any(*invoiceId);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (itineraryTravelStandard) {
      res["itinerary_travel_standard"] = itineraryTravelStandard ? boost::any(itineraryTravelStandard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (needHotel) {
      res["need_hotel"] = boost::any(*needHotel);
    }
    if (needTraffic) {
      res["need_traffic"] = boost::any(*needTraffic);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (thirdpartCostCenterId) {
      res["thirdpart_cost_center_id"] = boost::any(*thirdpartCostCenterId);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    if (tripWay) {
      res["trip_way"] = boost::any(*tripWay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_id") != m.end() && !m["invoice_id"].empty()) {
      invoiceId = make_shared<long>(boost::any_cast<long>(m["invoice_id"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("itinerary_travel_standard") != m.end() && !m["itinerary_travel_standard"].empty()) {
      if (typeid(map<string, boost::any>) == m["itinerary_travel_standard"].type()) {
        ApplyModifyRequestItineraryListItineraryTravelStandard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["itinerary_travel_standard"]));
        itineraryTravelStandard = make_shared<ApplyModifyRequestItineraryListItineraryTravelStandard>(model1);
      }
    }
    if (m.find("need_hotel") != m.end() && !m["need_hotel"].empty()) {
      needHotel = make_shared<bool>(boost::any_cast<bool>(m["need_hotel"]));
    }
    if (m.find("need_traffic") != m.end() && !m["need_traffic"].empty()) {
      needTraffic = make_shared<bool>(boost::any_cast<bool>(m["need_traffic"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("thirdpart_cost_center_id") != m.end() && !m["thirdpart_cost_center_id"].empty()) {
      thirdpartCostCenterId = make_shared<string>(boost::any_cast<string>(m["thirdpart_cost_center_id"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
    if (m.find("trip_way") != m.end() && !m["trip_way"].empty()) {
      tripWay = make_shared<long>(boost::any_cast<long>(m["trip_way"]));
    }
  }


  virtual ~ApplyModifyRequestItineraryList() = default;
};
class ApplyModifyRequestItinerarySetListItineraryTravelStandard : public Darabonba::Model {
public:
  shared_ptr<long> hotelAvailableNightsPerDay{};

  ApplyModifyRequestItinerarySetListItineraryTravelStandard() {}

  explicit ApplyModifyRequestItinerarySetListItineraryTravelStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelAvailableNightsPerDay) {
      res["hotel_available_nights_per_day"] = boost::any(*hotelAvailableNightsPerDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_available_nights_per_day") != m.end() && !m["hotel_available_nights_per_day"].empty()) {
      hotelAvailableNightsPerDay = make_shared<long>(boost::any_cast<long>(m["hotel_available_nights_per_day"]));
    }
  }


  virtual ~ApplyModifyRequestItinerarySetListItineraryTravelStandard() = default;
};
class ApplyModifyRequestItinerarySetList : public Darabonba::Model {
public:
  shared_ptr<string> arrDate{};
  shared_ptr<string> cityCodeSet{};
  shared_ptr<string> citySet{};
  shared_ptr<long> costCenterId{};
  shared_ptr<string> depDate{};
  shared_ptr<long> invoiceId{};
  shared_ptr<string> itineraryId{};
  shared_ptr<ApplyModifyRequestItinerarySetListItineraryTravelStandard> itineraryTravelStandard{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<string> thirdpartCostCenterId{};
  shared_ptr<long> trafficType{};

  ApplyModifyRequestItinerarySetList() {}

  explicit ApplyModifyRequestItinerarySetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (cityCodeSet) {
      res["city_code_set"] = boost::any(*cityCodeSet);
    }
    if (citySet) {
      res["city_set"] = boost::any(*citySet);
    }
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceId) {
      res["invoice_id"] = boost::any(*invoiceId);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (itineraryTravelStandard) {
      res["itinerary_travel_standard"] = itineraryTravelStandard ? boost::any(itineraryTravelStandard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (thirdpartCostCenterId) {
      res["thirdpart_cost_center_id"] = boost::any(*thirdpartCostCenterId);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("city_code_set") != m.end() && !m["city_code_set"].empty()) {
      cityCodeSet = make_shared<string>(boost::any_cast<string>(m["city_code_set"]));
    }
    if (m.find("city_set") != m.end() && !m["city_set"].empty()) {
      citySet = make_shared<string>(boost::any_cast<string>(m["city_set"]));
    }
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_id") != m.end() && !m["invoice_id"].empty()) {
      invoiceId = make_shared<long>(boost::any_cast<long>(m["invoice_id"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("itinerary_travel_standard") != m.end() && !m["itinerary_travel_standard"].empty()) {
      if (typeid(map<string, boost::any>) == m["itinerary_travel_standard"].type()) {
        ApplyModifyRequestItinerarySetListItineraryTravelStandard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["itinerary_travel_standard"]));
        itineraryTravelStandard = make_shared<ApplyModifyRequestItinerarySetListItineraryTravelStandard>(model1);
      }
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("thirdpart_cost_center_id") != m.end() && !m["thirdpart_cost_center_id"].empty()) {
      thirdpartCostCenterId = make_shared<string>(boost::any_cast<string>(m["thirdpart_cost_center_id"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
  }


  virtual ~ApplyModifyRequestItinerarySetList() = default;
};
class ApplyModifyRequestTravelerList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyModifyRequestTravelerList() {}

  explicit ApplyModifyRequestTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyModifyRequestTravelerList() = default;
};
class ApplyModifyRequestTravelerStandardCarCitySet : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};

  ApplyModifyRequestTravelerStandardCarCitySet() {}

  explicit ApplyModifyRequestTravelerStandardCarCitySet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
  }


  virtual ~ApplyModifyRequestTravelerStandardCarCitySet() = default;
};
class ApplyModifyRequestTravelerStandardHotelCitys : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> fee{};

  ApplyModifyRequestTravelerStandardHotelCitys() {}

  explicit ApplyModifyRequestTravelerStandardHotelCitys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
  }


  virtual ~ApplyModifyRequestTravelerStandardHotelCitys() = default;
};
class ApplyModifyRequestTravelerStandard : public Darabonba::Model {
public:
  shared_ptr<long> businessDiscount{};
  shared_ptr<vector<ApplyModifyRequestTravelerStandardCarCitySet>> carCitySet{};
  shared_ptr<long> economyDiscount{};
  shared_ptr<long> firstDiscount{};
  shared_ptr<string> flightCabins{};
  shared_ptr<vector<ApplyModifyRequestTravelerStandardHotelCitys>> hotelCitys{};
  shared_ptr<long> premiumEconomyDiscount{};
  shared_ptr<long> reserveType{};
  shared_ptr<string> trainSeats{};
  shared_ptr<string> userId{};

  ApplyModifyRequestTravelerStandard() {}

  explicit ApplyModifyRequestTravelerStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessDiscount) {
      res["business_discount"] = boost::any(*businessDiscount);
    }
    if (carCitySet) {
      vector<boost::any> temp1;
      for(auto item1:*carCitySet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["car_city_set"] = boost::any(temp1);
    }
    if (economyDiscount) {
      res["economy_discount"] = boost::any(*economyDiscount);
    }
    if (firstDiscount) {
      res["first_discount"] = boost::any(*firstDiscount);
    }
    if (flightCabins) {
      res["flight_cabins"] = boost::any(*flightCabins);
    }
    if (hotelCitys) {
      vector<boost::any> temp1;
      for(auto item1:*hotelCitys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_citys"] = boost::any(temp1);
    }
    if (premiumEconomyDiscount) {
      res["premium_economy_discount"] = boost::any(*premiumEconomyDiscount);
    }
    if (reserveType) {
      res["reserve_type"] = boost::any(*reserveType);
    }
    if (trainSeats) {
      res["train_seats"] = boost::any(*trainSeats);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("business_discount") != m.end() && !m["business_discount"].empty()) {
      businessDiscount = make_shared<long>(boost::any_cast<long>(m["business_discount"]));
    }
    if (m.find("car_city_set") != m.end() && !m["car_city_set"].empty()) {
      if (typeid(vector<boost::any>) == m["car_city_set"].type()) {
        vector<ApplyModifyRequestTravelerStandardCarCitySet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["car_city_set"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestTravelerStandardCarCitySet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        carCitySet = make_shared<vector<ApplyModifyRequestTravelerStandardCarCitySet>>(expect1);
      }
    }
    if (m.find("economy_discount") != m.end() && !m["economy_discount"].empty()) {
      economyDiscount = make_shared<long>(boost::any_cast<long>(m["economy_discount"]));
    }
    if (m.find("first_discount") != m.end() && !m["first_discount"].empty()) {
      firstDiscount = make_shared<long>(boost::any_cast<long>(m["first_discount"]));
    }
    if (m.find("flight_cabins") != m.end() && !m["flight_cabins"].empty()) {
      flightCabins = make_shared<string>(boost::any_cast<string>(m["flight_cabins"]));
    }
    if (m.find("hotel_citys") != m.end() && !m["hotel_citys"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_citys"].type()) {
        vector<ApplyModifyRequestTravelerStandardHotelCitys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_citys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestTravelerStandardHotelCitys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelCitys = make_shared<vector<ApplyModifyRequestTravelerStandardHotelCitys>>(expect1);
      }
    }
    if (m.find("premium_economy_discount") != m.end() && !m["premium_economy_discount"].empty()) {
      premiumEconomyDiscount = make_shared<long>(boost::any_cast<long>(m["premium_economy_discount"]));
    }
    if (m.find("reserve_type") != m.end() && !m["reserve_type"].empty()) {
      reserveType = make_shared<long>(boost::any_cast<long>(m["reserve_type"]));
    }
    if (m.find("train_seats") != m.end() && !m["train_seats"].empty()) {
      trainSeats = make_shared<string>(boost::any_cast<string>(m["train_seats"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~ApplyModifyRequestTravelerStandard() = default;
};
class ApplyModifyRequest : public Darabonba::Model {
public:
  shared_ptr<long> budget{};
  shared_ptr<long> budgetMerge{};
  shared_ptr<ApplyModifyRequestCarRule> carRule{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> extendField{};
  shared_ptr<vector<ApplyModifyRequestExternalTravelerList>> externalTravelerList{};
  shared_ptr<ApplyModifyRequestExternalTravelerStandard> externalTravelerStandard{};
  shared_ptr<long> flightBudget{};
  shared_ptr<long> hotelBudget{};
  shared_ptr<ApplyModifyRequestHotelShare> hotelShare{};
  shared_ptr<vector<ApplyModifyRequestItineraryList>> itineraryList{};
  shared_ptr<long> itineraryRule{};
  shared_ptr<vector<ApplyModifyRequestItinerarySetList>> itinerarySetList{};
  shared_ptr<long> limitTraveler{};
  shared_ptr<long> status{};
  shared_ptr<string> subCorpId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartBusinessId{};
  shared_ptr<string> thirdpartDepartId{};
  shared_ptr<long> togetherBookRule{};
  shared_ptr<long> trainBudget{};
  shared_ptr<vector<ApplyModifyRequestTravelerList>> travelerList{};
  shared_ptr<vector<ApplyModifyRequestTravelerStandard>> travelerStandard{};
  shared_ptr<string> tripCause{};
  shared_ptr<long> tripDay{};
  shared_ptr<string> tripTitle{};
  shared_ptr<string> unionNo{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> vehicleBudget{};

  ApplyModifyRequest() {}

  explicit ApplyModifyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (budget) {
      res["budget"] = boost::any(*budget);
    }
    if (budgetMerge) {
      res["budget_merge"] = boost::any(*budgetMerge);
    }
    if (carRule) {
      res["car_rule"] = carRule ? boost::any(carRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (extendField) {
      res["extend_field"] = boost::any(*extendField);
    }
    if (externalTravelerList) {
      vector<boost::any> temp1;
      for(auto item1:*externalTravelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["external_traveler_list"] = boost::any(temp1);
    }
    if (externalTravelerStandard) {
      res["external_traveler_standard"] = externalTravelerStandard ? boost::any(externalTravelerStandard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightBudget) {
      res["flight_budget"] = boost::any(*flightBudget);
    }
    if (hotelBudget) {
      res["hotel_budget"] = boost::any(*hotelBudget);
    }
    if (hotelShare) {
      res["hotel_share"] = hotelShare ? boost::any(hotelShare->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (itineraryList) {
      vector<boost::any> temp1;
      for(auto item1:*itineraryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_list"] = boost::any(temp1);
    }
    if (itineraryRule) {
      res["itinerary_rule"] = boost::any(*itineraryRule);
    }
    if (itinerarySetList) {
      vector<boost::any> temp1;
      for(auto item1:*itinerarySetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_set_list"] = boost::any(temp1);
    }
    if (limitTraveler) {
      res["limit_traveler"] = boost::any(*limitTraveler);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    if (thirdpartDepartId) {
      res["thirdpart_depart_id"] = boost::any(*thirdpartDepartId);
    }
    if (togetherBookRule) {
      res["together_book_rule"] = boost::any(*togetherBookRule);
    }
    if (trainBudget) {
      res["train_budget"] = boost::any(*trainBudget);
    }
    if (travelerList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_list"] = boost::any(temp1);
    }
    if (travelerStandard) {
      vector<boost::any> temp1;
      for(auto item1:*travelerStandard){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_standard"] = boost::any(temp1);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (tripDay) {
      res["trip_day"] = boost::any(*tripDay);
    }
    if (tripTitle) {
      res["trip_title"] = boost::any(*tripTitle);
    }
    if (unionNo) {
      res["union_no"] = boost::any(*unionNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (vehicleBudget) {
      res["vehicle_budget"] = boost::any(*vehicleBudget);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("budget") != m.end() && !m["budget"].empty()) {
      budget = make_shared<long>(boost::any_cast<long>(m["budget"]));
    }
    if (m.find("budget_merge") != m.end() && !m["budget_merge"].empty()) {
      budgetMerge = make_shared<long>(boost::any_cast<long>(m["budget_merge"]));
    }
    if (m.find("car_rule") != m.end() && !m["car_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["car_rule"].type()) {
        ApplyModifyRequestCarRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["car_rule"]));
        carRule = make_shared<ApplyModifyRequestCarRule>(model1);
      }
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("extend_field") != m.end() && !m["extend_field"].empty()) {
      extendField = make_shared<string>(boost::any_cast<string>(m["extend_field"]));
    }
    if (m.find("external_traveler_list") != m.end() && !m["external_traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["external_traveler_list"].type()) {
        vector<ApplyModifyRequestExternalTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["external_traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestExternalTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        externalTravelerList = make_shared<vector<ApplyModifyRequestExternalTravelerList>>(expect1);
      }
    }
    if (m.find("external_traveler_standard") != m.end() && !m["external_traveler_standard"].empty()) {
      if (typeid(map<string, boost::any>) == m["external_traveler_standard"].type()) {
        ApplyModifyRequestExternalTravelerStandard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["external_traveler_standard"]));
        externalTravelerStandard = make_shared<ApplyModifyRequestExternalTravelerStandard>(model1);
      }
    }
    if (m.find("flight_budget") != m.end() && !m["flight_budget"].empty()) {
      flightBudget = make_shared<long>(boost::any_cast<long>(m["flight_budget"]));
    }
    if (m.find("hotel_budget") != m.end() && !m["hotel_budget"].empty()) {
      hotelBudget = make_shared<long>(boost::any_cast<long>(m["hotel_budget"]));
    }
    if (m.find("hotel_share") != m.end() && !m["hotel_share"].empty()) {
      if (typeid(map<string, boost::any>) == m["hotel_share"].type()) {
        ApplyModifyRequestHotelShare model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["hotel_share"]));
        hotelShare = make_shared<ApplyModifyRequestHotelShare>(model1);
      }
    }
    if (m.find("itinerary_list") != m.end() && !m["itinerary_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_list"].type()) {
        vector<ApplyModifyRequestItineraryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestItineraryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itineraryList = make_shared<vector<ApplyModifyRequestItineraryList>>(expect1);
      }
    }
    if (m.find("itinerary_rule") != m.end() && !m["itinerary_rule"].empty()) {
      itineraryRule = make_shared<long>(boost::any_cast<long>(m["itinerary_rule"]));
    }
    if (m.find("itinerary_set_list") != m.end() && !m["itinerary_set_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_set_list"].type()) {
        vector<ApplyModifyRequestItinerarySetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_set_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestItinerarySetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itinerarySetList = make_shared<vector<ApplyModifyRequestItinerarySetList>>(expect1);
      }
    }
    if (m.find("limit_traveler") != m.end() && !m["limit_traveler"].empty()) {
      limitTraveler = make_shared<long>(boost::any_cast<long>(m["limit_traveler"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
    if (m.find("thirdpart_depart_id") != m.end() && !m["thirdpart_depart_id"].empty()) {
      thirdpartDepartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_depart_id"]));
    }
    if (m.find("together_book_rule") != m.end() && !m["together_book_rule"].empty()) {
      togetherBookRule = make_shared<long>(boost::any_cast<long>(m["together_book_rule"]));
    }
    if (m.find("train_budget") != m.end() && !m["train_budget"].empty()) {
      trainBudget = make_shared<long>(boost::any_cast<long>(m["train_budget"]));
    }
    if (m.find("traveler_list") != m.end() && !m["traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_list"].type()) {
        vector<ApplyModifyRequestTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerList = make_shared<vector<ApplyModifyRequestTravelerList>>(expect1);
      }
    }
    if (m.find("traveler_standard") != m.end() && !m["traveler_standard"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_standard"].type()) {
        vector<ApplyModifyRequestTravelerStandard> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_standard"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyModifyRequestTravelerStandard model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerStandard = make_shared<vector<ApplyModifyRequestTravelerStandard>>(expect1);
      }
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("trip_day") != m.end() && !m["trip_day"].empty()) {
      tripDay = make_shared<long>(boost::any_cast<long>(m["trip_day"]));
    }
    if (m.find("trip_title") != m.end() && !m["trip_title"].empty()) {
      tripTitle = make_shared<string>(boost::any_cast<string>(m["trip_title"]));
    }
    if (m.find("union_no") != m.end() && !m["union_no"].empty()) {
      unionNo = make_shared<string>(boost::any_cast<string>(m["union_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("vehicle_budget") != m.end() && !m["vehicle_budget"].empty()) {
      vehicleBudget = make_shared<long>(boost::any_cast<long>(m["vehicle_budget"]));
    }
  }


  virtual ~ApplyModifyRequest() = default;
};
class ApplyModifyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> budget{};
  shared_ptr<long> budgetMerge{};
  shared_ptr<string> carRuleShrink{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> extendField{};
  shared_ptr<string> externalTravelerListShrink{};
  shared_ptr<string> externalTravelerStandardShrink{};
  shared_ptr<long> flightBudget{};
  shared_ptr<long> hotelBudget{};
  shared_ptr<string> hotelShareShrink{};
  shared_ptr<string> itineraryListShrink{};
  shared_ptr<long> itineraryRule{};
  shared_ptr<string> itinerarySetListShrink{};
  shared_ptr<long> limitTraveler{};
  shared_ptr<long> status{};
  shared_ptr<string> subCorpId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartBusinessId{};
  shared_ptr<string> thirdpartDepartId{};
  shared_ptr<long> togetherBookRule{};
  shared_ptr<long> trainBudget{};
  shared_ptr<string> travelerListShrink{};
  shared_ptr<string> travelerStandardShrink{};
  shared_ptr<string> tripCause{};
  shared_ptr<long> tripDay{};
  shared_ptr<string> tripTitle{};
  shared_ptr<string> unionNo{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> vehicleBudget{};

  ApplyModifyShrinkRequest() {}

  explicit ApplyModifyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (budget) {
      res["budget"] = boost::any(*budget);
    }
    if (budgetMerge) {
      res["budget_merge"] = boost::any(*budgetMerge);
    }
    if (carRuleShrink) {
      res["car_rule"] = boost::any(*carRuleShrink);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (extendField) {
      res["extend_field"] = boost::any(*extendField);
    }
    if (externalTravelerListShrink) {
      res["external_traveler_list"] = boost::any(*externalTravelerListShrink);
    }
    if (externalTravelerStandardShrink) {
      res["external_traveler_standard"] = boost::any(*externalTravelerStandardShrink);
    }
    if (flightBudget) {
      res["flight_budget"] = boost::any(*flightBudget);
    }
    if (hotelBudget) {
      res["hotel_budget"] = boost::any(*hotelBudget);
    }
    if (hotelShareShrink) {
      res["hotel_share"] = boost::any(*hotelShareShrink);
    }
    if (itineraryListShrink) {
      res["itinerary_list"] = boost::any(*itineraryListShrink);
    }
    if (itineraryRule) {
      res["itinerary_rule"] = boost::any(*itineraryRule);
    }
    if (itinerarySetListShrink) {
      res["itinerary_set_list"] = boost::any(*itinerarySetListShrink);
    }
    if (limitTraveler) {
      res["limit_traveler"] = boost::any(*limitTraveler);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    if (thirdpartDepartId) {
      res["thirdpart_depart_id"] = boost::any(*thirdpartDepartId);
    }
    if (togetherBookRule) {
      res["together_book_rule"] = boost::any(*togetherBookRule);
    }
    if (trainBudget) {
      res["train_budget"] = boost::any(*trainBudget);
    }
    if (travelerListShrink) {
      res["traveler_list"] = boost::any(*travelerListShrink);
    }
    if (travelerStandardShrink) {
      res["traveler_standard"] = boost::any(*travelerStandardShrink);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (tripDay) {
      res["trip_day"] = boost::any(*tripDay);
    }
    if (tripTitle) {
      res["trip_title"] = boost::any(*tripTitle);
    }
    if (unionNo) {
      res["union_no"] = boost::any(*unionNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (vehicleBudget) {
      res["vehicle_budget"] = boost::any(*vehicleBudget);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("budget") != m.end() && !m["budget"].empty()) {
      budget = make_shared<long>(boost::any_cast<long>(m["budget"]));
    }
    if (m.find("budget_merge") != m.end() && !m["budget_merge"].empty()) {
      budgetMerge = make_shared<long>(boost::any_cast<long>(m["budget_merge"]));
    }
    if (m.find("car_rule") != m.end() && !m["car_rule"].empty()) {
      carRuleShrink = make_shared<string>(boost::any_cast<string>(m["car_rule"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("extend_field") != m.end() && !m["extend_field"].empty()) {
      extendField = make_shared<string>(boost::any_cast<string>(m["extend_field"]));
    }
    if (m.find("external_traveler_list") != m.end() && !m["external_traveler_list"].empty()) {
      externalTravelerListShrink = make_shared<string>(boost::any_cast<string>(m["external_traveler_list"]));
    }
    if (m.find("external_traveler_standard") != m.end() && !m["external_traveler_standard"].empty()) {
      externalTravelerStandardShrink = make_shared<string>(boost::any_cast<string>(m["external_traveler_standard"]));
    }
    if (m.find("flight_budget") != m.end() && !m["flight_budget"].empty()) {
      flightBudget = make_shared<long>(boost::any_cast<long>(m["flight_budget"]));
    }
    if (m.find("hotel_budget") != m.end() && !m["hotel_budget"].empty()) {
      hotelBudget = make_shared<long>(boost::any_cast<long>(m["hotel_budget"]));
    }
    if (m.find("hotel_share") != m.end() && !m["hotel_share"].empty()) {
      hotelShareShrink = make_shared<string>(boost::any_cast<string>(m["hotel_share"]));
    }
    if (m.find("itinerary_list") != m.end() && !m["itinerary_list"].empty()) {
      itineraryListShrink = make_shared<string>(boost::any_cast<string>(m["itinerary_list"]));
    }
    if (m.find("itinerary_rule") != m.end() && !m["itinerary_rule"].empty()) {
      itineraryRule = make_shared<long>(boost::any_cast<long>(m["itinerary_rule"]));
    }
    if (m.find("itinerary_set_list") != m.end() && !m["itinerary_set_list"].empty()) {
      itinerarySetListShrink = make_shared<string>(boost::any_cast<string>(m["itinerary_set_list"]));
    }
    if (m.find("limit_traveler") != m.end() && !m["limit_traveler"].empty()) {
      limitTraveler = make_shared<long>(boost::any_cast<long>(m["limit_traveler"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
    if (m.find("thirdpart_depart_id") != m.end() && !m["thirdpart_depart_id"].empty()) {
      thirdpartDepartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_depart_id"]));
    }
    if (m.find("together_book_rule") != m.end() && !m["together_book_rule"].empty()) {
      togetherBookRule = make_shared<long>(boost::any_cast<long>(m["together_book_rule"]));
    }
    if (m.find("train_budget") != m.end() && !m["train_budget"].empty()) {
      trainBudget = make_shared<long>(boost::any_cast<long>(m["train_budget"]));
    }
    if (m.find("traveler_list") != m.end() && !m["traveler_list"].empty()) {
      travelerListShrink = make_shared<string>(boost::any_cast<string>(m["traveler_list"]));
    }
    if (m.find("traveler_standard") != m.end() && !m["traveler_standard"].empty()) {
      travelerStandardShrink = make_shared<string>(boost::any_cast<string>(m["traveler_standard"]));
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("trip_day") != m.end() && !m["trip_day"].empty()) {
      tripDay = make_shared<long>(boost::any_cast<long>(m["trip_day"]));
    }
    if (m.find("trip_title") != m.end() && !m["trip_title"].empty()) {
      tripTitle = make_shared<string>(boost::any_cast<string>(m["trip_title"]));
    }
    if (m.find("union_no") != m.end() && !m["union_no"].empty()) {
      unionNo = make_shared<string>(boost::any_cast<string>(m["union_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("vehicle_budget") != m.end() && !m["vehicle_budget"].empty()) {
      vehicleBudget = make_shared<long>(boost::any_cast<long>(m["vehicle_budget"]));
    }
  }


  virtual ~ApplyModifyShrinkRequest() = default;
};
class ApplyModifyResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartBusinessId{};

  ApplyModifyResponseBodyModule() {}

  explicit ApplyModifyResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
  }


  virtual ~ApplyModifyResponseBodyModule() = default;
};
class ApplyModifyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<ApplyModifyResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ApplyModifyResponseBody() {}

  explicit ApplyModifyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        ApplyModifyResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<ApplyModifyResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ApplyModifyResponseBody() = default;
};
class ApplyModifyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyModifyResponseBody> body{};

  ApplyModifyResponse() {}

  explicit ApplyModifyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyModifyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyModifyResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyModifyResponse() = default;
};
class ApplyQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ApplyQueryHeaders() {}

  explicit ApplyQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ApplyQueryHeaders() = default;
};
class ApplyQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> applyShowId{};
  shared_ptr<string> subCorpId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<long> type{};

  ApplyQueryRequest() {}

  explicit ApplyQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (applyShowId) {
      res["apply_show_id"] = boost::any(*applyShowId);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("apply_show_id") != m.end() && !m["apply_show_id"].empty()) {
      applyShowId = make_shared<string>(boost::any_cast<string>(m["apply_show_id"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~ApplyQueryRequest() = default;
};
class ApplyQueryResponseBodyModuleApproverList : public Darabonba::Model {
public:
  shared_ptr<string> note{};
  shared_ptr<string> operateTime{};
  shared_ptr<long> order{};
  shared_ptr<long> status{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyQueryResponseBodyModuleApproverList() {}

  explicit ApplyQueryResponseBodyModuleApproverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (note) {
      res["note"] = boost::any(*note);
    }
    if (operateTime) {
      res["operate_time"] = boost::any(*operateTime);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["status_desc"] = boost::any(*statusDesc);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("note") != m.end() && !m["note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["note"]));
    }
    if (m.find("operate_time") != m.end() && !m["operate_time"].empty()) {
      operateTime = make_shared<string>(boost::any_cast<string>(m["operate_time"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["order"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("status_desc") != m.end() && !m["status_desc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["status_desc"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleApproverList() = default;
};
class ApplyQueryResponseBodyModuleCarRule : public Darabonba::Model {
public:
  shared_ptr<string> scenarioTemplateId{};
  shared_ptr<string> scenarioTemplateName{};

  ApplyQueryResponseBodyModuleCarRule() {}

  explicit ApplyQueryResponseBodyModuleCarRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scenarioTemplateId) {
      res["scenario_template_id"] = boost::any(*scenarioTemplateId);
    }
    if (scenarioTemplateName) {
      res["scenario_template_name"] = boost::any(*scenarioTemplateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scenario_template_id") != m.end() && !m["scenario_template_id"].empty()) {
      scenarioTemplateId = make_shared<string>(boost::any_cast<string>(m["scenario_template_id"]));
    }
    if (m.find("scenario_template_name") != m.end() && !m["scenario_template_name"].empty()) {
      scenarioTemplateName = make_shared<string>(boost::any_cast<string>(m["scenario_template_name"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleCarRule() = default;
};
class ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> fee{};

  ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys() {}

  explicit ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys() = default;
};
class ApplyQueryResponseBodyModuleExternalTravelerList : public Darabonba::Model {
public:
  shared_ptr<long> businessDiscount{};
  shared_ptr<long> economyDiscount{};
  shared_ptr<long> firstDiscount{};
  shared_ptr<string> flightCabins{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys>> hotelCitys{};
  shared_ptr<long> premiumEconomyDiscount{};
  shared_ptr<long> reserveType{};
  shared_ptr<string> trainSeats{};
  shared_ptr<string> userName{};

  ApplyQueryResponseBodyModuleExternalTravelerList() {}

  explicit ApplyQueryResponseBodyModuleExternalTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessDiscount) {
      res["business_discount"] = boost::any(*businessDiscount);
    }
    if (economyDiscount) {
      res["economy_discount"] = boost::any(*economyDiscount);
    }
    if (firstDiscount) {
      res["first_discount"] = boost::any(*firstDiscount);
    }
    if (flightCabins) {
      res["flight_cabins"] = boost::any(*flightCabins);
    }
    if (hotelCitys) {
      vector<boost::any> temp1;
      for(auto item1:*hotelCitys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_citys"] = boost::any(temp1);
    }
    if (premiumEconomyDiscount) {
      res["premium_economy_discount"] = boost::any(*premiumEconomyDiscount);
    }
    if (reserveType) {
      res["reserve_type"] = boost::any(*reserveType);
    }
    if (trainSeats) {
      res["train_seats"] = boost::any(*trainSeats);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("business_discount") != m.end() && !m["business_discount"].empty()) {
      businessDiscount = make_shared<long>(boost::any_cast<long>(m["business_discount"]));
    }
    if (m.find("economy_discount") != m.end() && !m["economy_discount"].empty()) {
      economyDiscount = make_shared<long>(boost::any_cast<long>(m["economy_discount"]));
    }
    if (m.find("first_discount") != m.end() && !m["first_discount"].empty()) {
      firstDiscount = make_shared<long>(boost::any_cast<long>(m["first_discount"]));
    }
    if (m.find("flight_cabins") != m.end() && !m["flight_cabins"].empty()) {
      flightCabins = make_shared<string>(boost::any_cast<string>(m["flight_cabins"]));
    }
    if (m.find("hotel_citys") != m.end() && !m["hotel_citys"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_citys"].type()) {
        vector<ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_citys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelCitys = make_shared<vector<ApplyQueryResponseBodyModuleExternalTravelerListHotelCitys>>(expect1);
      }
    }
    if (m.find("premium_economy_discount") != m.end() && !m["premium_economy_discount"].empty()) {
      premiumEconomyDiscount = make_shared<long>(boost::any_cast<long>(m["premium_economy_discount"]));
    }
    if (m.find("reserve_type") != m.end() && !m["reserve_type"].empty()) {
      reserveType = make_shared<long>(boost::any_cast<long>(m["reserve_type"]));
    }
    if (m.find("train_seats") != m.end() && !m["train_seats"].empty()) {
      trainSeats = make_shared<string>(boost::any_cast<string>(m["train_seats"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleExternalTravelerList() = default;
};
class ApplyQueryResponseBodyModuleHotelShare : public Darabonba::Model {
public:
  shared_ptr<string> param{};
  shared_ptr<string> type{};

  ApplyQueryResponseBodyModuleHotelShare() {}

  explicit ApplyQueryResponseBodyModuleHotelShare(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (param) {
      res["param"] = boost::any(*param);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("param") != m.end() && !m["param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["param"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleHotelShare() = default;
};
class ApplyQueryResponseBodyModuleItineraryListItineraryTravelStandard : public Darabonba::Model {
public:
  shared_ptr<long> hotelAvailableNightsPerDay{};

  ApplyQueryResponseBodyModuleItineraryListItineraryTravelStandard() {}

  explicit ApplyQueryResponseBodyModuleItineraryListItineraryTravelStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelAvailableNightsPerDay) {
      res["hotel_available_nights_per_day"] = boost::any(*hotelAvailableNightsPerDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_available_nights_per_day") != m.end() && !m["hotel_available_nights_per_day"].empty()) {
      hotelAvailableNightsPerDay = make_shared<long>(boost::any_cast<long>(m["hotel_available_nights_per_day"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleItineraryListItineraryTravelStandard() = default;
};
class ApplyQueryResponseBodyModuleItineraryList : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<string> invoiceName{};
  shared_ptr<string> itineraryId{};
  shared_ptr<ApplyQueryResponseBodyModuleItineraryListItineraryTravelStandard> itineraryTravelStandard{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<long> trafficType{};
  shared_ptr<long> tripWay{};

  ApplyQueryResponseBodyModuleItineraryList() {}

  explicit ApplyQueryResponseBodyModuleItineraryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceName) {
      res["invoice_name"] = boost::any(*invoiceName);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (itineraryTravelStandard) {
      res["itinerary_travel_standard"] = itineraryTravelStandard ? boost::any(itineraryTravelStandard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    if (tripWay) {
      res["trip_way"] = boost::any(*tripWay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_name") != m.end() && !m["invoice_name"].empty()) {
      invoiceName = make_shared<string>(boost::any_cast<string>(m["invoice_name"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("itinerary_travel_standard") != m.end() && !m["itinerary_travel_standard"].empty()) {
      if (typeid(map<string, boost::any>) == m["itinerary_travel_standard"].type()) {
        ApplyQueryResponseBodyModuleItineraryListItineraryTravelStandard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["itinerary_travel_standard"]));
        itineraryTravelStandard = make_shared<ApplyQueryResponseBodyModuleItineraryListItineraryTravelStandard>(model1);
      }
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
    if (m.find("trip_way") != m.end() && !m["trip_way"].empty()) {
      tripWay = make_shared<long>(boost::any_cast<long>(m["trip_way"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleItineraryList() = default;
};
class ApplyQueryResponseBodyModuleItinerarySetListItineraryTravelStandard : public Darabonba::Model {
public:
  shared_ptr<long> hotelAvailableNightsPerDay{};

  ApplyQueryResponseBodyModuleItinerarySetListItineraryTravelStandard() {}

  explicit ApplyQueryResponseBodyModuleItinerarySetListItineraryTravelStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelAvailableNightsPerDay) {
      res["hotel_available_nights_per_day"] = boost::any(*hotelAvailableNightsPerDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_available_nights_per_day") != m.end() && !m["hotel_available_nights_per_day"].empty()) {
      hotelAvailableNightsPerDay = make_shared<long>(boost::any_cast<long>(m["hotel_available_nights_per_day"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleItinerarySetListItineraryTravelStandard() = default;
};
class ApplyQueryResponseBodyModuleItinerarySetList : public Darabonba::Model {
public:
  shared_ptr<string> arrDate{};
  shared_ptr<string> cityCodeSet{};
  shared_ptr<string> citySet{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> depDate{};
  shared_ptr<string> invoiceName{};
  shared_ptr<string> itineraryId{};
  shared_ptr<ApplyQueryResponseBodyModuleItinerarySetListItineraryTravelStandard> itineraryTravelStandard{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<long> trafficType{};

  ApplyQueryResponseBodyModuleItinerarySetList() {}

  explicit ApplyQueryResponseBodyModuleItinerarySetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (cityCodeSet) {
      res["city_code_set"] = boost::any(*cityCodeSet);
    }
    if (citySet) {
      res["city_set"] = boost::any(*citySet);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceName) {
      res["invoice_name"] = boost::any(*invoiceName);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (itineraryTravelStandard) {
      res["itinerary_travel_standard"] = itineraryTravelStandard ? boost::any(itineraryTravelStandard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("city_code_set") != m.end() && !m["city_code_set"].empty()) {
      cityCodeSet = make_shared<string>(boost::any_cast<string>(m["city_code_set"]));
    }
    if (m.find("city_set") != m.end() && !m["city_set"].empty()) {
      citySet = make_shared<string>(boost::any_cast<string>(m["city_set"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_name") != m.end() && !m["invoice_name"].empty()) {
      invoiceName = make_shared<string>(boost::any_cast<string>(m["invoice_name"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("itinerary_travel_standard") != m.end() && !m["itinerary_travel_standard"].empty()) {
      if (typeid(map<string, boost::any>) == m["itinerary_travel_standard"].type()) {
        ApplyQueryResponseBodyModuleItinerarySetListItineraryTravelStandard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["itinerary_travel_standard"]));
        itineraryTravelStandard = make_shared<ApplyQueryResponseBodyModuleItinerarySetListItineraryTravelStandard>(model1);
      }
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleItinerarySetList() = default;
};
class ApplyQueryResponseBodyModuleTravelerListCarCitySet : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};

  ApplyQueryResponseBodyModuleTravelerListCarCitySet() {}

  explicit ApplyQueryResponseBodyModuleTravelerListCarCitySet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleTravelerListCarCitySet() = default;
};
class ApplyQueryResponseBodyModuleTravelerListHotelCitys : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> fee{};

  ApplyQueryResponseBodyModuleTravelerListHotelCitys() {}

  explicit ApplyQueryResponseBodyModuleTravelerListHotelCitys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleTravelerListHotelCitys() = default;
};
class ApplyQueryResponseBodyModuleTravelerList : public Darabonba::Model {
public:
  shared_ptr<long> businessDiscount{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleTravelerListCarCitySet>> carCitySet{};
  shared_ptr<long> economyDiscount{};
  shared_ptr<long> firstDiscount{};
  shared_ptr<string> flightCabins{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleTravelerListHotelCitys>> hotelCitys{};
  shared_ptr<long> premiumEconomyDiscount{};
  shared_ptr<long> reserveType{};
  shared_ptr<string> trainSeats{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  ApplyQueryResponseBodyModuleTravelerList() {}

  explicit ApplyQueryResponseBodyModuleTravelerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessDiscount) {
      res["business_discount"] = boost::any(*businessDiscount);
    }
    if (carCitySet) {
      vector<boost::any> temp1;
      for(auto item1:*carCitySet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["car_city_set"] = boost::any(temp1);
    }
    if (economyDiscount) {
      res["economy_discount"] = boost::any(*economyDiscount);
    }
    if (firstDiscount) {
      res["first_discount"] = boost::any(*firstDiscount);
    }
    if (flightCabins) {
      res["flight_cabins"] = boost::any(*flightCabins);
    }
    if (hotelCitys) {
      vector<boost::any> temp1;
      for(auto item1:*hotelCitys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_citys"] = boost::any(temp1);
    }
    if (premiumEconomyDiscount) {
      res["premium_economy_discount"] = boost::any(*premiumEconomyDiscount);
    }
    if (reserveType) {
      res["reserve_type"] = boost::any(*reserveType);
    }
    if (trainSeats) {
      res["train_seats"] = boost::any(*trainSeats);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("business_discount") != m.end() && !m["business_discount"].empty()) {
      businessDiscount = make_shared<long>(boost::any_cast<long>(m["business_discount"]));
    }
    if (m.find("car_city_set") != m.end() && !m["car_city_set"].empty()) {
      if (typeid(vector<boost::any>) == m["car_city_set"].type()) {
        vector<ApplyQueryResponseBodyModuleTravelerListCarCitySet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["car_city_set"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleTravelerListCarCitySet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        carCitySet = make_shared<vector<ApplyQueryResponseBodyModuleTravelerListCarCitySet>>(expect1);
      }
    }
    if (m.find("economy_discount") != m.end() && !m["economy_discount"].empty()) {
      economyDiscount = make_shared<long>(boost::any_cast<long>(m["economy_discount"]));
    }
    if (m.find("first_discount") != m.end() && !m["first_discount"].empty()) {
      firstDiscount = make_shared<long>(boost::any_cast<long>(m["first_discount"]));
    }
    if (m.find("flight_cabins") != m.end() && !m["flight_cabins"].empty()) {
      flightCabins = make_shared<string>(boost::any_cast<string>(m["flight_cabins"]));
    }
    if (m.find("hotel_citys") != m.end() && !m["hotel_citys"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_citys"].type()) {
        vector<ApplyQueryResponseBodyModuleTravelerListHotelCitys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_citys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleTravelerListHotelCitys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelCitys = make_shared<vector<ApplyQueryResponseBodyModuleTravelerListHotelCitys>>(expect1);
      }
    }
    if (m.find("premium_economy_discount") != m.end() && !m["premium_economy_discount"].empty()) {
      premiumEconomyDiscount = make_shared<long>(boost::any_cast<long>(m["premium_economy_discount"]));
    }
    if (m.find("reserve_type") != m.end() && !m["reserve_type"].empty()) {
      reserveType = make_shared<long>(boost::any_cast<long>(m["reserve_type"]));
    }
    if (m.find("train_seats") != m.end() && !m["train_seats"].empty()) {
      trainSeats = make_shared<string>(boost::any_cast<string>(m["train_seats"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModuleTravelerList() = default;
};
class ApplyQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> applyShowId{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleApproverList>> approverList{};
  shared_ptr<long> budget{};
  shared_ptr<long> budgetMerge{};
  shared_ptr<ApplyQueryResponseBodyModuleCarRule> carRule{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> extendField{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleExternalTravelerList>> externalTravelerList{};
  shared_ptr<long> flightBudget{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> hotelBudget{};
  shared_ptr<ApplyQueryResponseBodyModuleHotelShare> hotelShare{};
  shared_ptr<long> id{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleItineraryList>> itineraryList{};
  shared_ptr<long> itineraryRule{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleItinerarySetList>> itinerarySetList{};
  shared_ptr<long> limitTraveler{};
  shared_ptr<long> status{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> thirdpartBusinessId{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<long> togetherBookRule{};
  shared_ptr<long> trainBudget{};
  shared_ptr<vector<ApplyQueryResponseBodyModuleTravelerList>> travelerList{};
  shared_ptr<string> tripCause{};
  shared_ptr<long> tripDay{};
  shared_ptr<string> tripTitle{};
  shared_ptr<long> type{};
  shared_ptr<string> unionNo{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> vehicleBudget{};

  ApplyQueryResponseBodyModule() {}

  explicit ApplyQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyShowId) {
      res["apply_show_id"] = boost::any(*applyShowId);
    }
    if (approverList) {
      vector<boost::any> temp1;
      for(auto item1:*approverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["approver_list"] = boost::any(temp1);
    }
    if (budget) {
      res["budget"] = boost::any(*budget);
    }
    if (budgetMerge) {
      res["budget_merge"] = boost::any(*budgetMerge);
    }
    if (carRule) {
      res["car_rule"] = carRule ? boost::any(carRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (extendField) {
      res["extend_field"] = boost::any(*extendField);
    }
    if (externalTravelerList) {
      vector<boost::any> temp1;
      for(auto item1:*externalTravelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["external_traveler_list"] = boost::any(temp1);
    }
    if (flightBudget) {
      res["flight_budget"] = boost::any(*flightBudget);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (hotelBudget) {
      res["hotel_budget"] = boost::any(*hotelBudget);
    }
    if (hotelShare) {
      res["hotel_share"] = hotelShare ? boost::any(hotelShare->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (itineraryList) {
      vector<boost::any> temp1;
      for(auto item1:*itineraryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_list"] = boost::any(temp1);
    }
    if (itineraryRule) {
      res["itinerary_rule"] = boost::any(*itineraryRule);
    }
    if (itinerarySetList) {
      vector<boost::any> temp1;
      for(auto item1:*itinerarySetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_set_list"] = boost::any(temp1);
    }
    if (limitTraveler) {
      res["limit_traveler"] = boost::any(*limitTraveler);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["status_desc"] = boost::any(*statusDesc);
    }
    if (thirdpartBusinessId) {
      res["thirdpart_business_id"] = boost::any(*thirdpartBusinessId);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (togetherBookRule) {
      res["together_book_rule"] = boost::any(*togetherBookRule);
    }
    if (trainBudget) {
      res["train_budget"] = boost::any(*trainBudget);
    }
    if (travelerList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_list"] = boost::any(temp1);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (tripDay) {
      res["trip_day"] = boost::any(*tripDay);
    }
    if (tripTitle) {
      res["trip_title"] = boost::any(*tripTitle);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (unionNo) {
      res["union_no"] = boost::any(*unionNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (vehicleBudget) {
      res["vehicle_budget"] = boost::any(*vehicleBudget);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_show_id") != m.end() && !m["apply_show_id"].empty()) {
      applyShowId = make_shared<string>(boost::any_cast<string>(m["apply_show_id"]));
    }
    if (m.find("approver_list") != m.end() && !m["approver_list"].empty()) {
      if (typeid(vector<boost::any>) == m["approver_list"].type()) {
        vector<ApplyQueryResponseBodyModuleApproverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["approver_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleApproverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        approverList = make_shared<vector<ApplyQueryResponseBodyModuleApproverList>>(expect1);
      }
    }
    if (m.find("budget") != m.end() && !m["budget"].empty()) {
      budget = make_shared<long>(boost::any_cast<long>(m["budget"]));
    }
    if (m.find("budget_merge") != m.end() && !m["budget_merge"].empty()) {
      budgetMerge = make_shared<long>(boost::any_cast<long>(m["budget_merge"]));
    }
    if (m.find("car_rule") != m.end() && !m["car_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["car_rule"].type()) {
        ApplyQueryResponseBodyModuleCarRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["car_rule"]));
        carRule = make_shared<ApplyQueryResponseBodyModuleCarRule>(model1);
      }
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("extend_field") != m.end() && !m["extend_field"].empty()) {
      extendField = make_shared<string>(boost::any_cast<string>(m["extend_field"]));
    }
    if (m.find("external_traveler_list") != m.end() && !m["external_traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["external_traveler_list"].type()) {
        vector<ApplyQueryResponseBodyModuleExternalTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["external_traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleExternalTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        externalTravelerList = make_shared<vector<ApplyQueryResponseBodyModuleExternalTravelerList>>(expect1);
      }
    }
    if (m.find("flight_budget") != m.end() && !m["flight_budget"].empty()) {
      flightBudget = make_shared<long>(boost::any_cast<long>(m["flight_budget"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("hotel_budget") != m.end() && !m["hotel_budget"].empty()) {
      hotelBudget = make_shared<long>(boost::any_cast<long>(m["hotel_budget"]));
    }
    if (m.find("hotel_share") != m.end() && !m["hotel_share"].empty()) {
      if (typeid(map<string, boost::any>) == m["hotel_share"].type()) {
        ApplyQueryResponseBodyModuleHotelShare model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["hotel_share"]));
        hotelShare = make_shared<ApplyQueryResponseBodyModuleHotelShare>(model1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("itinerary_list") != m.end() && !m["itinerary_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_list"].type()) {
        vector<ApplyQueryResponseBodyModuleItineraryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleItineraryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itineraryList = make_shared<vector<ApplyQueryResponseBodyModuleItineraryList>>(expect1);
      }
    }
    if (m.find("itinerary_rule") != m.end() && !m["itinerary_rule"].empty()) {
      itineraryRule = make_shared<long>(boost::any_cast<long>(m["itinerary_rule"]));
    }
    if (m.find("itinerary_set_list") != m.end() && !m["itinerary_set_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_set_list"].type()) {
        vector<ApplyQueryResponseBodyModuleItinerarySetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_set_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleItinerarySetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itinerarySetList = make_shared<vector<ApplyQueryResponseBodyModuleItinerarySetList>>(expect1);
      }
    }
    if (m.find("limit_traveler") != m.end() && !m["limit_traveler"].empty()) {
      limitTraveler = make_shared<long>(boost::any_cast<long>(m["limit_traveler"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("status_desc") != m.end() && !m["status_desc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["status_desc"]));
    }
    if (m.find("thirdpart_business_id") != m.end() && !m["thirdpart_business_id"].empty()) {
      thirdpartBusinessId = make_shared<string>(boost::any_cast<string>(m["thirdpart_business_id"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("together_book_rule") != m.end() && !m["together_book_rule"].empty()) {
      togetherBookRule = make_shared<long>(boost::any_cast<long>(m["together_book_rule"]));
    }
    if (m.find("train_budget") != m.end() && !m["train_budget"].empty()) {
      trainBudget = make_shared<long>(boost::any_cast<long>(m["train_budget"]));
    }
    if (m.find("traveler_list") != m.end() && !m["traveler_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_list"].type()) {
        vector<ApplyQueryResponseBodyModuleTravelerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyQueryResponseBodyModuleTravelerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerList = make_shared<vector<ApplyQueryResponseBodyModuleTravelerList>>(expect1);
      }
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("trip_day") != m.end() && !m["trip_day"].empty()) {
      tripDay = make_shared<long>(boost::any_cast<long>(m["trip_day"]));
    }
    if (m.find("trip_title") != m.end() && !m["trip_title"].empty()) {
      tripTitle = make_shared<string>(boost::any_cast<string>(m["trip_title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("union_no") != m.end() && !m["union_no"].empty()) {
      unionNo = make_shared<string>(boost::any_cast<string>(m["union_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("vehicle_budget") != m.end() && !m["vehicle_budget"].empty()) {
      vehicleBudget = make_shared<long>(boost::any_cast<long>(m["vehicle_budget"]));
    }
  }


  virtual ~ApplyQueryResponseBodyModule() = default;
};
class ApplyQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<ApplyQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ApplyQueryResponseBody() {}

  explicit ApplyQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        ApplyQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<ApplyQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ApplyQueryResponseBody() = default;
};
class ApplyQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyQueryResponseBody> body{};

  ApplyQueryResponse() {}

  explicit ApplyQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyQueryResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyQueryResponse() = default;
};
class BtripBillInfoAdjustHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  BtripBillInfoAdjustHeaders() {}

  explicit BtripBillInfoAdjustHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~BtripBillInfoAdjustHeaders() = default;
};
class BtripBillInfoAdjustRequest : public Darabonba::Model {
public:
  shared_ptr<long> primaryId{};
  shared_ptr<string> thirdPartCostCenterId{};
  shared_ptr<string> thirdPartDepartmentId{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<string> thirdPartProjectId{};
  shared_ptr<string> userId{};

  BtripBillInfoAdjustRequest() {}

  explicit BtripBillInfoAdjustRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (primaryId) {
      res["primary_id"] = boost::any(*primaryId);
    }
    if (thirdPartCostCenterId) {
      res["third_part_cost_center_id"] = boost::any(*thirdPartCostCenterId);
    }
    if (thirdPartDepartmentId) {
      res["third_part_department_id"] = boost::any(*thirdPartDepartmentId);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (thirdPartProjectId) {
      res["third_part_project_id"] = boost::any(*thirdPartProjectId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("primary_id") != m.end() && !m["primary_id"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["primary_id"]));
    }
    if (m.find("third_part_cost_center_id") != m.end() && !m["third_part_cost_center_id"].empty()) {
      thirdPartCostCenterId = make_shared<string>(boost::any_cast<string>(m["third_part_cost_center_id"]));
    }
    if (m.find("third_part_department_id") != m.end() && !m["third_part_department_id"].empty()) {
      thirdPartDepartmentId = make_shared<string>(boost::any_cast<string>(m["third_part_department_id"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("third_part_project_id") != m.end() && !m["third_part_project_id"].empty()) {
      thirdPartProjectId = make_shared<string>(boost::any_cast<string>(m["third_part_project_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~BtripBillInfoAdjustRequest() = default;
};
class BtripBillInfoAdjustResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  BtripBillInfoAdjustResponseBody() {}

  explicit BtripBillInfoAdjustResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~BtripBillInfoAdjustResponseBody() = default;
};
class BtripBillInfoAdjustResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BtripBillInfoAdjustResponseBody> body{};

  BtripBillInfoAdjustResponse() {}

  explicit BtripBillInfoAdjustResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BtripBillInfoAdjustResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BtripBillInfoAdjustResponseBody>(model1);
      }
    }
  }


  virtual ~BtripBillInfoAdjustResponse() = default;
};
class CarApplyAddHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CarApplyAddHeaders() {}

  explicit CarApplyAddHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CarApplyAddHeaders() = default;
};
class CarApplyAddRequestTravelerStandardCarCitySet : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};

  CarApplyAddRequestTravelerStandardCarCitySet() {}

  explicit CarApplyAddRequestTravelerStandardCarCitySet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
  }


  virtual ~CarApplyAddRequestTravelerStandardCarCitySet() = default;
};
class CarApplyAddRequestTravelerStandard : public Darabonba::Model {
public:
  shared_ptr<vector<CarApplyAddRequestTravelerStandardCarCitySet>> carCitySet{};
  shared_ptr<string> userId{};

  CarApplyAddRequestTravelerStandard() {}

  explicit CarApplyAddRequestTravelerStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (carCitySet) {
      vector<boost::any> temp1;
      for(auto item1:*carCitySet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["car_city_set"] = boost::any(temp1);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("car_city_set") != m.end() && !m["car_city_set"].empty()) {
      if (typeid(vector<boost::any>) == m["car_city_set"].type()) {
        vector<CarApplyAddRequestTravelerStandardCarCitySet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["car_city_set"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarApplyAddRequestTravelerStandardCarCitySet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        carCitySet = make_shared<vector<CarApplyAddRequestTravelerStandardCarCitySet>>(expect1);
      }
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CarApplyAddRequestTravelerStandard() = default;
};
class CarApplyAddRequest : public Darabonba::Model {
public:
  shared_ptr<string> cause{};
  shared_ptr<string> city{};
  shared_ptr<string> cityCodeSet{};
  shared_ptr<string> date{};
  shared_ptr<string> finishedDate{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectName{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdPartApplyId{};
  shared_ptr<string> thirdPartCostCenterId{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<long> timesTotal{};
  shared_ptr<long> timesType{};
  shared_ptr<long> timesUsed{};
  shared_ptr<string> title{};
  shared_ptr<vector<CarApplyAddRequestTravelerStandard>> travelerStandard{};
  shared_ptr<string> userId{};

  CarApplyAddRequest() {}

  explicit CarApplyAddRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cause) {
      res["cause"] = boost::any(*cause);
    }
    if (city) {
      res["city"] = boost::any(*city);
    }
    if (cityCodeSet) {
      res["city_code_set"] = boost::any(*cityCodeSet);
    }
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (finishedDate) {
      res["finished_date"] = boost::any(*finishedDate);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdPartApplyId) {
      res["third_part_apply_id"] = boost::any(*thirdPartApplyId);
    }
    if (thirdPartCostCenterId) {
      res["third_part_cost_center_id"] = boost::any(*thirdPartCostCenterId);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (timesTotal) {
      res["times_total"] = boost::any(*timesTotal);
    }
    if (timesType) {
      res["times_type"] = boost::any(*timesType);
    }
    if (timesUsed) {
      res["times_used"] = boost::any(*timesUsed);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (travelerStandard) {
      vector<boost::any> temp1;
      for(auto item1:*travelerStandard){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_standard"] = boost::any(temp1);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cause") != m.end() && !m["cause"].empty()) {
      cause = make_shared<string>(boost::any_cast<string>(m["cause"]));
    }
    if (m.find("city") != m.end() && !m["city"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["city"]));
    }
    if (m.find("city_code_set") != m.end() && !m["city_code_set"].empty()) {
      cityCodeSet = make_shared<string>(boost::any_cast<string>(m["city_code_set"]));
    }
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["date"]));
    }
    if (m.find("finished_date") != m.end() && !m["finished_date"].empty()) {
      finishedDate = make_shared<string>(boost::any_cast<string>(m["finished_date"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("third_part_apply_id") != m.end() && !m["third_part_apply_id"].empty()) {
      thirdPartApplyId = make_shared<string>(boost::any_cast<string>(m["third_part_apply_id"]));
    }
    if (m.find("third_part_cost_center_id") != m.end() && !m["third_part_cost_center_id"].empty()) {
      thirdPartCostCenterId = make_shared<string>(boost::any_cast<string>(m["third_part_cost_center_id"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("times_total") != m.end() && !m["times_total"].empty()) {
      timesTotal = make_shared<long>(boost::any_cast<long>(m["times_total"]));
    }
    if (m.find("times_type") != m.end() && !m["times_type"].empty()) {
      timesType = make_shared<long>(boost::any_cast<long>(m["times_type"]));
    }
    if (m.find("times_used") != m.end() && !m["times_used"].empty()) {
      timesUsed = make_shared<long>(boost::any_cast<long>(m["times_used"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("traveler_standard") != m.end() && !m["traveler_standard"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_standard"].type()) {
        vector<CarApplyAddRequestTravelerStandard> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_standard"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarApplyAddRequestTravelerStandard model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerStandard = make_shared<vector<CarApplyAddRequestTravelerStandard>>(expect1);
      }
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CarApplyAddRequest() = default;
};
class CarApplyAddShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cause{};
  shared_ptr<string> city{};
  shared_ptr<string> cityCodeSet{};
  shared_ptr<string> date{};
  shared_ptr<string> finishedDate{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectName{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdPartApplyId{};
  shared_ptr<string> thirdPartCostCenterId{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<long> timesTotal{};
  shared_ptr<long> timesType{};
  shared_ptr<long> timesUsed{};
  shared_ptr<string> title{};
  shared_ptr<string> travelerStandardShrink{};
  shared_ptr<string> userId{};

  CarApplyAddShrinkRequest() {}

  explicit CarApplyAddShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cause) {
      res["cause"] = boost::any(*cause);
    }
    if (city) {
      res["city"] = boost::any(*city);
    }
    if (cityCodeSet) {
      res["city_code_set"] = boost::any(*cityCodeSet);
    }
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (finishedDate) {
      res["finished_date"] = boost::any(*finishedDate);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdPartApplyId) {
      res["third_part_apply_id"] = boost::any(*thirdPartApplyId);
    }
    if (thirdPartCostCenterId) {
      res["third_part_cost_center_id"] = boost::any(*thirdPartCostCenterId);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (timesTotal) {
      res["times_total"] = boost::any(*timesTotal);
    }
    if (timesType) {
      res["times_type"] = boost::any(*timesType);
    }
    if (timesUsed) {
      res["times_used"] = boost::any(*timesUsed);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (travelerStandardShrink) {
      res["traveler_standard"] = boost::any(*travelerStandardShrink);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cause") != m.end() && !m["cause"].empty()) {
      cause = make_shared<string>(boost::any_cast<string>(m["cause"]));
    }
    if (m.find("city") != m.end() && !m["city"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["city"]));
    }
    if (m.find("city_code_set") != m.end() && !m["city_code_set"].empty()) {
      cityCodeSet = make_shared<string>(boost::any_cast<string>(m["city_code_set"]));
    }
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["date"]));
    }
    if (m.find("finished_date") != m.end() && !m["finished_date"].empty()) {
      finishedDate = make_shared<string>(boost::any_cast<string>(m["finished_date"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("third_part_apply_id") != m.end() && !m["third_part_apply_id"].empty()) {
      thirdPartApplyId = make_shared<string>(boost::any_cast<string>(m["third_part_apply_id"]));
    }
    if (m.find("third_part_cost_center_id") != m.end() && !m["third_part_cost_center_id"].empty()) {
      thirdPartCostCenterId = make_shared<string>(boost::any_cast<string>(m["third_part_cost_center_id"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("times_total") != m.end() && !m["times_total"].empty()) {
      timesTotal = make_shared<long>(boost::any_cast<long>(m["times_total"]));
    }
    if (m.find("times_type") != m.end() && !m["times_type"].empty()) {
      timesType = make_shared<long>(boost::any_cast<long>(m["times_type"]));
    }
    if (m.find("times_used") != m.end() && !m["times_used"].empty()) {
      timesUsed = make_shared<long>(boost::any_cast<long>(m["times_used"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("traveler_standard") != m.end() && !m["traveler_standard"].empty()) {
      travelerStandardShrink = make_shared<string>(boost::any_cast<string>(m["traveler_standard"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CarApplyAddShrinkRequest() = default;
};
class CarApplyAddResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<long> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CarApplyAddResponseBody() {}

  explicit CarApplyAddResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<long>(boost::any_cast<long>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CarApplyAddResponseBody() = default;
};
class CarApplyAddResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CarApplyAddResponseBody> body{};

  CarApplyAddResponse() {}

  explicit CarApplyAddResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CarApplyAddResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CarApplyAddResponseBody>(model1);
      }
    }
  }


  virtual ~CarApplyAddResponse() = default;
};
class CarApplyModifyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CarApplyModifyHeaders() {}

  explicit CarApplyModifyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CarApplyModifyHeaders() = default;
};
class CarApplyModifyRequest : public Darabonba::Model {
public:
  shared_ptr<string> operateTime{};
  shared_ptr<string> remark{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdPartApplyId{};
  shared_ptr<string> userId{};

  CarApplyModifyRequest() {}

  explicit CarApplyModifyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateTime) {
      res["operate_time"] = boost::any(*operateTime);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdPartApplyId) {
      res["third_part_apply_id"] = boost::any(*thirdPartApplyId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("operate_time") != m.end() && !m["operate_time"].empty()) {
      operateTime = make_shared<string>(boost::any_cast<string>(m["operate_time"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("third_part_apply_id") != m.end() && !m["third_part_apply_id"].empty()) {
      thirdPartApplyId = make_shared<string>(boost::any_cast<string>(m["third_part_apply_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CarApplyModifyRequest() = default;
};
class CarApplyModifyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CarApplyModifyResponseBody() {}

  explicit CarApplyModifyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<bool>(boost::any_cast<bool>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CarApplyModifyResponseBody() = default;
};
class CarApplyModifyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CarApplyModifyResponseBody> body{};

  CarApplyModifyResponse() {}

  explicit CarApplyModifyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CarApplyModifyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CarApplyModifyResponseBody>(model1);
      }
    }
  }


  virtual ~CarApplyModifyResponse() = default;
};
class CarApplyQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CarApplyQueryHeaders() {}

  explicit CarApplyQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CarApplyQueryHeaders() = default;
};
class CarApplyQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> createdEndAt{};
  shared_ptr<string> createdStartAt{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> thirdPartApplyId{};
  shared_ptr<string> userId{};

  CarApplyQueryRequest() {}

  explicit CarApplyQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdEndAt) {
      res["created_end_at"] = boost::any(*createdEndAt);
    }
    if (createdStartAt) {
      res["created_start_at"] = boost::any(*createdStartAt);
    }
    if (pageNumber) {
      res["page_number"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (thirdPartApplyId) {
      res["third_part_apply_id"] = boost::any(*thirdPartApplyId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("created_end_at") != m.end() && !m["created_end_at"].empty()) {
      createdEndAt = make_shared<string>(boost::any_cast<string>(m["created_end_at"]));
    }
    if (m.find("created_start_at") != m.end() && !m["created_start_at"].empty()) {
      createdStartAt = make_shared<string>(boost::any_cast<string>(m["created_start_at"]));
    }
    if (m.find("page_number") != m.end() && !m["page_number"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["page_number"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("third_part_apply_id") != m.end() && !m["third_part_apply_id"].empty()) {
      thirdPartApplyId = make_shared<string>(boost::any_cast<string>(m["third_part_apply_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CarApplyQueryRequest() = default;
};
class CarApplyQueryResponseBodyApplyListApproverList : public Darabonba::Model {
public:
  shared_ptr<string> note{};
  shared_ptr<string> operateTime{};
  shared_ptr<long> order{};
  shared_ptr<long> status{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  CarApplyQueryResponseBodyApplyListApproverList() {}

  explicit CarApplyQueryResponseBodyApplyListApproverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (note) {
      res["note"] = boost::any(*note);
    }
    if (operateTime) {
      res["operate_time"] = boost::any(*operateTime);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["status_desc"] = boost::any(*statusDesc);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("note") != m.end() && !m["note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["note"]));
    }
    if (m.find("operate_time") != m.end() && !m["operate_time"].empty()) {
      operateTime = make_shared<string>(boost::any_cast<string>(m["operate_time"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["order"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("status_desc") != m.end() && !m["status_desc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["status_desc"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~CarApplyQueryResponseBodyApplyListApproverList() = default;
};
class CarApplyQueryResponseBodyApplyListItineraryList : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrDate{};
  shared_ptr<long> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<long> invoiceId{};
  shared_ptr<string> invoiceName{};
  shared_ptr<string> itineraryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<long> trafficType{};

  CarApplyQueryResponseBodyApplyListItineraryList() {}

  explicit CarApplyQueryResponseBodyApplyListItineraryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (invoiceId) {
      res["invoice_id"] = boost::any(*invoiceId);
    }
    if (invoiceName) {
      res["invoice_name"] = boost::any(*invoiceName);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (trafficType) {
      res["traffic_type"] = boost::any(*trafficType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("invoice_id") != m.end() && !m["invoice_id"].empty()) {
      invoiceId = make_shared<long>(boost::any_cast<long>(m["invoice_id"]));
    }
    if (m.find("invoice_name") != m.end() && !m["invoice_name"].empty()) {
      invoiceName = make_shared<string>(boost::any_cast<string>(m["invoice_name"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("traffic_type") != m.end() && !m["traffic_type"].empty()) {
      trafficType = make_shared<long>(boost::any_cast<long>(m["traffic_type"]));
    }
  }


  virtual ~CarApplyQueryResponseBodyApplyListItineraryList() = default;
};
class CarApplyQueryResponseBodyApplyListTravelerStandardCarCitySet : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};

  CarApplyQueryResponseBodyApplyListTravelerStandardCarCitySet() {}

  explicit CarApplyQueryResponseBodyApplyListTravelerStandardCarCitySet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
  }


  virtual ~CarApplyQueryResponseBodyApplyListTravelerStandardCarCitySet() = default;
};
class CarApplyQueryResponseBodyApplyListTravelerStandard : public Darabonba::Model {
public:
  shared_ptr<vector<CarApplyQueryResponseBodyApplyListTravelerStandardCarCitySet>> carCitySet{};
  shared_ptr<string> userId{};

  CarApplyQueryResponseBodyApplyListTravelerStandard() {}

  explicit CarApplyQueryResponseBodyApplyListTravelerStandard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (carCitySet) {
      vector<boost::any> temp1;
      for(auto item1:*carCitySet){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["car_city_set"] = boost::any(temp1);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("car_city_set") != m.end() && !m["car_city_set"].empty()) {
      if (typeid(vector<boost::any>) == m["car_city_set"].type()) {
        vector<CarApplyQueryResponseBodyApplyListTravelerStandardCarCitySet> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["car_city_set"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarApplyQueryResponseBodyApplyListTravelerStandardCarCitySet model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        carCitySet = make_shared<vector<CarApplyQueryResponseBodyApplyListTravelerStandardCarCitySet>>(expect1);
      }
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CarApplyQueryResponseBodyApplyListTravelerStandard() = default;
};
class CarApplyQueryResponseBodyApplyList : public Darabonba::Model {
public:
  shared_ptr<vector<CarApplyQueryResponseBodyApplyListApproverList>> approverList{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<vector<CarApplyQueryResponseBodyApplyListItineraryList>> itineraryList{};
  shared_ptr<long> status{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<vector<CarApplyQueryResponseBodyApplyListTravelerStandard>> travelerStandard{};
  shared_ptr<string> tripCause{};
  shared_ptr<string> tripTitle{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  CarApplyQueryResponseBodyApplyList() {}

  explicit CarApplyQueryResponseBodyApplyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approverList) {
      vector<boost::any> temp1;
      for(auto item1:*approverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["approver_list"] = boost::any(temp1);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (itineraryList) {
      vector<boost::any> temp1;
      for(auto item1:*itineraryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itinerary_list"] = boost::any(temp1);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["status_desc"] = boost::any(*statusDesc);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (travelerStandard) {
      vector<boost::any> temp1;
      for(auto item1:*travelerStandard){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_standard"] = boost::any(temp1);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (tripTitle) {
      res["trip_title"] = boost::any(*tripTitle);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("approver_list") != m.end() && !m["approver_list"].empty()) {
      if (typeid(vector<boost::any>) == m["approver_list"].type()) {
        vector<CarApplyQueryResponseBodyApplyListApproverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["approver_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarApplyQueryResponseBodyApplyListApproverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        approverList = make_shared<vector<CarApplyQueryResponseBodyApplyListApproverList>>(expect1);
      }
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("itinerary_list") != m.end() && !m["itinerary_list"].empty()) {
      if (typeid(vector<boost::any>) == m["itinerary_list"].type()) {
        vector<CarApplyQueryResponseBodyApplyListItineraryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itinerary_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarApplyQueryResponseBodyApplyListItineraryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itineraryList = make_shared<vector<CarApplyQueryResponseBodyApplyListItineraryList>>(expect1);
      }
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("status_desc") != m.end() && !m["status_desc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["status_desc"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("traveler_standard") != m.end() && !m["traveler_standard"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_standard"].type()) {
        vector<CarApplyQueryResponseBodyApplyListTravelerStandard> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_standard"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarApplyQueryResponseBodyApplyListTravelerStandard model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerStandard = make_shared<vector<CarApplyQueryResponseBodyApplyListTravelerStandard>>(expect1);
      }
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("trip_title") != m.end() && !m["trip_title"].empty()) {
      tripTitle = make_shared<string>(boost::any_cast<string>(m["trip_title"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~CarApplyQueryResponseBodyApplyList() = default;
};
class CarApplyQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CarApplyQueryResponseBodyApplyList>> applyList{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};
  shared_ptr<string> traceId{};

  CarApplyQueryResponseBody() {}

  explicit CarApplyQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyList) {
      vector<boost::any> temp1;
      for(auto item1:*applyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["apply_list"] = boost::any(temp1);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_list") != m.end() && !m["apply_list"].empty()) {
      if (typeid(vector<boost::any>) == m["apply_list"].type()) {
        vector<CarApplyQueryResponseBodyApplyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["apply_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarApplyQueryResponseBodyApplyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applyList = make_shared<vector<CarApplyQueryResponseBodyApplyList>>(expect1);
      }
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CarApplyQueryResponseBody() = default;
};
class CarApplyQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CarApplyQueryResponseBody> body{};

  CarApplyQueryResponse() {}

  explicit CarApplyQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CarApplyQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CarApplyQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CarApplyQueryResponse() = default;
};
class CarBillSettlementQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CarBillSettlementQueryHeaders() {}

  explicit CarBillSettlementQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CarBillSettlementQueryHeaders() = default;
};
class CarBillSettlementQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};

  CarBillSettlementQueryRequest() {}

  explicit CarBillSettlementQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
  }


  virtual ~CarBillSettlementQueryRequest() = default;
};
class CarBillSettlementQueryResponseBodyModuleDataList : public Darabonba::Model {
public:
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<string> applyArrCityCode{};
  shared_ptr<string> applyArrCityName{};
  shared_ptr<string> applyDepCityCode{};
  shared_ptr<string> applyDepCityName{};
  shared_ptr<string> applyExtendField{};
  shared_ptr<string> applyId{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> arrLocation{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> billRecordTime{};
  shared_ptr<string> bookModel{};
  shared_ptr<string> bookTime{};
  shared_ptr<string> bookerId{};
  shared_ptr<string> bookerJobNo{};
  shared_ptr<string> bookerName{};
  shared_ptr<string> businessCategory{};
  shared_ptr<string> capitalDirection{};
  shared_ptr<string> carLevel{};
  shared_ptr<string> cascadeDepartment{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<double> coupon{};
  shared_ptr<double> couponPrice{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> department{};
  shared_ptr<string> departmentId{};
  shared_ptr<string> deptCity{};
  shared_ptr<string> deptDate{};
  shared_ptr<string> deptLocation{};
  shared_ptr<string> deptTime{};
  shared_ptr<string> driverAddDetail{};
  shared_ptr<double> driverAddFee{};
  shared_ptr<string> estimateDriveDistance{};
  shared_ptr<double> estimatePrice{};
  shared_ptr<string> feeType{};
  shared_ptr<string> index{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> levelName{};
  shared_ptr<string> memo{};
  shared_ptr<string> orderId{};
  shared_ptr<double> orderPrice{};
  shared_ptr<string> overApplyId{};
  shared_ptr<double> personSettleFee{};
  shared_ptr<long> primaryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectName{};
  shared_ptr<string> providerName{};
  shared_ptr<string> realDriveDistance{};
  shared_ptr<string> realFromAddr{};
  shared_ptr<string> realToAddr{};
  shared_ptr<string> remark{};
  shared_ptr<double> serviceFee{};
  shared_ptr<double> settlementFee{};
  shared_ptr<double> settlementGrantFee{};
  shared_ptr<string> settlementTime{};
  shared_ptr<string> settlementType{};
  shared_ptr<string> specialOrder{};
  shared_ptr<string> specialReason{};
  shared_ptr<long> status{};
  shared_ptr<string> subOrderId{};
  shared_ptr<string> supplementApplyId{};
  shared_ptr<string> taxRate{};
  shared_ptr<string> thirdItineraryId{};
  shared_ptr<string> timeType{};
  shared_ptr<string> travelerId{};
  shared_ptr<string> travelerJobNo{};
  shared_ptr<string> travelerMemberTypeName{};
  shared_ptr<string> travelerName{};
  shared_ptr<string> userConfirmDesc{};
  shared_ptr<long> voucherType{};

  CarBillSettlementQueryResponseBodyModuleDataList() {}

  explicit CarBillSettlementQueryResponseBodyModuleDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (applyArrCityCode) {
      res["apply_arr_city_code"] = boost::any(*applyArrCityCode);
    }
    if (applyArrCityName) {
      res["apply_arr_city_name"] = boost::any(*applyArrCityName);
    }
    if (applyDepCityCode) {
      res["apply_dep_city_code"] = boost::any(*applyDepCityCode);
    }
    if (applyDepCityName) {
      res["apply_dep_city_name"] = boost::any(*applyDepCityName);
    }
    if (applyExtendField) {
      res["apply_extend_field"] = boost::any(*applyExtendField);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (arrLocation) {
      res["arr_location"] = boost::any(*arrLocation);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (billRecordTime) {
      res["bill_record_time"] = boost::any(*billRecordTime);
    }
    if (bookModel) {
      res["book_model"] = boost::any(*bookModel);
    }
    if (bookTime) {
      res["book_time"] = boost::any(*bookTime);
    }
    if (bookerId) {
      res["booker_id"] = boost::any(*bookerId);
    }
    if (bookerJobNo) {
      res["booker_job_no"] = boost::any(*bookerJobNo);
    }
    if (bookerName) {
      res["booker_name"] = boost::any(*bookerName);
    }
    if (businessCategory) {
      res["business_category"] = boost::any(*businessCategory);
    }
    if (capitalDirection) {
      res["capital_direction"] = boost::any(*capitalDirection);
    }
    if (carLevel) {
      res["car_level"] = boost::any(*carLevel);
    }
    if (cascadeDepartment) {
      res["cascade_department"] = boost::any(*cascadeDepartment);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (coupon) {
      res["coupon"] = boost::any(*coupon);
    }
    if (couponPrice) {
      res["coupon_price"] = boost::any(*couponPrice);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (departmentId) {
      res["department_id"] = boost::any(*departmentId);
    }
    if (deptCity) {
      res["dept_city"] = boost::any(*deptCity);
    }
    if (deptDate) {
      res["dept_date"] = boost::any(*deptDate);
    }
    if (deptLocation) {
      res["dept_location"] = boost::any(*deptLocation);
    }
    if (deptTime) {
      res["dept_time"] = boost::any(*deptTime);
    }
    if (driverAddDetail) {
      res["driver_add_detail"] = boost::any(*driverAddDetail);
    }
    if (driverAddFee) {
      res["driver_add_fee"] = boost::any(*driverAddFee);
    }
    if (estimateDriveDistance) {
      res["estimate_drive_distance"] = boost::any(*estimateDriveDistance);
    }
    if (estimatePrice) {
      res["estimate_price"] = boost::any(*estimatePrice);
    }
    if (feeType) {
      res["fee_type"] = boost::any(*feeType);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (levelName) {
      res["level_name"] = boost::any(*levelName);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderPrice) {
      res["order_price"] = boost::any(*orderPrice);
    }
    if (overApplyId) {
      res["over_apply_id"] = boost::any(*overApplyId);
    }
    if (personSettleFee) {
      res["person_settle_fee"] = boost::any(*personSettleFee);
    }
    if (primaryId) {
      res["primary_id"] = boost::any(*primaryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (providerName) {
      res["provider_name"] = boost::any(*providerName);
    }
    if (realDriveDistance) {
      res["real_drive_distance"] = boost::any(*realDriveDistance);
    }
    if (realFromAddr) {
      res["real_from_addr"] = boost::any(*realFromAddr);
    }
    if (realToAddr) {
      res["real_to_addr"] = boost::any(*realToAddr);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (settlementFee) {
      res["settlement_fee"] = boost::any(*settlementFee);
    }
    if (settlementGrantFee) {
      res["settlement_grant_fee"] = boost::any(*settlementGrantFee);
    }
    if (settlementTime) {
      res["settlement_time"] = boost::any(*settlementTime);
    }
    if (settlementType) {
      res["settlement_type"] = boost::any(*settlementType);
    }
    if (specialOrder) {
      res["special_order"] = boost::any(*specialOrder);
    }
    if (specialReason) {
      res["special_reason"] = boost::any(*specialReason);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    if (supplementApplyId) {
      res["supplement_apply_id"] = boost::any(*supplementApplyId);
    }
    if (taxRate) {
      res["tax_rate"] = boost::any(*taxRate);
    }
    if (thirdItineraryId) {
      res["third_itinerary_id"] = boost::any(*thirdItineraryId);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (travelerId) {
      res["traveler_id"] = boost::any(*travelerId);
    }
    if (travelerJobNo) {
      res["traveler_job_no"] = boost::any(*travelerJobNo);
    }
    if (travelerMemberTypeName) {
      res["traveler_member_type_name"] = boost::any(*travelerMemberTypeName);
    }
    if (travelerName) {
      res["traveler_name"] = boost::any(*travelerName);
    }
    if (userConfirmDesc) {
      res["user_confirm_desc"] = boost::any(*userConfirmDesc);
    }
    if (voucherType) {
      res["voucher_type"] = boost::any(*voucherType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("apply_arr_city_code") != m.end() && !m["apply_arr_city_code"].empty()) {
      applyArrCityCode = make_shared<string>(boost::any_cast<string>(m["apply_arr_city_code"]));
    }
    if (m.find("apply_arr_city_name") != m.end() && !m["apply_arr_city_name"].empty()) {
      applyArrCityName = make_shared<string>(boost::any_cast<string>(m["apply_arr_city_name"]));
    }
    if (m.find("apply_dep_city_code") != m.end() && !m["apply_dep_city_code"].empty()) {
      applyDepCityCode = make_shared<string>(boost::any_cast<string>(m["apply_dep_city_code"]));
    }
    if (m.find("apply_dep_city_name") != m.end() && !m["apply_dep_city_name"].empty()) {
      applyDepCityName = make_shared<string>(boost::any_cast<string>(m["apply_dep_city_name"]));
    }
    if (m.find("apply_extend_field") != m.end() && !m["apply_extend_field"].empty()) {
      applyExtendField = make_shared<string>(boost::any_cast<string>(m["apply_extend_field"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("arr_location") != m.end() && !m["arr_location"].empty()) {
      arrLocation = make_shared<string>(boost::any_cast<string>(m["arr_location"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("bill_record_time") != m.end() && !m["bill_record_time"].empty()) {
      billRecordTime = make_shared<string>(boost::any_cast<string>(m["bill_record_time"]));
    }
    if (m.find("book_model") != m.end() && !m["book_model"].empty()) {
      bookModel = make_shared<string>(boost::any_cast<string>(m["book_model"]));
    }
    if (m.find("book_time") != m.end() && !m["book_time"].empty()) {
      bookTime = make_shared<string>(boost::any_cast<string>(m["book_time"]));
    }
    if (m.find("booker_id") != m.end() && !m["booker_id"].empty()) {
      bookerId = make_shared<string>(boost::any_cast<string>(m["booker_id"]));
    }
    if (m.find("booker_job_no") != m.end() && !m["booker_job_no"].empty()) {
      bookerJobNo = make_shared<string>(boost::any_cast<string>(m["booker_job_no"]));
    }
    if (m.find("booker_name") != m.end() && !m["booker_name"].empty()) {
      bookerName = make_shared<string>(boost::any_cast<string>(m["booker_name"]));
    }
    if (m.find("business_category") != m.end() && !m["business_category"].empty()) {
      businessCategory = make_shared<string>(boost::any_cast<string>(m["business_category"]));
    }
    if (m.find("capital_direction") != m.end() && !m["capital_direction"].empty()) {
      capitalDirection = make_shared<string>(boost::any_cast<string>(m["capital_direction"]));
    }
    if (m.find("car_level") != m.end() && !m["car_level"].empty()) {
      carLevel = make_shared<string>(boost::any_cast<string>(m["car_level"]));
    }
    if (m.find("cascade_department") != m.end() && !m["cascade_department"].empty()) {
      cascadeDepartment = make_shared<string>(boost::any_cast<string>(m["cascade_department"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("coupon") != m.end() && !m["coupon"].empty()) {
      coupon = make_shared<double>(boost::any_cast<double>(m["coupon"]));
    }
    if (m.find("coupon_price") != m.end() && !m["coupon_price"].empty()) {
      couponPrice = make_shared<double>(boost::any_cast<double>(m["coupon_price"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("department_id") != m.end() && !m["department_id"].empty()) {
      departmentId = make_shared<string>(boost::any_cast<string>(m["department_id"]));
    }
    if (m.find("dept_city") != m.end() && !m["dept_city"].empty()) {
      deptCity = make_shared<string>(boost::any_cast<string>(m["dept_city"]));
    }
    if (m.find("dept_date") != m.end() && !m["dept_date"].empty()) {
      deptDate = make_shared<string>(boost::any_cast<string>(m["dept_date"]));
    }
    if (m.find("dept_location") != m.end() && !m["dept_location"].empty()) {
      deptLocation = make_shared<string>(boost::any_cast<string>(m["dept_location"]));
    }
    if (m.find("dept_time") != m.end() && !m["dept_time"].empty()) {
      deptTime = make_shared<string>(boost::any_cast<string>(m["dept_time"]));
    }
    if (m.find("driver_add_detail") != m.end() && !m["driver_add_detail"].empty()) {
      driverAddDetail = make_shared<string>(boost::any_cast<string>(m["driver_add_detail"]));
    }
    if (m.find("driver_add_fee") != m.end() && !m["driver_add_fee"].empty()) {
      driverAddFee = make_shared<double>(boost::any_cast<double>(m["driver_add_fee"]));
    }
    if (m.find("estimate_drive_distance") != m.end() && !m["estimate_drive_distance"].empty()) {
      estimateDriveDistance = make_shared<string>(boost::any_cast<string>(m["estimate_drive_distance"]));
    }
    if (m.find("estimate_price") != m.end() && !m["estimate_price"].empty()) {
      estimatePrice = make_shared<double>(boost::any_cast<double>(m["estimate_price"]));
    }
    if (m.find("fee_type") != m.end() && !m["fee_type"].empty()) {
      feeType = make_shared<string>(boost::any_cast<string>(m["fee_type"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("level_name") != m.end() && !m["level_name"].empty()) {
      levelName = make_shared<string>(boost::any_cast<string>(m["level_name"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("order_price") != m.end() && !m["order_price"].empty()) {
      orderPrice = make_shared<double>(boost::any_cast<double>(m["order_price"]));
    }
    if (m.find("over_apply_id") != m.end() && !m["over_apply_id"].empty()) {
      overApplyId = make_shared<string>(boost::any_cast<string>(m["over_apply_id"]));
    }
    if (m.find("person_settle_fee") != m.end() && !m["person_settle_fee"].empty()) {
      personSettleFee = make_shared<double>(boost::any_cast<double>(m["person_settle_fee"]));
    }
    if (m.find("primary_id") != m.end() && !m["primary_id"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["primary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("provider_name") != m.end() && !m["provider_name"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["provider_name"]));
    }
    if (m.find("real_drive_distance") != m.end() && !m["real_drive_distance"].empty()) {
      realDriveDistance = make_shared<string>(boost::any_cast<string>(m["real_drive_distance"]));
    }
    if (m.find("real_from_addr") != m.end() && !m["real_from_addr"].empty()) {
      realFromAddr = make_shared<string>(boost::any_cast<string>(m["real_from_addr"]));
    }
    if (m.find("real_to_addr") != m.end() && !m["real_to_addr"].empty()) {
      realToAddr = make_shared<string>(boost::any_cast<string>(m["real_to_addr"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<double>(boost::any_cast<double>(m["service_fee"]));
    }
    if (m.find("settlement_fee") != m.end() && !m["settlement_fee"].empty()) {
      settlementFee = make_shared<double>(boost::any_cast<double>(m["settlement_fee"]));
    }
    if (m.find("settlement_grant_fee") != m.end() && !m["settlement_grant_fee"].empty()) {
      settlementGrantFee = make_shared<double>(boost::any_cast<double>(m["settlement_grant_fee"]));
    }
    if (m.find("settlement_time") != m.end() && !m["settlement_time"].empty()) {
      settlementTime = make_shared<string>(boost::any_cast<string>(m["settlement_time"]));
    }
    if (m.find("settlement_type") != m.end() && !m["settlement_type"].empty()) {
      settlementType = make_shared<string>(boost::any_cast<string>(m["settlement_type"]));
    }
    if (m.find("special_order") != m.end() && !m["special_order"].empty()) {
      specialOrder = make_shared<string>(boost::any_cast<string>(m["special_order"]));
    }
    if (m.find("special_reason") != m.end() && !m["special_reason"].empty()) {
      specialReason = make_shared<string>(boost::any_cast<string>(m["special_reason"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<string>(boost::any_cast<string>(m["sub_order_id"]));
    }
    if (m.find("supplement_apply_id") != m.end() && !m["supplement_apply_id"].empty()) {
      supplementApplyId = make_shared<string>(boost::any_cast<string>(m["supplement_apply_id"]));
    }
    if (m.find("tax_rate") != m.end() && !m["tax_rate"].empty()) {
      taxRate = make_shared<string>(boost::any_cast<string>(m["tax_rate"]));
    }
    if (m.find("third_itinerary_id") != m.end() && !m["third_itinerary_id"].empty()) {
      thirdItineraryId = make_shared<string>(boost::any_cast<string>(m["third_itinerary_id"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("traveler_id") != m.end() && !m["traveler_id"].empty()) {
      travelerId = make_shared<string>(boost::any_cast<string>(m["traveler_id"]));
    }
    if (m.find("traveler_job_no") != m.end() && !m["traveler_job_no"].empty()) {
      travelerJobNo = make_shared<string>(boost::any_cast<string>(m["traveler_job_no"]));
    }
    if (m.find("traveler_member_type_name") != m.end() && !m["traveler_member_type_name"].empty()) {
      travelerMemberTypeName = make_shared<string>(boost::any_cast<string>(m["traveler_member_type_name"]));
    }
    if (m.find("traveler_name") != m.end() && !m["traveler_name"].empty()) {
      travelerName = make_shared<string>(boost::any_cast<string>(m["traveler_name"]));
    }
    if (m.find("user_confirm_desc") != m.end() && !m["user_confirm_desc"].empty()) {
      userConfirmDesc = make_shared<string>(boost::any_cast<string>(m["user_confirm_desc"]));
    }
    if (m.find("voucher_type") != m.end() && !m["voucher_type"].empty()) {
      voucherType = make_shared<long>(boost::any_cast<long>(m["voucher_type"]));
    }
  }


  virtual ~CarBillSettlementQueryResponseBodyModuleDataList() = default;
};
class CarBillSettlementQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> category{};
  shared_ptr<string> corpId{};
  shared_ptr<vector<CarBillSettlementQueryResponseBodyModuleDataList>> dataList{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};
  shared_ptr<long> totalNum{};

  CarBillSettlementQueryResponseBodyModule() {}

  explicit CarBillSettlementQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_list"] = boost::any(temp1);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    if (totalNum) {
      res["total_num"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["category"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("data_list") != m.end() && !m["data_list"].empty()) {
      if (typeid(vector<boost::any>) == m["data_list"].type()) {
        vector<CarBillSettlementQueryResponseBodyModuleDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarBillSettlementQueryResponseBodyModuleDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<CarBillSettlementQueryResponseBodyModuleDataList>>(expect1);
      }
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
    if (m.find("total_num") != m.end() && !m["total_num"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["total_num"]));
    }
  }


  virtual ~CarBillSettlementQueryResponseBodyModule() = default;
};
class CarBillSettlementQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CarBillSettlementQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CarBillSettlementQueryResponseBody() {}

  explicit CarBillSettlementQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CarBillSettlementQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CarBillSettlementQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CarBillSettlementQueryResponseBody() = default;
};
class CarBillSettlementQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CarBillSettlementQueryResponseBody> body{};

  CarBillSettlementQueryResponse() {}

  explicit CarBillSettlementQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CarBillSettlementQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CarBillSettlementQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CarBillSettlementQueryResponse() = default;
};
class CarOrderListQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CarOrderListQueryHeaders() {}

  explicit CarOrderListQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CarOrderListQueryHeaders() = default;
};
class CarOrderListQueryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allApply{};
  shared_ptr<long> applyId{};
  shared_ptr<string> departId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> updateEndTime{};
  shared_ptr<string> updateStartTime{};
  shared_ptr<string> userId{};

  CarOrderListQueryRequest() {}

  explicit CarOrderListQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allApply) {
      res["all_apply"] = boost::any(*allApply);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (updateEndTime) {
      res["update_end_time"] = boost::any(*updateEndTime);
    }
    if (updateStartTime) {
      res["update_start_time"] = boost::any(*updateStartTime);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_apply") != m.end() && !m["all_apply"].empty()) {
      allApply = make_shared<bool>(boost::any_cast<bool>(m["all_apply"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("update_end_time") != m.end() && !m["update_end_time"].empty()) {
      updateEndTime = make_shared<string>(boost::any_cast<string>(m["update_end_time"]));
    }
    if (m.find("update_start_time") != m.end() && !m["update_start_time"].empty()) {
      updateStartTime = make_shared<string>(boost::any_cast<string>(m["update_start_time"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CarOrderListQueryRequest() = default;
};
class CarOrderListQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<long> categoryType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> payType{};
  shared_ptr<double> personPrice{};
  shared_ptr<double> price{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  CarOrderListQueryResponseBodyModulePriceInfoList() {}

  explicit CarOrderListQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (categoryType) {
      res["category_type"] = boost::any(*categoryType);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (personPrice) {
      res["person_price"] = boost::any(*personPrice);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("category_type") != m.end() && !m["category_type"].empty()) {
      categoryType = make_shared<long>(boost::any_cast<long>(m["category_type"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("person_price") != m.end() && !m["person_price"].empty()) {
      personPrice = make_shared<double>(boost::any_cast<double>(m["person_price"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~CarOrderListQueryResponseBodyModulePriceInfoList() = default;
};
class CarOrderListQueryResponseBodyModuleUserAffiliateList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  CarOrderListQueryResponseBodyModuleUserAffiliateList() {}

  explicit CarOrderListQueryResponseBodyModuleUserAffiliateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~CarOrderListQueryResponseBodyModuleUserAffiliateList() = default;
};
class CarOrderListQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> applyShowId{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> businessCategory{};
  shared_ptr<string> cancelTime{};
  shared_ptr<string> carInfo{};
  shared_ptr<long> carLevel{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<long> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<long> deptId{};
  shared_ptr<string> deptName{};
  shared_ptr<string> driverConfirmTime{};
  shared_ptr<double> estimatePrice{};
  shared_ptr<string> fromAddress{};
  shared_ptr<string> fromCityAdCode{};
  shared_ptr<string> fromCityName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> invoiceId{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<bool> isSpecial{};
  shared_ptr<string> memo{};
  shared_ptr<long> orderStatus{};
  shared_ptr<string> passengerName{};
  shared_ptr<string> payTime{};
  shared_ptr<vector<CarOrderListQueryResponseBodyModulePriceInfoList>> priceInfoList{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<long> provider{};
  shared_ptr<string> publishTime{};
  shared_ptr<string> realFromAddress{};
  shared_ptr<string> realFromCityAdCode{};
  shared_ptr<string> realFromCityName{};
  shared_ptr<string> realToAddress{};
  shared_ptr<string> realToCityAdCode{};
  shared_ptr<string> realToCityName{};
  shared_ptr<long> serviceType{};
  shared_ptr<vector<string>> specialTypes{};
  shared_ptr<string> takenTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<string> toAddress{};
  shared_ptr<string> toCityAdCode{};
  shared_ptr<string> toCityName{};
  shared_ptr<double> travelDistance{};
  shared_ptr<vector<CarOrderListQueryResponseBodyModuleUserAffiliateList>> userAffiliateList{};
  shared_ptr<long> userConfirm{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  CarOrderListQueryResponseBodyModule() {}

  explicit CarOrderListQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (applyShowId) {
      res["apply_show_id"] = boost::any(*applyShowId);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (businessCategory) {
      res["business_category"] = boost::any(*businessCategory);
    }
    if (cancelTime) {
      res["cancel_time"] = boost::any(*cancelTime);
    }
    if (carInfo) {
      res["car_info"] = boost::any(*carInfo);
    }
    if (carLevel) {
      res["car_level"] = boost::any(*carLevel);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (deptId) {
      res["dept_id"] = boost::any(*deptId);
    }
    if (deptName) {
      res["dept_name"] = boost::any(*deptName);
    }
    if (driverConfirmTime) {
      res["driver_confirm_time"] = boost::any(*driverConfirmTime);
    }
    if (estimatePrice) {
      res["estimate_price"] = boost::any(*estimatePrice);
    }
    if (fromAddress) {
      res["from_address"] = boost::any(*fromAddress);
    }
    if (fromCityAdCode) {
      res["from_city_ad_code"] = boost::any(*fromCityAdCode);
    }
    if (fromCityName) {
      res["from_city_name"] = boost::any(*fromCityName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (invoiceId) {
      res["invoice_id"] = boost::any(*invoiceId);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (isSpecial) {
      res["is_special"] = boost::any(*isSpecial);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payTime) {
      res["pay_time"] = boost::any(*payTime);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (provider) {
      res["provider"] = boost::any(*provider);
    }
    if (publishTime) {
      res["publish_time"] = boost::any(*publishTime);
    }
    if (realFromAddress) {
      res["real_from_address"] = boost::any(*realFromAddress);
    }
    if (realFromCityAdCode) {
      res["real_from_city_ad_code"] = boost::any(*realFromCityAdCode);
    }
    if (realFromCityName) {
      res["real_from_city_name"] = boost::any(*realFromCityName);
    }
    if (realToAddress) {
      res["real_to_address"] = boost::any(*realToAddress);
    }
    if (realToCityAdCode) {
      res["real_to_city_ad_code"] = boost::any(*realToCityAdCode);
    }
    if (realToCityName) {
      res["real_to_city_name"] = boost::any(*realToCityName);
    }
    if (serviceType) {
      res["service_type"] = boost::any(*serviceType);
    }
    if (specialTypes) {
      res["special_types"] = boost::any(*specialTypes);
    }
    if (takenTime) {
      res["taken_time"] = boost::any(*takenTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (toAddress) {
      res["to_address"] = boost::any(*toAddress);
    }
    if (toCityAdCode) {
      res["to_city_ad_code"] = boost::any(*toCityAdCode);
    }
    if (toCityName) {
      res["to_city_name"] = boost::any(*toCityName);
    }
    if (travelDistance) {
      res["travel_distance"] = boost::any(*travelDistance);
    }
    if (userAffiliateList) {
      vector<boost::any> temp1;
      for(auto item1:*userAffiliateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["user_affiliate_list"] = boost::any(temp1);
    }
    if (userConfirm) {
      res["user_confirm"] = boost::any(*userConfirm);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("apply_show_id") != m.end() && !m["apply_show_id"].empty()) {
      applyShowId = make_shared<string>(boost::any_cast<string>(m["apply_show_id"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("business_category") != m.end() && !m["business_category"].empty()) {
      businessCategory = make_shared<string>(boost::any_cast<string>(m["business_category"]));
    }
    if (m.find("cancel_time") != m.end() && !m["cancel_time"].empty()) {
      cancelTime = make_shared<string>(boost::any_cast<string>(m["cancel_time"]));
    }
    if (m.find("car_info") != m.end() && !m["car_info"].empty()) {
      carInfo = make_shared<string>(boost::any_cast<string>(m["car_info"]));
    }
    if (m.find("car_level") != m.end() && !m["car_level"].empty()) {
      carLevel = make_shared<long>(boost::any_cast<long>(m["car_level"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("dept_id") != m.end() && !m["dept_id"].empty()) {
      deptId = make_shared<long>(boost::any_cast<long>(m["dept_id"]));
    }
    if (m.find("dept_name") != m.end() && !m["dept_name"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["dept_name"]));
    }
    if (m.find("driver_confirm_time") != m.end() && !m["driver_confirm_time"].empty()) {
      driverConfirmTime = make_shared<string>(boost::any_cast<string>(m["driver_confirm_time"]));
    }
    if (m.find("estimate_price") != m.end() && !m["estimate_price"].empty()) {
      estimatePrice = make_shared<double>(boost::any_cast<double>(m["estimate_price"]));
    }
    if (m.find("from_address") != m.end() && !m["from_address"].empty()) {
      fromAddress = make_shared<string>(boost::any_cast<string>(m["from_address"]));
    }
    if (m.find("from_city_ad_code") != m.end() && !m["from_city_ad_code"].empty()) {
      fromCityAdCode = make_shared<string>(boost::any_cast<string>(m["from_city_ad_code"]));
    }
    if (m.find("from_city_name") != m.end() && !m["from_city_name"].empty()) {
      fromCityName = make_shared<string>(boost::any_cast<string>(m["from_city_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("invoice_id") != m.end() && !m["invoice_id"].empty()) {
      invoiceId = make_shared<long>(boost::any_cast<long>(m["invoice_id"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("is_special") != m.end() && !m["is_special"].empty()) {
      isSpecial = make_shared<bool>(boost::any_cast<bool>(m["is_special"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_time") != m.end() && !m["pay_time"].empty()) {
      payTime = make_shared<string>(boost::any_cast<string>(m["pay_time"]));
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<CarOrderListQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarOrderListQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<CarOrderListQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("provider") != m.end() && !m["provider"].empty()) {
      provider = make_shared<long>(boost::any_cast<long>(m["provider"]));
    }
    if (m.find("publish_time") != m.end() && !m["publish_time"].empty()) {
      publishTime = make_shared<string>(boost::any_cast<string>(m["publish_time"]));
    }
    if (m.find("real_from_address") != m.end() && !m["real_from_address"].empty()) {
      realFromAddress = make_shared<string>(boost::any_cast<string>(m["real_from_address"]));
    }
    if (m.find("real_from_city_ad_code") != m.end() && !m["real_from_city_ad_code"].empty()) {
      realFromCityAdCode = make_shared<string>(boost::any_cast<string>(m["real_from_city_ad_code"]));
    }
    if (m.find("real_from_city_name") != m.end() && !m["real_from_city_name"].empty()) {
      realFromCityName = make_shared<string>(boost::any_cast<string>(m["real_from_city_name"]));
    }
    if (m.find("real_to_address") != m.end() && !m["real_to_address"].empty()) {
      realToAddress = make_shared<string>(boost::any_cast<string>(m["real_to_address"]));
    }
    if (m.find("real_to_city_ad_code") != m.end() && !m["real_to_city_ad_code"].empty()) {
      realToCityAdCode = make_shared<string>(boost::any_cast<string>(m["real_to_city_ad_code"]));
    }
    if (m.find("real_to_city_name") != m.end() && !m["real_to_city_name"].empty()) {
      realToCityName = make_shared<string>(boost::any_cast<string>(m["real_to_city_name"]));
    }
    if (m.find("service_type") != m.end() && !m["service_type"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["service_type"]));
    }
    if (m.find("special_types") != m.end() && !m["special_types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["special_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["special_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      specialTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("taken_time") != m.end() && !m["taken_time"].empty()) {
      takenTime = make_shared<string>(boost::any_cast<string>(m["taken_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("to_address") != m.end() && !m["to_address"].empty()) {
      toAddress = make_shared<string>(boost::any_cast<string>(m["to_address"]));
    }
    if (m.find("to_city_ad_code") != m.end() && !m["to_city_ad_code"].empty()) {
      toCityAdCode = make_shared<string>(boost::any_cast<string>(m["to_city_ad_code"]));
    }
    if (m.find("to_city_name") != m.end() && !m["to_city_name"].empty()) {
      toCityName = make_shared<string>(boost::any_cast<string>(m["to_city_name"]));
    }
    if (m.find("travel_distance") != m.end() && !m["travel_distance"].empty()) {
      travelDistance = make_shared<double>(boost::any_cast<double>(m["travel_distance"]));
    }
    if (m.find("user_affiliate_list") != m.end() && !m["user_affiliate_list"].empty()) {
      if (typeid(vector<boost::any>) == m["user_affiliate_list"].type()) {
        vector<CarOrderListQueryResponseBodyModuleUserAffiliateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["user_affiliate_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarOrderListQueryResponseBodyModuleUserAffiliateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userAffiliateList = make_shared<vector<CarOrderListQueryResponseBodyModuleUserAffiliateList>>(expect1);
      }
    }
    if (m.find("user_confirm") != m.end() && !m["user_confirm"].empty()) {
      userConfirm = make_shared<long>(boost::any_cast<long>(m["user_confirm"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~CarOrderListQueryResponseBodyModule() = default;
};
class CarOrderListQueryResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalNumber{};

  CarOrderListQueryResponseBodyPageInfo() {}

  explicit CarOrderListQueryResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalNumber) {
      res["total_number"] = boost::any(*totalNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_number") != m.end() && !m["total_number"].empty()) {
      totalNumber = make_shared<long>(boost::any_cast<long>(m["total_number"]));
    }
  }


  virtual ~CarOrderListQueryResponseBodyPageInfo() = default;
};
class CarOrderListQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<CarOrderListQueryResponseBodyModule>> module{};
  shared_ptr<CarOrderListQueryResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CarOrderListQueryResponseBody() {}

  explicit CarOrderListQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<CarOrderListQueryResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarOrderListQueryResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<CarOrderListQueryResponseBodyModule>>(expect1);
      }
    }
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        CarOrderListQueryResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<CarOrderListQueryResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CarOrderListQueryResponseBody() = default;
};
class CarOrderListQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CarOrderListQueryResponseBody> body{};

  CarOrderListQueryResponse() {}

  explicit CarOrderListQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CarOrderListQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CarOrderListQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CarOrderListQueryResponse() = default;
};
class CarOrderQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CarOrderQueryHeaders() {}

  explicit CarOrderQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CarOrderQueryHeaders() = default;
};
class CarOrderQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<long> subOrderId{};

  CarOrderQueryRequest() {}

  explicit CarOrderQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<long>(boost::any_cast<long>(m["sub_order_id"]));
    }
  }


  virtual ~CarOrderQueryRequest() = default;
};
class CarOrderQueryResponseBodyModuleCarInfo : public Darabonba::Model {
public:
  shared_ptr<string> businessCategory{};
  shared_ptr<long> cancelTime{};
  shared_ptr<string> carInfo{};
  shared_ptr<long> carLevel{};
  shared_ptr<string> driverCard{};
  shared_ptr<long> driverConfirmTime{};
  shared_ptr<string> driverName{};
  shared_ptr<long> estimatePrice{};
  shared_ptr<string> fromAddress{};
  shared_ptr<string> fromCityAdCode{};
  shared_ptr<string> fromCityName{};
  shared_ptr<bool> isSpecial{};
  shared_ptr<string> memo{};
  shared_ptr<long> payTime{};
  shared_ptr<long> publishTime{};
  shared_ptr<string> realFromAddress{};
  shared_ptr<string> realFromCityAdCode{};
  shared_ptr<string> realFromCityName{};
  shared_ptr<string> realToAddress{};
  shared_ptr<string> realToCityAdCode{};
  shared_ptr<string> realToCityName{};
  shared_ptr<long> serviceType{};
  shared_ptr<string> specialTypes{};
  shared_ptr<long> takenTime{};
  shared_ptr<string> toAddress{};
  shared_ptr<string> toCityAdCode{};
  shared_ptr<string> toCityName{};
  shared_ptr<string> travelDistance{};

  CarOrderQueryResponseBodyModuleCarInfo() {}

  explicit CarOrderQueryResponseBodyModuleCarInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessCategory) {
      res["business_category"] = boost::any(*businessCategory);
    }
    if (cancelTime) {
      res["cancel_time"] = boost::any(*cancelTime);
    }
    if (carInfo) {
      res["car_info"] = boost::any(*carInfo);
    }
    if (carLevel) {
      res["car_level"] = boost::any(*carLevel);
    }
    if (driverCard) {
      res["driver_card"] = boost::any(*driverCard);
    }
    if (driverConfirmTime) {
      res["driver_confirm_time"] = boost::any(*driverConfirmTime);
    }
    if (driverName) {
      res["driver_name"] = boost::any(*driverName);
    }
    if (estimatePrice) {
      res["estimate_price"] = boost::any(*estimatePrice);
    }
    if (fromAddress) {
      res["from_address"] = boost::any(*fromAddress);
    }
    if (fromCityAdCode) {
      res["from_city_ad_code"] = boost::any(*fromCityAdCode);
    }
    if (fromCityName) {
      res["from_city_name"] = boost::any(*fromCityName);
    }
    if (isSpecial) {
      res["is_special"] = boost::any(*isSpecial);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (payTime) {
      res["pay_time"] = boost::any(*payTime);
    }
    if (publishTime) {
      res["publish_time"] = boost::any(*publishTime);
    }
    if (realFromAddress) {
      res["real_from_address"] = boost::any(*realFromAddress);
    }
    if (realFromCityAdCode) {
      res["real_from_city_ad_code"] = boost::any(*realFromCityAdCode);
    }
    if (realFromCityName) {
      res["real_from_city_name"] = boost::any(*realFromCityName);
    }
    if (realToAddress) {
      res["real_to_address"] = boost::any(*realToAddress);
    }
    if (realToCityAdCode) {
      res["real_to_city_ad_code"] = boost::any(*realToCityAdCode);
    }
    if (realToCityName) {
      res["real_to_city_name"] = boost::any(*realToCityName);
    }
    if (serviceType) {
      res["service_type"] = boost::any(*serviceType);
    }
    if (specialTypes) {
      res["special_types"] = boost::any(*specialTypes);
    }
    if (takenTime) {
      res["taken_time"] = boost::any(*takenTime);
    }
    if (toAddress) {
      res["to_address"] = boost::any(*toAddress);
    }
    if (toCityAdCode) {
      res["to_city_ad_code"] = boost::any(*toCityAdCode);
    }
    if (toCityName) {
      res["to_city_name"] = boost::any(*toCityName);
    }
    if (travelDistance) {
      res["travel_distance"] = boost::any(*travelDistance);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("business_category") != m.end() && !m["business_category"].empty()) {
      businessCategory = make_shared<string>(boost::any_cast<string>(m["business_category"]));
    }
    if (m.find("cancel_time") != m.end() && !m["cancel_time"].empty()) {
      cancelTime = make_shared<long>(boost::any_cast<long>(m["cancel_time"]));
    }
    if (m.find("car_info") != m.end() && !m["car_info"].empty()) {
      carInfo = make_shared<string>(boost::any_cast<string>(m["car_info"]));
    }
    if (m.find("car_level") != m.end() && !m["car_level"].empty()) {
      carLevel = make_shared<long>(boost::any_cast<long>(m["car_level"]));
    }
    if (m.find("driver_card") != m.end() && !m["driver_card"].empty()) {
      driverCard = make_shared<string>(boost::any_cast<string>(m["driver_card"]));
    }
    if (m.find("driver_confirm_time") != m.end() && !m["driver_confirm_time"].empty()) {
      driverConfirmTime = make_shared<long>(boost::any_cast<long>(m["driver_confirm_time"]));
    }
    if (m.find("driver_name") != m.end() && !m["driver_name"].empty()) {
      driverName = make_shared<string>(boost::any_cast<string>(m["driver_name"]));
    }
    if (m.find("estimate_price") != m.end() && !m["estimate_price"].empty()) {
      estimatePrice = make_shared<long>(boost::any_cast<long>(m["estimate_price"]));
    }
    if (m.find("from_address") != m.end() && !m["from_address"].empty()) {
      fromAddress = make_shared<string>(boost::any_cast<string>(m["from_address"]));
    }
    if (m.find("from_city_ad_code") != m.end() && !m["from_city_ad_code"].empty()) {
      fromCityAdCode = make_shared<string>(boost::any_cast<string>(m["from_city_ad_code"]));
    }
    if (m.find("from_city_name") != m.end() && !m["from_city_name"].empty()) {
      fromCityName = make_shared<string>(boost::any_cast<string>(m["from_city_name"]));
    }
    if (m.find("is_special") != m.end() && !m["is_special"].empty()) {
      isSpecial = make_shared<bool>(boost::any_cast<bool>(m["is_special"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("pay_time") != m.end() && !m["pay_time"].empty()) {
      payTime = make_shared<long>(boost::any_cast<long>(m["pay_time"]));
    }
    if (m.find("publish_time") != m.end() && !m["publish_time"].empty()) {
      publishTime = make_shared<long>(boost::any_cast<long>(m["publish_time"]));
    }
    if (m.find("real_from_address") != m.end() && !m["real_from_address"].empty()) {
      realFromAddress = make_shared<string>(boost::any_cast<string>(m["real_from_address"]));
    }
    if (m.find("real_from_city_ad_code") != m.end() && !m["real_from_city_ad_code"].empty()) {
      realFromCityAdCode = make_shared<string>(boost::any_cast<string>(m["real_from_city_ad_code"]));
    }
    if (m.find("real_from_city_name") != m.end() && !m["real_from_city_name"].empty()) {
      realFromCityName = make_shared<string>(boost::any_cast<string>(m["real_from_city_name"]));
    }
    if (m.find("real_to_address") != m.end() && !m["real_to_address"].empty()) {
      realToAddress = make_shared<string>(boost::any_cast<string>(m["real_to_address"]));
    }
    if (m.find("real_to_city_ad_code") != m.end() && !m["real_to_city_ad_code"].empty()) {
      realToCityAdCode = make_shared<string>(boost::any_cast<string>(m["real_to_city_ad_code"]));
    }
    if (m.find("real_to_city_name") != m.end() && !m["real_to_city_name"].empty()) {
      realToCityName = make_shared<string>(boost::any_cast<string>(m["real_to_city_name"]));
    }
    if (m.find("service_type") != m.end() && !m["service_type"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["service_type"]));
    }
    if (m.find("special_types") != m.end() && !m["special_types"].empty()) {
      specialTypes = make_shared<string>(boost::any_cast<string>(m["special_types"]));
    }
    if (m.find("taken_time") != m.end() && !m["taken_time"].empty()) {
      takenTime = make_shared<long>(boost::any_cast<long>(m["taken_time"]));
    }
    if (m.find("to_address") != m.end() && !m["to_address"].empty()) {
      toAddress = make_shared<string>(boost::any_cast<string>(m["to_address"]));
    }
    if (m.find("to_city_ad_code") != m.end() && !m["to_city_ad_code"].empty()) {
      toCityAdCode = make_shared<string>(boost::any_cast<string>(m["to_city_ad_code"]));
    }
    if (m.find("to_city_name") != m.end() && !m["to_city_name"].empty()) {
      toCityName = make_shared<string>(boost::any_cast<string>(m["to_city_name"]));
    }
    if (m.find("travel_distance") != m.end() && !m["travel_distance"].empty()) {
      travelDistance = make_shared<string>(boost::any_cast<string>(m["travel_distance"]));
    }
  }


  virtual ~CarOrderQueryResponseBodyModuleCarInfo() = default;
};
class CarOrderQueryResponseBodyModuleInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  CarOrderQueryResponseBodyModuleInvoiceInfo() {}

  explicit CarOrderQueryResponseBodyModuleInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CarOrderQueryResponseBodyModuleInvoiceInfo() = default;
};
class CarOrderQueryResponseBodyModuleOrderBaseInfo : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> btripCause{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> itineraryId{};
  shared_ptr<long> orderId{};
  shared_ptr<long> orderStatus{};
  shared_ptr<long> subOrderId{};
  shared_ptr<string> thirdDepartId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  CarOrderQueryResponseBodyModuleOrderBaseInfo() {}

  explicit CarOrderQueryResponseBodyModuleOrderBaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (btripCause) {
      res["btrip_cause"] = boost::any(*btripCause);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    if (thirdDepartId) {
      res["third_depart_id"] = boost::any(*thirdDepartId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("btrip_cause") != m.end() && !m["btrip_cause"].empty()) {
      btripCause = make_shared<string>(boost::any_cast<string>(m["btrip_cause"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmt_modified"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<long>(boost::any_cast<long>(m["sub_order_id"]));
    }
    if (m.find("third_depart_id") != m.end() && !m["third_depart_id"].empty()) {
      thirdDepartId = make_shared<string>(boost::any_cast<string>(m["third_depart_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~CarOrderQueryResponseBodyModuleOrderBaseInfo() = default;
};
class CarOrderQueryResponseBodyModulePassengerList : public Darabonba::Model {
public:
  shared_ptr<long> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdpartCostCenterId{};
  shared_ptr<string> thirdpartProjectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> userType{};

  CarOrderQueryResponseBodyModulePassengerList() {}

  explicit CarOrderQueryResponseBodyModulePassengerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdpartCostCenterId) {
      res["thirdpart_cost_center_id"] = boost::any(*thirdpartCostCenterId);
    }
    if (thirdpartProjectId) {
      res["thirdpart_project_id"] = boost::any(*thirdpartProjectId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (userType) {
      res["user_type"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("thirdpart_cost_center_id") != m.end() && !m["thirdpart_cost_center_id"].empty()) {
      thirdpartCostCenterId = make_shared<string>(boost::any_cast<string>(m["thirdpart_cost_center_id"]));
    }
    if (m.find("thirdpart_project_id") != m.end() && !m["thirdpart_project_id"].empty()) {
      thirdpartProjectId = make_shared<string>(boost::any_cast<string>(m["thirdpart_project_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("user_type") != m.end() && !m["user_type"].empty()) {
      userType = make_shared<long>(boost::any_cast<long>(m["user_type"]));
    }
  }


  virtual ~CarOrderQueryResponseBodyModulePassengerList() = default;
};
class CarOrderQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> payType{};
  shared_ptr<long> personPrice{};
  shared_ptr<long> price{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  CarOrderQueryResponseBodyModulePriceInfoList() {}

  explicit CarOrderQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (personPrice) {
      res["person_price"] = boost::any(*personPrice);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmt_create"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("person_price") != m.end() && !m["person_price"].empty()) {
      personPrice = make_shared<long>(boost::any_cast<long>(m["person_price"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~CarOrderQueryResponseBodyModulePriceInfoList() = default;
};
class CarOrderQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<CarOrderQueryResponseBodyModuleCarInfo> carInfo{};
  shared_ptr<CarOrderQueryResponseBodyModuleInvoiceInfo> invoiceInfo{};
  shared_ptr<CarOrderQueryResponseBodyModuleOrderBaseInfo> orderBaseInfo{};
  shared_ptr<vector<CarOrderQueryResponseBodyModulePassengerList>> passengerList{};
  shared_ptr<vector<CarOrderQueryResponseBodyModulePriceInfoList>> priceInfoList{};

  CarOrderQueryResponseBodyModule() {}

  explicit CarOrderQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (carInfo) {
      res["car_info"] = carInfo ? boost::any(carInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invoiceInfo) {
      res["invoice_info"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderBaseInfo) {
      res["order_base_info"] = orderBaseInfo ? boost::any(orderBaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passengerList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_list"] = boost::any(temp1);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("car_info") != m.end() && !m["car_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["car_info"].type()) {
        CarOrderQueryResponseBodyModuleCarInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["car_info"]));
        carInfo = make_shared<CarOrderQueryResponseBodyModuleCarInfo>(model1);
      }
    }
    if (m.find("invoice_info") != m.end() && !m["invoice_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice_info"].type()) {
        CarOrderQueryResponseBodyModuleInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice_info"]));
        invoiceInfo = make_shared<CarOrderQueryResponseBodyModuleInvoiceInfo>(model1);
      }
    }
    if (m.find("order_base_info") != m.end() && !m["order_base_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["order_base_info"].type()) {
        CarOrderQueryResponseBodyModuleOrderBaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["order_base_info"]));
        orderBaseInfo = make_shared<CarOrderQueryResponseBodyModuleOrderBaseInfo>(model1);
      }
    }
    if (m.find("passenger_list") != m.end() && !m["passenger_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_list"].type()) {
        vector<CarOrderQueryResponseBodyModulePassengerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarOrderQueryResponseBodyModulePassengerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerList = make_shared<vector<CarOrderQueryResponseBodyModulePassengerList>>(expect1);
      }
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<CarOrderQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarOrderQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<CarOrderQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
  }


  virtual ~CarOrderQueryResponseBodyModule() = default;
};
class CarOrderQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CarOrderQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CarOrderQueryResponseBody() {}

  explicit CarOrderQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CarOrderQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CarOrderQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CarOrderQueryResponseBody() = default;
};
class CarOrderQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CarOrderQueryResponseBody> body{};

  CarOrderQueryResponse() {}

  explicit CarOrderQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CarOrderQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CarOrderQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CarOrderQueryResponse() = default;
};
class CarSceneQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  CarSceneQueryHeaders() {}

  explicit CarSceneQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~CarSceneQueryHeaders() = default;
};
class CarSceneQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> scenarioTemplateId{};
  shared_ptr<string> scenarioTemplateName{};
  shared_ptr<string> state{};

  CarSceneQueryResponseBodyModule() {}

  explicit CarSceneQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scenarioTemplateId) {
      res["scenarioTemplateId"] = boost::any(*scenarioTemplateId);
    }
    if (scenarioTemplateName) {
      res["scenarioTemplateName"] = boost::any(*scenarioTemplateName);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scenarioTemplateId") != m.end() && !m["scenarioTemplateId"].empty()) {
      scenarioTemplateId = make_shared<string>(boost::any_cast<string>(m["scenarioTemplateId"]));
    }
    if (m.find("scenarioTemplateName") != m.end() && !m["scenarioTemplateName"].empty()) {
      scenarioTemplateName = make_shared<string>(boost::any_cast<string>(m["scenarioTemplateName"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~CarSceneQueryResponseBodyModule() = default;
};
class CarSceneQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<CarSceneQueryResponseBodyModule>> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CarSceneQueryResponseBody() {}

  explicit CarSceneQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<CarSceneQueryResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CarSceneQueryResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<CarSceneQueryResponseBodyModule>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CarSceneQueryResponseBody() = default;
};
class CarSceneQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CarSceneQueryResponseBody> body{};

  CarSceneQueryResponse() {}

  explicit CarSceneQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CarSceneQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CarSceneQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CarSceneQueryResponse() = default;
};
class CitySearchHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CitySearchHeaders() {}

  explicit CitySearchHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CitySearchHeaders() = default;
};
class CitySearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};

  CitySearchRequest() {}

  explicit CitySearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["keyword"] = boost::any(*keyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("keyword") != m.end() && !m["keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["keyword"]));
    }
  }


  virtual ~CitySearchRequest() = default;
};
class CitySearchResponseBodyModuleCities : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};
  shared_ptr<long> region{};

  CitySearchResponseBodyModuleCities() {}

  explicit CitySearchResponseBodyModuleCities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<long>(boost::any_cast<long>(m["region"]));
    }
  }


  virtual ~CitySearchResponseBodyModuleCities() = default;
};
class CitySearchResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<CitySearchResponseBodyModuleCities>> cities{};

  CitySearchResponseBodyModule() {}

  explicit CitySearchResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cities) {
      vector<boost::any> temp1;
      for(auto item1:*cities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cities"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cities") != m.end() && !m["cities"].empty()) {
      if (typeid(vector<boost::any>) == m["cities"].type()) {
        vector<CitySearchResponseBodyModuleCities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CitySearchResponseBodyModuleCities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cities = make_shared<vector<CitySearchResponseBodyModuleCities>>(expect1);
      }
    }
  }


  virtual ~CitySearchResponseBodyModule() = default;
};
class CitySearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CitySearchResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CitySearchResponseBody() {}

  explicit CitySearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CitySearchResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CitySearchResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CitySearchResponseBody() = default;
};
class CitySearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CitySearchResponseBody> body{};

  CitySearchResponse() {}

  explicit CitySearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CitySearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CitySearchResponseBody>(model1);
      }
    }
  }


  virtual ~CitySearchResponse() = default;
};
class CommonApplyQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CommonApplyQueryHeaders() {}

  explicit CommonApplyQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CommonApplyQueryHeaders() = default;
};
class CommonApplyQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<long> bizCategory{};
  shared_ptr<string> userId{};

  CommonApplyQueryRequest() {}

  explicit CommonApplyQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (bizCategory) {
      res["biz_category"] = boost::any(*bizCategory);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("biz_category") != m.end() && !m["biz_category"].empty()) {
      bizCategory = make_shared<long>(boost::any_cast<long>(m["biz_category"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CommonApplyQueryRequest() = default;
};
class CommonApplyQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<long> bizCategory{};
  shared_ptr<string> cause{};
  shared_ptr<string> corpId{};
  shared_ptr<string> extendValue{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdpartCorpId{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<string> tripCause{};
  shared_ptr<string> userId{};

  CommonApplyQueryResponseBodyModule() {}

  explicit CommonApplyQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (bizCategory) {
      res["biz_category"] = boost::any(*bizCategory);
    }
    if (cause) {
      res["cause"] = boost::any(*cause);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (extendValue) {
      res["extend_value"] = boost::any(*extendValue);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdpartCorpId) {
      res["thirdpart_corp_id"] = boost::any(*thirdpartCorpId);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (tripCause) {
      res["trip_cause"] = boost::any(*tripCause);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("biz_category") != m.end() && !m["biz_category"].empty()) {
      bizCategory = make_shared<long>(boost::any_cast<long>(m["biz_category"]));
    }
    if (m.find("cause") != m.end() && !m["cause"].empty()) {
      cause = make_shared<string>(boost::any_cast<string>(m["cause"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("extend_value") != m.end() && !m["extend_value"].empty()) {
      extendValue = make_shared<string>(boost::any_cast<string>(m["extend_value"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("thirdpart_corp_id") != m.end() && !m["thirdpart_corp_id"].empty()) {
      thirdpartCorpId = make_shared<string>(boost::any_cast<string>(m["thirdpart_corp_id"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("trip_cause") != m.end() && !m["trip_cause"].empty()) {
      tripCause = make_shared<string>(boost::any_cast<string>(m["trip_cause"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CommonApplyQueryResponseBodyModule() = default;
};
class CommonApplyQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CommonApplyQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CommonApplyQueryResponseBody() {}

  explicit CommonApplyQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CommonApplyQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CommonApplyQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CommonApplyQueryResponseBody() = default;
};
class CommonApplyQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CommonApplyQueryResponseBody> body{};

  CommonApplyQueryResponse() {}

  explicit CommonApplyQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CommonApplyQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CommonApplyQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CommonApplyQueryResponse() = default;
};
class CommonApplySyncHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CommonApplySyncHeaders() {}

  explicit CommonApplySyncHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CommonApplySyncHeaders() = default;
};
class CommonApplySyncRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<long> bizCategory{};
  shared_ptr<string> remark{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdpartyFlowId{};
  shared_ptr<string> userId{};

  CommonApplySyncRequest() {}

  explicit CommonApplySyncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (bizCategory) {
      res["biz_category"] = boost::any(*bizCategory);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdpartyFlowId) {
      res["thirdparty_flow_id"] = boost::any(*thirdpartyFlowId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("biz_category") != m.end() && !m["biz_category"].empty()) {
      bizCategory = make_shared<long>(boost::any_cast<long>(m["biz_category"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("thirdparty_flow_id") != m.end() && !m["thirdparty_flow_id"].empty()) {
      thirdpartyFlowId = make_shared<string>(boost::any_cast<string>(m["thirdparty_flow_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CommonApplySyncRequest() = default;
};
class CommonApplySyncResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CommonApplySyncResponseBody() {}

  explicit CommonApplySyncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<bool>(boost::any_cast<bool>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CommonApplySyncResponseBody() = default;
};
class CommonApplySyncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CommonApplySyncResponseBody> body{};

  CommonApplySyncResponse() {}

  explicit CommonApplySyncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CommonApplySyncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CommonApplySyncResponseBody>(model1);
      }
    }
  }


  virtual ~CommonApplySyncResponse() = default;
};
class CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps : public Darabonba::Model {
public:
  shared_ptr<string> corpName{};
  shared_ptr<string> openCorpId{};
  shared_ptr<string> trueCorpId{};

  CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps() {}

  explicit CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (openCorpId) {
      res["open_corp_id"] = boost::any(*openCorpId);
    }
    if (trueCorpId) {
      res["true_corp_id"] = boost::any(*trueCorpId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("open_corp_id") != m.end() && !m["open_corp_id"].empty()) {
      openCorpId = make_shared<string>(boost::any_cast<string>(m["open_corp_id"]));
    }
    if (m.find("true_corp_id") != m.end() && !m["true_corp_id"].empty()) {
      trueCorpId = make_shared<string>(boost::any_cast<string>(m["true_corp_id"]));
    }
  }


  virtual ~CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps() = default;
};
class CorpAuthLinkInfoQueryResponseBodyModuleOrgCorp : public Darabonba::Model {
public:
  shared_ptr<string> corpName{};
  shared_ptr<string> openCorpId{};
  shared_ptr<string> trueCorpId{};

  CorpAuthLinkInfoQueryResponseBodyModuleOrgCorp() {}

  explicit CorpAuthLinkInfoQueryResponseBodyModuleOrgCorp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (openCorpId) {
      res["open_corp_id"] = boost::any(*openCorpId);
    }
    if (trueCorpId) {
      res["true_corp_id"] = boost::any(*trueCorpId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("open_corp_id") != m.end() && !m["open_corp_id"].empty()) {
      openCorpId = make_shared<string>(boost::any_cast<string>(m["open_corp_id"]));
    }
    if (m.find("true_corp_id") != m.end() && !m["true_corp_id"].empty()) {
      trueCorpId = make_shared<string>(boost::any_cast<string>(m["true_corp_id"]));
    }
  }


  virtual ~CorpAuthLinkInfoQueryResponseBodyModuleOrgCorp() = default;
};
class CorpAuthLinkInfoQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps>> linkCorps{};
  shared_ptr<CorpAuthLinkInfoQueryResponseBodyModuleOrgCorp> orgCorp{};

  CorpAuthLinkInfoQueryResponseBodyModule() {}

  explicit CorpAuthLinkInfoQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (linkCorps) {
      vector<boost::any> temp1;
      for(auto item1:*linkCorps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["link_corps"] = boost::any(temp1);
    }
    if (orgCorp) {
      res["org_corp"] = orgCorp ? boost::any(orgCorp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("link_corps") != m.end() && !m["link_corps"].empty()) {
      if (typeid(vector<boost::any>) == m["link_corps"].type()) {
        vector<CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["link_corps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        linkCorps = make_shared<vector<CorpAuthLinkInfoQueryResponseBodyModuleLinkCorps>>(expect1);
      }
    }
    if (m.find("org_corp") != m.end() && !m["org_corp"].empty()) {
      if (typeid(map<string, boost::any>) == m["org_corp"].type()) {
        CorpAuthLinkInfoQueryResponseBodyModuleOrgCorp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["org_corp"]));
        orgCorp = make_shared<CorpAuthLinkInfoQueryResponseBodyModuleOrgCorp>(model1);
      }
    }
  }


  virtual ~CorpAuthLinkInfoQueryResponseBodyModule() = default;
};
class CorpAuthLinkInfoQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CorpAuthLinkInfoQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<string> traceId{};

  CorpAuthLinkInfoQueryResponseBody() {}

  explicit CorpAuthLinkInfoQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CorpAuthLinkInfoQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CorpAuthLinkInfoQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CorpAuthLinkInfoQueryResponseBody() = default;
};
class CorpAuthLinkInfoQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CorpAuthLinkInfoQueryResponseBody> body{};

  CorpAuthLinkInfoQueryResponse() {}

  explicit CorpAuthLinkInfoQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CorpAuthLinkInfoQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CorpAuthLinkInfoQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CorpAuthLinkInfoQueryResponse() = default;
};
class CorpTokenHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripAccessToken{};

  CorpTokenHeaders() {}

  explicit CorpTokenHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripAccessToken) {
      res["x-acs-btrip-access-token"] = boost::any(*xAcsBtripAccessToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-access-token") != m.end() && !m["x-acs-btrip-access-token"].empty()) {
      xAcsBtripAccessToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-access-token"]));
    }
  }


  virtual ~CorpTokenHeaders() = default;
};
class CorpTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appSecret{};
  shared_ptr<string> corpId{};
  shared_ptr<long> type{};

  CorpTokenRequest() {}

  explicit CorpTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appSecret) {
      res["app_secret"] = boost::any(*appSecret);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("app_secret") != m.end() && !m["app_secret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["app_secret"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~CorpTokenRequest() = default;
};
class CorpTokenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> expire{};
  shared_ptr<string> token{};

  CorpTokenResponseBodyData() {}

  explicit CorpTokenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expire) {
      res["expire"] = boost::any(*expire);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("expire") != m.end() && !m["expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["expire"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~CorpTokenResponseBodyData() = default;
};
class CorpTokenResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> expire{};
  shared_ptr<long> start{};
  shared_ptr<string> token{};

  CorpTokenResponseBodyModule() {}

  explicit CorpTokenResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expire) {
      res["expire"] = boost::any(*expire);
    }
    if (start) {
      res["start"] = boost::any(*start);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("expire") != m.end() && !m["expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["expire"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["start"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~CorpTokenResponseBodyModule() = default;
};
class CorpTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CorpTokenResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<CorpTokenResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CorpTokenResponseBody() {}

  explicit CorpTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CorpTokenResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CorpTokenResponseBodyData>(model1);
      }
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CorpTokenResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CorpTokenResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CorpTokenResponseBody() = default;
};
class CorpTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CorpTokenResponseBody> body{};

  CorpTokenResponse() {}

  explicit CorpTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CorpTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CorpTokenResponseBody>(model1);
      }
    }
  }


  virtual ~CorpTokenResponse() = default;
};
class CostCenterDeleteHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CostCenterDeleteHeaders() {}

  explicit CostCenterDeleteHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CostCenterDeleteHeaders() = default;
};
class CostCenterDeleteRequest : public Darabonba::Model {
public:
  shared_ptr<string> thirdpartId{};

  CostCenterDeleteRequest() {}

  explicit CostCenterDeleteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
  }


  virtual ~CostCenterDeleteRequest() = default;
};
class CostCenterDeleteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CostCenterDeleteResponseBody() {}

  explicit CostCenterDeleteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CostCenterDeleteResponseBody() = default;
};
class CostCenterDeleteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CostCenterDeleteResponseBody> body{};

  CostCenterDeleteResponse() {}

  explicit CostCenterDeleteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CostCenterDeleteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CostCenterDeleteResponseBody>(model1);
      }
    }
  }


  virtual ~CostCenterDeleteResponse() = default;
};
class CostCenterModifyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CostCenterModifyHeaders() {}

  explicit CostCenterModifyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CostCenterModifyHeaders() = default;
};
class CostCenterModifyRequest : public Darabonba::Model {
public:
  shared_ptr<string> alipayNo{};
  shared_ptr<string> number{};
  shared_ptr<long> scope{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<string> title{};

  CostCenterModifyRequest() {}

  explicit CostCenterModifyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayNo) {
      res["alipay_no"] = boost::any(*alipayNo);
    }
    if (number) {
      res["number"] = boost::any(*number);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_no") != m.end() && !m["alipay_no"].empty()) {
      alipayNo = make_shared<string>(boost::any_cast<string>(m["alipay_no"]));
    }
    if (m.find("number") != m.end() && !m["number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["number"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<long>(boost::any_cast<long>(m["scope"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CostCenterModifyRequest() = default;
};
class CostCenterModifyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CostCenterModifyResponseBody() {}

  explicit CostCenterModifyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CostCenterModifyResponseBody() = default;
};
class CostCenterModifyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CostCenterModifyResponseBody> body{};

  CostCenterModifyResponse() {}

  explicit CostCenterModifyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CostCenterModifyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CostCenterModifyResponseBody>(model1);
      }
    }
  }


  virtual ~CostCenterModifyResponse() = default;
};
class CostCenterQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CostCenterQueryHeaders() {}

  explicit CostCenterQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CostCenterQueryHeaders() = default;
};
class CostCenterQueryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> needOrgEntity{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<string> title{};
  shared_ptr<string> userId{};

  CostCenterQueryRequest() {}

  explicit CostCenterQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (needOrgEntity) {
      res["need_org_entity"] = boost::any(*needOrgEntity);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("need_org_entity") != m.end() && !m["need_org_entity"].empty()) {
      needOrgEntity = make_shared<bool>(boost::any_cast<bool>(m["need_org_entity"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CostCenterQueryRequest() = default;
};
class CostCenterQueryResponseBodyModuleEntityDOS : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> entityId{};
  shared_ptr<string> entityType{};
  shared_ptr<string> name{};
  shared_ptr<long> userNum{};

  CostCenterQueryResponseBodyModuleEntityDOS() {}

  explicit CostCenterQueryResponseBodyModuleEntityDOS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (entityId) {
      res["entity_id"] = boost::any(*entityId);
    }
    if (entityType) {
      res["entity_type"] = boost::any(*entityType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (userNum) {
      res["user_num"] = boost::any(*userNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("entity_id") != m.end() && !m["entity_id"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["entity_id"]));
    }
    if (m.find("entity_type") != m.end() && !m["entity_type"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["entity_type"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("user_num") != m.end() && !m["user_num"].empty()) {
      userNum = make_shared<long>(boost::any_cast<long>(m["user_num"]));
    }
  }


  virtual ~CostCenterQueryResponseBodyModuleEntityDOS() = default;
};
class CostCenterQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> alipayNo{};
  shared_ptr<string> corpId{};
  shared_ptr<vector<CostCenterQueryResponseBodyModuleEntityDOS>> entityDOS{};
  shared_ptr<long> id{};
  shared_ptr<string> number{};
  shared_ptr<long> ruleCode{};
  shared_ptr<long> scope{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<string> title{};

  CostCenterQueryResponseBodyModule() {}

  explicit CostCenterQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayNo) {
      res["alipay_no"] = boost::any(*alipayNo);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (entityDOS) {
      vector<boost::any> temp1;
      for(auto item1:*entityDOS){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entity_d_o_s"] = boost::any(temp1);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (number) {
      res["number"] = boost::any(*number);
    }
    if (ruleCode) {
      res["rule_code"] = boost::any(*ruleCode);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_no") != m.end() && !m["alipay_no"].empty()) {
      alipayNo = make_shared<string>(boost::any_cast<string>(m["alipay_no"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("entity_d_o_s") != m.end() && !m["entity_d_o_s"].empty()) {
      if (typeid(vector<boost::any>) == m["entity_d_o_s"].type()) {
        vector<CostCenterQueryResponseBodyModuleEntityDOS> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entity_d_o_s"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CostCenterQueryResponseBodyModuleEntityDOS model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entityDOS = make_shared<vector<CostCenterQueryResponseBodyModuleEntityDOS>>(expect1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("number") != m.end() && !m["number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["number"]));
    }
    if (m.find("rule_code") != m.end() && !m["rule_code"].empty()) {
      ruleCode = make_shared<long>(boost::any_cast<long>(m["rule_code"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<long>(boost::any_cast<long>(m["scope"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CostCenterQueryResponseBodyModule() = default;
};
class CostCenterQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<CostCenterQueryResponseBodyModule>> module{};
  shared_ptr<bool> morePage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CostCenterQueryResponseBody() {}

  explicit CostCenterQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (morePage) {
      res["more_page"] = boost::any(*morePage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<CostCenterQueryResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CostCenterQueryResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<CostCenterQueryResponseBodyModule>>(expect1);
      }
    }
    if (m.find("more_page") != m.end() && !m["more_page"].empty()) {
      morePage = make_shared<bool>(boost::any_cast<bool>(m["more_page"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CostCenterQueryResponseBody() = default;
};
class CostCenterQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CostCenterQueryResponseBody> body{};

  CostCenterQueryResponse() {}

  explicit CostCenterQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CostCenterQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CostCenterQueryResponseBody>(model1);
      }
    }
  }


  virtual ~CostCenterQueryResponse() = default;
};
class CostCenterSaveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  CostCenterSaveHeaders() {}

  explicit CostCenterSaveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~CostCenterSaveHeaders() = default;
};
class CostCenterSaveRequest : public Darabonba::Model {
public:
  shared_ptr<string> alipayNo{};
  shared_ptr<string> number{};
  shared_ptr<long> scope{};
  shared_ptr<string> thirdpartId{};
  shared_ptr<string> title{};

  CostCenterSaveRequest() {}

  explicit CostCenterSaveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayNo) {
      res["alipay_no"] = boost::any(*alipayNo);
    }
    if (number) {
      res["number"] = boost::any(*number);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_no") != m.end() && !m["alipay_no"].empty()) {
      alipayNo = make_shared<string>(boost::any_cast<string>(m["alipay_no"]));
    }
    if (m.find("number") != m.end() && !m["number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["number"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<long>(boost::any_cast<long>(m["scope"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~CostCenterSaveRequest() = default;
};
class CostCenterSaveResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  CostCenterSaveResponseBodyModule() {}

  explicit CostCenterSaveResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
  }


  virtual ~CostCenterSaveResponseBodyModule() = default;
};
class CostCenterSaveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CostCenterSaveResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CostCenterSaveResponseBody() {}

  explicit CostCenterSaveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CostCenterSaveResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CostCenterSaveResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CostCenterSaveResponseBody() = default;
};
class CostCenterSaveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CostCenterSaveResponseBody> body{};

  CostCenterSaveResponse() {}

  explicit CostCenterSaveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CostCenterSaveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CostCenterSaveResponseBody>(model1);
      }
    }
  }


  virtual ~CostCenterSaveResponse() = default;
};
class CreateSubCorpHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  CreateSubCorpHeaders() {}

  explicit CreateSubCorpHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~CreateSubCorpHeaders() = default;
};
class CreateSubCorpRequest : public Darabonba::Model {
public:
  shared_ptr<string> outerCorpId{};
  shared_ptr<string> outerCorpName{};
  shared_ptr<string> userId{};

  CreateSubCorpRequest() {}

  explicit CreateSubCorpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outerCorpId) {
      res["outer_corp_id"] = boost::any(*outerCorpId);
    }
    if (outerCorpName) {
      res["outer_corp_name"] = boost::any(*outerCorpName);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("outer_corp_id") != m.end() && !m["outer_corp_id"].empty()) {
      outerCorpId = make_shared<string>(boost::any_cast<string>(m["outer_corp_id"]));
    }
    if (m.find("outer_corp_name") != m.end() && !m["outer_corp_name"].empty()) {
      outerCorpName = make_shared<string>(boost::any_cast<string>(m["outer_corp_name"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~CreateSubCorpRequest() = default;
};
class CreateSubCorpResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> subCorpId{};

  CreateSubCorpResponseBodyModule() {}

  explicit CreateSubCorpResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
  }


  virtual ~CreateSubCorpResponseBodyModule() = default;
};
class CreateSubCorpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CreateSubCorpResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  CreateSubCorpResponseBody() {}

  explicit CreateSubCorpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        CreateSubCorpResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<CreateSubCorpResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~CreateSubCorpResponseBody() = default;
};
class CreateSubCorpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSubCorpResponseBody> body{};

  CreateSubCorpResponse() {}

  explicit CreateSubCorpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSubCorpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSubCorpResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSubCorpResponse() = default;
};
class DeleteInvoiceEntityHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  DeleteInvoiceEntityHeaders() {}

  explicit DeleteInvoiceEntityHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~DeleteInvoiceEntityHeaders() = default;
};
class DeleteInvoiceEntityRequestEntities : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> entityType{};

  DeleteInvoiceEntityRequestEntities() {}

  explicit DeleteInvoiceEntityRequestEntities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["entity_id"] = boost::any(*entityId);
    }
    if (entityType) {
      res["entity_type"] = boost::any(*entityType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_id") != m.end() && !m["entity_id"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["entity_id"]));
    }
    if (m.find("entity_type") != m.end() && !m["entity_type"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["entity_type"]));
    }
  }


  virtual ~DeleteInvoiceEntityRequestEntities() = default;
};
class DeleteInvoiceEntityRequest : public Darabonba::Model {
public:
  shared_ptr<bool> delAll{};
  shared_ptr<vector<DeleteInvoiceEntityRequestEntities>> entities{};
  shared_ptr<string> thirdPartId{};

  DeleteInvoiceEntityRequest() {}

  explicit DeleteInvoiceEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delAll) {
      res["del_all"] = boost::any(*delAll);
    }
    if (entities) {
      vector<boost::any> temp1;
      for(auto item1:*entities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entities"] = boost::any(temp1);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("del_all") != m.end() && !m["del_all"].empty()) {
      delAll = make_shared<bool>(boost::any_cast<bool>(m["del_all"]));
    }
    if (m.find("entities") != m.end() && !m["entities"].empty()) {
      if (typeid(vector<boost::any>) == m["entities"].type()) {
        vector<DeleteInvoiceEntityRequestEntities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteInvoiceEntityRequestEntities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entities = make_shared<vector<DeleteInvoiceEntityRequestEntities>>(expect1);
      }
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~DeleteInvoiceEntityRequest() = default;
};
class DeleteInvoiceEntityShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> delAll{};
  shared_ptr<string> entitiesShrink{};
  shared_ptr<string> thirdPartId{};

  DeleteInvoiceEntityShrinkRequest() {}

  explicit DeleteInvoiceEntityShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delAll) {
      res["del_all"] = boost::any(*delAll);
    }
    if (entitiesShrink) {
      res["entities"] = boost::any(*entitiesShrink);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("del_all") != m.end() && !m["del_all"].empty()) {
      delAll = make_shared<bool>(boost::any_cast<bool>(m["del_all"]));
    }
    if (m.find("entities") != m.end() && !m["entities"].empty()) {
      entitiesShrink = make_shared<string>(boost::any_cast<string>(m["entities"]));
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~DeleteInvoiceEntityShrinkRequest() = default;
};
class DeleteInvoiceEntityResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> removeNum{};
  shared_ptr<long> selectedUserNum{};

  DeleteInvoiceEntityResponseBodyModule() {}

  explicit DeleteInvoiceEntityResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (removeNum) {
      res["remove_num"] = boost::any(*removeNum);
    }
    if (selectedUserNum) {
      res["selected_user_num"] = boost::any(*selectedUserNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("remove_num") != m.end() && !m["remove_num"].empty()) {
      removeNum = make_shared<long>(boost::any_cast<long>(m["remove_num"]));
    }
    if (m.find("selected_user_num") != m.end() && !m["selected_user_num"].empty()) {
      selectedUserNum = make_shared<long>(boost::any_cast<long>(m["selected_user_num"]));
    }
  }


  virtual ~DeleteInvoiceEntityResponseBodyModule() = default;
};
class DeleteInvoiceEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<DeleteInvoiceEntityResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DeleteInvoiceEntityResponseBody() {}

  explicit DeleteInvoiceEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        DeleteInvoiceEntityResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<DeleteInvoiceEntityResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~DeleteInvoiceEntityResponseBody() = default;
};
class DeleteInvoiceEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteInvoiceEntityResponseBody> body{};

  DeleteInvoiceEntityResponse() {}

  explicit DeleteInvoiceEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInvoiceEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInvoiceEntityResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInvoiceEntityResponse() = default;
};
class DepartmentSaveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  DepartmentSaveHeaders() {}

  explicit DepartmentSaveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~DepartmentSaveHeaders() = default;
};
class DepartmentSaveRequestDepartList : public Darabonba::Model {
public:
  shared_ptr<long> departId{};
  shared_ptr<string> departName{};
  shared_ptr<long> departPid{};
  shared_ptr<string> managerIds{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdDepartId{};
  shared_ptr<string> thirdDepartPid{};

  DepartmentSaveRequestDepartList() {}

  explicit DepartmentSaveRequestDepartList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (departPid) {
      res["depart_pid"] = boost::any(*departPid);
    }
    if (managerIds) {
      res["manager_ids"] = boost::any(*managerIds);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdDepartId) {
      res["third_depart_id"] = boost::any(*thirdDepartId);
    }
    if (thirdDepartPid) {
      res["third_depart_pid"] = boost::any(*thirdDepartPid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<long>(boost::any_cast<long>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("depart_pid") != m.end() && !m["depart_pid"].empty()) {
      departPid = make_shared<long>(boost::any_cast<long>(m["depart_pid"]));
    }
    if (m.find("manager_ids") != m.end() && !m["manager_ids"].empty()) {
      managerIds = make_shared<string>(boost::any_cast<string>(m["manager_ids"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("third_depart_id") != m.end() && !m["third_depart_id"].empty()) {
      thirdDepartId = make_shared<string>(boost::any_cast<string>(m["third_depart_id"]));
    }
    if (m.find("third_depart_pid") != m.end() && !m["third_depart_pid"].empty()) {
      thirdDepartPid = make_shared<string>(boost::any_cast<string>(m["third_depart_pid"]));
    }
  }


  virtual ~DepartmentSaveRequestDepartList() = default;
};
class DepartmentSaveRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DepartmentSaveRequestDepartList>> departList{};

  DepartmentSaveRequest() {}

  explicit DepartmentSaveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departList) {
      vector<boost::any> temp1;
      for(auto item1:*departList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["depart_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("depart_list") != m.end() && !m["depart_list"].empty()) {
      if (typeid(vector<boost::any>) == m["depart_list"].type()) {
        vector<DepartmentSaveRequestDepartList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["depart_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DepartmentSaveRequestDepartList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        departList = make_shared<vector<DepartmentSaveRequestDepartList>>(expect1);
      }
    }
  }


  virtual ~DepartmentSaveRequest() = default;
};
class DepartmentSaveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> departListShrink{};

  DepartmentSaveShrinkRequest() {}

  explicit DepartmentSaveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departListShrink) {
      res["depart_list"] = boost::any(*departListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("depart_list") != m.end() && !m["depart_list"].empty()) {
      departListShrink = make_shared<string>(boost::any_cast<string>(m["depart_list"]));
    }
  }


  virtual ~DepartmentSaveShrinkRequest() = default;
};
class DepartmentSaveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  DepartmentSaveResponseBody() {}

  explicit DepartmentSaveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~DepartmentSaveResponseBody() = default;
};
class DepartmentSaveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DepartmentSaveResponseBody> body{};

  DepartmentSaveResponse() {}

  explicit DepartmentSaveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DepartmentSaveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DepartmentSaveResponseBody>(model1);
      }
    }
  }


  virtual ~DepartmentSaveResponse() = default;
};
class EntityAddHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  EntityAddHeaders() {}

  explicit EntityAddHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~EntityAddHeaders() = default;
};
class EntityAddRequestEntityDOList : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> entityType{};

  EntityAddRequestEntityDOList() {}

  explicit EntityAddRequestEntityDOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["entity_id"] = boost::any(*entityId);
    }
    if (entityType) {
      res["entity_type"] = boost::any(*entityType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_id") != m.end() && !m["entity_id"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["entity_id"]));
    }
    if (m.find("entity_type") != m.end() && !m["entity_type"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["entity_type"]));
    }
  }


  virtual ~EntityAddRequestEntityDOList() = default;
};
class EntityAddRequest : public Darabonba::Model {
public:
  shared_ptr<vector<EntityAddRequestEntityDOList>> entityDOList{};
  shared_ptr<string> thirdpartId{};

  EntityAddRequest() {}

  explicit EntityAddRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityDOList) {
      vector<boost::any> temp1;
      for(auto item1:*entityDOList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entity_d_o_list"] = boost::any(temp1);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_d_o_list") != m.end() && !m["entity_d_o_list"].empty()) {
      if (typeid(vector<boost::any>) == m["entity_d_o_list"].type()) {
        vector<EntityAddRequestEntityDOList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entity_d_o_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EntityAddRequestEntityDOList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entityDOList = make_shared<vector<EntityAddRequestEntityDOList>>(expect1);
      }
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
  }


  virtual ~EntityAddRequest() = default;
};
class EntityAddShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> entityDOListShrink{};
  shared_ptr<string> thirdpartId{};

  EntityAddShrinkRequest() {}

  explicit EntityAddShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityDOListShrink) {
      res["entity_d_o_list"] = boost::any(*entityDOListShrink);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_d_o_list") != m.end() && !m["entity_d_o_list"].empty()) {
      entityDOListShrink = make_shared<string>(boost::any_cast<string>(m["entity_d_o_list"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
  }


  virtual ~EntityAddShrinkRequest() = default;
};
class EntityAddResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> addNum{};
  shared_ptr<long> selectedUserNum{};

  EntityAddResponseBodyModule() {}

  explicit EntityAddResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addNum) {
      res["add_num"] = boost::any(*addNum);
    }
    if (selectedUserNum) {
      res["selected_user_num"] = boost::any(*selectedUserNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("add_num") != m.end() && !m["add_num"].empty()) {
      addNum = make_shared<long>(boost::any_cast<long>(m["add_num"]));
    }
    if (m.find("selected_user_num") != m.end() && !m["selected_user_num"].empty()) {
      selectedUserNum = make_shared<long>(boost::any_cast<long>(m["selected_user_num"]));
    }
  }


  virtual ~EntityAddResponseBodyModule() = default;
};
class EntityAddResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<EntityAddResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  EntityAddResponseBody() {}

  explicit EntityAddResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        EntityAddResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<EntityAddResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~EntityAddResponseBody() = default;
};
class EntityAddResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EntityAddResponseBody> body{};

  EntityAddResponse() {}

  explicit EntityAddResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EntityAddResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EntityAddResponseBody>(model1);
      }
    }
  }


  virtual ~EntityAddResponse() = default;
};
class EntityDeleteHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  EntityDeleteHeaders() {}

  explicit EntityDeleteHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~EntityDeleteHeaders() = default;
};
class EntityDeleteRequestEntityDOList : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> entityType{};

  EntityDeleteRequestEntityDOList() {}

  explicit EntityDeleteRequestEntityDOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["entity_id"] = boost::any(*entityId);
    }
    if (entityType) {
      res["entity_type"] = boost::any(*entityType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_id") != m.end() && !m["entity_id"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["entity_id"]));
    }
    if (m.find("entity_type") != m.end() && !m["entity_type"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["entity_type"]));
    }
  }


  virtual ~EntityDeleteRequestEntityDOList() = default;
};
class EntityDeleteRequest : public Darabonba::Model {
public:
  shared_ptr<bool> delAll{};
  shared_ptr<vector<EntityDeleteRequestEntityDOList>> entityDOList{};
  shared_ptr<string> thirdpartId{};

  EntityDeleteRequest() {}

  explicit EntityDeleteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delAll) {
      res["del_all"] = boost::any(*delAll);
    }
    if (entityDOList) {
      vector<boost::any> temp1;
      for(auto item1:*entityDOList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entity_d_o_list"] = boost::any(temp1);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("del_all") != m.end() && !m["del_all"].empty()) {
      delAll = make_shared<bool>(boost::any_cast<bool>(m["del_all"]));
    }
    if (m.find("entity_d_o_list") != m.end() && !m["entity_d_o_list"].empty()) {
      if (typeid(vector<boost::any>) == m["entity_d_o_list"].type()) {
        vector<EntityDeleteRequestEntityDOList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entity_d_o_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EntityDeleteRequestEntityDOList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entityDOList = make_shared<vector<EntityDeleteRequestEntityDOList>>(expect1);
      }
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
  }


  virtual ~EntityDeleteRequest() = default;
};
class EntityDeleteShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> delAll{};
  shared_ptr<string> entityDOListShrink{};
  shared_ptr<string> thirdpartId{};

  EntityDeleteShrinkRequest() {}

  explicit EntityDeleteShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delAll) {
      res["del_all"] = boost::any(*delAll);
    }
    if (entityDOListShrink) {
      res["entity_d_o_list"] = boost::any(*entityDOListShrink);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("del_all") != m.end() && !m["del_all"].empty()) {
      delAll = make_shared<bool>(boost::any_cast<bool>(m["del_all"]));
    }
    if (m.find("entity_d_o_list") != m.end() && !m["entity_d_o_list"].empty()) {
      entityDOListShrink = make_shared<string>(boost::any_cast<string>(m["entity_d_o_list"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
  }


  virtual ~EntityDeleteShrinkRequest() = default;
};
class EntityDeleteResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> removeNum{};
  shared_ptr<long> selectedUserNum{};

  EntityDeleteResponseBodyModule() {}

  explicit EntityDeleteResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (removeNum) {
      res["remove_num"] = boost::any(*removeNum);
    }
    if (selectedUserNum) {
      res["selected_user_num"] = boost::any(*selectedUserNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("remove_num") != m.end() && !m["remove_num"].empty()) {
      removeNum = make_shared<long>(boost::any_cast<long>(m["remove_num"]));
    }
    if (m.find("selected_user_num") != m.end() && !m["selected_user_num"].empty()) {
      selectedUserNum = make_shared<long>(boost::any_cast<long>(m["selected_user_num"]));
    }
  }


  virtual ~EntityDeleteResponseBodyModule() = default;
};
class EntityDeleteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<EntityDeleteResponseBodyModule> module{};
  shared_ptr<bool> morePage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  EntityDeleteResponseBody() {}

  explicit EntityDeleteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (morePage) {
      res["more_page"] = boost::any(*morePage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        EntityDeleteResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<EntityDeleteResponseBodyModule>(model1);
      }
    }
    if (m.find("more_page") != m.end() && !m["more_page"].empty()) {
      morePage = make_shared<bool>(boost::any_cast<bool>(m["more_page"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~EntityDeleteResponseBody() = default;
};
class EntityDeleteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EntityDeleteResponseBody> body{};

  EntityDeleteResponse() {}

  explicit EntityDeleteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EntityDeleteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EntityDeleteResponseBody>(model1);
      }
    }
  }


  virtual ~EntityDeleteResponse() = default;
};
class EntitySetHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  EntitySetHeaders() {}

  explicit EntitySetHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~EntitySetHeaders() = default;
};
class EntitySetRequestEntityDOList : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> entityType{};

  EntitySetRequestEntityDOList() {}

  explicit EntitySetRequestEntityDOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["entity_id"] = boost::any(*entityId);
    }
    if (entityType) {
      res["entity_type"] = boost::any(*entityType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_id") != m.end() && !m["entity_id"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["entity_id"]));
    }
    if (m.find("entity_type") != m.end() && !m["entity_type"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["entity_type"]));
    }
  }


  virtual ~EntitySetRequestEntityDOList() = default;
};
class EntitySetRequest : public Darabonba::Model {
public:
  shared_ptr<vector<EntitySetRequestEntityDOList>> entityDOList{};
  shared_ptr<string> thirdpartId{};

  EntitySetRequest() {}

  explicit EntitySetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityDOList) {
      vector<boost::any> temp1;
      for(auto item1:*entityDOList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entity_d_o_list"] = boost::any(temp1);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_d_o_list") != m.end() && !m["entity_d_o_list"].empty()) {
      if (typeid(vector<boost::any>) == m["entity_d_o_list"].type()) {
        vector<EntitySetRequestEntityDOList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entity_d_o_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EntitySetRequestEntityDOList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entityDOList = make_shared<vector<EntitySetRequestEntityDOList>>(expect1);
      }
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
  }


  virtual ~EntitySetRequest() = default;
};
class EntitySetShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> entityDOListShrink{};
  shared_ptr<string> thirdpartId{};

  EntitySetShrinkRequest() {}

  explicit EntitySetShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityDOListShrink) {
      res["entity_d_o_list"] = boost::any(*entityDOListShrink);
    }
    if (thirdpartId) {
      res["thirdpart_id"] = boost::any(*thirdpartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_d_o_list") != m.end() && !m["entity_d_o_list"].empty()) {
      entityDOListShrink = make_shared<string>(boost::any_cast<string>(m["entity_d_o_list"]));
    }
    if (m.find("thirdpart_id") != m.end() && !m["thirdpart_id"].empty()) {
      thirdpartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_id"]));
    }
  }


  virtual ~EntitySetShrinkRequest() = default;
};
class EntitySetResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> addNum{};
  shared_ptr<long> removeNum{};
  shared_ptr<long> selectedUserNum{};

  EntitySetResponseBodyModule() {}

  explicit EntitySetResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addNum) {
      res["add_num"] = boost::any(*addNum);
    }
    if (removeNum) {
      res["remove_num"] = boost::any(*removeNum);
    }
    if (selectedUserNum) {
      res["selected_user_num"] = boost::any(*selectedUserNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("add_num") != m.end() && !m["add_num"].empty()) {
      addNum = make_shared<long>(boost::any_cast<long>(m["add_num"]));
    }
    if (m.find("remove_num") != m.end() && !m["remove_num"].empty()) {
      removeNum = make_shared<long>(boost::any_cast<long>(m["remove_num"]));
    }
    if (m.find("selected_user_num") != m.end() && !m["selected_user_num"].empty()) {
      selectedUserNum = make_shared<long>(boost::any_cast<long>(m["selected_user_num"]));
    }
  }


  virtual ~EntitySetResponseBodyModule() = default;
};
class EntitySetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<EntitySetResponseBodyModule> module{};
  shared_ptr<bool> morePage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  EntitySetResponseBody() {}

  explicit EntitySetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (morePage) {
      res["more_page"] = boost::any(*morePage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        EntitySetResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<EntitySetResponseBodyModule>(model1);
      }
    }
    if (m.find("more_page") != m.end() && !m["more_page"].empty()) {
      morePage = make_shared<bool>(boost::any_cast<bool>(m["more_page"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~EntitySetResponseBody() = default;
};
class EntitySetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EntitySetResponseBody> body{};

  EntitySetResponse() {}

  explicit EntitySetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EntitySetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EntitySetResponseBody>(model1);
      }
    }
  }


  virtual ~EntitySetResponse() = default;
};
class EstimatedPriceQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  EstimatedPriceQueryHeaders() {}

  explicit EstimatedPriceQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~EstimatedPriceQueryHeaders() = default;
};
class EstimatedPriceQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> category{};
  shared_ptr<string> depCity{};
  shared_ptr<long> endTime{};
  shared_ptr<string> itineraryId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> subCorpId{};
  shared_ptr<string> userId{};

  EstimatedPriceQueryRequest() {}

  explicit EstimatedPriceQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["category"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["end_time"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["start_time"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~EstimatedPriceQueryRequest() = default;
};
class EstimatedPriceQueryResponseBodyModuleHotelFeeDetail : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<long> criterion{};
  shared_ptr<string> itineraryId{};
  shared_ptr<long> total{};
  shared_ptr<long> tripDays{};

  EstimatedPriceQueryResponseBodyModuleHotelFeeDetail() {}

  explicit EstimatedPriceQueryResponseBodyModuleHotelFeeDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["city"] = boost::any(*city);
    }
    if (criterion) {
      res["criterion"] = boost::any(*criterion);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    if (tripDays) {
      res["trip_days"] = boost::any(*tripDays);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city") != m.end() && !m["city"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["city"]));
    }
    if (m.find("criterion") != m.end() && !m["criterion"].empty()) {
      criterion = make_shared<long>(boost::any_cast<long>(m["criterion"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
    if (m.find("trip_days") != m.end() && !m["trip_days"].empty()) {
      tripDays = make_shared<long>(boost::any_cast<long>(m["trip_days"]));
    }
  }


  virtual ~EstimatedPriceQueryResponseBodyModuleHotelFeeDetail() = default;
};
class EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesCheapest : public Darabonba::Model {
public:
  shared_ptr<string> arrTime{};
  shared_ptr<string> depTime{};
  shared_ptr<long> fee{};
  shared_ptr<string> seatGrade{};
  shared_ptr<string> vehicleNo{};

  EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesCheapest() {}

  explicit EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesCheapest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    if (seatGrade) {
      res["seat_grade"] = boost::any(*seatGrade);
    }
    if (vehicleNo) {
      res["vehicle_no"] = boost::any(*vehicleNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
    if (m.find("seat_grade") != m.end() && !m["seat_grade"].empty()) {
      seatGrade = make_shared<string>(boost::any_cast<string>(m["seat_grade"]));
    }
    if (m.find("vehicle_no") != m.end() && !m["vehicle_no"].empty()) {
      vehicleNo = make_shared<string>(boost::any_cast<string>(m["vehicle_no"]));
    }
  }


  virtual ~EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesCheapest() = default;
};
class EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesMostExpensive : public Darabonba::Model {
public:
  shared_ptr<string> arrTime{};
  shared_ptr<string> depTime{};
  shared_ptr<long> fee{};
  shared_ptr<string> seatGrade{};
  shared_ptr<string> vehicleNo{};

  EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesMostExpensive() {}

  explicit EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesMostExpensive(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (fee) {
      res["fee"] = boost::any(*fee);
    }
    if (seatGrade) {
      res["seat_grade"] = boost::any(*seatGrade);
    }
    if (vehicleNo) {
      res["vehicle_no"] = boost::any(*vehicleNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("fee") != m.end() && !m["fee"].empty()) {
      fee = make_shared<long>(boost::any_cast<long>(m["fee"]));
    }
    if (m.find("seat_grade") != m.end() && !m["seat_grade"].empty()) {
      seatGrade = make_shared<string>(boost::any_cast<string>(m["seat_grade"]));
    }
    if (m.find("vehicle_no") != m.end() && !m["vehicle_no"].empty()) {
      vehicleNo = make_shared<string>(boost::any_cast<string>(m["vehicle_no"]));
    }
  }


  virtual ~EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesMostExpensive() = default;
};
class EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<long> arrDate{};
  shared_ptr<EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesCheapest> cheapest{};
  shared_ptr<string> depCity{};
  shared_ptr<long> depDate{};
  shared_ptr<string> errMsg{};
  shared_ptr<string> itineraryId{};
  shared_ptr<EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesMostExpensive> mostExpensive{};
  shared_ptr<bool> success{};

  EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes() {}

  explicit EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (cheapest) {
      res["cheapest"] = cheapest ? boost::any(cheapest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (errMsg) {
      res["err_msg"] = boost::any(*errMsg);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (mostExpensive) {
      res["most_expensive"] = mostExpensive ? boost::any(mostExpensive->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<long>(boost::any_cast<long>(m["arr_date"]));
    }
    if (m.find("cheapest") != m.end() && !m["cheapest"].empty()) {
      if (typeid(map<string, boost::any>) == m["cheapest"].type()) {
        EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesCheapest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cheapest"]));
        cheapest = make_shared<EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesCheapest>(model1);
      }
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<long>(boost::any_cast<long>(m["dep_date"]));
    }
    if (m.find("err_msg") != m.end() && !m["err_msg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["err_msg"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("most_expensive") != m.end() && !m["most_expensive"].empty()) {
      if (typeid(map<string, boost::any>) == m["most_expensive"].type()) {
        EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesMostExpensive model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["most_expensive"]));
        mostExpensive = make_shared<EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutesMostExpensive>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes() = default;
};
class EstimatedPriceQueryResponseBodyModuleTrafficFee : public Darabonba::Model {
public:
  shared_ptr<vector<EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes>> btripRoutes{};
  shared_ptr<string> errMsg{};
  shared_ptr<long> maxFee{};
  shared_ptr<long> minFee{};
  shared_ptr<bool> success{};

  EstimatedPriceQueryResponseBodyModuleTrafficFee() {}

  explicit EstimatedPriceQueryResponseBodyModuleTrafficFee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripRoutes) {
      vector<boost::any> temp1;
      for(auto item1:*btripRoutes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["btrip_routes"] = boost::any(temp1);
    }
    if (errMsg) {
      res["err_msg"] = boost::any(*errMsg);
    }
    if (maxFee) {
      res["max_fee"] = boost::any(*maxFee);
    }
    if (minFee) {
      res["min_fee"] = boost::any(*minFee);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_routes") != m.end() && !m["btrip_routes"].empty()) {
      if (typeid(vector<boost::any>) == m["btrip_routes"].type()) {
        vector<EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["btrip_routes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        btripRoutes = make_shared<vector<EstimatedPriceQueryResponseBodyModuleTrafficFeeBtripRoutes>>(expect1);
      }
    }
    if (m.find("err_msg") != m.end() && !m["err_msg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["err_msg"]));
    }
    if (m.find("max_fee") != m.end() && !m["max_fee"].empty()) {
      maxFee = make_shared<long>(boost::any_cast<long>(m["max_fee"]));
    }
    if (m.find("min_fee") != m.end() && !m["min_fee"].empty()) {
      minFee = make_shared<long>(boost::any_cast<long>(m["min_fee"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~EstimatedPriceQueryResponseBodyModuleTrafficFee() = default;
};
class EstimatedPriceQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<EstimatedPriceQueryResponseBodyModuleHotelFeeDetail>> hotelFeeDetail{};
  shared_ptr<long> totalHotelFee{};
  shared_ptr<EstimatedPriceQueryResponseBodyModuleTrafficFee> trafficFee{};

  EstimatedPriceQueryResponseBodyModule() {}

  explicit EstimatedPriceQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelFeeDetail) {
      vector<boost::any> temp1;
      for(auto item1:*hotelFeeDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_fee_detail"] = boost::any(temp1);
    }
    if (totalHotelFee) {
      res["total_hotel_fee"] = boost::any(*totalHotelFee);
    }
    if (trafficFee) {
      res["traffic_fee"] = trafficFee ? boost::any(trafficFee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_fee_detail") != m.end() && !m["hotel_fee_detail"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_fee_detail"].type()) {
        vector<EstimatedPriceQueryResponseBodyModuleHotelFeeDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_fee_detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EstimatedPriceQueryResponseBodyModuleHotelFeeDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelFeeDetail = make_shared<vector<EstimatedPriceQueryResponseBodyModuleHotelFeeDetail>>(expect1);
      }
    }
    if (m.find("total_hotel_fee") != m.end() && !m["total_hotel_fee"].empty()) {
      totalHotelFee = make_shared<long>(boost::any_cast<long>(m["total_hotel_fee"]));
    }
    if (m.find("traffic_fee") != m.end() && !m["traffic_fee"].empty()) {
      if (typeid(map<string, boost::any>) == m["traffic_fee"].type()) {
        EstimatedPriceQueryResponseBodyModuleTrafficFee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["traffic_fee"]));
        trafficFee = make_shared<EstimatedPriceQueryResponseBodyModuleTrafficFee>(model1);
      }
    }
  }


  virtual ~EstimatedPriceQueryResponseBodyModule() = default;
};
class EstimatedPriceQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<EstimatedPriceQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  EstimatedPriceQueryResponseBody() {}

  explicit EstimatedPriceQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        EstimatedPriceQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<EstimatedPriceQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~EstimatedPriceQueryResponseBody() = default;
};
class EstimatedPriceQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EstimatedPriceQueryResponseBody> body{};

  EstimatedPriceQueryResponse() {}

  explicit EstimatedPriceQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EstimatedPriceQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EstimatedPriceQueryResponseBody>(model1);
      }
    }
  }


  virtual ~EstimatedPriceQueryResponse() = default;
};
class ExceedApplySyncHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ExceedApplySyncHeaders() {}

  explicit ExceedApplySyncHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ExceedApplySyncHeaders() = default;
};
class ExceedApplySyncRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<long> bizCategory{};
  shared_ptr<string> remark{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdpartyFlowId{};
  shared_ptr<string> userId{};

  ExceedApplySyncRequest() {}

  explicit ExceedApplySyncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (bizCategory) {
      res["biz_category"] = boost::any(*bizCategory);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdpartyFlowId) {
      res["thirdparty_flow_id"] = boost::any(*thirdpartyFlowId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("biz_category") != m.end() && !m["biz_category"].empty()) {
      bizCategory = make_shared<long>(boost::any_cast<long>(m["biz_category"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("thirdparty_flow_id") != m.end() && !m["thirdparty_flow_id"].empty()) {
      thirdpartyFlowId = make_shared<string>(boost::any_cast<string>(m["thirdparty_flow_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~ExceedApplySyncRequest() = default;
};
class ExceedApplySyncResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ExceedApplySyncResponseBody() {}

  explicit ExceedApplySyncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<bool>(boost::any_cast<bool>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ExceedApplySyncResponseBody() = default;
};
class ExceedApplySyncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExceedApplySyncResponseBody> body{};

  ExceedApplySyncResponse() {}

  explicit ExceedApplySyncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExceedApplySyncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExceedApplySyncResponseBody>(model1);
      }
    }
  }


  virtual ~ExceedApplySyncResponse() = default;
};
class FlightBillSettlementQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  FlightBillSettlementQueryHeaders() {}

  explicit FlightBillSettlementQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~FlightBillSettlementQueryHeaders() = default;
};
class FlightBillSettlementQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};

  FlightBillSettlementQueryRequest() {}

  explicit FlightBillSettlementQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
  }


  virtual ~FlightBillSettlementQueryRequest() = default;
};
class FlightBillSettlementQueryResponseBodyModuleDataList : public Darabonba::Model {
public:
  shared_ptr<long> advanceDay{};
  shared_ptr<string> airlineCorpCode{};
  shared_ptr<string> airlineCorpName{};
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<string> applyArrCityCode{};
  shared_ptr<string> applyArrCityName{};
  shared_ptr<string> applyDepCityCode{};
  shared_ptr<string> applyDepCityName{};
  shared_ptr<string> applyExtendField{};
  shared_ptr<string> applyId{};
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> arrStation{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> billRecordTime{};
  shared_ptr<string> bookTime{};
  shared_ptr<string> bookerId{};
  shared_ptr<string> bookerJobNo{};
  shared_ptr<string> bookerName{};
  shared_ptr<double> btripCouponFee{};
  shared_ptr<double> buildFee{};
  shared_ptr<string> businessTripResult{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> capitalDirection{};
  shared_ptr<string> cascadeDepartment{};
  shared_ptr<double> changeFee{};
  shared_ptr<string> changeResult{};
  shared_ptr<double> corpPayOrderFee{};
  shared_ptr<double> corpSettlePrice{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<double> coupon{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> department{};
  shared_ptr<string> departmentId{};
  shared_ptr<string> deptCity{};
  shared_ptr<string> deptDate{};
  shared_ptr<string> deptStation{};
  shared_ptr<string> deptTime{};
  shared_ptr<string> discount{};
  shared_ptr<string> exceedReason{};
  shared_ptr<string> feeType{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> index{};
  shared_ptr<string> insOrderId{};
  shared_ptr<double> insuranceFee{};
  shared_ptr<string> insuranceNumber{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> itemType{};
  shared_ptr<string> itineraryNum{};
  shared_ptr<double> itineraryPrice{};
  shared_ptr<string> mileage{};
  shared_ptr<string> mostDifferenceDeptTime{};
  shared_ptr<string> mostDifferenceDiscount{};
  shared_ptr<string> mostDifferenceFlightNo{};
  shared_ptr<double> mostDifferencePrice{};
  shared_ptr<string> mostDifferenceReason{};
  shared_ptr<double> mostPrice{};
  shared_ptr<double> negotiationCouponFee{};
  shared_ptr<double> oilFee{};
  shared_ptr<string> orderId{};
  shared_ptr<string> overApplyId{};
  shared_ptr<double> personSettlePrice{};
  shared_ptr<string> preBookTip{};
  shared_ptr<long> primaryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectName{};
  shared_ptr<double> refundFee{};
  shared_ptr<string> refundResult{};
  shared_ptr<double> refundUpgradeCost{};
  shared_ptr<string> remark{};
  shared_ptr<string> repeatRefund{};
  shared_ptr<double> sealPrice{};
  shared_ptr<double> serviceFee{};
  shared_ptr<double> settlementFee{};
  shared_ptr<double> settlementGrantFee{};
  shared_ptr<string> settlementTime{};
  shared_ptr<string> settlementType{};
  shared_ptr<long> status{};
  shared_ptr<string> taxRate{};
  shared_ptr<string> thirdItineraryId{};
  shared_ptr<string> ticketId{};
  shared_ptr<string> trade{};
  shared_ptr<string> travelerId{};
  shared_ptr<string> travelerJobNo{};
  shared_ptr<string> travelerMemberTypeName{};
  shared_ptr<string> travelerName{};
  shared_ptr<double> upgradeCost{};
  shared_ptr<long> voucherType{};
  shared_ptr<string> voyageName{};

  FlightBillSettlementQueryResponseBodyModuleDataList() {}

  explicit FlightBillSettlementQueryResponseBodyModuleDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advanceDay) {
      res["advance_day"] = boost::any(*advanceDay);
    }
    if (airlineCorpCode) {
      res["airline_corp_code"] = boost::any(*airlineCorpCode);
    }
    if (airlineCorpName) {
      res["airline_corp_name"] = boost::any(*airlineCorpName);
    }
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (applyArrCityCode) {
      res["apply_arr_city_code"] = boost::any(*applyArrCityCode);
    }
    if (applyArrCityName) {
      res["apply_arr_city_name"] = boost::any(*applyArrCityName);
    }
    if (applyDepCityCode) {
      res["apply_dep_city_code"] = boost::any(*applyDepCityCode);
    }
    if (applyDepCityName) {
      res["apply_dep_city_name"] = boost::any(*applyDepCityName);
    }
    if (applyExtendField) {
      res["apply_extend_field"] = boost::any(*applyExtendField);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (arrStation) {
      res["arr_station"] = boost::any(*arrStation);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (billRecordTime) {
      res["bill_record_time"] = boost::any(*billRecordTime);
    }
    if (bookTime) {
      res["book_time"] = boost::any(*bookTime);
    }
    if (bookerId) {
      res["booker_id"] = boost::any(*bookerId);
    }
    if (bookerJobNo) {
      res["booker_job_no"] = boost::any(*bookerJobNo);
    }
    if (bookerName) {
      res["booker_name"] = boost::any(*bookerName);
    }
    if (btripCouponFee) {
      res["btrip_coupon_fee"] = boost::any(*btripCouponFee);
    }
    if (buildFee) {
      res["build_fee"] = boost::any(*buildFee);
    }
    if (businessTripResult) {
      res["business_trip_result"] = boost::any(*businessTripResult);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (capitalDirection) {
      res["capital_direction"] = boost::any(*capitalDirection);
    }
    if (cascadeDepartment) {
      res["cascade_department"] = boost::any(*cascadeDepartment);
    }
    if (changeFee) {
      res["change_fee"] = boost::any(*changeFee);
    }
    if (changeResult) {
      res["change_result"] = boost::any(*changeResult);
    }
    if (corpPayOrderFee) {
      res["corp_pay_order_fee"] = boost::any(*corpPayOrderFee);
    }
    if (corpSettlePrice) {
      res["corp_settle_price"] = boost::any(*corpSettlePrice);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (coupon) {
      res["coupon"] = boost::any(*coupon);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (departmentId) {
      res["department_id"] = boost::any(*departmentId);
    }
    if (deptCity) {
      res["dept_city"] = boost::any(*deptCity);
    }
    if (deptDate) {
      res["dept_date"] = boost::any(*deptDate);
    }
    if (deptStation) {
      res["dept_station"] = boost::any(*deptStation);
    }
    if (deptTime) {
      res["dept_time"] = boost::any(*deptTime);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (exceedReason) {
      res["exceed_reason"] = boost::any(*exceedReason);
    }
    if (feeType) {
      res["fee_type"] = boost::any(*feeType);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (insOrderId) {
      res["ins_order_id"] = boost::any(*insOrderId);
    }
    if (insuranceFee) {
      res["insurance_fee"] = boost::any(*insuranceFee);
    }
    if (insuranceNumber) {
      res["insurance_number"] = boost::any(*insuranceNumber);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (itemType) {
      res["item_type"] = boost::any(*itemType);
    }
    if (itineraryNum) {
      res["itinerary_num"] = boost::any(*itineraryNum);
    }
    if (itineraryPrice) {
      res["itinerary_price"] = boost::any(*itineraryPrice);
    }
    if (mileage) {
      res["mileage"] = boost::any(*mileage);
    }
    if (mostDifferenceDeptTime) {
      res["most_difference_dept_time"] = boost::any(*mostDifferenceDeptTime);
    }
    if (mostDifferenceDiscount) {
      res["most_difference_discount"] = boost::any(*mostDifferenceDiscount);
    }
    if (mostDifferenceFlightNo) {
      res["most_difference_flight_no"] = boost::any(*mostDifferenceFlightNo);
    }
    if (mostDifferencePrice) {
      res["most_difference_price"] = boost::any(*mostDifferencePrice);
    }
    if (mostDifferenceReason) {
      res["most_difference_reason"] = boost::any(*mostDifferenceReason);
    }
    if (mostPrice) {
      res["most_price"] = boost::any(*mostPrice);
    }
    if (negotiationCouponFee) {
      res["negotiation_coupon_fee"] = boost::any(*negotiationCouponFee);
    }
    if (oilFee) {
      res["oil_fee"] = boost::any(*oilFee);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (overApplyId) {
      res["over_apply_id"] = boost::any(*overApplyId);
    }
    if (personSettlePrice) {
      res["person_settle_price"] = boost::any(*personSettlePrice);
    }
    if (preBookTip) {
      res["pre_book_tip"] = boost::any(*preBookTip);
    }
    if (primaryId) {
      res["primary_id"] = boost::any(*primaryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (refundResult) {
      res["refund_result"] = boost::any(*refundResult);
    }
    if (refundUpgradeCost) {
      res["refund_upgrade_cost"] = boost::any(*refundUpgradeCost);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (repeatRefund) {
      res["repeat_refund"] = boost::any(*repeatRefund);
    }
    if (sealPrice) {
      res["seal_price"] = boost::any(*sealPrice);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (settlementFee) {
      res["settlement_fee"] = boost::any(*settlementFee);
    }
    if (settlementGrantFee) {
      res["settlement_grant_fee"] = boost::any(*settlementGrantFee);
    }
    if (settlementTime) {
      res["settlement_time"] = boost::any(*settlementTime);
    }
    if (settlementType) {
      res["settlement_type"] = boost::any(*settlementType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (taxRate) {
      res["tax_rate"] = boost::any(*taxRate);
    }
    if (thirdItineraryId) {
      res["third_itinerary_id"] = boost::any(*thirdItineraryId);
    }
    if (ticketId) {
      res["ticket_id"] = boost::any(*ticketId);
    }
    if (trade) {
      res["trade"] = boost::any(*trade);
    }
    if (travelerId) {
      res["traveler_id"] = boost::any(*travelerId);
    }
    if (travelerJobNo) {
      res["traveler_job_no"] = boost::any(*travelerJobNo);
    }
    if (travelerMemberTypeName) {
      res["traveler_member_type_name"] = boost::any(*travelerMemberTypeName);
    }
    if (travelerName) {
      res["traveler_name"] = boost::any(*travelerName);
    }
    if (upgradeCost) {
      res["upgrade_cost"] = boost::any(*upgradeCost);
    }
    if (voucherType) {
      res["voucher_type"] = boost::any(*voucherType);
    }
    if (voyageName) {
      res["voyage_name"] = boost::any(*voyageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("advance_day") != m.end() && !m["advance_day"].empty()) {
      advanceDay = make_shared<long>(boost::any_cast<long>(m["advance_day"]));
    }
    if (m.find("airline_corp_code") != m.end() && !m["airline_corp_code"].empty()) {
      airlineCorpCode = make_shared<string>(boost::any_cast<string>(m["airline_corp_code"]));
    }
    if (m.find("airline_corp_name") != m.end() && !m["airline_corp_name"].empty()) {
      airlineCorpName = make_shared<string>(boost::any_cast<string>(m["airline_corp_name"]));
    }
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("apply_arr_city_code") != m.end() && !m["apply_arr_city_code"].empty()) {
      applyArrCityCode = make_shared<string>(boost::any_cast<string>(m["apply_arr_city_code"]));
    }
    if (m.find("apply_arr_city_name") != m.end() && !m["apply_arr_city_name"].empty()) {
      applyArrCityName = make_shared<string>(boost::any_cast<string>(m["apply_arr_city_name"]));
    }
    if (m.find("apply_dep_city_code") != m.end() && !m["apply_dep_city_code"].empty()) {
      applyDepCityCode = make_shared<string>(boost::any_cast<string>(m["apply_dep_city_code"]));
    }
    if (m.find("apply_dep_city_name") != m.end() && !m["apply_dep_city_name"].empty()) {
      applyDepCityName = make_shared<string>(boost::any_cast<string>(m["apply_dep_city_name"]));
    }
    if (m.find("apply_extend_field") != m.end() && !m["apply_extend_field"].empty()) {
      applyExtendField = make_shared<string>(boost::any_cast<string>(m["apply_extend_field"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("arr_station") != m.end() && !m["arr_station"].empty()) {
      arrStation = make_shared<string>(boost::any_cast<string>(m["arr_station"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("bill_record_time") != m.end() && !m["bill_record_time"].empty()) {
      billRecordTime = make_shared<string>(boost::any_cast<string>(m["bill_record_time"]));
    }
    if (m.find("book_time") != m.end() && !m["book_time"].empty()) {
      bookTime = make_shared<string>(boost::any_cast<string>(m["book_time"]));
    }
    if (m.find("booker_id") != m.end() && !m["booker_id"].empty()) {
      bookerId = make_shared<string>(boost::any_cast<string>(m["booker_id"]));
    }
    if (m.find("booker_job_no") != m.end() && !m["booker_job_no"].empty()) {
      bookerJobNo = make_shared<string>(boost::any_cast<string>(m["booker_job_no"]));
    }
    if (m.find("booker_name") != m.end() && !m["booker_name"].empty()) {
      bookerName = make_shared<string>(boost::any_cast<string>(m["booker_name"]));
    }
    if (m.find("btrip_coupon_fee") != m.end() && !m["btrip_coupon_fee"].empty()) {
      btripCouponFee = make_shared<double>(boost::any_cast<double>(m["btrip_coupon_fee"]));
    }
    if (m.find("build_fee") != m.end() && !m["build_fee"].empty()) {
      buildFee = make_shared<double>(boost::any_cast<double>(m["build_fee"]));
    }
    if (m.find("business_trip_result") != m.end() && !m["business_trip_result"].empty()) {
      businessTripResult = make_shared<string>(boost::any_cast<string>(m["business_trip_result"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("capital_direction") != m.end() && !m["capital_direction"].empty()) {
      capitalDirection = make_shared<string>(boost::any_cast<string>(m["capital_direction"]));
    }
    if (m.find("cascade_department") != m.end() && !m["cascade_department"].empty()) {
      cascadeDepartment = make_shared<string>(boost::any_cast<string>(m["cascade_department"]));
    }
    if (m.find("change_fee") != m.end() && !m["change_fee"].empty()) {
      changeFee = make_shared<double>(boost::any_cast<double>(m["change_fee"]));
    }
    if (m.find("change_result") != m.end() && !m["change_result"].empty()) {
      changeResult = make_shared<string>(boost::any_cast<string>(m["change_result"]));
    }
    if (m.find("corp_pay_order_fee") != m.end() && !m["corp_pay_order_fee"].empty()) {
      corpPayOrderFee = make_shared<double>(boost::any_cast<double>(m["corp_pay_order_fee"]));
    }
    if (m.find("corp_settle_price") != m.end() && !m["corp_settle_price"].empty()) {
      corpSettlePrice = make_shared<double>(boost::any_cast<double>(m["corp_settle_price"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("coupon") != m.end() && !m["coupon"].empty()) {
      coupon = make_shared<double>(boost::any_cast<double>(m["coupon"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("department_id") != m.end() && !m["department_id"].empty()) {
      departmentId = make_shared<string>(boost::any_cast<string>(m["department_id"]));
    }
    if (m.find("dept_city") != m.end() && !m["dept_city"].empty()) {
      deptCity = make_shared<string>(boost::any_cast<string>(m["dept_city"]));
    }
    if (m.find("dept_date") != m.end() && !m["dept_date"].empty()) {
      deptDate = make_shared<string>(boost::any_cast<string>(m["dept_date"]));
    }
    if (m.find("dept_station") != m.end() && !m["dept_station"].empty()) {
      deptStation = make_shared<string>(boost::any_cast<string>(m["dept_station"]));
    }
    if (m.find("dept_time") != m.end() && !m["dept_time"].empty()) {
      deptTime = make_shared<string>(boost::any_cast<string>(m["dept_time"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("exceed_reason") != m.end() && !m["exceed_reason"].empty()) {
      exceedReason = make_shared<string>(boost::any_cast<string>(m["exceed_reason"]));
    }
    if (m.find("fee_type") != m.end() && !m["fee_type"].empty()) {
      feeType = make_shared<string>(boost::any_cast<string>(m["fee_type"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("ins_order_id") != m.end() && !m["ins_order_id"].empty()) {
      insOrderId = make_shared<string>(boost::any_cast<string>(m["ins_order_id"]));
    }
    if (m.find("insurance_fee") != m.end() && !m["insurance_fee"].empty()) {
      insuranceFee = make_shared<double>(boost::any_cast<double>(m["insurance_fee"]));
    }
    if (m.find("insurance_number") != m.end() && !m["insurance_number"].empty()) {
      insuranceNumber = make_shared<string>(boost::any_cast<string>(m["insurance_number"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("item_type") != m.end() && !m["item_type"].empty()) {
      itemType = make_shared<string>(boost::any_cast<string>(m["item_type"]));
    }
    if (m.find("itinerary_num") != m.end() && !m["itinerary_num"].empty()) {
      itineraryNum = make_shared<string>(boost::any_cast<string>(m["itinerary_num"]));
    }
    if (m.find("itinerary_price") != m.end() && !m["itinerary_price"].empty()) {
      itineraryPrice = make_shared<double>(boost::any_cast<double>(m["itinerary_price"]));
    }
    if (m.find("mileage") != m.end() && !m["mileage"].empty()) {
      mileage = make_shared<string>(boost::any_cast<string>(m["mileage"]));
    }
    if (m.find("most_difference_dept_time") != m.end() && !m["most_difference_dept_time"].empty()) {
      mostDifferenceDeptTime = make_shared<string>(boost::any_cast<string>(m["most_difference_dept_time"]));
    }
    if (m.find("most_difference_discount") != m.end() && !m["most_difference_discount"].empty()) {
      mostDifferenceDiscount = make_shared<string>(boost::any_cast<string>(m["most_difference_discount"]));
    }
    if (m.find("most_difference_flight_no") != m.end() && !m["most_difference_flight_no"].empty()) {
      mostDifferenceFlightNo = make_shared<string>(boost::any_cast<string>(m["most_difference_flight_no"]));
    }
    if (m.find("most_difference_price") != m.end() && !m["most_difference_price"].empty()) {
      mostDifferencePrice = make_shared<double>(boost::any_cast<double>(m["most_difference_price"]));
    }
    if (m.find("most_difference_reason") != m.end() && !m["most_difference_reason"].empty()) {
      mostDifferenceReason = make_shared<string>(boost::any_cast<string>(m["most_difference_reason"]));
    }
    if (m.find("most_price") != m.end() && !m["most_price"].empty()) {
      mostPrice = make_shared<double>(boost::any_cast<double>(m["most_price"]));
    }
    if (m.find("negotiation_coupon_fee") != m.end() && !m["negotiation_coupon_fee"].empty()) {
      negotiationCouponFee = make_shared<double>(boost::any_cast<double>(m["negotiation_coupon_fee"]));
    }
    if (m.find("oil_fee") != m.end() && !m["oil_fee"].empty()) {
      oilFee = make_shared<double>(boost::any_cast<double>(m["oil_fee"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("over_apply_id") != m.end() && !m["over_apply_id"].empty()) {
      overApplyId = make_shared<string>(boost::any_cast<string>(m["over_apply_id"]));
    }
    if (m.find("person_settle_price") != m.end() && !m["person_settle_price"].empty()) {
      personSettlePrice = make_shared<double>(boost::any_cast<double>(m["person_settle_price"]));
    }
    if (m.find("pre_book_tip") != m.end() && !m["pre_book_tip"].empty()) {
      preBookTip = make_shared<string>(boost::any_cast<string>(m["pre_book_tip"]));
    }
    if (m.find("primary_id") != m.end() && !m["primary_id"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["primary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<double>(boost::any_cast<double>(m["refund_fee"]));
    }
    if (m.find("refund_result") != m.end() && !m["refund_result"].empty()) {
      refundResult = make_shared<string>(boost::any_cast<string>(m["refund_result"]));
    }
    if (m.find("refund_upgrade_cost") != m.end() && !m["refund_upgrade_cost"].empty()) {
      refundUpgradeCost = make_shared<double>(boost::any_cast<double>(m["refund_upgrade_cost"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("repeat_refund") != m.end() && !m["repeat_refund"].empty()) {
      repeatRefund = make_shared<string>(boost::any_cast<string>(m["repeat_refund"]));
    }
    if (m.find("seal_price") != m.end() && !m["seal_price"].empty()) {
      sealPrice = make_shared<double>(boost::any_cast<double>(m["seal_price"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<double>(boost::any_cast<double>(m["service_fee"]));
    }
    if (m.find("settlement_fee") != m.end() && !m["settlement_fee"].empty()) {
      settlementFee = make_shared<double>(boost::any_cast<double>(m["settlement_fee"]));
    }
    if (m.find("settlement_grant_fee") != m.end() && !m["settlement_grant_fee"].empty()) {
      settlementGrantFee = make_shared<double>(boost::any_cast<double>(m["settlement_grant_fee"]));
    }
    if (m.find("settlement_time") != m.end() && !m["settlement_time"].empty()) {
      settlementTime = make_shared<string>(boost::any_cast<string>(m["settlement_time"]));
    }
    if (m.find("settlement_type") != m.end() && !m["settlement_type"].empty()) {
      settlementType = make_shared<string>(boost::any_cast<string>(m["settlement_type"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("tax_rate") != m.end() && !m["tax_rate"].empty()) {
      taxRate = make_shared<string>(boost::any_cast<string>(m["tax_rate"]));
    }
    if (m.find("third_itinerary_id") != m.end() && !m["third_itinerary_id"].empty()) {
      thirdItineraryId = make_shared<string>(boost::any_cast<string>(m["third_itinerary_id"]));
    }
    if (m.find("ticket_id") != m.end() && !m["ticket_id"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["ticket_id"]));
    }
    if (m.find("trade") != m.end() && !m["trade"].empty()) {
      trade = make_shared<string>(boost::any_cast<string>(m["trade"]));
    }
    if (m.find("traveler_id") != m.end() && !m["traveler_id"].empty()) {
      travelerId = make_shared<string>(boost::any_cast<string>(m["traveler_id"]));
    }
    if (m.find("traveler_job_no") != m.end() && !m["traveler_job_no"].empty()) {
      travelerJobNo = make_shared<string>(boost::any_cast<string>(m["traveler_job_no"]));
    }
    if (m.find("traveler_member_type_name") != m.end() && !m["traveler_member_type_name"].empty()) {
      travelerMemberTypeName = make_shared<string>(boost::any_cast<string>(m["traveler_member_type_name"]));
    }
    if (m.find("traveler_name") != m.end() && !m["traveler_name"].empty()) {
      travelerName = make_shared<string>(boost::any_cast<string>(m["traveler_name"]));
    }
    if (m.find("upgrade_cost") != m.end() && !m["upgrade_cost"].empty()) {
      upgradeCost = make_shared<double>(boost::any_cast<double>(m["upgrade_cost"]));
    }
    if (m.find("voucher_type") != m.end() && !m["voucher_type"].empty()) {
      voucherType = make_shared<long>(boost::any_cast<long>(m["voucher_type"]));
    }
    if (m.find("voyage_name") != m.end() && !m["voyage_name"].empty()) {
      voyageName = make_shared<string>(boost::any_cast<string>(m["voyage_name"]));
    }
  }


  virtual ~FlightBillSettlementQueryResponseBodyModuleDataList() = default;
};
class FlightBillSettlementQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> category{};
  shared_ptr<string> corpId{};
  shared_ptr<vector<FlightBillSettlementQueryResponseBodyModuleDataList>> dataList{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};
  shared_ptr<long> totalNum{};

  FlightBillSettlementQueryResponseBodyModule() {}

  explicit FlightBillSettlementQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_list"] = boost::any(temp1);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    if (totalNum) {
      res["total_num"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["category"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("data_list") != m.end() && !m["data_list"].empty()) {
      if (typeid(vector<boost::any>) == m["data_list"].type()) {
        vector<FlightBillSettlementQueryResponseBodyModuleDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightBillSettlementQueryResponseBodyModuleDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<FlightBillSettlementQueryResponseBodyModuleDataList>>(expect1);
      }
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
    if (m.find("total_num") != m.end() && !m["total_num"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["total_num"]));
    }
  }


  virtual ~FlightBillSettlementQueryResponseBodyModule() = default;
};
class FlightBillSettlementQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightBillSettlementQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightBillSettlementQueryResponseBody() {}

  explicit FlightBillSettlementQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightBillSettlementQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightBillSettlementQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightBillSettlementQueryResponseBody() = default;
};
class FlightBillSettlementQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightBillSettlementQueryResponseBody> body{};

  FlightBillSettlementQueryResponse() {}

  explicit FlightBillSettlementQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightBillSettlementQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightBillSettlementQueryResponseBody>(model1);
      }
    }
  }


  virtual ~FlightBillSettlementQueryResponse() = default;
};
class FlightCancelOrderHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightCancelOrderHeaders() {}

  explicit FlightCancelOrderHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightCancelOrderHeaders() = default;
};
class FlightCancelOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};

  FlightCancelOrderRequest() {}

  explicit FlightCancelOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
  }


  virtual ~FlightCancelOrderRequest() = default;
};
class FlightCancelOrderResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> cancelTime{};
  shared_ptr<string> failCode{};
  shared_ptr<string> failReason{};
  shared_ptr<string> orderStatus{};

  FlightCancelOrderResponseBodyModule() {}

  explicit FlightCancelOrderResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelTime) {
      res["cancel_time"] = boost::any(*cancelTime);
    }
    if (failCode) {
      res["fail_code"] = boost::any(*failCode);
    }
    if (failReason) {
      res["fail_reason"] = boost::any(*failReason);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cancel_time") != m.end() && !m["cancel_time"].empty()) {
      cancelTime = make_shared<string>(boost::any_cast<string>(m["cancel_time"]));
    }
    if (m.find("fail_code") != m.end() && !m["fail_code"].empty()) {
      failCode = make_shared<string>(boost::any_cast<string>(m["fail_code"]));
    }
    if (m.find("fail_reason") != m.end() && !m["fail_reason"].empty()) {
      failReason = make_shared<string>(boost::any_cast<string>(m["fail_reason"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<string>(boost::any_cast<string>(m["order_status"]));
    }
  }


  virtual ~FlightCancelOrderResponseBodyModule() = default;
};
class FlightCancelOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightCancelOrderResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightCancelOrderResponseBody() {}

  explicit FlightCancelOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightCancelOrderResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightCancelOrderResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightCancelOrderResponseBody() = default;
};
class FlightCancelOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightCancelOrderResponseBody> body{};

  FlightCancelOrderResponse() {}

  explicit FlightCancelOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightCancelOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightCancelOrderResponseBody>(model1);
      }
    }
  }


  virtual ~FlightCancelOrderResponse() = default;
};
class FlightCancelOrderV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightCancelOrderV2Headers() {}

  explicit FlightCancelOrderV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightCancelOrderV2Headers() = default;
};
class FlightCancelOrderV2Request : public Darabonba::Model {
public:
  shared_ptr<string> isvName{};
  shared_ptr<string> orderId{};
  shared_ptr<string> outOrderId{};

  FlightCancelOrderV2Request() {}

  explicit FlightCancelOrderV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
  }


  virtual ~FlightCancelOrderV2Request() = default;
};
class FlightCancelOrderV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> cancelTime{};

  FlightCancelOrderV2ResponseBodyModule() {}

  explicit FlightCancelOrderV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelTime) {
      res["cancel_time"] = boost::any(*cancelTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cancel_time") != m.end() && !m["cancel_time"].empty()) {
      cancelTime = make_shared<string>(boost::any_cast<string>(m["cancel_time"]));
    }
  }


  virtual ~FlightCancelOrderV2ResponseBodyModule() = default;
};
class FlightCancelOrderV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightCancelOrderV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightCancelOrderV2ResponseBody() {}

  explicit FlightCancelOrderV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightCancelOrderV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightCancelOrderV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightCancelOrderV2ResponseBody() = default;
};
class FlightCancelOrderV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightCancelOrderV2ResponseBody> body{};

  FlightCancelOrderV2Response() {}

  explicit FlightCancelOrderV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightCancelOrderV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightCancelOrderV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightCancelOrderV2Response() = default;
};
class FlightCreateOrderHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightCreateOrderHeaders() {}

  explicit FlightCreateOrderHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightCreateOrderHeaders() = default;
};
class FlightCreateOrderRequestContactInfo : public Darabonba::Model {
public:
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactPhone{};

  FlightCreateOrderRequestContactInfo() {}

  explicit FlightCreateOrderRequestContactInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactEmail) {
      res["contact_email"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (contactPhone) {
      res["contact_phone"] = boost::any(*contactPhone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contact_email") != m.end() && !m["contact_email"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["contact_email"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("contact_phone") != m.end() && !m["contact_phone"].empty()) {
      contactPhone = make_shared<string>(boost::any_cast<string>(m["contact_phone"]));
    }
  }


  virtual ~FlightCreateOrderRequestContactInfo() = default;
};
class FlightCreateOrderRequestTravelerInfoList : public Darabonba::Model {
public:
  shared_ptr<string> birthday{};
  shared_ptr<string> certNation{};
  shared_ptr<string> certNo{};
  shared_ptr<string> certType{};
  shared_ptr<string> certValidDate{};
  shared_ptr<string> name{};
  shared_ptr<string> nationality{};
  shared_ptr<string> nationalityCode{};
  shared_ptr<string> outUserId{};
  shared_ptr<string> phone{};
  shared_ptr<long> sex{};
  shared_ptr<string> type{};

  FlightCreateOrderRequestTravelerInfoList() {}

  explicit FlightCreateOrderRequestTravelerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthday) {
      res["birthday"] = boost::any(*birthday);
    }
    if (certNation) {
      res["cert_nation"] = boost::any(*certNation);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (certValidDate) {
      res["cert_valid_date"] = boost::any(*certValidDate);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nationality) {
      res["nationality"] = boost::any(*nationality);
    }
    if (nationalityCode) {
      res["nationality_code"] = boost::any(*nationalityCode);
    }
    if (outUserId) {
      res["out_user_id"] = boost::any(*outUserId);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (sex) {
      res["sex"] = boost::any(*sex);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birthday") != m.end() && !m["birthday"].empty()) {
      birthday = make_shared<string>(boost::any_cast<string>(m["birthday"]));
    }
    if (m.find("cert_nation") != m.end() && !m["cert_nation"].empty()) {
      certNation = make_shared<string>(boost::any_cast<string>(m["cert_nation"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["cert_type"]));
    }
    if (m.find("cert_valid_date") != m.end() && !m["cert_valid_date"].empty()) {
      certValidDate = make_shared<string>(boost::any_cast<string>(m["cert_valid_date"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nationality") != m.end() && !m["nationality"].empty()) {
      nationality = make_shared<string>(boost::any_cast<string>(m["nationality"]));
    }
    if (m.find("nationality_code") != m.end() && !m["nationality_code"].empty()) {
      nationalityCode = make_shared<string>(boost::any_cast<string>(m["nationality_code"]));
    }
    if (m.find("out_user_id") != m.end() && !m["out_user_id"].empty()) {
      outUserId = make_shared<string>(boost::any_cast<string>(m["out_user_id"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("sex") != m.end() && !m["sex"].empty()) {
      sex = make_shared<long>(boost::any_cast<long>(m["sex"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~FlightCreateOrderRequestTravelerInfoList() = default;
};
class FlightCreateOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<long> autoPay{};
  shared_ptr<string> buyerName{};
  shared_ptr<string> buyerUniqueKey{};
  shared_ptr<FlightCreateOrderRequestContactInfo> contactInfo{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<string> disOrderId{};
  shared_ptr<map<string, boost::any>> orderAttr{};
  shared_ptr<string> orderParams{};
  shared_ptr<string> otaItemId{};
  shared_ptr<long> price{};
  shared_ptr<string> receiptAddress{};
  shared_ptr<long> receiptTarget{};
  shared_ptr<string> receiptTitle{};
  shared_ptr<vector<FlightCreateOrderRequestTravelerInfoList>> travelerInfoList{};
  shared_ptr<long> tripType{};

  FlightCreateOrderRequest() {}

  explicit FlightCreateOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (autoPay) {
      res["auto_pay"] = boost::any(*autoPay);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (buyerUniqueKey) {
      res["buyer_unique_key"] = boost::any(*buyerUniqueKey);
    }
    if (contactInfo) {
      res["contact_info"] = contactInfo ? boost::any(contactInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (orderAttr) {
      res["order_attr"] = boost::any(*orderAttr);
    }
    if (orderParams) {
      res["order_params"] = boost::any(*orderParams);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (receiptAddress) {
      res["receipt_address"] = boost::any(*receiptAddress);
    }
    if (receiptTarget) {
      res["receipt_target"] = boost::any(*receiptTarget);
    }
    if (receiptTitle) {
      res["receipt_title"] = boost::any(*receiptTitle);
    }
    if (travelerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_info_list"] = boost::any(temp1);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("auto_pay") != m.end() && !m["auto_pay"].empty()) {
      autoPay = make_shared<long>(boost::any_cast<long>(m["auto_pay"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("buyer_unique_key") != m.end() && !m["buyer_unique_key"].empty()) {
      buyerUniqueKey = make_shared<string>(boost::any_cast<string>(m["buyer_unique_key"]));
    }
    if (m.find("contact_info") != m.end() && !m["contact_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["contact_info"].type()) {
        FlightCreateOrderRequestContactInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["contact_info"]));
        contactInfo = make_shared<FlightCreateOrderRequestContactInfo>(model1);
      }
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("order_attr") != m.end() && !m["order_attr"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["order_attr"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      orderAttr = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("order_params") != m.end() && !m["order_params"].empty()) {
      orderParams = make_shared<string>(boost::any_cast<string>(m["order_params"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("receipt_address") != m.end() && !m["receipt_address"].empty()) {
      receiptAddress = make_shared<string>(boost::any_cast<string>(m["receipt_address"]));
    }
    if (m.find("receipt_target") != m.end() && !m["receipt_target"].empty()) {
      receiptTarget = make_shared<long>(boost::any_cast<long>(m["receipt_target"]));
    }
    if (m.find("receipt_title") != m.end() && !m["receipt_title"].empty()) {
      receiptTitle = make_shared<string>(boost::any_cast<string>(m["receipt_title"]));
    }
    if (m.find("traveler_info_list") != m.end() && !m["traveler_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_info_list"].type()) {
        vector<FlightCreateOrderRequestTravelerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightCreateOrderRequestTravelerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerInfoList = make_shared<vector<FlightCreateOrderRequestTravelerInfoList>>(expect1);
      }
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightCreateOrderRequest() = default;
};
class FlightCreateOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<long> autoPay{};
  shared_ptr<string> buyerName{};
  shared_ptr<string> buyerUniqueKey{};
  shared_ptr<string> contactInfoShrink{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> orderAttrShrink{};
  shared_ptr<string> orderParams{};
  shared_ptr<string> otaItemId{};
  shared_ptr<long> price{};
  shared_ptr<string> receiptAddress{};
  shared_ptr<long> receiptTarget{};
  shared_ptr<string> receiptTitle{};
  shared_ptr<string> travelerInfoListShrink{};
  shared_ptr<long> tripType{};

  FlightCreateOrderShrinkRequest() {}

  explicit FlightCreateOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (autoPay) {
      res["auto_pay"] = boost::any(*autoPay);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (buyerUniqueKey) {
      res["buyer_unique_key"] = boost::any(*buyerUniqueKey);
    }
    if (contactInfoShrink) {
      res["contact_info"] = boost::any(*contactInfoShrink);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (orderAttrShrink) {
      res["order_attr"] = boost::any(*orderAttrShrink);
    }
    if (orderParams) {
      res["order_params"] = boost::any(*orderParams);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (receiptAddress) {
      res["receipt_address"] = boost::any(*receiptAddress);
    }
    if (receiptTarget) {
      res["receipt_target"] = boost::any(*receiptTarget);
    }
    if (receiptTitle) {
      res["receipt_title"] = boost::any(*receiptTitle);
    }
    if (travelerInfoListShrink) {
      res["traveler_info_list"] = boost::any(*travelerInfoListShrink);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("auto_pay") != m.end() && !m["auto_pay"].empty()) {
      autoPay = make_shared<long>(boost::any_cast<long>(m["auto_pay"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("buyer_unique_key") != m.end() && !m["buyer_unique_key"].empty()) {
      buyerUniqueKey = make_shared<string>(boost::any_cast<string>(m["buyer_unique_key"]));
    }
    if (m.find("contact_info") != m.end() && !m["contact_info"].empty()) {
      contactInfoShrink = make_shared<string>(boost::any_cast<string>(m["contact_info"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("order_attr") != m.end() && !m["order_attr"].empty()) {
      orderAttrShrink = make_shared<string>(boost::any_cast<string>(m["order_attr"]));
    }
    if (m.find("order_params") != m.end() && !m["order_params"].empty()) {
      orderParams = make_shared<string>(boost::any_cast<string>(m["order_params"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("receipt_address") != m.end() && !m["receipt_address"].empty()) {
      receiptAddress = make_shared<string>(boost::any_cast<string>(m["receipt_address"]));
    }
    if (m.find("receipt_target") != m.end() && !m["receipt_target"].empty()) {
      receiptTarget = make_shared<long>(boost::any_cast<long>(m["receipt_target"]));
    }
    if (m.find("receipt_title") != m.end() && !m["receipt_title"].empty()) {
      receiptTitle = make_shared<string>(boost::any_cast<string>(m["receipt_title"]));
    }
    if (m.find("traveler_info_list") != m.end() && !m["traveler_info_list"].empty()) {
      travelerInfoListShrink = make_shared<string>(boost::any_cast<string>(m["traveler_info_list"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightCreateOrderShrinkRequest() = default;
};
class FlightCreateOrderResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<long> btripOrderId{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> lastPayTime{};
  shared_ptr<long> orderStatus{};
  shared_ptr<long> payStatus{};
  shared_ptr<long> paymentPrice{};
  shared_ptr<long> totalPrice{};

  FlightCreateOrderResponseBodyModule() {}

  explicit FlightCreateOrderResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (lastPayTime) {
      res["last_pay_time"] = boost::any(*lastPayTime);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (payStatus) {
      res["pay_status"] = boost::any(*payStatus);
    }
    if (paymentPrice) {
      res["payment_price"] = boost::any(*paymentPrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_order_id"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("last_pay_time") != m.end() && !m["last_pay_time"].empty()) {
      lastPayTime = make_shared<string>(boost::any_cast<string>(m["last_pay_time"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("pay_status") != m.end() && !m["pay_status"].empty()) {
      payStatus = make_shared<long>(boost::any_cast<long>(m["pay_status"]));
    }
    if (m.find("payment_price") != m.end() && !m["payment_price"].empty()) {
      paymentPrice = make_shared<long>(boost::any_cast<long>(m["payment_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<long>(boost::any_cast<long>(m["total_price"]));
    }
  }


  virtual ~FlightCreateOrderResponseBodyModule() = default;
};
class FlightCreateOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightCreateOrderResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightCreateOrderResponseBody() {}

  explicit FlightCreateOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightCreateOrderResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightCreateOrderResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightCreateOrderResponseBody() = default;
};
class FlightCreateOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightCreateOrderResponseBody> body{};

  FlightCreateOrderResponse() {}

  explicit FlightCreateOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightCreateOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightCreateOrderResponseBody>(model1);
      }
    }
  }


  virtual ~FlightCreateOrderResponse() = default;
};
class FlightCreateOrderV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightCreateOrderV2Headers() {}

  explicit FlightCreateOrderV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightCreateOrderV2Headers() = default;
};
class FlightCreateOrderV2RequestContactInfo : public Darabonba::Model {
public:
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactPhone{};
  shared_ptr<bool> sendMsgToPassenger{};

  FlightCreateOrderV2RequestContactInfo() {}

  explicit FlightCreateOrderV2RequestContactInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactEmail) {
      res["contact_email"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (contactPhone) {
      res["contact_phone"] = boost::any(*contactPhone);
    }
    if (sendMsgToPassenger) {
      res["send_msg_to_passenger"] = boost::any(*sendMsgToPassenger);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contact_email") != m.end() && !m["contact_email"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["contact_email"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("contact_phone") != m.end() && !m["contact_phone"].empty()) {
      contactPhone = make_shared<string>(boost::any_cast<string>(m["contact_phone"]));
    }
    if (m.find("send_msg_to_passenger") != m.end() && !m["send_msg_to_passenger"].empty()) {
      sendMsgToPassenger = make_shared<bool>(boost::any_cast<bool>(m["send_msg_to_passenger"]));
    }
  }


  virtual ~FlightCreateOrderV2RequestContactInfo() = default;
};
class FlightCreateOrderV2RequestTravelers : public Darabonba::Model {
public:
  shared_ptr<string> birthday{};
  shared_ptr<string> certNation{};
  shared_ptr<string> certNo{};
  shared_ptr<long> certType{};
  shared_ptr<string> certValidDate{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<string> deptId{};
  shared_ptr<string> deptName{};
  shared_ptr<long> gender{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> nationality{};
  shared_ptr<string> nationalityCode{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> passengerType{};
  shared_ptr<string> phone{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> userId{};
  shared_ptr<long> userType{};

  FlightCreateOrderV2RequestTravelers() {}

  explicit FlightCreateOrderV2RequestTravelers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthday) {
      res["birthday"] = boost::any(*birthday);
    }
    if (certNation) {
      res["cert_nation"] = boost::any(*certNation);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (certValidDate) {
      res["cert_valid_date"] = boost::any(*certValidDate);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (deptId) {
      res["dept_id"] = boost::any(*deptId);
    }
    if (deptName) {
      res["dept_name"] = boost::any(*deptName);
    }
    if (gender) {
      res["gender"] = boost::any(*gender);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (nationality) {
      res["nationality"] = boost::any(*nationality);
    }
    if (nationalityCode) {
      res["nationality_code"] = boost::any(*nationalityCode);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userType) {
      res["user_type"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birthday") != m.end() && !m["birthday"].empty()) {
      birthday = make_shared<string>(boost::any_cast<string>(m["birthday"]));
    }
    if (m.find("cert_nation") != m.end() && !m["cert_nation"].empty()) {
      certNation = make_shared<string>(boost::any_cast<string>(m["cert_nation"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<long>(boost::any_cast<long>(m["cert_type"]));
    }
    if (m.find("cert_valid_date") != m.end() && !m["cert_valid_date"].empty()) {
      certValidDate = make_shared<string>(boost::any_cast<string>(m["cert_valid_date"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("dept_id") != m.end() && !m["dept_id"].empty()) {
      deptId = make_shared<string>(boost::any_cast<string>(m["dept_id"]));
    }
    if (m.find("dept_name") != m.end() && !m["dept_name"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["dept_name"]));
    }
    if (m.find("gender") != m.end() && !m["gender"].empty()) {
      gender = make_shared<long>(boost::any_cast<long>(m["gender"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("nationality") != m.end() && !m["nationality"].empty()) {
      nationality = make_shared<string>(boost::any_cast<string>(m["nationality"]));
    }
    if (m.find("nationality_code") != m.end() && !m["nationality_code"].empty()) {
      nationalityCode = make_shared<string>(boost::any_cast<string>(m["nationality_code"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<long>(boost::any_cast<long>(m["passenger_type"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_type") != m.end() && !m["user_type"].empty()) {
      userType = make_shared<long>(boost::any_cast<long>(m["user_type"]));
    }
  }


  virtual ~FlightCreateOrderV2RequestTravelers() = default;
};
class FlightCreateOrderV2Request : public Darabonba::Model {
public:
  shared_ptr<string> asyncCreateOrderKey{};
  shared_ptr<bool> asyncCreateOrderMode{};
  shared_ptr<string> btripUserId{};
  shared_ptr<string> buyerName{};
  shared_ptr<FlightCreateOrderV2RequestContactInfo> contactInfo{};
  shared_ptr<string> isvName{};
  shared_ptr<string> otaItemId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<long> totalPriceCent{};
  shared_ptr<vector<FlightCreateOrderV2RequestTravelers>> travelers{};

  FlightCreateOrderV2Request() {}

  explicit FlightCreateOrderV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncCreateOrderKey) {
      res["async_create_order_key"] = boost::any(*asyncCreateOrderKey);
    }
    if (asyncCreateOrderMode) {
      res["async_create_order_mode"] = boost::any(*asyncCreateOrderMode);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (contactInfo) {
      res["contact_info"] = contactInfo ? boost::any(contactInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (totalPriceCent) {
      res["total_price_cent"] = boost::any(*totalPriceCent);
    }
    if (travelers) {
      vector<boost::any> temp1;
      for(auto item1:*travelers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["travelers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("async_create_order_key") != m.end() && !m["async_create_order_key"].empty()) {
      asyncCreateOrderKey = make_shared<string>(boost::any_cast<string>(m["async_create_order_key"]));
    }
    if (m.find("async_create_order_mode") != m.end() && !m["async_create_order_mode"].empty()) {
      asyncCreateOrderMode = make_shared<bool>(boost::any_cast<bool>(m["async_create_order_mode"]));
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("contact_info") != m.end() && !m["contact_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["contact_info"].type()) {
        FlightCreateOrderV2RequestContactInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["contact_info"]));
        contactInfo = make_shared<FlightCreateOrderV2RequestContactInfo>(model1);
      }
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("total_price_cent") != m.end() && !m["total_price_cent"].empty()) {
      totalPriceCent = make_shared<long>(boost::any_cast<long>(m["total_price_cent"]));
    }
    if (m.find("travelers") != m.end() && !m["travelers"].empty()) {
      if (typeid(vector<boost::any>) == m["travelers"].type()) {
        vector<FlightCreateOrderV2RequestTravelers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["travelers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightCreateOrderV2RequestTravelers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelers = make_shared<vector<FlightCreateOrderV2RequestTravelers>>(expect1);
      }
    }
  }


  virtual ~FlightCreateOrderV2Request() = default;
};
class FlightCreateOrderV2ShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> asyncCreateOrderKey{};
  shared_ptr<bool> asyncCreateOrderMode{};
  shared_ptr<string> btripUserId{};
  shared_ptr<string> buyerName{};
  shared_ptr<string> contactInfoShrink{};
  shared_ptr<string> isvName{};
  shared_ptr<string> otaItemId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<long> totalPriceCent{};
  shared_ptr<string> travelersShrink{};

  FlightCreateOrderV2ShrinkRequest() {}

  explicit FlightCreateOrderV2ShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncCreateOrderKey) {
      res["async_create_order_key"] = boost::any(*asyncCreateOrderKey);
    }
    if (asyncCreateOrderMode) {
      res["async_create_order_mode"] = boost::any(*asyncCreateOrderMode);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (contactInfoShrink) {
      res["contact_info"] = boost::any(*contactInfoShrink);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (totalPriceCent) {
      res["total_price_cent"] = boost::any(*totalPriceCent);
    }
    if (travelersShrink) {
      res["travelers"] = boost::any(*travelersShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("async_create_order_key") != m.end() && !m["async_create_order_key"].empty()) {
      asyncCreateOrderKey = make_shared<string>(boost::any_cast<string>(m["async_create_order_key"]));
    }
    if (m.find("async_create_order_mode") != m.end() && !m["async_create_order_mode"].empty()) {
      asyncCreateOrderMode = make_shared<bool>(boost::any_cast<bool>(m["async_create_order_mode"]));
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("contact_info") != m.end() && !m["contact_info"].empty()) {
      contactInfoShrink = make_shared<string>(boost::any_cast<string>(m["contact_info"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("total_price_cent") != m.end() && !m["total_price_cent"].empty()) {
      totalPriceCent = make_shared<long>(boost::any_cast<long>(m["total_price_cent"]));
    }
    if (m.find("travelers") != m.end() && !m["travelers"].empty()) {
      travelersShrink = make_shared<string>(boost::any_cast<string>(m["travelers"]));
    }
  }


  virtual ~FlightCreateOrderV2ShrinkRequest() = default;
};
class FlightCreateOrderV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> asyncCreateOrderKey{};
  shared_ptr<string> latestPayTime{};
  shared_ptr<long> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<long> status{};
  shared_ptr<long> totalPrice{};

  FlightCreateOrderV2ResponseBodyModule() {}

  explicit FlightCreateOrderV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncCreateOrderKey) {
      res["async_create_order_key"] = boost::any(*asyncCreateOrderKey);
    }
    if (latestPayTime) {
      res["latest_pay_time"] = boost::any(*latestPayTime);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("async_create_order_key") != m.end() && !m["async_create_order_key"].empty()) {
      asyncCreateOrderKey = make_shared<string>(boost::any_cast<string>(m["async_create_order_key"]));
    }
    if (m.find("latest_pay_time") != m.end() && !m["latest_pay_time"].empty()) {
      latestPayTime = make_shared<string>(boost::any_cast<string>(m["latest_pay_time"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<long>(boost::any_cast<long>(m["total_price"]));
    }
  }


  virtual ~FlightCreateOrderV2ResponseBodyModule() = default;
};
class FlightCreateOrderV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightCreateOrderV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightCreateOrderV2ResponseBody() {}

  explicit FlightCreateOrderV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightCreateOrderV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightCreateOrderV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightCreateOrderV2ResponseBody() = default;
};
class FlightCreateOrderV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightCreateOrderV2ResponseBody> body{};

  FlightCreateOrderV2Response() {}

  explicit FlightCreateOrderV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightCreateOrderV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightCreateOrderV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightCreateOrderV2Response() = default;
};
class FlightExceedApplyQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  FlightExceedApplyQueryHeaders() {}

  explicit FlightExceedApplyQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~FlightExceedApplyQueryHeaders() = default;
};
class FlightExceedApplyQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};

  FlightExceedApplyQueryRequest() {}

  explicit FlightExceedApplyQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
  }


  virtual ~FlightExceedApplyQueryRequest() = default;
};
class FlightExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo : public Darabonba::Model {
public:
  shared_ptr<string> arrAirportName{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> cabin{};
  shared_ptr<long> cabinClass{};
  shared_ptr<string> cabinClassStr{};
  shared_ptr<string> depAirportName{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depTime{};
  shared_ptr<string> discount{};
  shared_ptr<string> flightNo{};
  shared_ptr<long> price{};
  shared_ptr<long> type{};

  FlightExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo() {}

  explicit FlightExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrAirportName) {
      res["arr_airport_name"] = boost::any(*arrAirportName);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassStr) {
      res["cabin_class_str"] = boost::any(*cabinClassStr);
    }
    if (depAirportName) {
      res["dep_airport_name"] = boost::any(*depAirportName);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_airport_name") != m.end() && !m["arr_airport_name"].empty()) {
      arrAirportName = make_shared<string>(boost::any_cast<string>(m["arr_airport_name"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<long>(boost::any_cast<long>(m["cabin_class"]));
    }
    if (m.find("cabin_class_str") != m.end() && !m["cabin_class_str"].empty()) {
      cabinClassStr = make_shared<string>(boost::any_cast<string>(m["cabin_class_str"]));
    }
    if (m.find("dep_airport_name") != m.end() && !m["dep_airport_name"].empty()) {
      depAirportName = make_shared<string>(boost::any_cast<string>(m["dep_airport_name"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo() = default;
};
class FlightExceedApplyQueryResponseBodyModuleApplyRecommendFlights : public Darabonba::Model {
public:
  shared_ptr<string> arrAirportName{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> cabin{};
  shared_ptr<long> cabinClass{};
  shared_ptr<string> cabinClassStr{};
  shared_ptr<string> depAirportName{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depTime{};
  shared_ptr<string> discount{};
  shared_ptr<string> flightNo{};
  shared_ptr<long> price{};
  shared_ptr<string> transferAirportName{};

  FlightExceedApplyQueryResponseBodyModuleApplyRecommendFlights() {}

  explicit FlightExceedApplyQueryResponseBodyModuleApplyRecommendFlights(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrAirportName) {
      res["arr_airport_name"] = boost::any(*arrAirportName);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassStr) {
      res["cabin_class_str"] = boost::any(*cabinClassStr);
    }
    if (depAirportName) {
      res["dep_airport_name"] = boost::any(*depAirportName);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (transferAirportName) {
      res["transfer_airport_name"] = boost::any(*transferAirportName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_airport_name") != m.end() && !m["arr_airport_name"].empty()) {
      arrAirportName = make_shared<string>(boost::any_cast<string>(m["arr_airport_name"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<long>(boost::any_cast<long>(m["cabin_class"]));
    }
    if (m.find("cabin_class_str") != m.end() && !m["cabin_class_str"].empty()) {
      cabinClassStr = make_shared<string>(boost::any_cast<string>(m["cabin_class_str"]));
    }
    if (m.find("dep_airport_name") != m.end() && !m["dep_airport_name"].empty()) {
      depAirportName = make_shared<string>(boost::any_cast<string>(m["dep_airport_name"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("transfer_airport_name") != m.end() && !m["transfer_airport_name"].empty()) {
      transferAirportName = make_shared<string>(boost::any_cast<string>(m["transfer_airport_name"]));
    }
  }


  virtual ~FlightExceedApplyQueryResponseBodyModuleApplyRecommendFlights() = default;
};
class FlightExceedApplyQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<FlightExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo> applyIntentionInfoDo{};
  shared_ptr<FlightExceedApplyQueryResponseBodyModuleApplyRecommendFlights> applyRecommendFlights{};
  shared_ptr<string> btripCause{};
  shared_ptr<string> corpId{};
  shared_ptr<string> exceedReason{};
  shared_ptr<long> exceedType{};
  shared_ptr<string> originStandard{};
  shared_ptr<long> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartCorpId{};
  shared_ptr<string> userId{};

  FlightExceedApplyQueryResponseBodyModule() {}

  explicit FlightExceedApplyQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (applyIntentionInfoDo) {
      res["apply_intention_info_do"] = applyIntentionInfoDo ? boost::any(applyIntentionInfoDo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (applyRecommendFlights) {
      res["apply_recommend_flights"] = applyRecommendFlights ? boost::any(applyRecommendFlights->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (btripCause) {
      res["btrip_cause"] = boost::any(*btripCause);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (exceedReason) {
      res["exceed_reason"] = boost::any(*exceedReason);
    }
    if (exceedType) {
      res["exceed_type"] = boost::any(*exceedType);
    }
    if (originStandard) {
      res["origin_standard"] = boost::any(*originStandard);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (submitTime) {
      res["submit_time"] = boost::any(*submitTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartCorpId) {
      res["thirdpart_corp_id"] = boost::any(*thirdpartCorpId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("apply_intention_info_do") != m.end() && !m["apply_intention_info_do"].empty()) {
      if (typeid(map<string, boost::any>) == m["apply_intention_info_do"].type()) {
        FlightExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["apply_intention_info_do"]));
        applyIntentionInfoDo = make_shared<FlightExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo>(model1);
      }
    }
    if (m.find("apply_recommend_flights") != m.end() && !m["apply_recommend_flights"].empty()) {
      if (typeid(map<string, boost::any>) == m["apply_recommend_flights"].type()) {
        FlightExceedApplyQueryResponseBodyModuleApplyRecommendFlights model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["apply_recommend_flights"]));
        applyRecommendFlights = make_shared<FlightExceedApplyQueryResponseBodyModuleApplyRecommendFlights>(model1);
      }
    }
    if (m.find("btrip_cause") != m.end() && !m["btrip_cause"].empty()) {
      btripCause = make_shared<string>(boost::any_cast<string>(m["btrip_cause"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("exceed_reason") != m.end() && !m["exceed_reason"].empty()) {
      exceedReason = make_shared<string>(boost::any_cast<string>(m["exceed_reason"]));
    }
    if (m.find("exceed_type") != m.end() && !m["exceed_type"].empty()) {
      exceedType = make_shared<long>(boost::any_cast<long>(m["exceed_type"]));
    }
    if (m.find("origin_standard") != m.end() && !m["origin_standard"].empty()) {
      originStandard = make_shared<string>(boost::any_cast<string>(m["origin_standard"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("submit_time") != m.end() && !m["submit_time"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["submit_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_corp_id") != m.end() && !m["thirdpart_corp_id"].empty()) {
      thirdpartCorpId = make_shared<string>(boost::any_cast<string>(m["thirdpart_corp_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightExceedApplyQueryResponseBodyModule() = default;
};
class FlightExceedApplyQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightExceedApplyQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightExceedApplyQueryResponseBody() {}

  explicit FlightExceedApplyQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightExceedApplyQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightExceedApplyQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightExceedApplyQueryResponseBody() = default;
};
class FlightExceedApplyQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightExceedApplyQueryResponseBody> body{};

  FlightExceedApplyQueryResponse() {}

  explicit FlightExceedApplyQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightExceedApplyQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightExceedApplyQueryResponseBody>(model1);
      }
    }
  }


  virtual ~FlightExceedApplyQueryResponse() = default;
};
class FlightItineraryScanQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  FlightItineraryScanQueryHeaders() {}

  explicit FlightItineraryScanQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~FlightItineraryScanQueryHeaders() = default;
};
class FlightItineraryScanQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> billDate{};
  shared_ptr<long> billId{};
  shared_ptr<long> invoiceSubTaskId{};
  shared_ptr<string> itineraryNum{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ticketNo{};

  FlightItineraryScanQueryRequest() {}

  explicit FlightItineraryScanQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (billId) {
      res["bill_id"] = boost::any(*billId);
    }
    if (invoiceSubTaskId) {
      res["invoice_sub_task_id"] = boost::any(*invoiceSubTaskId);
    }
    if (itineraryNum) {
      res["itinerary_num"] = boost::any(*itineraryNum);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("bill_id") != m.end() && !m["bill_id"].empty()) {
      billId = make_shared<long>(boost::any_cast<long>(m["bill_id"]));
    }
    if (m.find("invoice_sub_task_id") != m.end() && !m["invoice_sub_task_id"].empty()) {
      invoiceSubTaskId = make_shared<long>(boost::any_cast<long>(m["invoice_sub_task_id"]));
    }
    if (m.find("itinerary_num") != m.end() && !m["itinerary_num"].empty()) {
      itineraryNum = make_shared<string>(boost::any_cast<string>(m["itinerary_num"]));
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
  }


  virtual ~FlightItineraryScanQueryRequest() = default;
};
class FlightItineraryScanQueryResponseBodyModuleItemsFlights : public Darabonba::Model {
public:
  shared_ptr<string> arrivalStation{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> carrier{};
  shared_ptr<string> departureStation{};
  shared_ptr<string> flightDate{};
  shared_ptr<string> flightNumber{};
  shared_ptr<string> flightTime{};
  shared_ptr<string> freeBaggageAllowance{};
  shared_ptr<string> index{};
  shared_ptr<string> seatClass{};
  shared_ptr<string> validFromDate{};
  shared_ptr<string> validToDate{};

  FlightItineraryScanQueryResponseBodyModuleItemsFlights() {}

  explicit FlightItineraryScanQueryResponseBodyModuleItemsFlights(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrivalStation) {
      res["arrival_station"] = boost::any(*arrivalStation);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (carrier) {
      res["carrier"] = boost::any(*carrier);
    }
    if (departureStation) {
      res["departure_station"] = boost::any(*departureStation);
    }
    if (flightDate) {
      res["flight_date"] = boost::any(*flightDate);
    }
    if (flightNumber) {
      res["flight_number"] = boost::any(*flightNumber);
    }
    if (flightTime) {
      res["flight_time"] = boost::any(*flightTime);
    }
    if (freeBaggageAllowance) {
      res["free_baggage_allowance"] = boost::any(*freeBaggageAllowance);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (seatClass) {
      res["seat_class"] = boost::any(*seatClass);
    }
    if (validFromDate) {
      res["valid_from_date"] = boost::any(*validFromDate);
    }
    if (validToDate) {
      res["valid_to_date"] = boost::any(*validToDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arrival_station") != m.end() && !m["arrival_station"].empty()) {
      arrivalStation = make_shared<string>(boost::any_cast<string>(m["arrival_station"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("carrier") != m.end() && !m["carrier"].empty()) {
      carrier = make_shared<string>(boost::any_cast<string>(m["carrier"]));
    }
    if (m.find("departure_station") != m.end() && !m["departure_station"].empty()) {
      departureStation = make_shared<string>(boost::any_cast<string>(m["departure_station"]));
    }
    if (m.find("flight_date") != m.end() && !m["flight_date"].empty()) {
      flightDate = make_shared<string>(boost::any_cast<string>(m["flight_date"]));
    }
    if (m.find("flight_number") != m.end() && !m["flight_number"].empty()) {
      flightNumber = make_shared<string>(boost::any_cast<string>(m["flight_number"]));
    }
    if (m.find("flight_time") != m.end() && !m["flight_time"].empty()) {
      flightTime = make_shared<string>(boost::any_cast<string>(m["flight_time"]));
    }
    if (m.find("free_baggage_allowance") != m.end() && !m["free_baggage_allowance"].empty()) {
      freeBaggageAllowance = make_shared<string>(boost::any_cast<string>(m["free_baggage_allowance"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("seat_class") != m.end() && !m["seat_class"].empty()) {
      seatClass = make_shared<string>(boost::any_cast<string>(m["seat_class"]));
    }
    if (m.find("valid_from_date") != m.end() && !m["valid_from_date"].empty()) {
      validFromDate = make_shared<string>(boost::any_cast<string>(m["valid_from_date"]));
    }
    if (m.find("valid_to_date") != m.end() && !m["valid_to_date"].empty()) {
      validToDate = make_shared<string>(boost::any_cast<string>(m["valid_to_date"]));
    }
  }


  virtual ~FlightItineraryScanQueryResponseBodyModuleItemsFlights() = default;
};
class FlightItineraryScanQueryResponseBodyModuleItems : public Darabonba::Model {
public:
  shared_ptr<string> agentCode{};
  shared_ptr<string> billDate{};
  shared_ptr<string> build{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> department{};
  shared_ptr<vector<FlightItineraryScanQueryResponseBodyModuleItemsFlights>> flights{};
  shared_ptr<string> fuelSurcharge{};
  shared_ptr<string> id{};
  shared_ptr<string> insurance{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> issueCompany{};
  shared_ptr<string> issueDate{};
  shared_ptr<string> itineraryNum{};
  shared_ptr<long> orderId{};
  shared_ptr<string> ossUrl{};
  shared_ptr<string> passengerName{};
  shared_ptr<string> project{};
  shared_ptr<string> promptMessage{};
  shared_ptr<string> taxAmount{};
  shared_ptr<string> taxRate{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> ticketPrice{};
  shared_ptr<string> totalPrice{};
  shared_ptr<string> validationCode{};

  FlightItineraryScanQueryResponseBodyModuleItems() {}

  explicit FlightItineraryScanQueryResponseBodyModuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentCode) {
      res["agent_code"] = boost::any(*agentCode);
    }
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (build) {
      res["build"] = boost::any(*build);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (flights) {
      vector<boost::any> temp1;
      for(auto item1:*flights){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flights"] = boost::any(temp1);
    }
    if (fuelSurcharge) {
      res["fuel_surcharge"] = boost::any(*fuelSurcharge);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (insurance) {
      res["insurance"] = boost::any(*insurance);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (issueCompany) {
      res["issue_company"] = boost::any(*issueCompany);
    }
    if (issueDate) {
      res["issue_date"] = boost::any(*issueDate);
    }
    if (itineraryNum) {
      res["itinerary_num"] = boost::any(*itineraryNum);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (ossUrl) {
      res["oss_url"] = boost::any(*ossUrl);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (project) {
      res["project"] = boost::any(*project);
    }
    if (promptMessage) {
      res["prompt_message"] = boost::any(*promptMessage);
    }
    if (taxAmount) {
      res["tax_amount"] = boost::any(*taxAmount);
    }
    if (taxRate) {
      res["tax_rate"] = boost::any(*taxRate);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    if (validationCode) {
      res["validation_code"] = boost::any(*validationCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("agent_code") != m.end() && !m["agent_code"].empty()) {
      agentCode = make_shared<string>(boost::any_cast<string>(m["agent_code"]));
    }
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("build") != m.end() && !m["build"].empty()) {
      build = make_shared<string>(boost::any_cast<string>(m["build"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("flights") != m.end() && !m["flights"].empty()) {
      if (typeid(vector<boost::any>) == m["flights"].type()) {
        vector<FlightItineraryScanQueryResponseBodyModuleItemsFlights> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flights"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightItineraryScanQueryResponseBodyModuleItemsFlights model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flights = make_shared<vector<FlightItineraryScanQueryResponseBodyModuleItemsFlights>>(expect1);
      }
    }
    if (m.find("fuel_surcharge") != m.end() && !m["fuel_surcharge"].empty()) {
      fuelSurcharge = make_shared<string>(boost::any_cast<string>(m["fuel_surcharge"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("insurance") != m.end() && !m["insurance"].empty()) {
      insurance = make_shared<string>(boost::any_cast<string>(m["insurance"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("issue_company") != m.end() && !m["issue_company"].empty()) {
      issueCompany = make_shared<string>(boost::any_cast<string>(m["issue_company"]));
    }
    if (m.find("issue_date") != m.end() && !m["issue_date"].empty()) {
      issueDate = make_shared<string>(boost::any_cast<string>(m["issue_date"]));
    }
    if (m.find("itinerary_num") != m.end() && !m["itinerary_num"].empty()) {
      itineraryNum = make_shared<string>(boost::any_cast<string>(m["itinerary_num"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("oss_url") != m.end() && !m["oss_url"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["oss_url"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("project") != m.end() && !m["project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["project"]));
    }
    if (m.find("prompt_message") != m.end() && !m["prompt_message"].empty()) {
      promptMessage = make_shared<string>(boost::any_cast<string>(m["prompt_message"]));
    }
    if (m.find("tax_amount") != m.end() && !m["tax_amount"].empty()) {
      taxAmount = make_shared<string>(boost::any_cast<string>(m["tax_amount"]));
    }
    if (m.find("tax_rate") != m.end() && !m["tax_rate"].empty()) {
      taxRate = make_shared<string>(boost::any_cast<string>(m["tax_rate"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<string>(boost::any_cast<string>(m["ticket_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<string>(boost::any_cast<string>(m["total_price"]));
    }
    if (m.find("validation_code") != m.end() && !m["validation_code"].empty()) {
      validationCode = make_shared<string>(boost::any_cast<string>(m["validation_code"]));
    }
  }


  virtual ~FlightItineraryScanQueryResponseBodyModuleItems() = default;
};
class FlightItineraryScanQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightItineraryScanQueryResponseBodyModuleItems>> items{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalPage{};
  shared_ptr<long> totalSize{};

  FlightItineraryScanQueryResponseBodyModule() {}

  explicit FlightItineraryScanQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalPage) {
      res["total_page"] = boost::any(*totalPage);
    }
    if (totalSize) {
      res["total_size"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<FlightItineraryScanQueryResponseBodyModuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightItineraryScanQueryResponseBodyModuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FlightItineraryScanQueryResponseBodyModuleItems>>(expect1);
      }
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_page") != m.end() && !m["total_page"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["total_page"]));
    }
    if (m.find("total_size") != m.end() && !m["total_size"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["total_size"]));
    }
  }


  virtual ~FlightItineraryScanQueryResponseBodyModule() = default;
};
class FlightItineraryScanQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightItineraryScanQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightItineraryScanQueryResponseBody() {}

  explicit FlightItineraryScanQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightItineraryScanQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightItineraryScanQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightItineraryScanQueryResponseBody() = default;
};
class FlightItineraryScanQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightItineraryScanQueryResponseBody> body{};

  FlightItineraryScanQueryResponse() {}

  explicit FlightItineraryScanQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightItineraryScanQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightItineraryScanQueryResponseBody>(model1);
      }
    }
  }


  virtual ~FlightItineraryScanQueryResponse() = default;
};
class FlightListingSearchHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightListingSearchHeaders() {}

  explicit FlightListingSearchHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightListingSearchHeaders() = default;
};
class FlightListingSearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};

  FlightListingSearchRequest() {}

  explicit FlightListingSearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
  }


  virtual ~FlightListingSearchRequest() = default;
};
class FlightListingSearchResponseBodyModuleFlightListAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};

  FlightListingSearchResponseBodyModuleFlightListAirlineInfo() {}

  explicit FlightListingSearchResponseBodyModuleFlightListAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListAirlineInfo() = default;
};
class FlightListingSearchResponseBodyModuleFlightListArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightListingSearchResponseBodyModuleFlightListArrAirportInfo() {}

  explicit FlightListingSearchResponseBodyModuleFlightListArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListArrAirportInfo() = default;
};
class FlightListingSearchResponseBodyModuleFlightListDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightListingSearchResponseBodyModuleFlightListDepAirportInfo() {}

  explicit FlightListingSearchResponseBodyModuleFlightListDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListDepAirportInfo() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["image_d_o"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("image_d_o") != m.end() && !m["image_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["image_d_o"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["image_d_o"]));
        imageDO = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<boost::any>> extraContentVisualizes{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (extraContentVisualizes) {
      res["extra_content_visualizes"] = boost::any(*extraContentVisualizes);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("extra_content_visualizes") != m.end() && !m["extra_content_visualizes"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["extra_content_visualizes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extra_content_visualizes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      extraContentVisualizes = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItem() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItem() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo>> info{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRule() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRule() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo>> info{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRule() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRule() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo>> info{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRule() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRule() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo>> info{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule() = default;
};
class FlightListingSearchResponseBodyModuleFlightListFlightRuleList : public Darabonba::Model {
public:
  shared_ptr<string> baggageInfo{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItem> baggageItem{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRule> changeRule{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem> changeRuleItem{};
  shared_ptr<string> extra{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRule> refundRule{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem> refundRuleItem{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRule> signRule{};
  shared_ptr<string> tuigaiqianInfo{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule> upgradeRule{};

  FlightListingSearchResponseBodyModuleFlightListFlightRuleList() {}

  explicit FlightListingSearchResponseBodyModuleFlightListFlightRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageInfo) {
      res["baggage_info"] = boost::any(*baggageInfo);
    }
    if (baggageItem) {
      res["baggage_item"] = baggageItem ? boost::any(baggageItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRule) {
      res["change_rule"] = changeRule ? boost::any(changeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRuleItem) {
      res["change_rule_item"] = changeRuleItem ? boost::any(changeRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (refundRule) {
      res["refund_rule"] = refundRule ? boost::any(refundRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundRuleItem) {
      res["refund_rule_item"] = refundRuleItem ? boost::any(refundRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signRule) {
      res["sign_rule"] = signRule ? boost::any(signRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    if (upgradeRule) {
      res["upgrade_rule"] = upgradeRule ? boost::any(upgradeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_info") != m.end() && !m["baggage_info"].empty()) {
      baggageInfo = make_shared<string>(boost::any_cast<string>(m["baggage_info"]));
    }
    if (m.find("baggage_item") != m.end() && !m["baggage_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["baggage_item"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["baggage_item"]));
        baggageItem = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListBaggageItem>(model1);
      }
    }
    if (m.find("change_rule") != m.end() && !m["change_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule"]));
        changeRule = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRule>(model1);
      }
    }
    if (m.find("change_rule_item") != m.end() && !m["change_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule_item"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule_item"]));
        changeRuleItem = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem>(model1);
      }
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("refund_rule") != m.end() && !m["refund_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule"]));
        refundRule = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRule>(model1);
      }
    }
    if (m.find("refund_rule_item") != m.end() && !m["refund_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule_item"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule_item"]));
        refundRuleItem = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem>(model1);
      }
    }
    if (m.find("sign_rule") != m.end() && !m["sign_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["sign_rule"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sign_rule"]));
        signRule = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListSignRule>(model1);
      }
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
    if (m.find("upgrade_rule") != m.end() && !m["upgrade_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_rule"].type()) {
        FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_rule"]));
        upgradeRule = make_shared<FlightListingSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule>(model1);
      }
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightListFlightRuleList() = default;
};
class FlightListingSearchResponseBodyModuleFlightList : public Darabonba::Model {
public:
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListAirlineInfo> airlineInfo{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListArrAirportInfo> arrAirportInfo{};
  shared_ptr<string> arrDate{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> carrierAirline{};
  shared_ptr<string> carrierNo{};
  shared_ptr<FlightListingSearchResponseBodyModuleFlightListDepAirportInfo> depAirportInfo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<long> discount{};
  shared_ptr<string> flightNo{};
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleList>> flightRuleList{};
  shared_ptr<string> flightRuleListStr{};
  shared_ptr<string> flightSize{};
  shared_ptr<string> flightType{};
  shared_ptr<long> invoiceType{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<bool> isShare{};
  shared_ptr<bool> isStop{};
  shared_ptr<bool> isTransfer{};
  shared_ptr<string> mealDesc{};
  shared_ptr<long> oilPrice{};
  shared_ptr<string> otaItemId{};
  shared_ptr<long> price{};
  shared_ptr<long> productType{};
  shared_ptr<string> productTypeDesc{};
  shared_ptr<string> promotionPrice{};
  shared_ptr<string> remainedSeatCount{};
  shared_ptr<string> secretParams{};
  shared_ptr<string> segmentNumber{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopDepTime{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<string> totalPrice{};
  shared_ptr<long> tripType{};

  FlightListingSearchResponseBodyModuleFlightList() {}

  explicit FlightListingSearchResponseBodyModuleFlightList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (carrierAirline) {
      res["carrier_airline"] = boost::any(*carrierAirline);
    }
    if (carrierNo) {
      res["carrier_no"] = boost::any(*carrierNo);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*flightRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_rule_list"] = boost::any(temp1);
    }
    if (flightRuleListStr) {
      res["flight_rule_list_str"] = boost::any(*flightRuleListStr);
    }
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (isShare) {
      res["is_share"] = boost::any(*isShare);
    }
    if (isStop) {
      res["is_stop"] = boost::any(*isStop);
    }
    if (isTransfer) {
      res["is_transfer"] = boost::any(*isTransfer);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (productType) {
      res["product_type"] = boost::any(*productType);
    }
    if (productTypeDesc) {
      res["product_type_desc"] = boost::any(*productTypeDesc);
    }
    if (promotionPrice) {
      res["promotion_price"] = boost::any(*promotionPrice);
    }
    if (remainedSeatCount) {
      res["remained_seat_count"] = boost::any(*remainedSeatCount);
    }
    if (secretParams) {
      res["secret_params"] = boost::any(*secretParams);
    }
    if (segmentNumber) {
      res["segment_number"] = boost::any(*segmentNumber);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        FlightListingSearchResponseBodyModuleFlightListAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<FlightListingSearchResponseBodyModuleFlightListAirlineInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        FlightListingSearchResponseBodyModuleFlightListArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<FlightListingSearchResponseBodyModuleFlightListArrAirportInfo>(model1);
      }
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("carrier_airline") != m.end() && !m["carrier_airline"].empty()) {
      carrierAirline = make_shared<string>(boost::any_cast<string>(m["carrier_airline"]));
    }
    if (m.find("carrier_no") != m.end() && !m["carrier_no"].empty()) {
      carrierNo = make_shared<string>(boost::any_cast<string>(m["carrier_no"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        FlightListingSearchResponseBodyModuleFlightListDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<FlightListingSearchResponseBodyModuleFlightListDepAirportInfo>(model1);
      }
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<long>(boost::any_cast<long>(m["discount"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_rule_list") != m.end() && !m["flight_rule_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_rule_list"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_rule_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightListFlightRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightRuleList = make_shared<vector<FlightListingSearchResponseBodyModuleFlightListFlightRuleList>>(expect1);
      }
    }
    if (m.find("flight_rule_list_str") != m.end() && !m["flight_rule_list_str"].empty()) {
      flightRuleListStr = make_shared<string>(boost::any_cast<string>(m["flight_rule_list_str"]));
    }
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("is_share") != m.end() && !m["is_share"].empty()) {
      isShare = make_shared<bool>(boost::any_cast<bool>(m["is_share"]));
    }
    if (m.find("is_stop") != m.end() && !m["is_stop"].empty()) {
      isStop = make_shared<bool>(boost::any_cast<bool>(m["is_stop"]));
    }
    if (m.find("is_transfer") != m.end() && !m["is_transfer"].empty()) {
      isTransfer = make_shared<bool>(boost::any_cast<bool>(m["is_transfer"]));
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("product_type") != m.end() && !m["product_type"].empty()) {
      productType = make_shared<long>(boost::any_cast<long>(m["product_type"]));
    }
    if (m.find("product_type_desc") != m.end() && !m["product_type_desc"].empty()) {
      productTypeDesc = make_shared<string>(boost::any_cast<string>(m["product_type_desc"]));
    }
    if (m.find("promotion_price") != m.end() && !m["promotion_price"].empty()) {
      promotionPrice = make_shared<string>(boost::any_cast<string>(m["promotion_price"]));
    }
    if (m.find("remained_seat_count") != m.end() && !m["remained_seat_count"].empty()) {
      remainedSeatCount = make_shared<string>(boost::any_cast<string>(m["remained_seat_count"]));
    }
    if (m.find("secret_params") != m.end() && !m["secret_params"].empty()) {
      secretParams = make_shared<string>(boost::any_cast<string>(m["secret_params"]));
    }
    if (m.find("segment_number") != m.end() && !m["segment_number"].empty()) {
      segmentNumber = make_shared<string>(boost::any_cast<string>(m["segment_number"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<string>(boost::any_cast<string>(m["total_price"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightListingSearchResponseBodyModuleFlightList() = default;
};
class FlightListingSearchResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightListingSearchResponseBodyModuleFlightList>> flightList{};

  FlightListingSearchResponseBodyModule() {}

  explicit FlightListingSearchResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightList) {
      vector<boost::any> temp1;
      for(auto item1:*flightList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_list") != m.end() && !m["flight_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_list"].type()) {
        vector<FlightListingSearchResponseBodyModuleFlightList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchResponseBodyModuleFlightList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightList = make_shared<vector<FlightListingSearchResponseBodyModuleFlightList>>(expect1);
      }
    }
  }


  virtual ~FlightListingSearchResponseBodyModule() = default;
};
class FlightListingSearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightListingSearchResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightListingSearchResponseBody() {}

  explicit FlightListingSearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightListingSearchResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightListingSearchResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightListingSearchResponseBody() = default;
};
class FlightListingSearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightListingSearchResponseBody> body{};

  FlightListingSearchResponse() {}

  explicit FlightListingSearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightListingSearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightListingSearchResponseBody>(model1);
      }
    }
  }


  virtual ~FlightListingSearchResponse() = default;
};
class FlightListingSearchV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightListingSearchV2Headers() {}

  explicit FlightListingSearchV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightListingSearchV2Headers() = default;
};
class FlightListingSearchV2RequestSearchJourneysSelectedFlights : public Darabonba::Model {
public:
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> flightTime{};
  shared_ptr<string> marketFlightNo{};
  shared_ptr<string> operateFlightNo{};

  FlightListingSearchV2RequestSearchJourneysSelectedFlights() {}

  explicit FlightListingSearchV2RequestSearchJourneysSelectedFlights(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (flightTime) {
      res["flight_time"] = boost::any(*flightTime);
    }
    if (marketFlightNo) {
      res["market_flight_no"] = boost::any(*marketFlightNo);
    }
    if (operateFlightNo) {
      res["operate_flight_no"] = boost::any(*operateFlightNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("flight_time") != m.end() && !m["flight_time"].empty()) {
      flightTime = make_shared<string>(boost::any_cast<string>(m["flight_time"]));
    }
    if (m.find("market_flight_no") != m.end() && !m["market_flight_no"].empty()) {
      marketFlightNo = make_shared<string>(boost::any_cast<string>(m["market_flight_no"]));
    }
    if (m.find("operate_flight_no") != m.end() && !m["operate_flight_no"].empty()) {
      operateFlightNo = make_shared<string>(boost::any_cast<string>(m["operate_flight_no"]));
    }
  }


  virtual ~FlightListingSearchV2RequestSearchJourneysSelectedFlights() = default;
};
class FlightListingSearchV2RequestSearchJourneys : public Darabonba::Model {
public:
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<vector<FlightListingSearchV2RequestSearchJourneysSelectedFlights>> selectedFlights{};

  FlightListingSearchV2RequestSearchJourneys() {}

  explicit FlightListingSearchV2RequestSearchJourneys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (selectedFlights) {
      vector<boost::any> temp1;
      for(auto item1:*selectedFlights){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["selected_flights"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("selected_flights") != m.end() && !m["selected_flights"].empty()) {
      if (typeid(vector<boost::any>) == m["selected_flights"].type()) {
        vector<FlightListingSearchV2RequestSearchJourneysSelectedFlights> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["selected_flights"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchV2RequestSearchJourneysSelectedFlights model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        selectedFlights = make_shared<vector<FlightListingSearchV2RequestSearchJourneysSelectedFlights>>(expect1);
      }
    }
  }


  virtual ~FlightListingSearchV2RequestSearchJourneys() = default;
};
class FlightListingSearchV2Request : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<vector<long>> cabinTypeList{};
  shared_ptr<bool> directOnly{};
  shared_ptr<string> isvName{};
  shared_ptr<bool> needMultiClassPrice{};
  shared_ptr<bool> needQueryServiceFee{};
  shared_ptr<bool> needShareFlight{};
  shared_ptr<bool> needYCBestPrice{};
  shared_ptr<vector<FlightListingSearchV2RequestSearchJourneys>> searchJourneys{};
  shared_ptr<long> searchMode{};
  shared_ptr<long> tripType{};

  FlightListingSearchV2Request() {}

  explicit FlightListingSearchV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (cabinTypeList) {
      res["cabin_type_list"] = boost::any(*cabinTypeList);
    }
    if (directOnly) {
      res["direct_only"] = boost::any(*directOnly);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (needMultiClassPrice) {
      res["need_multi_class_price"] = boost::any(*needMultiClassPrice);
    }
    if (needQueryServiceFee) {
      res["need_query_service_fee"] = boost::any(*needQueryServiceFee);
    }
    if (needShareFlight) {
      res["need_share_flight"] = boost::any(*needShareFlight);
    }
    if (needYCBestPrice) {
      res["need_y_c_best_price"] = boost::any(*needYCBestPrice);
    }
    if (searchJourneys) {
      vector<boost::any> temp1;
      for(auto item1:*searchJourneys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["search_journeys"] = boost::any(temp1);
    }
    if (searchMode) {
      res["search_mode"] = boost::any(*searchMode);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("cabin_type_list") != m.end() && !m["cabin_type_list"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["cabin_type_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["cabin_type_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      cabinTypeList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("direct_only") != m.end() && !m["direct_only"].empty()) {
      directOnly = make_shared<bool>(boost::any_cast<bool>(m["direct_only"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("need_multi_class_price") != m.end() && !m["need_multi_class_price"].empty()) {
      needMultiClassPrice = make_shared<bool>(boost::any_cast<bool>(m["need_multi_class_price"]));
    }
    if (m.find("need_query_service_fee") != m.end() && !m["need_query_service_fee"].empty()) {
      needQueryServiceFee = make_shared<bool>(boost::any_cast<bool>(m["need_query_service_fee"]));
    }
    if (m.find("need_share_flight") != m.end() && !m["need_share_flight"].empty()) {
      needShareFlight = make_shared<bool>(boost::any_cast<bool>(m["need_share_flight"]));
    }
    if (m.find("need_y_c_best_price") != m.end() && !m["need_y_c_best_price"].empty()) {
      needYCBestPrice = make_shared<bool>(boost::any_cast<bool>(m["need_y_c_best_price"]));
    }
    if (m.find("search_journeys") != m.end() && !m["search_journeys"].empty()) {
      if (typeid(vector<boost::any>) == m["search_journeys"].type()) {
        vector<FlightListingSearchV2RequestSearchJourneys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["search_journeys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchV2RequestSearchJourneys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchJourneys = make_shared<vector<FlightListingSearchV2RequestSearchJourneys>>(expect1);
      }
    }
    if (m.find("search_mode") != m.end() && !m["search_mode"].empty()) {
      searchMode = make_shared<long>(boost::any_cast<long>(m["search_mode"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightListingSearchV2Request() = default;
};
class FlightListingSearchV2ShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> cabinTypeListShrink{};
  shared_ptr<bool> directOnly{};
  shared_ptr<string> isvName{};
  shared_ptr<bool> needMultiClassPrice{};
  shared_ptr<bool> needQueryServiceFee{};
  shared_ptr<bool> needShareFlight{};
  shared_ptr<bool> needYCBestPrice{};
  shared_ptr<string> searchJourneysShrink{};
  shared_ptr<long> searchMode{};
  shared_ptr<long> tripType{};

  FlightListingSearchV2ShrinkRequest() {}

  explicit FlightListingSearchV2ShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (cabinTypeListShrink) {
      res["cabin_type_list"] = boost::any(*cabinTypeListShrink);
    }
    if (directOnly) {
      res["direct_only"] = boost::any(*directOnly);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (needMultiClassPrice) {
      res["need_multi_class_price"] = boost::any(*needMultiClassPrice);
    }
    if (needQueryServiceFee) {
      res["need_query_service_fee"] = boost::any(*needQueryServiceFee);
    }
    if (needShareFlight) {
      res["need_share_flight"] = boost::any(*needShareFlight);
    }
    if (needYCBestPrice) {
      res["need_y_c_best_price"] = boost::any(*needYCBestPrice);
    }
    if (searchJourneysShrink) {
      res["search_journeys"] = boost::any(*searchJourneysShrink);
    }
    if (searchMode) {
      res["search_mode"] = boost::any(*searchMode);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("cabin_type_list") != m.end() && !m["cabin_type_list"].empty()) {
      cabinTypeListShrink = make_shared<string>(boost::any_cast<string>(m["cabin_type_list"]));
    }
    if (m.find("direct_only") != m.end() && !m["direct_only"].empty()) {
      directOnly = make_shared<bool>(boost::any_cast<bool>(m["direct_only"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("need_multi_class_price") != m.end() && !m["need_multi_class_price"].empty()) {
      needMultiClassPrice = make_shared<bool>(boost::any_cast<bool>(m["need_multi_class_price"]));
    }
    if (m.find("need_query_service_fee") != m.end() && !m["need_query_service_fee"].empty()) {
      needQueryServiceFee = make_shared<bool>(boost::any_cast<bool>(m["need_query_service_fee"]));
    }
    if (m.find("need_share_flight") != m.end() && !m["need_share_flight"].empty()) {
      needShareFlight = make_shared<bool>(boost::any_cast<bool>(m["need_share_flight"]));
    }
    if (m.find("need_y_c_best_price") != m.end() && !m["need_y_c_best_price"].empty()) {
      needYCBestPrice = make_shared<bool>(boost::any_cast<bool>(m["need_y_c_best_price"]));
    }
    if (m.find("search_journeys") != m.end() && !m["search_journeys"].empty()) {
      searchJourneysShrink = make_shared<string>(boost::any_cast<string>(m["search_journeys"]));
    }
    if (m.find("search_mode") != m.end() && !m["search_mode"].empty()) {
      searchMode = make_shared<long>(boost::any_cast<long>(m["search_mode"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightListingSearchV2ShrinkRequest() = default;
};
class FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItemSubItems : public Darabonba::Model {
public:
  shared_ptr<map<string, ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValue>> shoppingItemMap{};
  shared_ptr<string> uniqKey{};

  FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItemSubItems() {}

  explicit FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItemSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (shoppingItemMap) {
      map<string, boost::any> temp1;
      for(auto item1:*shoppingItemMap){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["shopping_item_map"] = boost::any(temp1);
    }
    if (uniqKey) {
      res["uniq_key"] = boost::any(*uniqKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("shopping_item_map") != m.end() && !m["shopping_item_map"].empty()) {
      if (typeid(map<string, boost::any>) == m["shopping_item_map"].type()) {
        map<string, ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["shopping_item_map"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        shoppingItemMap = make_shared<map<string, ModuleFlightItemListBestPriceItemSubItemsShoppingItemMapValue>>(expect1);
      }
    }
    if (m.find("uniq_key") != m.end() && !m["uniq_key"].empty()) {
      uniqKey = make_shared<string>(boost::any_cast<string>(m["uniq_key"]));
    }
  }


  virtual ~FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItemSubItems() = default;
};
class FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItem : public Darabonba::Model {
public:
  shared_ptr<map<string, ModuleFlightItemListBestPriceItemFlightRuleInfosValue>> flightRuleInfos{};
  shared_ptr<string> itemId{};
  shared_ptr<map<string, ModuleFlightItemListBestPriceItemShoppingItemMapValue>> shoppingItemMap{};
  shared_ptr<map<string, vector<ModuleFlightItemListBestPriceItemSubItemPositionMapValue>>> subItemPositionMap{};
  shared_ptr<vector<FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItemSubItems>> subItems{};

  FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItem() {}

  explicit FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightRuleInfos) {
      map<string, boost::any> temp1;
      for(auto item1:*flightRuleInfos){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["flight_rule_infos"] = boost::any(temp1);
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (shoppingItemMap) {
      map<string, boost::any> temp1;
      for(auto item1:*shoppingItemMap){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["shopping_item_map"] = boost::any(temp1);
    }
    if (subItemPositionMap) {
      map<string, boost::any> temp1;
      for(auto item1:*subItemPositionMap){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["sub_item_position_map"] = boost::any(temp1);
    }
    if (subItems) {
      vector<boost::any> temp1;
      for(auto item1:*subItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["sub_items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_rule_infos") != m.end() && !m["flight_rule_infos"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_rule_infos"].type()) {
        map<string, ModuleFlightItemListBestPriceItemFlightRuleInfosValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["flight_rule_infos"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleFlightItemListBestPriceItemFlightRuleInfosValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        flightRuleInfos = make_shared<map<string, ModuleFlightItemListBestPriceItemFlightRuleInfosValue>>(expect1);
      }
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["item_id"]));
    }
    if (m.find("shopping_item_map") != m.end() && !m["shopping_item_map"].empty()) {
      if (typeid(map<string, boost::any>) == m["shopping_item_map"].type()) {
        map<string, ModuleFlightItemListBestPriceItemShoppingItemMapValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["shopping_item_map"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleFlightItemListBestPriceItemShoppingItemMapValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        shoppingItemMap = make_shared<map<string, ModuleFlightItemListBestPriceItemShoppingItemMapValue>>(expect1);
      }
    }
    if (m.find("sub_item_position_map") != m.end() && !m["sub_item_position_map"].empty()) {
      if (typeid(map<string, boost::any>) == m["sub_item_position_map"].type()) {
        map<string, vector<ModuleFlightItemListBestPriceItemSubItemPositionMapValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["sub_item_position_map"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<ModuleFlightItemListBestPriceItemSubItemPositionMapValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                ModuleFlightItemListBestPriceItemSubItemPositionMapValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        subItemPositionMap = make_shared<map<string, vector<ModuleFlightItemListBestPriceItemSubItemPositionMapValue>>>(expect1);
      }
    }
    if (m.find("sub_items") != m.end() && !m["sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["sub_items"].type()) {
        vector<FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItemSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItemSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subItems = make_shared<vector<FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItemSubItems>>(expect1);
      }
    }
  }


  virtual ~FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItem() = default;
};
class FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineChineseName{};
  shared_ptr<string> airlineChineseShortName{};
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineIcon{};
  shared_ptr<bool> cheapFlight{};

  FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosAirlineInfo() {}

  explicit FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineChineseName) {
      res["airline_chinese_name"] = boost::any(*airlineChineseName);
    }
    if (airlineChineseShortName) {
      res["airline_chinese_short_name"] = boost::any(*airlineChineseShortName);
    }
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineIcon) {
      res["airline_icon"] = boost::any(*airlineIcon);
    }
    if (cheapFlight) {
      res["cheap_flight"] = boost::any(*cheapFlight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_chinese_name") != m.end() && !m["airline_chinese_name"].empty()) {
      airlineChineseName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_name"]));
    }
    if (m.find("airline_chinese_short_name") != m.end() && !m["airline_chinese_short_name"].empty()) {
      airlineChineseShortName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_short_name"]));
    }
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_icon") != m.end() && !m["airline_icon"].empty()) {
      airlineIcon = make_shared<string>(boost::any_cast<string>(m["airline_icon"]));
    }
    if (m.find("cheap_flight") != m.end() && !m["cheap_flight"].empty()) {
      cheapFlight = make_shared<bool>(boost::any_cast<bool>(m["cheap_flight"]));
    }
  }


  virtual ~FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosAirlineInfo() = default;
};
class FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> airportNameColor{};
  shared_ptr<string> airportShortName{};
  shared_ptr<string> terminal{};

  FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosArrAirportInfo() {}

  explicit FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (airportNameColor) {
      res["airport_name_color"] = boost::any(*airportNameColor);
    }
    if (airportShortName) {
      res["airport_short_name"] = boost::any(*airportShortName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("airport_name_color") != m.end() && !m["airport_name_color"].empty()) {
      airportNameColor = make_shared<string>(boost::any_cast<string>(m["airport_name_color"]));
    }
    if (m.find("airport_short_name") != m.end() && !m["airport_short_name"].empty()) {
      airportShortName = make_shared<string>(boost::any_cast<string>(m["airport_short_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosArrAirportInfo() = default;
};
class FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> airportNameColor{};
  shared_ptr<string> airportShortName{};
  shared_ptr<string> terminal{};

  FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosDepAirportInfo() {}

  explicit FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (airportNameColor) {
      res["airport_name_color"] = boost::any(*airportNameColor);
    }
    if (airportShortName) {
      res["airport_short_name"] = boost::any(*airportShortName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("airport_name_color") != m.end() && !m["airport_name_color"].empty()) {
      airportNameColor = make_shared<string>(boost::any_cast<string>(m["airport_name_color"]));
    }
    if (m.find("airport_short_name") != m.end() && !m["airport_short_name"].empty()) {
      airportShortName = make_shared<string>(boost::any_cast<string>(m["airport_short_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosDepAirportInfo() = default;
};
class FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightShareInfoOperatingAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineChineseName{};
  shared_ptr<string> airlineChineseShortName{};
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineIcon{};
  shared_ptr<bool> cheapFlight{};

  FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightShareInfoOperatingAirlineInfo() {}

  explicit FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightShareInfoOperatingAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineChineseName) {
      res["airline_chinese_name"] = boost::any(*airlineChineseName);
    }
    if (airlineChineseShortName) {
      res["airline_chinese_short_name"] = boost::any(*airlineChineseShortName);
    }
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineIcon) {
      res["airline_icon"] = boost::any(*airlineIcon);
    }
    if (cheapFlight) {
      res["cheap_flight"] = boost::any(*cheapFlight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_chinese_name") != m.end() && !m["airline_chinese_name"].empty()) {
      airlineChineseName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_name"]));
    }
    if (m.find("airline_chinese_short_name") != m.end() && !m["airline_chinese_short_name"].empty()) {
      airlineChineseShortName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_short_name"]));
    }
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_icon") != m.end() && !m["airline_icon"].empty()) {
      airlineIcon = make_shared<string>(boost::any_cast<string>(m["airline_icon"]));
    }
    if (m.find("cheap_flight") != m.end() && !m["cheap_flight"].empty()) {
      cheapFlight = make_shared<bool>(boost::any_cast<bool>(m["cheap_flight"]));
    }
  }


  virtual ~FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightShareInfoOperatingAirlineInfo() = default;
};
class FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightShareInfo : public Darabonba::Model {
public:
  shared_ptr<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightShareInfoOperatingAirlineInfo> operatingAirlineInfo{};
  shared_ptr<string> operatingFlightNo{};

  FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightShareInfo() {}

  explicit FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightShareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operatingAirlineInfo) {
      res["operating_airline_info"] = operatingAirlineInfo ? boost::any(operatingAirlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operatingFlightNo) {
      res["operating_flight_no"] = boost::any(*operatingFlightNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("operating_airline_info") != m.end() && !m["operating_airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["operating_airline_info"].type()) {
        FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightShareInfoOperatingAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["operating_airline_info"]));
        operatingAirlineInfo = make_shared<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightShareInfoOperatingAirlineInfo>(model1);
      }
    }
    if (m.find("operating_flight_no") != m.end() && !m["operating_flight_no"].empty()) {
      operatingFlightNo = make_shared<string>(boost::any_cast<string>(m["operating_flight_no"]));
    }
  }


  virtual ~FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightShareInfo() = default;
};
class FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightStopInfo : public Darabonba::Model {
public:
  shared_ptr<string> stopAirport{};
  shared_ptr<string> stopAirportName{};
  shared_ptr<string> stopArrTerm{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCityCode{};
  shared_ptr<string> stopCityName{};
  shared_ptr<vector<string>> stopCityNames{};
  shared_ptr<string> stopDepTerm{};
  shared_ptr<string> stopDepTime{};
  shared_ptr<string> stopTime{};

  FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightStopInfo() {}

  explicit FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightStopInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stopAirport) {
      res["stop_airport"] = boost::any(*stopAirport);
    }
    if (stopAirportName) {
      res["stop_airport_name"] = boost::any(*stopAirportName);
    }
    if (stopArrTerm) {
      res["stop_arr_term"] = boost::any(*stopArrTerm);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCityCode) {
      res["stop_city_code"] = boost::any(*stopCityCode);
    }
    if (stopCityName) {
      res["stop_city_name"] = boost::any(*stopCityName);
    }
    if (stopCityNames) {
      res["stop_city_names"] = boost::any(*stopCityNames);
    }
    if (stopDepTerm) {
      res["stop_dep_term"] = boost::any(*stopDepTerm);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    if (stopTime) {
      res["stop_time"] = boost::any(*stopTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("stop_airport") != m.end() && !m["stop_airport"].empty()) {
      stopAirport = make_shared<string>(boost::any_cast<string>(m["stop_airport"]));
    }
    if (m.find("stop_airport_name") != m.end() && !m["stop_airport_name"].empty()) {
      stopAirportName = make_shared<string>(boost::any_cast<string>(m["stop_airport_name"]));
    }
    if (m.find("stop_arr_term") != m.end() && !m["stop_arr_term"].empty()) {
      stopArrTerm = make_shared<string>(boost::any_cast<string>(m["stop_arr_term"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city_code") != m.end() && !m["stop_city_code"].empty()) {
      stopCityCode = make_shared<string>(boost::any_cast<string>(m["stop_city_code"]));
    }
    if (m.find("stop_city_name") != m.end() && !m["stop_city_name"].empty()) {
      stopCityName = make_shared<string>(boost::any_cast<string>(m["stop_city_name"]));
    }
    if (m.find("stop_city_names") != m.end() && !m["stop_city_names"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["stop_city_names"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["stop_city_names"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      stopCityNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("stop_dep_term") != m.end() && !m["stop_dep_term"].empty()) {
      stopDepTerm = make_shared<string>(boost::any_cast<string>(m["stop_dep_term"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
    if (m.find("stop_time") != m.end() && !m["stop_time"].empty()) {
      stopTime = make_shared<string>(boost::any_cast<string>(m["stop_time"]));
    }
  }


  virtual ~FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightStopInfo() = default;
};
class FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfos : public Darabonba::Model {
public:
  shared_ptr<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosAirlineInfo> airlineInfo{};
  shared_ptr<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosArrAirportInfo> arrAirportInfo{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> baggageDesc{};
  shared_ptr<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosDepAirportInfo> depAirportInfo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depTime{};
  shared_ptr<long> duration{};
  shared_ptr<map<string, boost::any>> extraInfo{};
  shared_ptr<string> flightNo{};
  shared_ptr<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightShareInfo> flightShareInfo{};
  shared_ptr<string> flightSize{};
  shared_ptr<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightStopInfo> flightStopInfo{};
  shared_ptr<string> flightType{};
  shared_ptr<string> manufacturer{};
  shared_ptr<string> mealDesc{};
  shared_ptr<long> miles{};
  shared_ptr<string> onTimeRate{};
  shared_ptr<long> oneMore{};
  shared_ptr<string> oneMoreShow{};
  shared_ptr<long> segmentIndex{};
  shared_ptr<bool> share{};
  shared_ptr<string> shortFlightSize{};
  shared_ptr<bool> stop{};
  shared_ptr<string> totalTime{};
  shared_ptr<string> transferTime{};
  shared_ptr<long> transferTimeNumber{};

  FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfos() {}

  explicit FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (extraInfo) {
      res["extra_info"] = boost::any(*extraInfo);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightShareInfo) {
      res["flight_share_info"] = flightShareInfo ? boost::any(flightShareInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (flightStopInfo) {
      res["flight_stop_info"] = flightStopInfo ? boost::any(flightStopInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (manufacturer) {
      res["manufacturer"] = boost::any(*manufacturer);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (miles) {
      res["miles"] = boost::any(*miles);
    }
    if (onTimeRate) {
      res["on_time_rate"] = boost::any(*onTimeRate);
    }
    if (oneMore) {
      res["one_more"] = boost::any(*oneMore);
    }
    if (oneMoreShow) {
      res["one_more_show"] = boost::any(*oneMoreShow);
    }
    if (segmentIndex) {
      res["segment_index"] = boost::any(*segmentIndex);
    }
    if (share) {
      res["share"] = boost::any(*share);
    }
    if (shortFlightSize) {
      res["short_flight_size"] = boost::any(*shortFlightSize);
    }
    if (stop) {
      res["stop"] = boost::any(*stop);
    }
    if (totalTime) {
      res["total_time"] = boost::any(*totalTime);
    }
    if (transferTime) {
      res["transfer_time"] = boost::any(*transferTime);
    }
    if (transferTimeNumber) {
      res["transfer_time_number"] = boost::any(*transferTimeNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosAirlineInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosArrAirportInfo>(model1);
      }
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      baggageDesc = make_shared<string>(boost::any_cast<string>(m["baggage_desc"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosDepAirportInfo>(model1);
      }
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("extra_info") != m.end() && !m["extra_info"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["extra_info"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_share_info") != m.end() && !m["flight_share_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_share_info"].type()) {
        FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightShareInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flight_share_info"]));
        flightShareInfo = make_shared<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightShareInfo>(model1);
      }
    }
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("flight_stop_info") != m.end() && !m["flight_stop_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_stop_info"].type()) {
        FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightStopInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flight_stop_info"]));
        flightStopInfo = make_shared<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfosFlightStopInfo>(model1);
      }
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("manufacturer") != m.end() && !m["manufacturer"].empty()) {
      manufacturer = make_shared<string>(boost::any_cast<string>(m["manufacturer"]));
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("miles") != m.end() && !m["miles"].empty()) {
      miles = make_shared<long>(boost::any_cast<long>(m["miles"]));
    }
    if (m.find("on_time_rate") != m.end() && !m["on_time_rate"].empty()) {
      onTimeRate = make_shared<string>(boost::any_cast<string>(m["on_time_rate"]));
    }
    if (m.find("one_more") != m.end() && !m["one_more"].empty()) {
      oneMore = make_shared<long>(boost::any_cast<long>(m["one_more"]));
    }
    if (m.find("one_more_show") != m.end() && !m["one_more_show"].empty()) {
      oneMoreShow = make_shared<string>(boost::any_cast<string>(m["one_more_show"]));
    }
    if (m.find("segment_index") != m.end() && !m["segment_index"].empty()) {
      segmentIndex = make_shared<long>(boost::any_cast<long>(m["segment_index"]));
    }
    if (m.find("share") != m.end() && !m["share"].empty()) {
      share = make_shared<bool>(boost::any_cast<bool>(m["share"]));
    }
    if (m.find("short_flight_size") != m.end() && !m["short_flight_size"].empty()) {
      shortFlightSize = make_shared<string>(boost::any_cast<string>(m["short_flight_size"]));
    }
    if (m.find("stop") != m.end() && !m["stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["stop"]));
    }
    if (m.find("total_time") != m.end() && !m["total_time"].empty()) {
      totalTime = make_shared<string>(boost::any_cast<string>(m["total_time"]));
    }
    if (m.find("transfer_time") != m.end() && !m["transfer_time"].empty()) {
      transferTime = make_shared<string>(boost::any_cast<string>(m["transfer_time"]));
    }
    if (m.find("transfer_time_number") != m.end() && !m["transfer_time_number"].empty()) {
      transferTimeNumber = make_shared<long>(boost::any_cast<long>(m["transfer_time_number"]));
    }
  }


  virtual ~FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfos() = default;
};
class FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfos : public Darabonba::Model {
public:
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depTime{};
  shared_ptr<long> duration{};
  shared_ptr<map<string, string>> extensions{};
  shared_ptr<vector<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfos>> flightSegmentInfos{};
  shared_ptr<long> journeyIndex{};
  shared_ptr<long> transferTime{};

  FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfos() {}

  explicit FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (extensions) {
      res["extensions"] = boost::any(*extensions);
    }
    if (flightSegmentInfos) {
      vector<boost::any> temp1;
      for(auto item1:*flightSegmentInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_segment_infos"] = boost::any(temp1);
    }
    if (journeyIndex) {
      res["journey_index"] = boost::any(*journeyIndex);
    }
    if (transferTime) {
      res["transfer_time"] = boost::any(*transferTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("extensions") != m.end() && !m["extensions"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["extensions"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extensions = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("flight_segment_infos") != m.end() && !m["flight_segment_infos"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_segment_infos"].type()) {
        vector<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_segment_infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightSegmentInfos = make_shared<vector<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfosFlightSegmentInfos>>(expect1);
      }
    }
    if (m.find("journey_index") != m.end() && !m["journey_index"].empty()) {
      journeyIndex = make_shared<long>(boost::any_cast<long>(m["journey_index"]));
    }
    if (m.find("transfer_time") != m.end() && !m["transfer_time"].empty()) {
      transferTime = make_shared<long>(boost::any_cast<long>(m["transfer_time"]));
    }
  }


  virtual ~FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfos() = default;
};
class FlightListingSearchV2ResponseBodyModuleFlightItemListItemListSubItems : public Darabonba::Model {
public:
  shared_ptr<map<string, ModuleFlightItemListItemListSubItemsShoppingItemMapValue>> shoppingItemMap{};
  shared_ptr<string> uniqKey{};

  FlightListingSearchV2ResponseBodyModuleFlightItemListItemListSubItems() {}

  explicit FlightListingSearchV2ResponseBodyModuleFlightItemListItemListSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (shoppingItemMap) {
      map<string, boost::any> temp1;
      for(auto item1:*shoppingItemMap){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["shopping_item_map"] = boost::any(temp1);
    }
    if (uniqKey) {
      res["uniq_key"] = boost::any(*uniqKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("shopping_item_map") != m.end() && !m["shopping_item_map"].empty()) {
      if (typeid(map<string, boost::any>) == m["shopping_item_map"].type()) {
        map<string, ModuleFlightItemListItemListSubItemsShoppingItemMapValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["shopping_item_map"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleFlightItemListItemListSubItemsShoppingItemMapValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        shoppingItemMap = make_shared<map<string, ModuleFlightItemListItemListSubItemsShoppingItemMapValue>>(expect1);
      }
    }
    if (m.find("uniq_key") != m.end() && !m["uniq_key"].empty()) {
      uniqKey = make_shared<string>(boost::any_cast<string>(m["uniq_key"]));
    }
  }


  virtual ~FlightListingSearchV2ResponseBodyModuleFlightItemListItemListSubItems() = default;
};
class FlightListingSearchV2ResponseBodyModuleFlightItemListItemList : public Darabonba::Model {
public:
  shared_ptr<map<string, ModuleFlightItemListItemListFlightRuleInfosValue>> flightRuleInfos{};
  shared_ptr<string> itemId{};
  shared_ptr<map<string, ModuleFlightItemListItemListShoppingItemMapValue>> shoppingItemMap{};
  shared_ptr<map<string, vector<ModuleFlightItemListItemListSubItemPositionMapValue>>> subItemPositionMap{};
  shared_ptr<vector<FlightListingSearchV2ResponseBodyModuleFlightItemListItemListSubItems>> subItems{};

  FlightListingSearchV2ResponseBodyModuleFlightItemListItemList() {}

  explicit FlightListingSearchV2ResponseBodyModuleFlightItemListItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightRuleInfos) {
      map<string, boost::any> temp1;
      for(auto item1:*flightRuleInfos){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["flight_rule_infos"] = boost::any(temp1);
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (shoppingItemMap) {
      map<string, boost::any> temp1;
      for(auto item1:*shoppingItemMap){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["shopping_item_map"] = boost::any(temp1);
    }
    if (subItemPositionMap) {
      map<string, boost::any> temp1;
      for(auto item1:*subItemPositionMap){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["sub_item_position_map"] = boost::any(temp1);
    }
    if (subItems) {
      vector<boost::any> temp1;
      for(auto item1:*subItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["sub_items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_rule_infos") != m.end() && !m["flight_rule_infos"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_rule_infos"].type()) {
        map<string, ModuleFlightItemListItemListFlightRuleInfosValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["flight_rule_infos"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleFlightItemListItemListFlightRuleInfosValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        flightRuleInfos = make_shared<map<string, ModuleFlightItemListItemListFlightRuleInfosValue>>(expect1);
      }
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["item_id"]));
    }
    if (m.find("shopping_item_map") != m.end() && !m["shopping_item_map"].empty()) {
      if (typeid(map<string, boost::any>) == m["shopping_item_map"].type()) {
        map<string, ModuleFlightItemListItemListShoppingItemMapValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["shopping_item_map"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleFlightItemListItemListShoppingItemMapValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        shoppingItemMap = make_shared<map<string, ModuleFlightItemListItemListShoppingItemMapValue>>(expect1);
      }
    }
    if (m.find("sub_item_position_map") != m.end() && !m["sub_item_position_map"].empty()) {
      if (typeid(map<string, boost::any>) == m["sub_item_position_map"].type()) {
        map<string, vector<ModuleFlightItemListItemListSubItemPositionMapValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["sub_item_position_map"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<ModuleFlightItemListItemListSubItemPositionMapValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                ModuleFlightItemListItemListSubItemPositionMapValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        subItemPositionMap = make_shared<map<string, vector<ModuleFlightItemListItemListSubItemPositionMapValue>>>(expect1);
      }
    }
    if (m.find("sub_items") != m.end() && !m["sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["sub_items"].type()) {
        vector<FlightListingSearchV2ResponseBodyModuleFlightItemListItemListSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchV2ResponseBodyModuleFlightItemListItemListSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subItems = make_shared<vector<FlightListingSearchV2ResponseBodyModuleFlightItemListItemListSubItems>>(expect1);
      }
    }
  }


  virtual ~FlightListingSearchV2ResponseBodyModuleFlightItemListItemList() = default;
};
class FlightListingSearchV2ResponseBodyModuleFlightItemList : public Darabonba::Model {
public:
  shared_ptr<FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItem> bestPriceItem{};
  shared_ptr<vector<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfos>> flightJourneyInfos{};
  shared_ptr<vector<FlightListingSearchV2ResponseBodyModuleFlightItemListItemList>> itemList{};

  FlightListingSearchV2ResponseBodyModuleFlightItemList() {}

  explicit FlightListingSearchV2ResponseBodyModuleFlightItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bestPriceItem) {
      res["best_price_item"] = bestPriceItem ? boost::any(bestPriceItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightJourneyInfos) {
      vector<boost::any> temp1;
      for(auto item1:*flightJourneyInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_journey_infos"] = boost::any(temp1);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["item_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("best_price_item") != m.end() && !m["best_price_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["best_price_item"].type()) {
        FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["best_price_item"]));
        bestPriceItem = make_shared<FlightListingSearchV2ResponseBodyModuleFlightItemListBestPriceItem>(model1);
      }
    }
    if (m.find("flight_journey_infos") != m.end() && !m["flight_journey_infos"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_journey_infos"].type()) {
        vector<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_journey_infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightJourneyInfos = make_shared<vector<FlightListingSearchV2ResponseBodyModuleFlightItemListFlightJourneyInfos>>(expect1);
      }
    }
    if (m.find("item_list") != m.end() && !m["item_list"].empty()) {
      if (typeid(vector<boost::any>) == m["item_list"].type()) {
        vector<FlightListingSearchV2ResponseBodyModuleFlightItemListItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["item_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchV2ResponseBodyModuleFlightItemListItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<FlightListingSearchV2ResponseBodyModuleFlightItemListItemList>>(expect1);
      }
    }
  }


  virtual ~FlightListingSearchV2ResponseBodyModuleFlightItemList() = default;
};
class FlightListingSearchV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightListingSearchV2ResponseBodyModuleFlightItemList>> flightItemList{};
  shared_ptr<long> searchMode{};
  shared_ptr<long> tripType{};

  FlightListingSearchV2ResponseBodyModule() {}

  explicit FlightListingSearchV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightItemList) {
      vector<boost::any> temp1;
      for(auto item1:*flightItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_item_list"] = boost::any(temp1);
    }
    if (searchMode) {
      res["search_mode"] = boost::any(*searchMode);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_item_list") != m.end() && !m["flight_item_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_item_list"].type()) {
        vector<FlightListingSearchV2ResponseBodyModuleFlightItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_item_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightListingSearchV2ResponseBodyModuleFlightItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightItemList = make_shared<vector<FlightListingSearchV2ResponseBodyModuleFlightItemList>>(expect1);
      }
    }
    if (m.find("search_mode") != m.end() && !m["search_mode"].empty()) {
      searchMode = make_shared<long>(boost::any_cast<long>(m["search_mode"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightListingSearchV2ResponseBodyModule() = default;
};
class FlightListingSearchV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightListingSearchV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightListingSearchV2ResponseBody() {}

  explicit FlightListingSearchV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightListingSearchV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightListingSearchV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightListingSearchV2ResponseBody() = default;
};
class FlightListingSearchV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightListingSearchV2ResponseBody> body{};

  FlightListingSearchV2Response() {}

  explicit FlightListingSearchV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightListingSearchV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightListingSearchV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightListingSearchV2Response() = default;
};
class FlightModifyApplyV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightModifyApplyV2Headers() {}

  explicit FlightModifyApplyV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightModifyApplyV2Headers() = default;
};
class FlightModifyApplyV2RequestPassengerSegmentRelations : public Darabonba::Model {
public:
  shared_ptr<string> passengerId{};
  shared_ptr<vector<string>> segmentIdList{};

  FlightModifyApplyV2RequestPassengerSegmentRelations() {}

  explicit FlightModifyApplyV2RequestPassengerSegmentRelations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passengerId) {
      res["passenger_id"] = boost::any(*passengerId);
    }
    if (segmentIdList) {
      res["segment_id_list"] = boost::any(*segmentIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("passenger_id") != m.end() && !m["passenger_id"].empty()) {
      passengerId = make_shared<string>(boost::any_cast<string>(m["passenger_id"]));
    }
    if (m.find("segment_id_list") != m.end() && !m["segment_id_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["segment_id_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["segment_id_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      segmentIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~FlightModifyApplyV2RequestPassengerSegmentRelations() = default;
};
class FlightModifyApplyV2Request : public Darabonba::Model {
public:
  shared_ptr<string> cacheKey{};
  shared_ptr<string> contactPhone{};
  shared_ptr<string> isvName{};
  shared_ptr<string> itemId{};
  shared_ptr<long> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<vector<FlightModifyApplyV2RequestPassengerSegmentRelations>> passengerSegmentRelations{};
  shared_ptr<string> reason{};
  shared_ptr<string> sessionId{};
  shared_ptr<bool> voluntary{};

  FlightModifyApplyV2Request() {}

  explicit FlightModifyApplyV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheKey) {
      res["cache_key"] = boost::any(*cacheKey);
    }
    if (contactPhone) {
      res["contact_phone"] = boost::any(*contactPhone);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (passengerSegmentRelations) {
      vector<boost::any> temp1;
      for(auto item1:*passengerSegmentRelations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_segment_relations"] = boost::any(temp1);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (voluntary) {
      res["voluntary"] = boost::any(*voluntary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cache_key") != m.end() && !m["cache_key"].empty()) {
      cacheKey = make_shared<string>(boost::any_cast<string>(m["cache_key"]));
    }
    if (m.find("contact_phone") != m.end() && !m["contact_phone"].empty()) {
      contactPhone = make_shared<string>(boost::any_cast<string>(m["contact_phone"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["item_id"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("passenger_segment_relations") != m.end() && !m["passenger_segment_relations"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_segment_relations"].type()) {
        vector<FlightModifyApplyV2RequestPassengerSegmentRelations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_segment_relations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightModifyApplyV2RequestPassengerSegmentRelations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerSegmentRelations = make_shared<vector<FlightModifyApplyV2RequestPassengerSegmentRelations>>(expect1);
      }
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("voluntary") != m.end() && !m["voluntary"].empty()) {
      voluntary = make_shared<bool>(boost::any_cast<bool>(m["voluntary"]));
    }
  }


  virtual ~FlightModifyApplyV2Request() = default;
};
class FlightModifyApplyV2ShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cacheKey{};
  shared_ptr<string> contactPhone{};
  shared_ptr<string> isvName{};
  shared_ptr<string> itemId{};
  shared_ptr<long> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<string> passengerSegmentRelationsShrink{};
  shared_ptr<string> reason{};
  shared_ptr<string> sessionId{};
  shared_ptr<bool> voluntary{};

  FlightModifyApplyV2ShrinkRequest() {}

  explicit FlightModifyApplyV2ShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cacheKey) {
      res["cache_key"] = boost::any(*cacheKey);
    }
    if (contactPhone) {
      res["contact_phone"] = boost::any(*contactPhone);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (passengerSegmentRelationsShrink) {
      res["passenger_segment_relations"] = boost::any(*passengerSegmentRelationsShrink);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (voluntary) {
      res["voluntary"] = boost::any(*voluntary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cache_key") != m.end() && !m["cache_key"].empty()) {
      cacheKey = make_shared<string>(boost::any_cast<string>(m["cache_key"]));
    }
    if (m.find("contact_phone") != m.end() && !m["contact_phone"].empty()) {
      contactPhone = make_shared<string>(boost::any_cast<string>(m["contact_phone"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["item_id"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("passenger_segment_relations") != m.end() && !m["passenger_segment_relations"].empty()) {
      passengerSegmentRelationsShrink = make_shared<string>(boost::any_cast<string>(m["passenger_segment_relations"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("voluntary") != m.end() && !m["voluntary"].empty()) {
      voluntary = make_shared<bool>(boost::any_cast<bool>(m["voluntary"]));
    }
  }


  virtual ~FlightModifyApplyV2ShrinkRequest() = default;
};
class FlightModifyApplyV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<string> subOrderId{};

  FlightModifyApplyV2ResponseBodyModule() {}

  explicit FlightModifyApplyV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<string>(boost::any_cast<string>(m["sub_order_id"]));
    }
  }


  virtual ~FlightModifyApplyV2ResponseBodyModule() = default;
};
class FlightModifyApplyV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightModifyApplyV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightModifyApplyV2ResponseBody() {}

  explicit FlightModifyApplyV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightModifyApplyV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightModifyApplyV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightModifyApplyV2ResponseBody() = default;
};
class FlightModifyApplyV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightModifyApplyV2ResponseBody> body{};

  FlightModifyApplyV2Response() {}

  explicit FlightModifyApplyV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightModifyApplyV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightModifyApplyV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightModifyApplyV2Response() = default;
};
class FlightModifyCancelV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightModifyCancelV2Headers() {}

  explicit FlightModifyCancelV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightModifyCancelV2Headers() = default;
};
class FlightModifyCancelV2Request : public Darabonba::Model {
public:
  shared_ptr<string> isvName{};
  shared_ptr<long> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<long> subOrderId{};

  FlightModifyCancelV2Request() {}

  explicit FlightModifyCancelV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<long>(boost::any_cast<long>(m["sub_order_id"]));
    }
  }


  virtual ~FlightModifyCancelV2Request() = default;
};
class FlightModifyCancelV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<map<string, boost::any>> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightModifyCancelV2ResponseBody() {}

  explicit FlightModifyCancelV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["module"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      module = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightModifyCancelV2ResponseBody() = default;
};
class FlightModifyCancelV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightModifyCancelV2ResponseBody> body{};

  FlightModifyCancelV2Response() {}

  explicit FlightModifyCancelV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightModifyCancelV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightModifyCancelV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightModifyCancelV2Response() = default;
};
class FlightModifyListingSearchV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightModifyListingSearchV2Headers() {}

  explicit FlightModifyListingSearchV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightModifyListingSearchV2Headers() = default;
};
class FlightModifyListingSearchV2RequestPassengerSegmentRelations : public Darabonba::Model {
public:
  shared_ptr<string> passengerId{};
  shared_ptr<vector<string>> segmentIdList{};

  FlightModifyListingSearchV2RequestPassengerSegmentRelations() {}

  explicit FlightModifyListingSearchV2RequestPassengerSegmentRelations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passengerId) {
      res["passenger_id"] = boost::any(*passengerId);
    }
    if (segmentIdList) {
      res["segment_id_list"] = boost::any(*segmentIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("passenger_id") != m.end() && !m["passenger_id"].empty()) {
      passengerId = make_shared<string>(boost::any_cast<string>(m["passenger_id"]));
    }
    if (m.find("segment_id_list") != m.end() && !m["segment_id_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["segment_id_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["segment_id_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      segmentIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~FlightModifyListingSearchV2RequestPassengerSegmentRelations() = default;
};
class FlightModifyListingSearchV2RequestSelectedSegments : public Darabonba::Model {
public:
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDateTime{};
  shared_ptr<long> journeySeq{};
  shared_ptr<string> marketingFlightNo{};
  shared_ptr<string> operatingFlightNo{};
  shared_ptr<long> segmentSeq{};

  FlightModifyListingSearchV2RequestSelectedSegments() {}

  explicit FlightModifyListingSearchV2RequestSelectedSegments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDateTime) {
      res["dep_date_time"] = boost::any(*depDateTime);
    }
    if (journeySeq) {
      res["journey_seq"] = boost::any(*journeySeq);
    }
    if (marketingFlightNo) {
      res["marketing_flight_no"] = boost::any(*marketingFlightNo);
    }
    if (operatingFlightNo) {
      res["operating_flight_no"] = boost::any(*operatingFlightNo);
    }
    if (segmentSeq) {
      res["segment_seq"] = boost::any(*segmentSeq);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date_time") != m.end() && !m["dep_date_time"].empty()) {
      depDateTime = make_shared<string>(boost::any_cast<string>(m["dep_date_time"]));
    }
    if (m.find("journey_seq") != m.end() && !m["journey_seq"].empty()) {
      journeySeq = make_shared<long>(boost::any_cast<long>(m["journey_seq"]));
    }
    if (m.find("marketing_flight_no") != m.end() && !m["marketing_flight_no"].empty()) {
      marketingFlightNo = make_shared<string>(boost::any_cast<string>(m["marketing_flight_no"]));
    }
    if (m.find("operating_flight_no") != m.end() && !m["operating_flight_no"].empty()) {
      operatingFlightNo = make_shared<string>(boost::any_cast<string>(m["operating_flight_no"]));
    }
    if (m.find("segment_seq") != m.end() && !m["segment_seq"].empty()) {
      segmentSeq = make_shared<long>(boost::any_cast<long>(m["segment_seq"]));
    }
  }


  virtual ~FlightModifyListingSearchV2RequestSelectedSegments() = default;
};
class FlightModifyListingSearchV2Request : public Darabonba::Model {
public:
  shared_ptr<vector<long>> cabinClass{};
  shared_ptr<vector<string>> depDate{};
  shared_ptr<string> isvName{};
  shared_ptr<long> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<vector<FlightModifyListingSearchV2RequestPassengerSegmentRelations>> passengerSegmentRelations{};
  shared_ptr<long> searchMode{};
  shared_ptr<vector<FlightModifyListingSearchV2RequestSelectedSegments>> selectedSegments{};
  shared_ptr<string> sessionId{};
  shared_ptr<bool> voluntary{};

  FlightModifyListingSearchV2Request() {}

  explicit FlightModifyListingSearchV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (passengerSegmentRelations) {
      vector<boost::any> temp1;
      for(auto item1:*passengerSegmentRelations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_segment_relations"] = boost::any(temp1);
    }
    if (searchMode) {
      res["search_mode"] = boost::any(*searchMode);
    }
    if (selectedSegments) {
      vector<boost::any> temp1;
      for(auto item1:*selectedSegments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["selected_segments"] = boost::any(temp1);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (voluntary) {
      res["voluntary"] = boost::any(*voluntary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["cabin_class"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["cabin_class"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      cabinClass = make_shared<vector<long>>(toVec1);
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["dep_date"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["dep_date"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      depDate = make_shared<vector<string>>(toVec1);
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("passenger_segment_relations") != m.end() && !m["passenger_segment_relations"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_segment_relations"].type()) {
        vector<FlightModifyListingSearchV2RequestPassengerSegmentRelations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_segment_relations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightModifyListingSearchV2RequestPassengerSegmentRelations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerSegmentRelations = make_shared<vector<FlightModifyListingSearchV2RequestPassengerSegmentRelations>>(expect1);
      }
    }
    if (m.find("search_mode") != m.end() && !m["search_mode"].empty()) {
      searchMode = make_shared<long>(boost::any_cast<long>(m["search_mode"]));
    }
    if (m.find("selected_segments") != m.end() && !m["selected_segments"].empty()) {
      if (typeid(vector<boost::any>) == m["selected_segments"].type()) {
        vector<FlightModifyListingSearchV2RequestSelectedSegments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["selected_segments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightModifyListingSearchV2RequestSelectedSegments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        selectedSegments = make_shared<vector<FlightModifyListingSearchV2RequestSelectedSegments>>(expect1);
      }
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("voluntary") != m.end() && !m["voluntary"].empty()) {
      voluntary = make_shared<bool>(boost::any_cast<bool>(m["voluntary"]));
    }
  }


  virtual ~FlightModifyListingSearchV2Request() = default;
};
class FlightModifyListingSearchV2ShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cabinClassShrink{};
  shared_ptr<string> depDateShrink{};
  shared_ptr<string> isvName{};
  shared_ptr<long> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> passengerSegmentRelationsShrink{};
  shared_ptr<long> searchMode{};
  shared_ptr<string> selectedSegmentsShrink{};
  shared_ptr<string> sessionId{};
  shared_ptr<bool> voluntary{};

  FlightModifyListingSearchV2ShrinkRequest() {}

  explicit FlightModifyListingSearchV2ShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabinClassShrink) {
      res["cabin_class"] = boost::any(*cabinClassShrink);
    }
    if (depDateShrink) {
      res["dep_date"] = boost::any(*depDateShrink);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (passengerSegmentRelationsShrink) {
      res["passenger_segment_relations"] = boost::any(*passengerSegmentRelationsShrink);
    }
    if (searchMode) {
      res["search_mode"] = boost::any(*searchMode);
    }
    if (selectedSegmentsShrink) {
      res["selected_segments"] = boost::any(*selectedSegmentsShrink);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (voluntary) {
      res["voluntary"] = boost::any(*voluntary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClassShrink = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDateShrink = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("passenger_segment_relations") != m.end() && !m["passenger_segment_relations"].empty()) {
      passengerSegmentRelationsShrink = make_shared<string>(boost::any_cast<string>(m["passenger_segment_relations"]));
    }
    if (m.find("search_mode") != m.end() && !m["search_mode"].empty()) {
      searchMode = make_shared<long>(boost::any_cast<long>(m["search_mode"]));
    }
    if (m.find("selected_segments") != m.end() && !m["selected_segments"].empty()) {
      selectedSegmentsShrink = make_shared<string>(boost::any_cast<string>(m["selected_segments"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("voluntary") != m.end() && !m["voluntary"].empty()) {
      voluntary = make_shared<bool>(boost::any_cast<bool>(m["voluntary"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ShrinkRequest() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineChineseName{};
  shared_ptr<string> airlineChineseShortName{};
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineIcon{};
  shared_ptr<bool> cheapFlight{};

  FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListAirlineInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineChineseName) {
      res["airline_chinese_name"] = boost::any(*airlineChineseName);
    }
    if (airlineChineseShortName) {
      res["airline_chinese_short_name"] = boost::any(*airlineChineseShortName);
    }
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineIcon) {
      res["airline_icon"] = boost::any(*airlineIcon);
    }
    if (cheapFlight) {
      res["cheap_flight"] = boost::any(*cheapFlight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_chinese_name") != m.end() && !m["airline_chinese_name"].empty()) {
      airlineChineseName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_name"]));
    }
    if (m.find("airline_chinese_short_name") != m.end() && !m["airline_chinese_short_name"].empty()) {
      airlineChineseShortName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_short_name"]));
    }
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_icon") != m.end() && !m["airline_icon"].empty()) {
      airlineIcon = make_shared<string>(boost::any_cast<string>(m["airline_icon"]));
    }
    if (m.find("cheap_flight") != m.end() && !m["cheap_flight"].empty()) {
      cheapFlight = make_shared<bool>(boost::any_cast<bool>(m["cheap_flight"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListAirlineInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> airportShortName{};
  shared_ptr<string> terminal{};

  FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListArrAirportInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (airportShortName) {
      res["airport_short_name"] = boost::any(*airportShortName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("airport_short_name") != m.end() && !m["airport_short_name"].empty()) {
      airportShortName = make_shared<string>(boost::any_cast<string>(m["airport_short_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListArrAirportInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> airportShortName{};
  shared_ptr<string> terminal{};

  FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListDepAirportInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (airportShortName) {
      res["airport_short_name"] = boost::any(*airportShortName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("airport_short_name") != m.end() && !m["airport_short_name"].empty()) {
      airportShortName = make_shared<string>(boost::any_cast<string>(m["airport_short_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListDepAirportInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightShareInfoOperatingAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineChineseName{};
  shared_ptr<string> airlineChineseShortName{};
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineIcon{};
  shared_ptr<bool> cheapFlight{};

  FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightShareInfoOperatingAirlineInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightShareInfoOperatingAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineChineseName) {
      res["airline_chinese_name"] = boost::any(*airlineChineseName);
    }
    if (airlineChineseShortName) {
      res["airline_chinese_short_name"] = boost::any(*airlineChineseShortName);
    }
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineIcon) {
      res["airline_icon"] = boost::any(*airlineIcon);
    }
    if (cheapFlight) {
      res["cheap_flight"] = boost::any(*cheapFlight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_chinese_name") != m.end() && !m["airline_chinese_name"].empty()) {
      airlineChineseName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_name"]));
    }
    if (m.find("airline_chinese_short_name") != m.end() && !m["airline_chinese_short_name"].empty()) {
      airlineChineseShortName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_short_name"]));
    }
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_icon") != m.end() && !m["airline_icon"].empty()) {
      airlineIcon = make_shared<string>(boost::any_cast<string>(m["airline_icon"]));
    }
    if (m.find("cheap_flight") != m.end() && !m["cheap_flight"].empty()) {
      cheapFlight = make_shared<bool>(boost::any_cast<bool>(m["cheap_flight"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightShareInfoOperatingAirlineInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightShareInfo : public Darabonba::Model {
public:
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightShareInfoOperatingAirlineInfo> operatingAirlineInfo{};
  shared_ptr<string> operatingFlightNo{};

  FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightShareInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightShareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operatingAirlineInfo) {
      res["operating_airline_info"] = operatingAirlineInfo ? boost::any(operatingAirlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operatingFlightNo) {
      res["operating_flight_no"] = boost::any(*operatingFlightNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("operating_airline_info") != m.end() && !m["operating_airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["operating_airline_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightShareInfoOperatingAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["operating_airline_info"]));
        operatingAirlineInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightShareInfoOperatingAirlineInfo>(model1);
      }
    }
    if (m.find("operating_flight_no") != m.end() && !m["operating_flight_no"].empty()) {
      operatingFlightNo = make_shared<string>(boost::any_cast<string>(m["operating_flight_no"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightShareInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightStopInfo : public Darabonba::Model {
public:
  shared_ptr<string> stopAirport{};
  shared_ptr<string> stopArrTerm{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCityCode{};
  shared_ptr<string> stopCityName{};
  shared_ptr<string> stopDepTerm{};
  shared_ptr<string> stopDepTime{};

  FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightStopInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightStopInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stopAirport) {
      res["stop_airport"] = boost::any(*stopAirport);
    }
    if (stopArrTerm) {
      res["stop_arr_term"] = boost::any(*stopArrTerm);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCityCode) {
      res["stop_city_code"] = boost::any(*stopCityCode);
    }
    if (stopCityName) {
      res["stop_city_name"] = boost::any(*stopCityName);
    }
    if (stopDepTerm) {
      res["stop_dep_term"] = boost::any(*stopDepTerm);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("stop_airport") != m.end() && !m["stop_airport"].empty()) {
      stopAirport = make_shared<string>(boost::any_cast<string>(m["stop_airport"]));
    }
    if (m.find("stop_arr_term") != m.end() && !m["stop_arr_term"].empty()) {
      stopArrTerm = make_shared<string>(boost::any_cast<string>(m["stop_arr_term"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city_code") != m.end() && !m["stop_city_code"].empty()) {
      stopCityCode = make_shared<string>(boost::any_cast<string>(m["stop_city_code"]));
    }
    if (m.find("stop_city_name") != m.end() && !m["stop_city_name"].empty()) {
      stopCityName = make_shared<string>(boost::any_cast<string>(m["stop_city_name"]));
    }
    if (m.find("stop_dep_term") != m.end() && !m["stop_dep_term"].empty()) {
      stopDepTerm = make_shared<string>(boost::any_cast<string>(m["stop_dep_term"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightStopInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightTransferInfoTransferAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineChineseName{};
  shared_ptr<string> airlineChineseShortName{};
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineIcon{};
  shared_ptr<bool> cheapFlight{};

  FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightTransferInfoTransferAirlineInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightTransferInfoTransferAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineChineseName) {
      res["airline_chinese_name"] = boost::any(*airlineChineseName);
    }
    if (airlineChineseShortName) {
      res["airline_chinese_short_name"] = boost::any(*airlineChineseShortName);
    }
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineIcon) {
      res["airline_icon"] = boost::any(*airlineIcon);
    }
    if (cheapFlight) {
      res["cheap_flight"] = boost::any(*cheapFlight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_chinese_name") != m.end() && !m["airline_chinese_name"].empty()) {
      airlineChineseName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_name"]));
    }
    if (m.find("airline_chinese_short_name") != m.end() && !m["airline_chinese_short_name"].empty()) {
      airlineChineseShortName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_short_name"]));
    }
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_icon") != m.end() && !m["airline_icon"].empty()) {
      airlineIcon = make_shared<string>(boost::any_cast<string>(m["airline_icon"]));
    }
    if (m.find("cheap_flight") != m.end() && !m["cheap_flight"].empty()) {
      cheapFlight = make_shared<bool>(boost::any_cast<bool>(m["cheap_flight"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightTransferInfoTransferAirlineInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightTransferInfo : public Darabonba::Model {
public:
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightTransferInfoTransferAirlineInfo> transferAirlineInfo{};
  shared_ptr<string> transferCityCode{};
  shared_ptr<string> transferCityName{};
  shared_ptr<string> transferDepTime{};
  shared_ptr<string> transferFlightNo{};
  shared_ptr<string> transferFlightSize{};
  shared_ptr<bool> transferShare{};
  shared_ptr<long> transferStopTime{};

  FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightTransferInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightTransferInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transferAirlineInfo) {
      res["transfer_airline_info"] = transferAirlineInfo ? boost::any(transferAirlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transferCityCode) {
      res["transfer_city_code"] = boost::any(*transferCityCode);
    }
    if (transferCityName) {
      res["transfer_city_name"] = boost::any(*transferCityName);
    }
    if (transferDepTime) {
      res["transfer_dep_time"] = boost::any(*transferDepTime);
    }
    if (transferFlightNo) {
      res["transfer_flight_no"] = boost::any(*transferFlightNo);
    }
    if (transferFlightSize) {
      res["transfer_flight_size"] = boost::any(*transferFlightSize);
    }
    if (transferShare) {
      res["transfer_share"] = boost::any(*transferShare);
    }
    if (transferStopTime) {
      res["transfer_stop_time"] = boost::any(*transferStopTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("transfer_airline_info") != m.end() && !m["transfer_airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["transfer_airline_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightTransferInfoTransferAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["transfer_airline_info"]));
        transferAirlineInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightTransferInfoTransferAirlineInfo>(model1);
      }
    }
    if (m.find("transfer_city_code") != m.end() && !m["transfer_city_code"].empty()) {
      transferCityCode = make_shared<string>(boost::any_cast<string>(m["transfer_city_code"]));
    }
    if (m.find("transfer_city_name") != m.end() && !m["transfer_city_name"].empty()) {
      transferCityName = make_shared<string>(boost::any_cast<string>(m["transfer_city_name"]));
    }
    if (m.find("transfer_dep_time") != m.end() && !m["transfer_dep_time"].empty()) {
      transferDepTime = make_shared<string>(boost::any_cast<string>(m["transfer_dep_time"]));
    }
    if (m.find("transfer_flight_no") != m.end() && !m["transfer_flight_no"].empty()) {
      transferFlightNo = make_shared<string>(boost::any_cast<string>(m["transfer_flight_no"]));
    }
    if (m.find("transfer_flight_size") != m.end() && !m["transfer_flight_size"].empty()) {
      transferFlightSize = make_shared<string>(boost::any_cast<string>(m["transfer_flight_size"]));
    }
    if (m.find("transfer_share") != m.end() && !m["transfer_share"].empty()) {
      transferShare = make_shared<bool>(boost::any_cast<bool>(m["transfer_share"]));
    }
    if (m.find("transfer_stop_time") != m.end() && !m["transfer_stop_time"].empty()) {
      transferStopTime = make_shared<long>(boost::any_cast<long>(m["transfer_stop_time"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightTransferInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListPriceInfoDTOReShopPriceInfoDTO : public Darabonba::Model {
public:
  shared_ptr<long> reShopAdultChangeFee{};
  shared_ptr<long> reShopAdultPrice{};
  shared_ptr<long> reShopAdultPriceGap{};
  shared_ptr<long> reShopChildChangeFee{};
  shared_ptr<long> reShopChildPrice{};
  shared_ptr<long> reShopChildPriceGap{};
  shared_ptr<long> reShopInfChangeFee{};
  shared_ptr<long> reShopInfPrice{};
  shared_ptr<long> reShopInfPriceGap{};

  FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListPriceInfoDTOReShopPriceInfoDTO() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListPriceInfoDTOReShopPriceInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reShopAdultChangeFee) {
      res["re_shop_adult_change_fee"] = boost::any(*reShopAdultChangeFee);
    }
    if (reShopAdultPrice) {
      res["re_shop_adult_price"] = boost::any(*reShopAdultPrice);
    }
    if (reShopAdultPriceGap) {
      res["re_shop_adult_price_gap"] = boost::any(*reShopAdultPriceGap);
    }
    if (reShopChildChangeFee) {
      res["re_shop_child_change_fee"] = boost::any(*reShopChildChangeFee);
    }
    if (reShopChildPrice) {
      res["re_shop_child_price"] = boost::any(*reShopChildPrice);
    }
    if (reShopChildPriceGap) {
      res["re_shop_child_price_gap"] = boost::any(*reShopChildPriceGap);
    }
    if (reShopInfChangeFee) {
      res["re_shop_inf_change_fee"] = boost::any(*reShopInfChangeFee);
    }
    if (reShopInfPrice) {
      res["re_shop_inf_price"] = boost::any(*reShopInfPrice);
    }
    if (reShopInfPriceGap) {
      res["re_shop_inf_price_gap"] = boost::any(*reShopInfPriceGap);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("re_shop_adult_change_fee") != m.end() && !m["re_shop_adult_change_fee"].empty()) {
      reShopAdultChangeFee = make_shared<long>(boost::any_cast<long>(m["re_shop_adult_change_fee"]));
    }
    if (m.find("re_shop_adult_price") != m.end() && !m["re_shop_adult_price"].empty()) {
      reShopAdultPrice = make_shared<long>(boost::any_cast<long>(m["re_shop_adult_price"]));
    }
    if (m.find("re_shop_adult_price_gap") != m.end() && !m["re_shop_adult_price_gap"].empty()) {
      reShopAdultPriceGap = make_shared<long>(boost::any_cast<long>(m["re_shop_adult_price_gap"]));
    }
    if (m.find("re_shop_child_change_fee") != m.end() && !m["re_shop_child_change_fee"].empty()) {
      reShopChildChangeFee = make_shared<long>(boost::any_cast<long>(m["re_shop_child_change_fee"]));
    }
    if (m.find("re_shop_child_price") != m.end() && !m["re_shop_child_price"].empty()) {
      reShopChildPrice = make_shared<long>(boost::any_cast<long>(m["re_shop_child_price"]));
    }
    if (m.find("re_shop_child_price_gap") != m.end() && !m["re_shop_child_price_gap"].empty()) {
      reShopChildPriceGap = make_shared<long>(boost::any_cast<long>(m["re_shop_child_price_gap"]));
    }
    if (m.find("re_shop_inf_change_fee") != m.end() && !m["re_shop_inf_change_fee"].empty()) {
      reShopInfChangeFee = make_shared<long>(boost::any_cast<long>(m["re_shop_inf_change_fee"]));
    }
    if (m.find("re_shop_inf_price") != m.end() && !m["re_shop_inf_price"].empty()) {
      reShopInfPrice = make_shared<long>(boost::any_cast<long>(m["re_shop_inf_price"]));
    }
    if (m.find("re_shop_inf_price_gap") != m.end() && !m["re_shop_inf_price_gap"].empty()) {
      reShopInfPriceGap = make_shared<long>(boost::any_cast<long>(m["re_shop_inf_price_gap"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListPriceInfoDTOReShopPriceInfoDTO() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListPriceInfoDTO : public Darabonba::Model {
public:
  shared_ptr<long> adultPrice{};
  shared_ptr<long> adultTax{};
  shared_ptr<long> adultTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> childPrice{};
  shared_ptr<long> childTax{};
  shared_ptr<long> childTotalPrice{};
  shared_ptr<long> infantPrice{};
  shared_ptr<long> infantTax{};
  shared_ptr<long> infantTotalPrice{};
  shared_ptr<long> originalAdultPrice{};
  shared_ptr<long> originalAdultTotalPrice{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListPriceInfoDTOReShopPriceInfoDTO> reShopPriceInfoDTO{};

  FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListPriceInfoDTO() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListPriceInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adultPrice) {
      res["adult_price"] = boost::any(*adultPrice);
    }
    if (adultTax) {
      res["adult_tax"] = boost::any(*adultTax);
    }
    if (adultTotalPrice) {
      res["adult_total_price"] = boost::any(*adultTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (childPrice) {
      res["child_price"] = boost::any(*childPrice);
    }
    if (childTax) {
      res["child_tax"] = boost::any(*childTax);
    }
    if (childTotalPrice) {
      res["child_total_price"] = boost::any(*childTotalPrice);
    }
    if (infantPrice) {
      res["infant_price"] = boost::any(*infantPrice);
    }
    if (infantTax) {
      res["infant_tax"] = boost::any(*infantTax);
    }
    if (infantTotalPrice) {
      res["infant_total_price"] = boost::any(*infantTotalPrice);
    }
    if (originalAdultPrice) {
      res["original_adult_price"] = boost::any(*originalAdultPrice);
    }
    if (originalAdultTotalPrice) {
      res["original_adult_total_price"] = boost::any(*originalAdultTotalPrice);
    }
    if (reShopPriceInfoDTO) {
      res["re_shop_price_info_d_t_o"] = reShopPriceInfoDTO ? boost::any(reShopPriceInfoDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("adult_price") != m.end() && !m["adult_price"].empty()) {
      adultPrice = make_shared<long>(boost::any_cast<long>(m["adult_price"]));
    }
    if (m.find("adult_tax") != m.end() && !m["adult_tax"].empty()) {
      adultTax = make_shared<long>(boost::any_cast<long>(m["adult_tax"]));
    }
    if (m.find("adult_total_price") != m.end() && !m["adult_total_price"].empty()) {
      adultTotalPrice = make_shared<long>(boost::any_cast<long>(m["adult_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("child_price") != m.end() && !m["child_price"].empty()) {
      childPrice = make_shared<long>(boost::any_cast<long>(m["child_price"]));
    }
    if (m.find("child_tax") != m.end() && !m["child_tax"].empty()) {
      childTax = make_shared<long>(boost::any_cast<long>(m["child_tax"]));
    }
    if (m.find("child_total_price") != m.end() && !m["child_total_price"].empty()) {
      childTotalPrice = make_shared<long>(boost::any_cast<long>(m["child_total_price"]));
    }
    if (m.find("infant_price") != m.end() && !m["infant_price"].empty()) {
      infantPrice = make_shared<long>(boost::any_cast<long>(m["infant_price"]));
    }
    if (m.find("infant_tax") != m.end() && !m["infant_tax"].empty()) {
      infantTax = make_shared<long>(boost::any_cast<long>(m["infant_tax"]));
    }
    if (m.find("infant_total_price") != m.end() && !m["infant_total_price"].empty()) {
      infantTotalPrice = make_shared<long>(boost::any_cast<long>(m["infant_total_price"]));
    }
    if (m.find("original_adult_price") != m.end() && !m["original_adult_price"].empty()) {
      originalAdultPrice = make_shared<long>(boost::any_cast<long>(m["original_adult_price"]));
    }
    if (m.find("original_adult_total_price") != m.end() && !m["original_adult_total_price"].empty()) {
      originalAdultTotalPrice = make_shared<long>(boost::any_cast<long>(m["original_adult_total_price"]));
    }
    if (m.find("re_shop_price_info_d_t_o") != m.end() && !m["re_shop_price_info_d_t_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["re_shop_price_info_d_t_o"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListPriceInfoDTOReShopPriceInfoDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["re_shop_price_info_d_t_o"]));
        reShopPriceInfoDTO = make_shared<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListPriceInfoDTOReShopPriceInfoDTO>(model1);
      }
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListPriceInfoDTO() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleDirectFlightList : public Darabonba::Model {
public:
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListAirlineInfo> airlineInfo{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListArrAirportInfo> arrAirportInfo{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListDepAirportInfo> depAirportInfo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depTime{};
  shared_ptr<long> duration{};
  shared_ptr<string> flightNo{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightShareInfo> flightShareInfo{};
  shared_ptr<string> flightSize{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightStopInfo> flightStopInfo{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightTransferInfo> flightTransferInfo{};
  shared_ptr<string> flightType{};
  shared_ptr<long> journeySeq{};
  shared_ptr<string> leftNum{};
  shared_ptr<string> manufacturer{};
  shared_ptr<string> mealDesc{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListPriceInfoDTO> priceInfoDTO{};
  shared_ptr<long> segmentSeq{};
  shared_ptr<bool> share{};
  shared_ptr<string> shortFlightSize{};
  shared_ptr<string> spanDay{};
  shared_ptr<bool> stop{};
  shared_ptr<bool> transfer{};

  FlightModifyListingSearchV2ResponseBodyModuleDirectFlightList() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleDirectFlightList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (cabinClass) {
      res["cabinClass"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabinClassName"] = boost::any(*cabinClassName);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightShareInfo) {
      res["flight_share_info"] = flightShareInfo ? boost::any(flightShareInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (flightStopInfo) {
      res["flight_stop_info"] = flightStopInfo ? boost::any(flightStopInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightTransferInfo) {
      res["flight_transfer_info"] = flightTransferInfo ? boost::any(flightTransferInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (journeySeq) {
      res["journey_seq"] = boost::any(*journeySeq);
    }
    if (leftNum) {
      res["left_num"] = boost::any(*leftNum);
    }
    if (manufacturer) {
      res["manufacturer"] = boost::any(*manufacturer);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (priceInfoDTO) {
      res["price_info_d_t_o"] = priceInfoDTO ? boost::any(priceInfoDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segmentSeq) {
      res["segment_seq"] = boost::any(*segmentSeq);
    }
    if (share) {
      res["share"] = boost::any(*share);
    }
    if (shortFlightSize) {
      res["short_flight_size"] = boost::any(*shortFlightSize);
    }
    if (spanDay) {
      res["span_day"] = boost::any(*spanDay);
    }
    if (stop) {
      res["stop"] = boost::any(*stop);
    }
    if (transfer) {
      res["transfer"] = boost::any(*transfer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListAirlineInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListArrAirportInfo>(model1);
      }
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("cabinClass") != m.end() && !m["cabinClass"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabinClass"]));
    }
    if (m.find("cabinClassName") != m.end() && !m["cabinClassName"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabinClassName"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListDepAirportInfo>(model1);
      }
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_share_info") != m.end() && !m["flight_share_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_share_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightShareInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flight_share_info"]));
        flightShareInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightShareInfo>(model1);
      }
    }
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("flight_stop_info") != m.end() && !m["flight_stop_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_stop_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightStopInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flight_stop_info"]));
        flightStopInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightStopInfo>(model1);
      }
    }
    if (m.find("flight_transfer_info") != m.end() && !m["flight_transfer_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_transfer_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightTransferInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flight_transfer_info"]));
        flightTransferInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListFlightTransferInfo>(model1);
      }
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("journey_seq") != m.end() && !m["journey_seq"].empty()) {
      journeySeq = make_shared<long>(boost::any_cast<long>(m["journey_seq"]));
    }
    if (m.find("left_num") != m.end() && !m["left_num"].empty()) {
      leftNum = make_shared<string>(boost::any_cast<string>(m["left_num"]));
    }
    if (m.find("manufacturer") != m.end() && !m["manufacturer"].empty()) {
      manufacturer = make_shared<string>(boost::any_cast<string>(m["manufacturer"]));
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("price_info_d_t_o") != m.end() && !m["price_info_d_t_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_info_d_t_o"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListPriceInfoDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_info_d_t_o"]));
        priceInfoDTO = make_shared<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightListPriceInfoDTO>(model1);
      }
    }
    if (m.find("segment_seq") != m.end() && !m["segment_seq"].empty()) {
      segmentSeq = make_shared<long>(boost::any_cast<long>(m["segment_seq"]));
    }
    if (m.find("share") != m.end() && !m["share"].empty()) {
      share = make_shared<bool>(boost::any_cast<bool>(m["share"]));
    }
    if (m.find("short_flight_size") != m.end() && !m["short_flight_size"].empty()) {
      shortFlightSize = make_shared<string>(boost::any_cast<string>(m["short_flight_size"]));
    }
    if (m.find("span_day") != m.end() && !m["span_day"].empty()) {
      spanDay = make_shared<string>(boost::any_cast<string>(m["span_day"]));
    }
    if (m.find("stop") != m.end() && !m["stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["stop"]));
    }
    if (m.find("transfer") != m.end() && !m["transfer"].empty()) {
      transfer = make_shared<bool>(boost::any_cast<bool>(m["transfer"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleDirectFlightList() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineChineseName{};
  shared_ptr<string> airlineChineseShortName{};
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineIcon{};
  shared_ptr<bool> cheapFlight{};

  FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListAirlineInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineChineseName) {
      res["airline_chinese_name"] = boost::any(*airlineChineseName);
    }
    if (airlineChineseShortName) {
      res["airline_chinese_short_name"] = boost::any(*airlineChineseShortName);
    }
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineIcon) {
      res["airline_icon"] = boost::any(*airlineIcon);
    }
    if (cheapFlight) {
      res["cheap_flight"] = boost::any(*cheapFlight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_chinese_name") != m.end() && !m["airline_chinese_name"].empty()) {
      airlineChineseName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_name"]));
    }
    if (m.find("airline_chinese_short_name") != m.end() && !m["airline_chinese_short_name"].empty()) {
      airlineChineseShortName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_short_name"]));
    }
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_icon") != m.end() && !m["airline_icon"].empty()) {
      airlineIcon = make_shared<string>(boost::any_cast<string>(m["airline_icon"]));
    }
    if (m.find("cheap_flight") != m.end() && !m["cheap_flight"].empty()) {
      cheapFlight = make_shared<bool>(boost::any_cast<bool>(m["cheap_flight"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListAirlineInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> airportShortName{};
  shared_ptr<string> terminal{};

  FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListArrAirportInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (airportShortName) {
      res["airport_short_name"] = boost::any(*airportShortName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("airport_short_name") != m.end() && !m["airport_short_name"].empty()) {
      airportShortName = make_shared<string>(boost::any_cast<string>(m["airport_short_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListArrAirportInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> airportShortName{};
  shared_ptr<string> terminal{};

  FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListDepAirportInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (airportShortName) {
      res["airport_short_name"] = boost::any(*airportShortName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("airport_short_name") != m.end() && !m["airport_short_name"].empty()) {
      airportShortName = make_shared<string>(boost::any_cast<string>(m["airport_short_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListDepAirportInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightShareInfoOperatingAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineChineseName{};
  shared_ptr<string> airlineChineseShortName{};
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineIcon{};
  shared_ptr<bool> cheapFlight{};

  FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightShareInfoOperatingAirlineInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightShareInfoOperatingAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineChineseName) {
      res["airline_chinese_name"] = boost::any(*airlineChineseName);
    }
    if (airlineChineseShortName) {
      res["airline_chinese_short_name"] = boost::any(*airlineChineseShortName);
    }
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineIcon) {
      res["airline_icon"] = boost::any(*airlineIcon);
    }
    if (cheapFlight) {
      res["cheap_flight"] = boost::any(*cheapFlight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_chinese_name") != m.end() && !m["airline_chinese_name"].empty()) {
      airlineChineseName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_name"]));
    }
    if (m.find("airline_chinese_short_name") != m.end() && !m["airline_chinese_short_name"].empty()) {
      airlineChineseShortName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_short_name"]));
    }
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_icon") != m.end() && !m["airline_icon"].empty()) {
      airlineIcon = make_shared<string>(boost::any_cast<string>(m["airline_icon"]));
    }
    if (m.find("cheap_flight") != m.end() && !m["cheap_flight"].empty()) {
      cheapFlight = make_shared<bool>(boost::any_cast<bool>(m["cheap_flight"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightShareInfoOperatingAirlineInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightShareInfo : public Darabonba::Model {
public:
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightShareInfoOperatingAirlineInfo> operatingAirlineInfo{};
  shared_ptr<string> operatingFlightNo{};

  FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightShareInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightShareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operatingAirlineInfo) {
      res["operating_airline_info"] = operatingAirlineInfo ? boost::any(operatingAirlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operatingFlightNo) {
      res["operating_flight_no"] = boost::any(*operatingFlightNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("operating_airline_info") != m.end() && !m["operating_airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["operating_airline_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightShareInfoOperatingAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["operating_airline_info"]));
        operatingAirlineInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightShareInfoOperatingAirlineInfo>(model1);
      }
    }
    if (m.find("operating_flight_no") != m.end() && !m["operating_flight_no"].empty()) {
      operatingFlightNo = make_shared<string>(boost::any_cast<string>(m["operating_flight_no"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightShareInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightStopInfo : public Darabonba::Model {
public:
  shared_ptr<string> stopAirport{};
  shared_ptr<string> stopArrTerm{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCityCode{};
  shared_ptr<string> stopCityName{};
  shared_ptr<string> stopDepTerm{};
  shared_ptr<string> stopDepTime{};

  FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightStopInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightStopInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stopAirport) {
      res["stop_airport"] = boost::any(*stopAirport);
    }
    if (stopArrTerm) {
      res["stop_arr_term"] = boost::any(*stopArrTerm);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCityCode) {
      res["stop_city_code"] = boost::any(*stopCityCode);
    }
    if (stopCityName) {
      res["stop_city_name"] = boost::any(*stopCityName);
    }
    if (stopDepTerm) {
      res["stop_dep_term"] = boost::any(*stopDepTerm);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("stop_airport") != m.end() && !m["stop_airport"].empty()) {
      stopAirport = make_shared<string>(boost::any_cast<string>(m["stop_airport"]));
    }
    if (m.find("stop_arr_term") != m.end() && !m["stop_arr_term"].empty()) {
      stopArrTerm = make_shared<string>(boost::any_cast<string>(m["stop_arr_term"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city_code") != m.end() && !m["stop_city_code"].empty()) {
      stopCityCode = make_shared<string>(boost::any_cast<string>(m["stop_city_code"]));
    }
    if (m.find("stop_city_name") != m.end() && !m["stop_city_name"].empty()) {
      stopCityName = make_shared<string>(boost::any_cast<string>(m["stop_city_name"]));
    }
    if (m.find("stop_dep_term") != m.end() && !m["stop_dep_term"].empty()) {
      stopDepTerm = make_shared<string>(boost::any_cast<string>(m["stop_dep_term"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightStopInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightTransferInfoTransferAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineChineseName{};
  shared_ptr<string> airlineChineseShortName{};
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineIcon{};
  shared_ptr<bool> cheapFlight{};

  FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightTransferInfoTransferAirlineInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightTransferInfoTransferAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineChineseName) {
      res["airline_chinese_name"] = boost::any(*airlineChineseName);
    }
    if (airlineChineseShortName) {
      res["airline_chinese_short_name"] = boost::any(*airlineChineseShortName);
    }
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineIcon) {
      res["airline_icon"] = boost::any(*airlineIcon);
    }
    if (cheapFlight) {
      res["cheap_flight"] = boost::any(*cheapFlight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_chinese_name") != m.end() && !m["airline_chinese_name"].empty()) {
      airlineChineseName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_name"]));
    }
    if (m.find("airline_chinese_short_name") != m.end() && !m["airline_chinese_short_name"].empty()) {
      airlineChineseShortName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_short_name"]));
    }
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_icon") != m.end() && !m["airline_icon"].empty()) {
      airlineIcon = make_shared<string>(boost::any_cast<string>(m["airline_icon"]));
    }
    if (m.find("cheap_flight") != m.end() && !m["cheap_flight"].empty()) {
      cheapFlight = make_shared<bool>(boost::any_cast<bool>(m["cheap_flight"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightTransferInfoTransferAirlineInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightTransferInfo : public Darabonba::Model {
public:
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightTransferInfoTransferAirlineInfo> transferAirlineInfo{};
  shared_ptr<string> transferCityCode{};
  shared_ptr<string> transferCityName{};
  shared_ptr<string> transferDepTime{};
  shared_ptr<string> transferFlightNo{};
  shared_ptr<string> transferFlightSize{};
  shared_ptr<bool> transferShare{};
  shared_ptr<long> transferStopTime{};

  FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightTransferInfo() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightTransferInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transferAirlineInfo) {
      res["transfer_airline_info"] = transferAirlineInfo ? boost::any(transferAirlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transferCityCode) {
      res["transfer_city_code"] = boost::any(*transferCityCode);
    }
    if (transferCityName) {
      res["transfer_city_name"] = boost::any(*transferCityName);
    }
    if (transferDepTime) {
      res["transfer_dep_time"] = boost::any(*transferDepTime);
    }
    if (transferFlightNo) {
      res["transfer_flight_no"] = boost::any(*transferFlightNo);
    }
    if (transferFlightSize) {
      res["transfer_flight_size"] = boost::any(*transferFlightSize);
    }
    if (transferShare) {
      res["transfer_share"] = boost::any(*transferShare);
    }
    if (transferStopTime) {
      res["transfer_stop_time"] = boost::any(*transferStopTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("transfer_airline_info") != m.end() && !m["transfer_airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["transfer_airline_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightTransferInfoTransferAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["transfer_airline_info"]));
        transferAirlineInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightTransferInfoTransferAirlineInfo>(model1);
      }
    }
    if (m.find("transfer_city_code") != m.end() && !m["transfer_city_code"].empty()) {
      transferCityCode = make_shared<string>(boost::any_cast<string>(m["transfer_city_code"]));
    }
    if (m.find("transfer_city_name") != m.end() && !m["transfer_city_name"].empty()) {
      transferCityName = make_shared<string>(boost::any_cast<string>(m["transfer_city_name"]));
    }
    if (m.find("transfer_dep_time") != m.end() && !m["transfer_dep_time"].empty()) {
      transferDepTime = make_shared<string>(boost::any_cast<string>(m["transfer_dep_time"]));
    }
    if (m.find("transfer_flight_no") != m.end() && !m["transfer_flight_no"].empty()) {
      transferFlightNo = make_shared<string>(boost::any_cast<string>(m["transfer_flight_no"]));
    }
    if (m.find("transfer_flight_size") != m.end() && !m["transfer_flight_size"].empty()) {
      transferFlightSize = make_shared<string>(boost::any_cast<string>(m["transfer_flight_size"]));
    }
    if (m.find("transfer_share") != m.end() && !m["transfer_share"].empty()) {
      transferShare = make_shared<bool>(boost::any_cast<bool>(m["transfer_share"]));
    }
    if (m.find("transfer_stop_time") != m.end() && !m["transfer_stop_time"].empty()) {
      transferStopTime = make_shared<long>(boost::any_cast<long>(m["transfer_stop_time"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightTransferInfo() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListPriceInfoDTOReShopPriceInfoDTO : public Darabonba::Model {
public:
  shared_ptr<long> reShopAdultChangeFee{};
  shared_ptr<long> reShopAdultPrice{};
  shared_ptr<long> reShopAdultPriceGap{};
  shared_ptr<long> reShopChildChangeFee{};
  shared_ptr<long> reShopChildPrice{};
  shared_ptr<long> reShopChildPriceGap{};
  shared_ptr<long> reShopInfChangeFee{};
  shared_ptr<long> reShopInfPrice{};
  shared_ptr<long> reShopInfPriceGap{};

  FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListPriceInfoDTOReShopPriceInfoDTO() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListPriceInfoDTOReShopPriceInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reShopAdultChangeFee) {
      res["re_shop_adult_change_fee"] = boost::any(*reShopAdultChangeFee);
    }
    if (reShopAdultPrice) {
      res["re_shop_adult_price"] = boost::any(*reShopAdultPrice);
    }
    if (reShopAdultPriceGap) {
      res["re_shop_adult_price_gap"] = boost::any(*reShopAdultPriceGap);
    }
    if (reShopChildChangeFee) {
      res["re_shop_child_change_fee"] = boost::any(*reShopChildChangeFee);
    }
    if (reShopChildPrice) {
      res["re_shop_child_price"] = boost::any(*reShopChildPrice);
    }
    if (reShopChildPriceGap) {
      res["re_shop_child_price_gap"] = boost::any(*reShopChildPriceGap);
    }
    if (reShopInfChangeFee) {
      res["re_shop_inf_change_fee"] = boost::any(*reShopInfChangeFee);
    }
    if (reShopInfPrice) {
      res["re_shop_inf_price"] = boost::any(*reShopInfPrice);
    }
    if (reShopInfPriceGap) {
      res["re_shop_inf_price_gap"] = boost::any(*reShopInfPriceGap);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("re_shop_adult_change_fee") != m.end() && !m["re_shop_adult_change_fee"].empty()) {
      reShopAdultChangeFee = make_shared<long>(boost::any_cast<long>(m["re_shop_adult_change_fee"]));
    }
    if (m.find("re_shop_adult_price") != m.end() && !m["re_shop_adult_price"].empty()) {
      reShopAdultPrice = make_shared<long>(boost::any_cast<long>(m["re_shop_adult_price"]));
    }
    if (m.find("re_shop_adult_price_gap") != m.end() && !m["re_shop_adult_price_gap"].empty()) {
      reShopAdultPriceGap = make_shared<long>(boost::any_cast<long>(m["re_shop_adult_price_gap"]));
    }
    if (m.find("re_shop_child_change_fee") != m.end() && !m["re_shop_child_change_fee"].empty()) {
      reShopChildChangeFee = make_shared<long>(boost::any_cast<long>(m["re_shop_child_change_fee"]));
    }
    if (m.find("re_shop_child_price") != m.end() && !m["re_shop_child_price"].empty()) {
      reShopChildPrice = make_shared<long>(boost::any_cast<long>(m["re_shop_child_price"]));
    }
    if (m.find("re_shop_child_price_gap") != m.end() && !m["re_shop_child_price_gap"].empty()) {
      reShopChildPriceGap = make_shared<long>(boost::any_cast<long>(m["re_shop_child_price_gap"]));
    }
    if (m.find("re_shop_inf_change_fee") != m.end() && !m["re_shop_inf_change_fee"].empty()) {
      reShopInfChangeFee = make_shared<long>(boost::any_cast<long>(m["re_shop_inf_change_fee"]));
    }
    if (m.find("re_shop_inf_price") != m.end() && !m["re_shop_inf_price"].empty()) {
      reShopInfPrice = make_shared<long>(boost::any_cast<long>(m["re_shop_inf_price"]));
    }
    if (m.find("re_shop_inf_price_gap") != m.end() && !m["re_shop_inf_price_gap"].empty()) {
      reShopInfPriceGap = make_shared<long>(boost::any_cast<long>(m["re_shop_inf_price_gap"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListPriceInfoDTOReShopPriceInfoDTO() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListPriceInfoDTO : public Darabonba::Model {
public:
  shared_ptr<long> adultPrice{};
  shared_ptr<long> adultTax{};
  shared_ptr<long> adultTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> childPrice{};
  shared_ptr<long> childTax{};
  shared_ptr<long> childTotalPrice{};
  shared_ptr<long> infantPrice{};
  shared_ptr<long> infantTax{};
  shared_ptr<long> infantTotalPrice{};
  shared_ptr<long> originalAdultPrice{};
  shared_ptr<long> originalAdultTotalPrice{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListPriceInfoDTOReShopPriceInfoDTO> reShopPriceInfoDTO{};

  FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListPriceInfoDTO() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListPriceInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adultPrice) {
      res["adult_price"] = boost::any(*adultPrice);
    }
    if (adultTax) {
      res["adult_tax"] = boost::any(*adultTax);
    }
    if (adultTotalPrice) {
      res["adult_total_price"] = boost::any(*adultTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (childPrice) {
      res["child_price"] = boost::any(*childPrice);
    }
    if (childTax) {
      res["child_tax"] = boost::any(*childTax);
    }
    if (childTotalPrice) {
      res["child_total_price"] = boost::any(*childTotalPrice);
    }
    if (infantPrice) {
      res["infant_price"] = boost::any(*infantPrice);
    }
    if (infantTax) {
      res["infant_tax"] = boost::any(*infantTax);
    }
    if (infantTotalPrice) {
      res["infant_total_price"] = boost::any(*infantTotalPrice);
    }
    if (originalAdultPrice) {
      res["original_adult_price"] = boost::any(*originalAdultPrice);
    }
    if (originalAdultTotalPrice) {
      res["original_adult_total_price"] = boost::any(*originalAdultTotalPrice);
    }
    if (reShopPriceInfoDTO) {
      res["re_shop_price_info_d_t_o"] = reShopPriceInfoDTO ? boost::any(reShopPriceInfoDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("adult_price") != m.end() && !m["adult_price"].empty()) {
      adultPrice = make_shared<long>(boost::any_cast<long>(m["adult_price"]));
    }
    if (m.find("adult_tax") != m.end() && !m["adult_tax"].empty()) {
      adultTax = make_shared<long>(boost::any_cast<long>(m["adult_tax"]));
    }
    if (m.find("adult_total_price") != m.end() && !m["adult_total_price"].empty()) {
      adultTotalPrice = make_shared<long>(boost::any_cast<long>(m["adult_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("child_price") != m.end() && !m["child_price"].empty()) {
      childPrice = make_shared<long>(boost::any_cast<long>(m["child_price"]));
    }
    if (m.find("child_tax") != m.end() && !m["child_tax"].empty()) {
      childTax = make_shared<long>(boost::any_cast<long>(m["child_tax"]));
    }
    if (m.find("child_total_price") != m.end() && !m["child_total_price"].empty()) {
      childTotalPrice = make_shared<long>(boost::any_cast<long>(m["child_total_price"]));
    }
    if (m.find("infant_price") != m.end() && !m["infant_price"].empty()) {
      infantPrice = make_shared<long>(boost::any_cast<long>(m["infant_price"]));
    }
    if (m.find("infant_tax") != m.end() && !m["infant_tax"].empty()) {
      infantTax = make_shared<long>(boost::any_cast<long>(m["infant_tax"]));
    }
    if (m.find("infant_total_price") != m.end() && !m["infant_total_price"].empty()) {
      infantTotalPrice = make_shared<long>(boost::any_cast<long>(m["infant_total_price"]));
    }
    if (m.find("original_adult_price") != m.end() && !m["original_adult_price"].empty()) {
      originalAdultPrice = make_shared<long>(boost::any_cast<long>(m["original_adult_price"]));
    }
    if (m.find("original_adult_total_price") != m.end() && !m["original_adult_total_price"].empty()) {
      originalAdultTotalPrice = make_shared<long>(boost::any_cast<long>(m["original_adult_total_price"]));
    }
    if (m.find("re_shop_price_info_d_t_o") != m.end() && !m["re_shop_price_info_d_t_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["re_shop_price_info_d_t_o"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListPriceInfoDTOReShopPriceInfoDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["re_shop_price_info_d_t_o"]));
        reShopPriceInfoDTO = make_shared<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListPriceInfoDTOReShopPriceInfoDTO>(model1);
      }
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListPriceInfoDTO() = default;
};
class FlightModifyListingSearchV2ResponseBodyModuleTransferFlightList : public Darabonba::Model {
public:
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListAirlineInfo> airlineInfo{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListArrAirportInfo> arrAirportInfo{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListDepAirportInfo> depAirportInfo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depTime{};
  shared_ptr<long> duration{};
  shared_ptr<string> flightNo{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightShareInfo> flightShareInfo{};
  shared_ptr<string> flightSize{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightStopInfo> flightStopInfo{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightTransferInfo> flightTransferInfo{};
  shared_ptr<string> flightType{};
  shared_ptr<long> journeySeq{};
  shared_ptr<string> leftNum{};
  shared_ptr<string> manufacturer{};
  shared_ptr<string> mealDesc{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListPriceInfoDTO> priceInfoDTO{};
  shared_ptr<long> segmentSeq{};
  shared_ptr<bool> share{};
  shared_ptr<string> shortFlightSize{};
  shared_ptr<string> spanDay{};
  shared_ptr<bool> stop{};
  shared_ptr<bool> transfer{};

  FlightModifyListingSearchV2ResponseBodyModuleTransferFlightList() {}

  explicit FlightModifyListingSearchV2ResponseBodyModuleTransferFlightList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (cabinClass) {
      res["cabinClass"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabinClassName"] = boost::any(*cabinClassName);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightShareInfo) {
      res["flight_share_info"] = flightShareInfo ? boost::any(flightShareInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (flightStopInfo) {
      res["flight_stop_info"] = flightStopInfo ? boost::any(flightStopInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightTransferInfo) {
      res["flight_transfer_info"] = flightTransferInfo ? boost::any(flightTransferInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (journeySeq) {
      res["journey_seq"] = boost::any(*journeySeq);
    }
    if (leftNum) {
      res["left_num"] = boost::any(*leftNum);
    }
    if (manufacturer) {
      res["manufacturer"] = boost::any(*manufacturer);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (priceInfoDTO) {
      res["price_info_d_t_o"] = priceInfoDTO ? boost::any(priceInfoDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segmentSeq) {
      res["segment_seq"] = boost::any(*segmentSeq);
    }
    if (share) {
      res["share"] = boost::any(*share);
    }
    if (shortFlightSize) {
      res["short_flight_size"] = boost::any(*shortFlightSize);
    }
    if (spanDay) {
      res["span_day"] = boost::any(*spanDay);
    }
    if (stop) {
      res["stop"] = boost::any(*stop);
    }
    if (transfer) {
      res["transfer"] = boost::any(*transfer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListAirlineInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListArrAirportInfo>(model1);
      }
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("cabinClass") != m.end() && !m["cabinClass"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabinClass"]));
    }
    if (m.find("cabinClassName") != m.end() && !m["cabinClassName"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabinClassName"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListDepAirportInfo>(model1);
      }
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_share_info") != m.end() && !m["flight_share_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_share_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightShareInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flight_share_info"]));
        flightShareInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightShareInfo>(model1);
      }
    }
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("flight_stop_info") != m.end() && !m["flight_stop_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_stop_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightStopInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flight_stop_info"]));
        flightStopInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightStopInfo>(model1);
      }
    }
    if (m.find("flight_transfer_info") != m.end() && !m["flight_transfer_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_transfer_info"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightTransferInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flight_transfer_info"]));
        flightTransferInfo = make_shared<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListFlightTransferInfo>(model1);
      }
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("journey_seq") != m.end() && !m["journey_seq"].empty()) {
      journeySeq = make_shared<long>(boost::any_cast<long>(m["journey_seq"]));
    }
    if (m.find("left_num") != m.end() && !m["left_num"].empty()) {
      leftNum = make_shared<string>(boost::any_cast<string>(m["left_num"]));
    }
    if (m.find("manufacturer") != m.end() && !m["manufacturer"].empty()) {
      manufacturer = make_shared<string>(boost::any_cast<string>(m["manufacturer"]));
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("price_info_d_t_o") != m.end() && !m["price_info_d_t_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_info_d_t_o"].type()) {
        FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListPriceInfoDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_info_d_t_o"]));
        priceInfoDTO = make_shared<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightListPriceInfoDTO>(model1);
      }
    }
    if (m.find("segment_seq") != m.end() && !m["segment_seq"].empty()) {
      segmentSeq = make_shared<long>(boost::any_cast<long>(m["segment_seq"]));
    }
    if (m.find("share") != m.end() && !m["share"].empty()) {
      share = make_shared<bool>(boost::any_cast<bool>(m["share"]));
    }
    if (m.find("short_flight_size") != m.end() && !m["short_flight_size"].empty()) {
      shortFlightSize = make_shared<string>(boost::any_cast<string>(m["short_flight_size"]));
    }
    if (m.find("span_day") != m.end() && !m["span_day"].empty()) {
      spanDay = make_shared<string>(boost::any_cast<string>(m["span_day"]));
    }
    if (m.find("stop") != m.end() && !m["stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["stop"]));
    }
    if (m.find("transfer") != m.end() && !m["transfer"].empty()) {
      transfer = make_shared<bool>(boost::any_cast<bool>(m["transfer"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModuleTransferFlightList() = default;
};
class FlightModifyListingSearchV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightList>> directFlightList{};
  shared_ptr<string> sessionId{};
  shared_ptr<vector<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightList>> transferFlightList{};
  shared_ptr<string> transferTitle{};

  FlightModifyListingSearchV2ResponseBodyModule() {}

  explicit FlightModifyListingSearchV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directFlightList) {
      vector<boost::any> temp1;
      for(auto item1:*directFlightList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["direct_flight_list"] = boost::any(temp1);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (transferFlightList) {
      vector<boost::any> temp1;
      for(auto item1:*transferFlightList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["transfer_flight_list"] = boost::any(temp1);
    }
    if (transferTitle) {
      res["transfer_title"] = boost::any(*transferTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("direct_flight_list") != m.end() && !m["direct_flight_list"].empty()) {
      if (typeid(vector<boost::any>) == m["direct_flight_list"].type()) {
        vector<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["direct_flight_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightModifyListingSearchV2ResponseBodyModuleDirectFlightList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        directFlightList = make_shared<vector<FlightModifyListingSearchV2ResponseBodyModuleDirectFlightList>>(expect1);
      }
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("transfer_flight_list") != m.end() && !m["transfer_flight_list"].empty()) {
      if (typeid(vector<boost::any>) == m["transfer_flight_list"].type()) {
        vector<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["transfer_flight_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightModifyListingSearchV2ResponseBodyModuleTransferFlightList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transferFlightList = make_shared<vector<FlightModifyListingSearchV2ResponseBodyModuleTransferFlightList>>(expect1);
      }
    }
    if (m.find("transfer_title") != m.end() && !m["transfer_title"].empty()) {
      transferTitle = make_shared<string>(boost::any_cast<string>(m["transfer_title"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBodyModule() = default;
};
class FlightModifyListingSearchV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightModifyListingSearchV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightModifyListingSearchV2ResponseBody() {}

  explicit FlightModifyListingSearchV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightModifyListingSearchV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightModifyListingSearchV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightModifyListingSearchV2ResponseBody() = default;
};
class FlightModifyListingSearchV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightModifyListingSearchV2ResponseBody> body{};

  FlightModifyListingSearchV2Response() {}

  explicit FlightModifyListingSearchV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightModifyListingSearchV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightModifyListingSearchV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightModifyListingSearchV2Response() = default;
};
class FlightModifyOrderDetailV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightModifyOrderDetailV2Headers() {}

  explicit FlightModifyOrderDetailV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightModifyOrderDetailV2Headers() = default;
};
class FlightModifyOrderDetailV2Request : public Darabonba::Model {
public:
  shared_ptr<string> isvName{};
  shared_ptr<string> modifyApplyId{};
  shared_ptr<bool> needQueryServiceFee{};
  shared_ptr<string> orderId{};

  FlightModifyOrderDetailV2Request() {}

  explicit FlightModifyOrderDetailV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (modifyApplyId) {
      res["modify_apply_id"] = boost::any(*modifyApplyId);
    }
    if (needQueryServiceFee) {
      res["need_query_service_fee"] = boost::any(*needQueryServiceFee);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("modify_apply_id") != m.end() && !m["modify_apply_id"].empty()) {
      modifyApplyId = make_shared<string>(boost::any_cast<string>(m["modify_apply_id"]));
    }
    if (m.find("need_query_service_fee") != m.end() && !m["need_query_service_fee"].empty()) {
      needQueryServiceFee = make_shared<bool>(boost::any_cast<bool>(m["need_query_service_fee"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
  }


  virtual ~FlightModifyOrderDetailV2Request() = default;
};
class FlightModifyOrderDetailV2ResponseBodyModuleContactInfoDTO : public Darabonba::Model {
public:
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactPhone{};
  shared_ptr<bool> sendMsgToPassenger{};

  FlightModifyOrderDetailV2ResponseBodyModuleContactInfoDTO() {}

  explicit FlightModifyOrderDetailV2ResponseBodyModuleContactInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactEmail) {
      res["contact_email"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (contactPhone) {
      res["contact_phone"] = boost::any(*contactPhone);
    }
    if (sendMsgToPassenger) {
      res["send_msg_to_passenger"] = boost::any(*sendMsgToPassenger);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contact_email") != m.end() && !m["contact_email"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["contact_email"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("contact_phone") != m.end() && !m["contact_phone"].empty()) {
      contactPhone = make_shared<string>(boost::any_cast<string>(m["contact_phone"]));
    }
    if (m.find("send_msg_to_passenger") != m.end() && !m["send_msg_to_passenger"].empty()) {
      sendMsgToPassenger = make_shared<bool>(boost::any_cast<bool>(m["send_msg_to_passenger"]));
    }
  }


  virtual ~FlightModifyOrderDetailV2ResponseBodyModuleContactInfoDTO() = default;
};
class FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOSSegmentPosition : public Darabonba::Model {
public:
  shared_ptr<long> journeyIndex{};
  shared_ptr<long> segmentIndex{};

  FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOSSegmentPosition() {}

  explicit FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOSSegmentPosition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (journeyIndex) {
      res["journey_index"] = boost::any(*journeyIndex);
    }
    if (segmentIndex) {
      res["segment_index"] = boost::any(*segmentIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("journey_index") != m.end() && !m["journey_index"].empty()) {
      journeyIndex = make_shared<long>(boost::any_cast<long>(m["journey_index"]));
    }
    if (m.find("segment_index") != m.end() && !m["segment_index"].empty()) {
      segmentIndex = make_shared<long>(boost::any_cast<long>(m["segment_index"]));
    }
  }


  virtual ~FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOSSegmentPosition() = default;
};
class FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOS : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineIconUrl{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrAirportName{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrTerminal{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<long> cabinDiscount{};
  shared_ptr<string> carrierAirlineCode{};
  shared_ptr<string> carrierAirlineIconUrl{};
  shared_ptr<string> carrierAirlineName{};
  shared_ptr<string> carrierFlightNo{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depAirportName{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depTerminal{};
  shared_ptr<string> depTime{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> flightType{};
  shared_ptr<string> mealDesc{};
  shared_ptr<string> segmentIId{};
  shared_ptr<FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOSSegmentPosition> segmentPosition{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopDepTime{};

  FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOS() {}

  explicit FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineIconUrl) {
      res["airline_icon_url"] = boost::any(*airlineIconUrl);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrAirportName) {
      res["arr_airport_name"] = boost::any(*arrAirportName);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrTerminal) {
      res["arr_terminal"] = boost::any(*arrTerminal);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabin_class_name"] = boost::any(*cabinClassName);
    }
    if (cabinDiscount) {
      res["cabin_discount"] = boost::any(*cabinDiscount);
    }
    if (carrierAirlineCode) {
      res["carrier_airline_code"] = boost::any(*carrierAirlineCode);
    }
    if (carrierAirlineIconUrl) {
      res["carrier_airline_icon_url"] = boost::any(*carrierAirlineIconUrl);
    }
    if (carrierAirlineName) {
      res["carrier_airline_name"] = boost::any(*carrierAirlineName);
    }
    if (carrierFlightNo) {
      res["carrier_flight_no"] = boost::any(*carrierFlightNo);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depAirportName) {
      res["dep_airport_name"] = boost::any(*depAirportName);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depTerminal) {
      res["dep_terminal"] = boost::any(*depTerminal);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (segmentIId) {
      res["segmentI_id"] = boost::any(*segmentIId);
    }
    if (segmentPosition) {
      res["segment_position"] = segmentPosition ? boost::any(segmentPosition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_icon_url") != m.end() && !m["airline_icon_url"].empty()) {
      airlineIconUrl = make_shared<string>(boost::any_cast<string>(m["airline_icon_url"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_airport_name") != m.end() && !m["arr_airport_name"].empty()) {
      arrAirportName = make_shared<string>(boost::any_cast<string>(m["arr_airport_name"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_terminal") != m.end() && !m["arr_terminal"].empty()) {
      arrTerminal = make_shared<string>(boost::any_cast<string>(m["arr_terminal"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_class_name") != m.end() && !m["cabin_class_name"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabin_class_name"]));
    }
    if (m.find("cabin_discount") != m.end() && !m["cabin_discount"].empty()) {
      cabinDiscount = make_shared<long>(boost::any_cast<long>(m["cabin_discount"]));
    }
    if (m.find("carrier_airline_code") != m.end() && !m["carrier_airline_code"].empty()) {
      carrierAirlineCode = make_shared<string>(boost::any_cast<string>(m["carrier_airline_code"]));
    }
    if (m.find("carrier_airline_icon_url") != m.end() && !m["carrier_airline_icon_url"].empty()) {
      carrierAirlineIconUrl = make_shared<string>(boost::any_cast<string>(m["carrier_airline_icon_url"]));
    }
    if (m.find("carrier_airline_name") != m.end() && !m["carrier_airline_name"].empty()) {
      carrierAirlineName = make_shared<string>(boost::any_cast<string>(m["carrier_airline_name"]));
    }
    if (m.find("carrier_flight_no") != m.end() && !m["carrier_flight_no"].empty()) {
      carrierFlightNo = make_shared<string>(boost::any_cast<string>(m["carrier_flight_no"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_airport_name") != m.end() && !m["dep_airport_name"].empty()) {
      depAirportName = make_shared<string>(boost::any_cast<string>(m["dep_airport_name"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_terminal") != m.end() && !m["dep_terminal"].empty()) {
      depTerminal = make_shared<string>(boost::any_cast<string>(m["dep_terminal"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("segmentI_id") != m.end() && !m["segmentI_id"].empty()) {
      segmentIId = make_shared<string>(boost::any_cast<string>(m["segmentI_id"]));
    }
    if (m.find("segment_position") != m.end() && !m["segment_position"].empty()) {
      if (typeid(map<string, boost::any>) == m["segment_position"].type()) {
        FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOSSegmentPosition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["segment_position"]));
        segmentPosition = make_shared<FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOSSegmentPosition>(model1);
      }
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
  }


  virtual ~FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOS() = default;
};
class FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOSChangeFee : public Darabonba::Model {
public:
  shared_ptr<long> changeFee{};
  shared_ptr<long> serviceFee{};
  shared_ptr<long> upgradePrice{};

  FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOSChangeFee() {}

  explicit FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOSChangeFee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeFee) {
      res["change_fee"] = boost::any(*changeFee);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (upgradePrice) {
      res["upgrade_price"] = boost::any(*upgradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("change_fee") != m.end() && !m["change_fee"].empty()) {
      changeFee = make_shared<long>(boost::any_cast<long>(m["change_fee"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<long>(boost::any_cast<long>(m["service_fee"]));
    }
    if (m.find("upgrade_price") != m.end() && !m["upgrade_price"].empty()) {
      upgradePrice = make_shared<long>(boost::any_cast<long>(m["upgrade_price"]));
    }
  }


  virtual ~FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOSChangeFee() = default;
};
class FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOS : public Darabonba::Model {
public:
  shared_ptr<string> birthDate{};
  shared_ptr<string> certNo{};
  shared_ptr<long> certType{};
  shared_ptr<FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOSChangeFee> changeFee{};
  shared_ptr<long> gender{};
  shared_ptr<vector<string>> originTicketNos{};
  shared_ptr<string> passengerId{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> passengerType{};
  shared_ptr<string> phone{};
  shared_ptr<long> pid{};
  shared_ptr<vector<string>> ticketNos{};

  FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOS() {}

  explicit FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthDate) {
      res["birth_date"] = boost::any(*birthDate);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (changeFee) {
      res["change_fee"] = changeFee ? boost::any(changeFee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gender) {
      res["gender"] = boost::any(*gender);
    }
    if (originTicketNos) {
      res["origin_ticket_nos"] = boost::any(*originTicketNos);
    }
    if (passengerId) {
      res["passenger_id"] = boost::any(*passengerId);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (pid) {
      res["pid"] = boost::any(*pid);
    }
    if (ticketNos) {
      res["ticket_nos"] = boost::any(*ticketNos);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birth_date") != m.end() && !m["birth_date"].empty()) {
      birthDate = make_shared<string>(boost::any_cast<string>(m["birth_date"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<long>(boost::any_cast<long>(m["cert_type"]));
    }
    if (m.find("change_fee") != m.end() && !m["change_fee"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_fee"].type()) {
        FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOSChangeFee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_fee"]));
        changeFee = make_shared<FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOSChangeFee>(model1);
      }
    }
    if (m.find("gender") != m.end() && !m["gender"].empty()) {
      gender = make_shared<long>(boost::any_cast<long>(m["gender"]));
    }
    if (m.find("origin_ticket_nos") != m.end() && !m["origin_ticket_nos"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["origin_ticket_nos"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["origin_ticket_nos"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      originTicketNos = make_shared<vector<string>>(toVec1);
    }
    if (m.find("passenger_id") != m.end() && !m["passenger_id"].empty()) {
      passengerId = make_shared<string>(boost::any_cast<string>(m["passenger_id"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<long>(boost::any_cast<long>(m["passenger_type"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("pid") != m.end() && !m["pid"].empty()) {
      pid = make_shared<long>(boost::any_cast<long>(m["pid"]));
    }
    if (m.find("ticket_nos") != m.end() && !m["ticket_nos"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ticket_nos"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ticket_nos"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ticketNos = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOS() = default;
};
class FlightModifyOrderDetailV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> applyTime{};
  shared_ptr<string> bookUserEmail{};
  shared_ptr<string> bookUserName{};
  shared_ptr<string> bookuserPhone{};
  shared_ptr<string> changeFailReason{};
  shared_ptr<FlightModifyOrderDetailV2ResponseBodyModuleContactInfoDTO> contactInfoDTO{};
  shared_ptr<vector<FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOS>> destFlightInfoDTOS{};
  shared_ptr<string> lastPayTime{};
  shared_ptr<long> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<string> payTime{};
  shared_ptr<string> reason{};
  shared_ptr<long> status{};
  shared_ptr<long> subOrderId{};
  shared_ptr<string> ticketTime{};
  shared_ptr<long> totalPrice{};
  shared_ptr<long> totalServiceFeePrice{};
  shared_ptr<vector<FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOS>> travelerInfoDTOS{};

  FlightModifyOrderDetailV2ResponseBodyModule() {}

  explicit FlightModifyOrderDetailV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyTime) {
      res["apply_time"] = boost::any(*applyTime);
    }
    if (bookUserEmail) {
      res["book_user_email"] = boost::any(*bookUserEmail);
    }
    if (bookUserName) {
      res["book_user_name"] = boost::any(*bookUserName);
    }
    if (bookuserPhone) {
      res["bookuser_phone"] = boost::any(*bookuserPhone);
    }
    if (changeFailReason) {
      res["change_fail_reason"] = boost::any(*changeFailReason);
    }
    if (contactInfoDTO) {
      res["contact_info_d_t_o"] = contactInfoDTO ? boost::any(contactInfoDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (destFlightInfoDTOS) {
      vector<boost::any> temp1;
      for(auto item1:*destFlightInfoDTOS){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dest_flight_info_d_t_o_s"] = boost::any(temp1);
    }
    if (lastPayTime) {
      res["last_pay_time"] = boost::any(*lastPayTime);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (payTime) {
      res["pay_time"] = boost::any(*payTime);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    if (ticketTime) {
      res["ticket_time"] = boost::any(*ticketTime);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    if (totalServiceFeePrice) {
      res["total_service_fee_price"] = boost::any(*totalServiceFeePrice);
    }
    if (travelerInfoDTOS) {
      vector<boost::any> temp1;
      for(auto item1:*travelerInfoDTOS){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_info_d_t_o_s"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_time") != m.end() && !m["apply_time"].empty()) {
      applyTime = make_shared<string>(boost::any_cast<string>(m["apply_time"]));
    }
    if (m.find("book_user_email") != m.end() && !m["book_user_email"].empty()) {
      bookUserEmail = make_shared<string>(boost::any_cast<string>(m["book_user_email"]));
    }
    if (m.find("book_user_name") != m.end() && !m["book_user_name"].empty()) {
      bookUserName = make_shared<string>(boost::any_cast<string>(m["book_user_name"]));
    }
    if (m.find("bookuser_phone") != m.end() && !m["bookuser_phone"].empty()) {
      bookuserPhone = make_shared<string>(boost::any_cast<string>(m["bookuser_phone"]));
    }
    if (m.find("change_fail_reason") != m.end() && !m["change_fail_reason"].empty()) {
      changeFailReason = make_shared<string>(boost::any_cast<string>(m["change_fail_reason"]));
    }
    if (m.find("contact_info_d_t_o") != m.end() && !m["contact_info_d_t_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["contact_info_d_t_o"].type()) {
        FlightModifyOrderDetailV2ResponseBodyModuleContactInfoDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["contact_info_d_t_o"]));
        contactInfoDTO = make_shared<FlightModifyOrderDetailV2ResponseBodyModuleContactInfoDTO>(model1);
      }
    }
    if (m.find("dest_flight_info_d_t_o_s") != m.end() && !m["dest_flight_info_d_t_o_s"].empty()) {
      if (typeid(vector<boost::any>) == m["dest_flight_info_d_t_o_s"].type()) {
        vector<FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOS> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dest_flight_info_d_t_o_s"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOS model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        destFlightInfoDTOS = make_shared<vector<FlightModifyOrderDetailV2ResponseBodyModuleDestFlightInfoDTOS>>(expect1);
      }
    }
    if (m.find("last_pay_time") != m.end() && !m["last_pay_time"].empty()) {
      lastPayTime = make_shared<string>(boost::any_cast<string>(m["last_pay_time"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("pay_time") != m.end() && !m["pay_time"].empty()) {
      payTime = make_shared<string>(boost::any_cast<string>(m["pay_time"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<long>(boost::any_cast<long>(m["sub_order_id"]));
    }
    if (m.find("ticket_time") != m.end() && !m["ticket_time"].empty()) {
      ticketTime = make_shared<string>(boost::any_cast<string>(m["ticket_time"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<long>(boost::any_cast<long>(m["total_price"]));
    }
    if (m.find("total_service_fee_price") != m.end() && !m["total_service_fee_price"].empty()) {
      totalServiceFeePrice = make_shared<long>(boost::any_cast<long>(m["total_service_fee_price"]));
    }
    if (m.find("traveler_info_d_t_o_s") != m.end() && !m["traveler_info_d_t_o_s"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_info_d_t_o_s"].type()) {
        vector<FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOS> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_info_d_t_o_s"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOS model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerInfoDTOS = make_shared<vector<FlightModifyOrderDetailV2ResponseBodyModuleTravelerInfoDTOS>>(expect1);
      }
    }
  }


  virtual ~FlightModifyOrderDetailV2ResponseBodyModule() = default;
};
class FlightModifyOrderDetailV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightModifyOrderDetailV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightModifyOrderDetailV2ResponseBody() {}

  explicit FlightModifyOrderDetailV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightModifyOrderDetailV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightModifyOrderDetailV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightModifyOrderDetailV2ResponseBody() = default;
};
class FlightModifyOrderDetailV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightModifyOrderDetailV2ResponseBody> body{};

  FlightModifyOrderDetailV2Response() {}

  explicit FlightModifyOrderDetailV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightModifyOrderDetailV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightModifyOrderDetailV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightModifyOrderDetailV2Response() = default;
};
class FlightModifyOtaSearchV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightModifyOtaSearchV2Headers() {}

  explicit FlightModifyOtaSearchV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2Headers() = default;
};
class FlightModifyOtaSearchV2RequestPassengerSegmentRelations : public Darabonba::Model {
public:
  shared_ptr<string> passengerId{};
  shared_ptr<vector<string>> segmentIdList{};

  FlightModifyOtaSearchV2RequestPassengerSegmentRelations() {}

  explicit FlightModifyOtaSearchV2RequestPassengerSegmentRelations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passengerId) {
      res["passenger_id"] = boost::any(*passengerId);
    }
    if (segmentIdList) {
      res["segment_id_list"] = boost::any(*segmentIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("passenger_id") != m.end() && !m["passenger_id"].empty()) {
      passengerId = make_shared<string>(boost::any_cast<string>(m["passenger_id"]));
    }
    if (m.find("segment_id_list") != m.end() && !m["segment_id_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["segment_id_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["segment_id_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      segmentIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~FlightModifyOtaSearchV2RequestPassengerSegmentRelations() = default;
};
class FlightModifyOtaSearchV2RequestSelectedSegments : public Darabonba::Model {
public:
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDateTime{};
  shared_ptr<long> journeySeq{};
  shared_ptr<string> marketingFlightNo{};
  shared_ptr<string> operatingFlightNo{};
  shared_ptr<long> segmentSeq{};

  FlightModifyOtaSearchV2RequestSelectedSegments() {}

  explicit FlightModifyOtaSearchV2RequestSelectedSegments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDateTime) {
      res["dep_date_time"] = boost::any(*depDateTime);
    }
    if (journeySeq) {
      res["journey_seq"] = boost::any(*journeySeq);
    }
    if (marketingFlightNo) {
      res["marketing_flight_no"] = boost::any(*marketingFlightNo);
    }
    if (operatingFlightNo) {
      res["operating_flight_no"] = boost::any(*operatingFlightNo);
    }
    if (segmentSeq) {
      res["segment_seq"] = boost::any(*segmentSeq);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date_time") != m.end() && !m["dep_date_time"].empty()) {
      depDateTime = make_shared<string>(boost::any_cast<string>(m["dep_date_time"]));
    }
    if (m.find("journey_seq") != m.end() && !m["journey_seq"].empty()) {
      journeySeq = make_shared<long>(boost::any_cast<long>(m["journey_seq"]));
    }
    if (m.find("marketing_flight_no") != m.end() && !m["marketing_flight_no"].empty()) {
      marketingFlightNo = make_shared<string>(boost::any_cast<string>(m["marketing_flight_no"]));
    }
    if (m.find("operating_flight_no") != m.end() && !m["operating_flight_no"].empty()) {
      operatingFlightNo = make_shared<string>(boost::any_cast<string>(m["operating_flight_no"]));
    }
    if (m.find("segment_seq") != m.end() && !m["segment_seq"].empty()) {
      segmentSeq = make_shared<long>(boost::any_cast<long>(m["segment_seq"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2RequestSelectedSegments() = default;
};
class FlightModifyOtaSearchV2Request : public Darabonba::Model {
public:
  shared_ptr<vector<long>> cabinClass{};
  shared_ptr<vector<string>> depDate{};
  shared_ptr<string> isvName{};
  shared_ptr<long> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<vector<FlightModifyOtaSearchV2RequestPassengerSegmentRelations>> passengerSegmentRelations{};
  shared_ptr<vector<FlightModifyOtaSearchV2RequestSelectedSegments>> selectedSegments{};
  shared_ptr<string> sessionId{};
  shared_ptr<bool> voluntary{};

  FlightModifyOtaSearchV2Request() {}

  explicit FlightModifyOtaSearchV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (passengerSegmentRelations) {
      vector<boost::any> temp1;
      for(auto item1:*passengerSegmentRelations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_segment_relations"] = boost::any(temp1);
    }
    if (selectedSegments) {
      vector<boost::any> temp1;
      for(auto item1:*selectedSegments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["selected_segments"] = boost::any(temp1);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (voluntary) {
      res["voluntary"] = boost::any(*voluntary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["cabin_class"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["cabin_class"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      cabinClass = make_shared<vector<long>>(toVec1);
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["dep_date"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["dep_date"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      depDate = make_shared<vector<string>>(toVec1);
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("passenger_segment_relations") != m.end() && !m["passenger_segment_relations"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_segment_relations"].type()) {
        vector<FlightModifyOtaSearchV2RequestPassengerSegmentRelations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_segment_relations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightModifyOtaSearchV2RequestPassengerSegmentRelations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerSegmentRelations = make_shared<vector<FlightModifyOtaSearchV2RequestPassengerSegmentRelations>>(expect1);
      }
    }
    if (m.find("selected_segments") != m.end() && !m["selected_segments"].empty()) {
      if (typeid(vector<boost::any>) == m["selected_segments"].type()) {
        vector<FlightModifyOtaSearchV2RequestSelectedSegments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["selected_segments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightModifyOtaSearchV2RequestSelectedSegments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        selectedSegments = make_shared<vector<FlightModifyOtaSearchV2RequestSelectedSegments>>(expect1);
      }
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("voluntary") != m.end() && !m["voluntary"].empty()) {
      voluntary = make_shared<bool>(boost::any_cast<bool>(m["voluntary"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2Request() = default;
};
class FlightModifyOtaSearchV2ShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cabinClassShrink{};
  shared_ptr<string> depDateShrink{};
  shared_ptr<string> isvName{};
  shared_ptr<long> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> passengerSegmentRelationsShrink{};
  shared_ptr<string> selectedSegmentsShrink{};
  shared_ptr<string> sessionId{};
  shared_ptr<bool> voluntary{};

  FlightModifyOtaSearchV2ShrinkRequest() {}

  explicit FlightModifyOtaSearchV2ShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabinClassShrink) {
      res["cabin_class"] = boost::any(*cabinClassShrink);
    }
    if (depDateShrink) {
      res["dep_date"] = boost::any(*depDateShrink);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (passengerSegmentRelationsShrink) {
      res["passenger_segment_relations"] = boost::any(*passengerSegmentRelationsShrink);
    }
    if (selectedSegmentsShrink) {
      res["selected_segments"] = boost::any(*selectedSegmentsShrink);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (voluntary) {
      res["voluntary"] = boost::any(*voluntary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClassShrink = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDateShrink = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("passenger_segment_relations") != m.end() && !m["passenger_segment_relations"].empty()) {
      passengerSegmentRelationsShrink = make_shared<string>(boost::any_cast<string>(m["passenger_segment_relations"]));
    }
    if (m.find("selected_segments") != m.end() && !m["selected_segments"].empty()) {
      selectedSegmentsShrink = make_shared<string>(boost::any_cast<string>(m["selected_segments"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("voluntary") != m.end() && !m["voluntary"].empty()) {
      voluntary = make_shared<bool>(boost::any_cast<bool>(m["voluntary"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2ShrinkRequest() = default;
};
class FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoCabinClassInfo : public Darabonba::Model {
public:
  shared_ptr<string> cabinClass{};
  shared_ptr<string> className{};
  shared_ptr<long> innerCabinClass{};
  shared_ptr<string> quantity{};

  FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoCabinClassInfo() {}

  explicit FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoCabinClassInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (className) {
      res["class_name"] = boost::any(*className);
    }
    if (innerCabinClass) {
      res["inner_cabin_class"] = boost::any(*innerCabinClass);
    }
    if (quantity) {
      res["quantity"] = boost::any(*quantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("class_name") != m.end() && !m["class_name"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["class_name"]));
    }
    if (m.find("inner_cabin_class") != m.end() && !m["inner_cabin_class"].empty()) {
      innerCabinClass = make_shared<long>(boost::any_cast<long>(m["inner_cabin_class"]));
    }
    if (m.find("quantity") != m.end() && !m["quantity"].empty()) {
      quantity = make_shared<string>(boost::any_cast<string>(m["quantity"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoCabinClassInfo() = default;
};
class FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoPriceInfoDTOReShopPriceInfoDTO : public Darabonba::Model {
public:
  shared_ptr<long> reShopAdultChangeFee{};
  shared_ptr<long> reShopAdultPrice{};
  shared_ptr<long> reShopAdultPriceGap{};
  shared_ptr<long> reShopChildChangeFee{};
  shared_ptr<long> reShopChildPrice{};
  shared_ptr<long> reShopChildPriceGap{};
  shared_ptr<long> reShopInfChangeFee{};
  shared_ptr<long> reShopInfPrice{};
  shared_ptr<long> reShopInfPriceGap{};

  FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoPriceInfoDTOReShopPriceInfoDTO() {}

  explicit FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoPriceInfoDTOReShopPriceInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reShopAdultChangeFee) {
      res["re_shop_adult_change_fee"] = boost::any(*reShopAdultChangeFee);
    }
    if (reShopAdultPrice) {
      res["re_shop_adult_price"] = boost::any(*reShopAdultPrice);
    }
    if (reShopAdultPriceGap) {
      res["re_shop_adult_price_gap"] = boost::any(*reShopAdultPriceGap);
    }
    if (reShopChildChangeFee) {
      res["re_shop_child_change_fee"] = boost::any(*reShopChildChangeFee);
    }
    if (reShopChildPrice) {
      res["re_shop_child_price"] = boost::any(*reShopChildPrice);
    }
    if (reShopChildPriceGap) {
      res["re_shop_child_price_gap"] = boost::any(*reShopChildPriceGap);
    }
    if (reShopInfChangeFee) {
      res["re_shop_inf_change_fee"] = boost::any(*reShopInfChangeFee);
    }
    if (reShopInfPrice) {
      res["re_shop_inf_price"] = boost::any(*reShopInfPrice);
    }
    if (reShopInfPriceGap) {
      res["re_shop_inf_price_gap"] = boost::any(*reShopInfPriceGap);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("re_shop_adult_change_fee") != m.end() && !m["re_shop_adult_change_fee"].empty()) {
      reShopAdultChangeFee = make_shared<long>(boost::any_cast<long>(m["re_shop_adult_change_fee"]));
    }
    if (m.find("re_shop_adult_price") != m.end() && !m["re_shop_adult_price"].empty()) {
      reShopAdultPrice = make_shared<long>(boost::any_cast<long>(m["re_shop_adult_price"]));
    }
    if (m.find("re_shop_adult_price_gap") != m.end() && !m["re_shop_adult_price_gap"].empty()) {
      reShopAdultPriceGap = make_shared<long>(boost::any_cast<long>(m["re_shop_adult_price_gap"]));
    }
    if (m.find("re_shop_child_change_fee") != m.end() && !m["re_shop_child_change_fee"].empty()) {
      reShopChildChangeFee = make_shared<long>(boost::any_cast<long>(m["re_shop_child_change_fee"]));
    }
    if (m.find("re_shop_child_price") != m.end() && !m["re_shop_child_price"].empty()) {
      reShopChildPrice = make_shared<long>(boost::any_cast<long>(m["re_shop_child_price"]));
    }
    if (m.find("re_shop_child_price_gap") != m.end() && !m["re_shop_child_price_gap"].empty()) {
      reShopChildPriceGap = make_shared<long>(boost::any_cast<long>(m["re_shop_child_price_gap"]));
    }
    if (m.find("re_shop_inf_change_fee") != m.end() && !m["re_shop_inf_change_fee"].empty()) {
      reShopInfChangeFee = make_shared<long>(boost::any_cast<long>(m["re_shop_inf_change_fee"]));
    }
    if (m.find("re_shop_inf_price") != m.end() && !m["re_shop_inf_price"].empty()) {
      reShopInfPrice = make_shared<long>(boost::any_cast<long>(m["re_shop_inf_price"]));
    }
    if (m.find("re_shop_inf_price_gap") != m.end() && !m["re_shop_inf_price_gap"].empty()) {
      reShopInfPriceGap = make_shared<long>(boost::any_cast<long>(m["re_shop_inf_price_gap"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoPriceInfoDTOReShopPriceInfoDTO() = default;
};
class FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoPriceInfoDTO : public Darabonba::Model {
public:
  shared_ptr<long> adultPrice{};
  shared_ptr<long> adultTax{};
  shared_ptr<long> adultTotalPrice{};
  shared_ptr<long> beforeControlPrice{};
  shared_ptr<long> childPrice{};
  shared_ptr<long> childTax{};
  shared_ptr<long> childTotalPrice{};
  shared_ptr<long> infantPrice{};
  shared_ptr<long> infantTax{};
  shared_ptr<long> infantTotalPrice{};
  shared_ptr<long> originalAdultPrice{};
  shared_ptr<long> originalAdultTotalPrice{};
  shared_ptr<FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoPriceInfoDTOReShopPriceInfoDTO> reShopPriceInfoDTO{};

  FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoPriceInfoDTO() {}

  explicit FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoPriceInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adultPrice) {
      res["adult_price"] = boost::any(*adultPrice);
    }
    if (adultTax) {
      res["adult_tax"] = boost::any(*adultTax);
    }
    if (adultTotalPrice) {
      res["adult_total_price"] = boost::any(*adultTotalPrice);
    }
    if (beforeControlPrice) {
      res["before_control_price"] = boost::any(*beforeControlPrice);
    }
    if (childPrice) {
      res["child_price"] = boost::any(*childPrice);
    }
    if (childTax) {
      res["child_tax"] = boost::any(*childTax);
    }
    if (childTotalPrice) {
      res["child_total_price"] = boost::any(*childTotalPrice);
    }
    if (infantPrice) {
      res["infant_price"] = boost::any(*infantPrice);
    }
    if (infantTax) {
      res["infant_tax"] = boost::any(*infantTax);
    }
    if (infantTotalPrice) {
      res["infant_total_price"] = boost::any(*infantTotalPrice);
    }
    if (originalAdultPrice) {
      res["original_adult_price"] = boost::any(*originalAdultPrice);
    }
    if (originalAdultTotalPrice) {
      res["original_adult_total_price"] = boost::any(*originalAdultTotalPrice);
    }
    if (reShopPriceInfoDTO) {
      res["re_shop_price_info_d_t_o"] = reShopPriceInfoDTO ? boost::any(reShopPriceInfoDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("adult_price") != m.end() && !m["adult_price"].empty()) {
      adultPrice = make_shared<long>(boost::any_cast<long>(m["adult_price"]));
    }
    if (m.find("adult_tax") != m.end() && !m["adult_tax"].empty()) {
      adultTax = make_shared<long>(boost::any_cast<long>(m["adult_tax"]));
    }
    if (m.find("adult_total_price") != m.end() && !m["adult_total_price"].empty()) {
      adultTotalPrice = make_shared<long>(boost::any_cast<long>(m["adult_total_price"]));
    }
    if (m.find("before_control_price") != m.end() && !m["before_control_price"].empty()) {
      beforeControlPrice = make_shared<long>(boost::any_cast<long>(m["before_control_price"]));
    }
    if (m.find("child_price") != m.end() && !m["child_price"].empty()) {
      childPrice = make_shared<long>(boost::any_cast<long>(m["child_price"]));
    }
    if (m.find("child_tax") != m.end() && !m["child_tax"].empty()) {
      childTax = make_shared<long>(boost::any_cast<long>(m["child_tax"]));
    }
    if (m.find("child_total_price") != m.end() && !m["child_total_price"].empty()) {
      childTotalPrice = make_shared<long>(boost::any_cast<long>(m["child_total_price"]));
    }
    if (m.find("infant_price") != m.end() && !m["infant_price"].empty()) {
      infantPrice = make_shared<long>(boost::any_cast<long>(m["infant_price"]));
    }
    if (m.find("infant_tax") != m.end() && !m["infant_tax"].empty()) {
      infantTax = make_shared<long>(boost::any_cast<long>(m["infant_tax"]));
    }
    if (m.find("infant_total_price") != m.end() && !m["infant_total_price"].empty()) {
      infantTotalPrice = make_shared<long>(boost::any_cast<long>(m["infant_total_price"]));
    }
    if (m.find("original_adult_price") != m.end() && !m["original_adult_price"].empty()) {
      originalAdultPrice = make_shared<long>(boost::any_cast<long>(m["original_adult_price"]));
    }
    if (m.find("original_adult_total_price") != m.end() && !m["original_adult_total_price"].empty()) {
      originalAdultTotalPrice = make_shared<long>(boost::any_cast<long>(m["original_adult_total_price"]));
    }
    if (m.find("re_shop_price_info_d_t_o") != m.end() && !m["re_shop_price_info_d_t_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["re_shop_price_info_d_t_o"].type()) {
        FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoPriceInfoDTOReShopPriceInfoDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["re_shop_price_info_d_t_o"]));
        reShopPriceInfoDTO = make_shared<FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoPriceInfoDTOReShopPriceInfoDTO>(model1);
      }
    }
  }


  virtual ~FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoPriceInfoDTO() = default;
};
class FlightModifyOtaSearchV2ResponseBodyModuleAgentInfo : public Darabonba::Model {
public:
  shared_ptr<map<string, vector<ModuleAgentInfoAttributeShowInfoMapValue>>> attributeShowInfoMap{};
  shared_ptr<double> bestDiscount{};
  shared_ptr<FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoCabinClassInfo> cabinClassInfo{};
  shared_ptr<long> cabinCode{};
  shared_ptr<string> cabinName{};
  shared_ptr<string> itemId{};
  shared_ptr<string> modifyTypeDesc{};
  shared_ptr<string> modifyTypeName{};
  shared_ptr<FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoPriceInfoDTO> priceInfoDTO{};
  shared_ptr<long> quantity{};
  shared_ptr<bool> supportChildTicket{};

  FlightModifyOtaSearchV2ResponseBodyModuleAgentInfo() {}

  explicit FlightModifyOtaSearchV2ResponseBodyModuleAgentInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeShowInfoMap) {
      map<string, boost::any> temp1;
      for(auto item1:*attributeShowInfoMap){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["attribute_show_info_map"] = boost::any(temp1);
    }
    if (bestDiscount) {
      res["best_discount"] = boost::any(*bestDiscount);
    }
    if (cabinClassInfo) {
      res["cabin_class_info"] = cabinClassInfo ? boost::any(cabinClassInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cabinCode) {
      res["cabin_code"] = boost::any(*cabinCode);
    }
    if (cabinName) {
      res["cabin_name"] = boost::any(*cabinName);
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (modifyTypeDesc) {
      res["modify_type_desc"] = boost::any(*modifyTypeDesc);
    }
    if (modifyTypeName) {
      res["modify_type_name"] = boost::any(*modifyTypeName);
    }
    if (priceInfoDTO) {
      res["price_info_d_t_o"] = priceInfoDTO ? boost::any(priceInfoDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (quantity) {
      res["quantity"] = boost::any(*quantity);
    }
    if (supportChildTicket) {
      res["support_child_ticket"] = boost::any(*supportChildTicket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("attribute_show_info_map") != m.end() && !m["attribute_show_info_map"].empty()) {
      if (typeid(map<string, boost::any>) == m["attribute_show_info_map"].type()) {
        map<string, vector<ModuleAgentInfoAttributeShowInfoMapValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["attribute_show_info_map"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<ModuleAgentInfoAttributeShowInfoMapValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                ModuleAgentInfoAttributeShowInfoMapValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        attributeShowInfoMap = make_shared<map<string, vector<ModuleAgentInfoAttributeShowInfoMapValue>>>(expect1);
      }
    }
    if (m.find("best_discount") != m.end() && !m["best_discount"].empty()) {
      bestDiscount = make_shared<double>(boost::any_cast<double>(m["best_discount"]));
    }
    if (m.find("cabin_class_info") != m.end() && !m["cabin_class_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["cabin_class_info"].type()) {
        FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoCabinClassInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cabin_class_info"]));
        cabinClassInfo = make_shared<FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoCabinClassInfo>(model1);
      }
    }
    if (m.find("cabin_code") != m.end() && !m["cabin_code"].empty()) {
      cabinCode = make_shared<long>(boost::any_cast<long>(m["cabin_code"]));
    }
    if (m.find("cabin_name") != m.end() && !m["cabin_name"].empty()) {
      cabinName = make_shared<string>(boost::any_cast<string>(m["cabin_name"]));
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["item_id"]));
    }
    if (m.find("modify_type_desc") != m.end() && !m["modify_type_desc"].empty()) {
      modifyTypeDesc = make_shared<string>(boost::any_cast<string>(m["modify_type_desc"]));
    }
    if (m.find("modify_type_name") != m.end() && !m["modify_type_name"].empty()) {
      modifyTypeName = make_shared<string>(boost::any_cast<string>(m["modify_type_name"]));
    }
    if (m.find("price_info_d_t_o") != m.end() && !m["price_info_d_t_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["price_info_d_t_o"].type()) {
        FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoPriceInfoDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["price_info_d_t_o"]));
        priceInfoDTO = make_shared<FlightModifyOtaSearchV2ResponseBodyModuleAgentInfoPriceInfoDTO>(model1);
      }
    }
    if (m.find("quantity") != m.end() && !m["quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["quantity"]));
    }
    if (m.find("support_child_ticket") != m.end() && !m["support_child_ticket"].empty()) {
      supportChildTicket = make_shared<bool>(boost::any_cast<bool>(m["support_child_ticket"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2ResponseBodyModuleAgentInfo() = default;
};
class FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> airportShortName{};
  shared_ptr<string> terminal{};

  FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosDepAirportInfo() {}

  explicit FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (airportShortName) {
      res["airport_short_name"] = boost::any(*airportShortName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("airport_short_name") != m.end() && !m["airport_short_name"].empty()) {
      airportShortName = make_shared<string>(boost::any_cast<string>(m["airport_short_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosDepAirportInfo() = default;
};
class FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> airportShortName{};
  shared_ptr<string> terminal{};

  FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosArrAirportInfo() {}

  explicit FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (airportShortName) {
      res["airport_short_name"] = boost::any(*airportShortName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("airport_short_name") != m.end() && !m["airport_short_name"].empty()) {
      airportShortName = make_shared<string>(boost::any_cast<string>(m["airport_short_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosArrAirportInfo() = default;
};
class FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineChineseName{};
  shared_ptr<string> airlineChineseShortName{};
  shared_ptr<string> airlineIcon{};
  shared_ptr<bool> cheapFlight{};

  FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosAirlineInfo() {}

  explicit FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineChineseName) {
      res["airline_chinese_name"] = boost::any(*airlineChineseName);
    }
    if (airlineChineseShortName) {
      res["airline_chinese_short_name"] = boost::any(*airlineChineseShortName);
    }
    if (airlineIcon) {
      res["airline_icon"] = boost::any(*airlineIcon);
    }
    if (cheapFlight) {
      res["cheap_flight"] = boost::any(*cheapFlight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_chinese_name") != m.end() && !m["airline_chinese_name"].empty()) {
      airlineChineseName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_name"]));
    }
    if (m.find("airline_chinese_short_name") != m.end() && !m["airline_chinese_short_name"].empty()) {
      airlineChineseShortName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_short_name"]));
    }
    if (m.find("airline_icon") != m.end() && !m["airline_icon"].empty()) {
      airlineIcon = make_shared<string>(boost::any_cast<string>(m["airline_icon"]));
    }
    if (m.find("cheap_flight") != m.end() && !m["cheap_flight"].empty()) {
      cheapFlight = make_shared<bool>(boost::any_cast<bool>(m["cheap_flight"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosAirlineInfo() = default;
};
class FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightSharedInfoOperatingAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineChineseName{};
  shared_ptr<string> airlineChineseShortName{};
  shared_ptr<string> airlineIcon{};
  shared_ptr<bool> cheapFlight{};

  FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightSharedInfoOperatingAirlineInfo() {}

  explicit FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightSharedInfoOperatingAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineChineseName) {
      res["airline_chinese_name"] = boost::any(*airlineChineseName);
    }
    if (airlineChineseShortName) {
      res["airline_chinese_short_name"] = boost::any(*airlineChineseShortName);
    }
    if (airlineIcon) {
      res["airline_icon"] = boost::any(*airlineIcon);
    }
    if (cheapFlight) {
      res["cheap_flight"] = boost::any(*cheapFlight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_chinese_name") != m.end() && !m["airline_chinese_name"].empty()) {
      airlineChineseName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_name"]));
    }
    if (m.find("airline_chinese_short_name") != m.end() && !m["airline_chinese_short_name"].empty()) {
      airlineChineseShortName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_short_name"]));
    }
    if (m.find("airline_icon") != m.end() && !m["airline_icon"].empty()) {
      airlineIcon = make_shared<string>(boost::any_cast<string>(m["airline_icon"]));
    }
    if (m.find("cheap_flight") != m.end() && !m["cheap_flight"].empty()) {
      cheapFlight = make_shared<bool>(boost::any_cast<bool>(m["cheap_flight"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightSharedInfoOperatingAirlineInfo() = default;
};
class FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightSharedInfo : public Darabonba::Model {
public:
  shared_ptr<string> operatingFlightNo{};
  shared_ptr<FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightSharedInfoOperatingAirlineInfo> operatingAirlineInfo{};

  FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightSharedInfo() {}

  explicit FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightSharedInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operatingFlightNo) {
      res["operating_flight_no"] = boost::any(*operatingFlightNo);
    }
    if (operatingAirlineInfo) {
      res["operating_airline_info"] = operatingAirlineInfo ? boost::any(operatingAirlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("operating_flight_no") != m.end() && !m["operating_flight_no"].empty()) {
      operatingFlightNo = make_shared<string>(boost::any_cast<string>(m["operating_flight_no"]));
    }
    if (m.find("operating_airline_info") != m.end() && !m["operating_airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["operating_airline_info"].type()) {
        FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightSharedInfoOperatingAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["operating_airline_info"]));
        operatingAirlineInfo = make_shared<FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightSharedInfoOperatingAirlineInfo>(model1);
      }
    }
  }


  virtual ~FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightSharedInfo() = default;
};
class FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightStopInfo : public Darabonba::Model {
public:
  shared_ptr<string> stopCityName{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopDepTime{};
  shared_ptr<string> stopCityCode{};
  shared_ptr<string> stopAirport{};
  shared_ptr<string> stopArrTerm{};
  shared_ptr<string> stopDepTerm{};

  FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightStopInfo() {}

  explicit FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightStopInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stopCityName) {
      res["stop_city_name"] = boost::any(*stopCityName);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    if (stopCityCode) {
      res["stop_city_code"] = boost::any(*stopCityCode);
    }
    if (stopAirport) {
      res["stop_airport"] = boost::any(*stopAirport);
    }
    if (stopArrTerm) {
      res["stop_arr_term"] = boost::any(*stopArrTerm);
    }
    if (stopDepTerm) {
      res["stop_dep_term"] = boost::any(*stopDepTerm);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("stop_city_name") != m.end() && !m["stop_city_name"].empty()) {
      stopCityName = make_shared<string>(boost::any_cast<string>(m["stop_city_name"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
    if (m.find("stop_city_code") != m.end() && !m["stop_city_code"].empty()) {
      stopCityCode = make_shared<string>(boost::any_cast<string>(m["stop_city_code"]));
    }
    if (m.find("stop_airport") != m.end() && !m["stop_airport"].empty()) {
      stopAirport = make_shared<string>(boost::any_cast<string>(m["stop_airport"]));
    }
    if (m.find("stop_arr_term") != m.end() && !m["stop_arr_term"].empty()) {
      stopArrTerm = make_shared<string>(boost::any_cast<string>(m["stop_arr_term"]));
    }
    if (m.find("stop_dep_term") != m.end() && !m["stop_dep_term"].empty()) {
      stopDepTerm = make_shared<string>(boost::any_cast<string>(m["stop_dep_term"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightStopInfo() = default;
};
class FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfos : public Darabonba::Model {
public:
  shared_ptr<long> journeySeq{};
  shared_ptr<long> segmentSeq{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> arrCityName{};
  shared_ptr<FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosDepAirportInfo> depAirportInfo{};
  shared_ptr<FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosArrAirportInfo> arrAirportInfo{};
  shared_ptr<string> depTime{};
  shared_ptr<string> arrTime{};
  shared_ptr<FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosAirlineInfo> airlineInfo{};
  shared_ptr<bool> share{};
  shared_ptr<FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightSharedInfo> flightSharedInfo{};
  shared_ptr<bool> stop{};
  shared_ptr<FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightStopInfo> flightStopInfo{};
  shared_ptr<long> transferTime{};
  shared_ptr<long> duration{};
  shared_ptr<string> manufacturer{};
  shared_ptr<string> flightType{};
  shared_ptr<string> flightSize{};
  shared_ptr<string> mealDesc{};
  shared_ptr<string> onTimeRate{};

  FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfos() {}

  explicit FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (journeySeq) {
      res["journey_seq"] = boost::any(*journeySeq);
    }
    if (segmentSeq) {
      res["segment_seq"] = boost::any(*segmentSeq);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (share) {
      res["share"] = boost::any(*share);
    }
    if (flightSharedInfo) {
      res["flight_shared_info"] = flightSharedInfo ? boost::any(flightSharedInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stop) {
      res["stop"] = boost::any(*stop);
    }
    if (flightStopInfo) {
      res["flight_stop_info"] = flightStopInfo ? boost::any(flightStopInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transferTime) {
      res["transfer_time"] = boost::any(*transferTime);
    }
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (manufacturer) {
      res["manufacturer"] = boost::any(*manufacturer);
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (onTimeRate) {
      res["on_time_rate"] = boost::any(*onTimeRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("journey_seq") != m.end() && !m["journey_seq"].empty()) {
      journeySeq = make_shared<long>(boost::any_cast<long>(m["journey_seq"]));
    }
    if (m.find("segment_seq") != m.end() && !m["segment_seq"].empty()) {
      segmentSeq = make_shared<long>(boost::any_cast<long>(m["segment_seq"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosDepAirportInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosArrAirportInfo>(model1);
      }
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosAirlineInfo>(model1);
      }
    }
    if (m.find("share") != m.end() && !m["share"].empty()) {
      share = make_shared<bool>(boost::any_cast<bool>(m["share"]));
    }
    if (m.find("flight_shared_info") != m.end() && !m["flight_shared_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_shared_info"].type()) {
        FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightSharedInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flight_shared_info"]));
        flightSharedInfo = make_shared<FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightSharedInfo>(model1);
      }
    }
    if (m.find("stop") != m.end() && !m["stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["stop"]));
    }
    if (m.find("flight_stop_info") != m.end() && !m["flight_stop_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_stop_info"].type()) {
        FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightStopInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flight_stop_info"]));
        flightStopInfo = make_shared<FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfosFlightStopInfo>(model1);
      }
    }
    if (m.find("transfer_time") != m.end() && !m["transfer_time"].empty()) {
      transferTime = make_shared<long>(boost::any_cast<long>(m["transfer_time"]));
    }
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("manufacturer") != m.end() && !m["manufacturer"].empty()) {
      manufacturer = make_shared<string>(boost::any_cast<string>(m["manufacturer"]));
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("on_time_rate") != m.end() && !m["on_time_rate"].empty()) {
      onTimeRate = make_shared<string>(boost::any_cast<string>(m["on_time_rate"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2ResponseBodyModuleFlightSegmentInfos() = default;
};
class FlightModifyOtaSearchV2ResponseBodyModulePassengerCount : public Darabonba::Model {
public:
  shared_ptr<long> adultPassengerNum{};
  shared_ptr<long> childPassengerNum{};
  shared_ptr<long> infantPassengerNum{};

  FlightModifyOtaSearchV2ResponseBodyModulePassengerCount() {}

  explicit FlightModifyOtaSearchV2ResponseBodyModulePassengerCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adultPassengerNum) {
      res["adult_passenger_num"] = boost::any(*adultPassengerNum);
    }
    if (childPassengerNum) {
      res["child_passenger_num"] = boost::any(*childPassengerNum);
    }
    if (infantPassengerNum) {
      res["infant_passenger_num"] = boost::any(*infantPassengerNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("adult_passenger_num") != m.end() && !m["adult_passenger_num"].empty()) {
      adultPassengerNum = make_shared<long>(boost::any_cast<long>(m["adult_passenger_num"]));
    }
    if (m.find("child_passenger_num") != m.end() && !m["child_passenger_num"].empty()) {
      childPassengerNum = make_shared<long>(boost::any_cast<long>(m["child_passenger_num"]));
    }
    if (m.find("infant_passenger_num") != m.end() && !m["infant_passenger_num"].empty()) {
      infantPassengerNum = make_shared<long>(boost::any_cast<long>(m["infant_passenger_num"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2ResponseBodyModulePassengerCount() = default;
};
class FlightModifyOtaSearchV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<FlightModifyOtaSearchV2ResponseBodyModuleAgentInfo> agentInfo{};
  shared_ptr<string> cacheKey{};
  shared_ptr<vector<vector<undefined>>> flightSegmentInfos{};
  shared_ptr<FlightModifyOtaSearchV2ResponseBodyModulePassengerCount> passengerCount{};
  shared_ptr<string> sessionId{};

  FlightModifyOtaSearchV2ResponseBodyModule() {}

  explicit FlightModifyOtaSearchV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentInfo) {
      res["agent_info"] = agentInfo ? boost::any(agentInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cacheKey) {
      res["cache_key"] = boost::any(*cacheKey);
    }
    if (flightSegmentInfos) {
      vector<boost::any> temp1;
      for(auto item1:*flightSegmentInfos){
        vector<boost::any> temp2;
        for(auto item2:item1){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1 = boost::any(temp2);
      }
      res["flight_segment_infos"] = boost::any(temp1);
    }
    if (passengerCount) {
      res["passenger_count"] = passengerCount ? boost::any(passengerCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("agent_info") != m.end() && !m["agent_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["agent_info"].type()) {
        FlightModifyOtaSearchV2ResponseBodyModuleAgentInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["agent_info"]));
        agentInfo = make_shared<FlightModifyOtaSearchV2ResponseBodyModuleAgentInfo>(model1);
      }
    }
    if (m.find("cache_key") != m.end() && !m["cache_key"].empty()) {
      cacheKey = make_shared<string>(boost::any_cast<string>(m["cache_key"]));
    }
    if (m.find("flight_segment_infos") != m.end() && !m["flight_segment_infos"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_segment_infos"].type()) {
        vector<vector<undefined>> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_segment_infos"])){
          if (typeid(vector<boost::any>) == item1.type()) {
            vector<undefined> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                undefined model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1.push_back(expect2);
          }
        }
        flightSegmentInfos = make_shared<vector<vector<undefined>>>(expect1);
      }
    }
    if (m.find("passenger_count") != m.end() && !m["passenger_count"].empty()) {
      if (typeid(map<string, boost::any>) == m["passenger_count"].type()) {
        FlightModifyOtaSearchV2ResponseBodyModulePassengerCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["passenger_count"]));
        passengerCount = make_shared<FlightModifyOtaSearchV2ResponseBodyModulePassengerCount>(model1);
      }
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2ResponseBodyModule() = default;
};
class FlightModifyOtaSearchV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightModifyOtaSearchV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightModifyOtaSearchV2ResponseBody() {}

  explicit FlightModifyOtaSearchV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightModifyOtaSearchV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightModifyOtaSearchV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightModifyOtaSearchV2ResponseBody() = default;
};
class FlightModifyOtaSearchV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightModifyOtaSearchV2ResponseBody> body{};

  FlightModifyOtaSearchV2Response() {}

  explicit FlightModifyOtaSearchV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightModifyOtaSearchV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightModifyOtaSearchV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightModifyOtaSearchV2Response() = default;
};
class FlightModifyPayV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightModifyPayV2Headers() {}

  explicit FlightModifyPayV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightModifyPayV2Headers() = default;
};
class FlightModifyPayV2Request : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> extParams{};
  shared_ptr<string> isvName{};
  shared_ptr<long> modifyPayAmount{};
  shared_ptr<long> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<long> subOrderId{};

  FlightModifyPayV2Request() {}

  explicit FlightModifyPayV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extParams) {
      res["ext_params"] = boost::any(*extParams);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (modifyPayAmount) {
      res["modify_pay_amount"] = boost::any(*modifyPayAmount);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ext_params") != m.end() && !m["ext_params"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ext_params"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extParams = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("modify_pay_amount") != m.end() && !m["modify_pay_amount"].empty()) {
      modifyPayAmount = make_shared<long>(boost::any_cast<long>(m["modify_pay_amount"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<long>(boost::any_cast<long>(m["sub_order_id"]));
    }
  }


  virtual ~FlightModifyPayV2Request() = default;
};
class FlightModifyPayV2ShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> extParamsShrink{};
  shared_ptr<string> isvName{};
  shared_ptr<long> modifyPayAmount{};
  shared_ptr<long> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<long> subOrderId{};

  FlightModifyPayV2ShrinkRequest() {}

  explicit FlightModifyPayV2ShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extParamsShrink) {
      res["ext_params"] = boost::any(*extParamsShrink);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (modifyPayAmount) {
      res["modify_pay_amount"] = boost::any(*modifyPayAmount);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ext_params") != m.end() && !m["ext_params"].empty()) {
      extParamsShrink = make_shared<string>(boost::any_cast<string>(m["ext_params"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("modify_pay_amount") != m.end() && !m["modify_pay_amount"].empty()) {
      modifyPayAmount = make_shared<long>(boost::any_cast<long>(m["modify_pay_amount"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<long>(boost::any_cast<long>(m["sub_order_id"]));
    }
  }


  virtual ~FlightModifyPayV2ShrinkRequest() = default;
};
class FlightModifyPayV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<map<string, boost::any>> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightModifyPayV2ResponseBody() {}

  explicit FlightModifyPayV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["module"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      module = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightModifyPayV2ResponseBody() = default;
};
class FlightModifyPayV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightModifyPayV2ResponseBody> body{};

  FlightModifyPayV2Response() {}

  explicit FlightModifyPayV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightModifyPayV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightModifyPayV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightModifyPayV2Response() = default;
};
class FlightOrderDetailInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightOrderDetailInfoHeaders() {}

  explicit FlightOrderDetailInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightOrderDetailInfoHeaders() = default;
};
class FlightOrderDetailInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};

  FlightOrderDetailInfoRequest() {}

  explicit FlightOrderDetailInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
  }


  virtual ~FlightOrderDetailInfoRequest() = default;
};
class FlightOrderDetailInfoResponseBodyModuleFlightInfoList : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};
  shared_ptr<string> arrAirport{};
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrAirportCodeName{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrTerminal{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> baggage{};
  shared_ptr<long> buildPrice{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> carrier{};
  shared_ptr<string> depAirport{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depAirportCodeName{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depTerminal{};
  shared_ptr<string> depTime{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> lastCabin{};
  shared_ptr<string> lastFlightNo{};
  shared_ptr<string> meal{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> segmentType{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopDepTime{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<string> tuigaiqianInfo{};

  FlightOrderDetailInfoResponseBodyModuleFlightInfoList() {}

  explicit FlightOrderDetailInfoResponseBodyModuleFlightInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    if (arrAirport) {
      res["arr_airport"] = boost::any(*arrAirport);
    }
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrAirportCodeName) {
      res["arr_airport_code_name"] = boost::any(*arrAirportCodeName);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrTerminal) {
      res["arr_terminal"] = boost::any(*arrTerminal);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (baggage) {
      res["baggage"] = boost::any(*baggage);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (carrier) {
      res["carrier"] = boost::any(*carrier);
    }
    if (depAirport) {
      res["dep_airport"] = boost::any(*depAirport);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depAirportCodeName) {
      res["dep_airport_code_name"] = boost::any(*depAirportCodeName);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depTerminal) {
      res["dep_terminal"] = boost::any(*depTerminal);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (lastCabin) {
      res["last_cabin"] = boost::any(*lastCabin);
    }
    if (lastFlightNo) {
      res["last_flight_no"] = boost::any(*lastFlightNo);
    }
    if (meal) {
      res["meal"] = boost::any(*meal);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (segmentType) {
      res["segment_type"] = boost::any(*segmentType);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
    if (m.find("arr_airport") != m.end() && !m["arr_airport"].empty()) {
      arrAirport = make_shared<string>(boost::any_cast<string>(m["arr_airport"]));
    }
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_airport_code_name") != m.end() && !m["arr_airport_code_name"].empty()) {
      arrAirportCodeName = make_shared<string>(boost::any_cast<string>(m["arr_airport_code_name"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_terminal") != m.end() && !m["arr_terminal"].empty()) {
      arrTerminal = make_shared<string>(boost::any_cast<string>(m["arr_terminal"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("baggage") != m.end() && !m["baggage"].empty()) {
      baggage = make_shared<string>(boost::any_cast<string>(m["baggage"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("carrier") != m.end() && !m["carrier"].empty()) {
      carrier = make_shared<string>(boost::any_cast<string>(m["carrier"]));
    }
    if (m.find("dep_airport") != m.end() && !m["dep_airport"].empty()) {
      depAirport = make_shared<string>(boost::any_cast<string>(m["dep_airport"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_airport_code_name") != m.end() && !m["dep_airport_code_name"].empty()) {
      depAirportCodeName = make_shared<string>(boost::any_cast<string>(m["dep_airport_code_name"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_terminal") != m.end() && !m["dep_terminal"].empty()) {
      depTerminal = make_shared<string>(boost::any_cast<string>(m["dep_terminal"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("last_cabin") != m.end() && !m["last_cabin"].empty()) {
      lastCabin = make_shared<string>(boost::any_cast<string>(m["last_cabin"]));
    }
    if (m.find("last_flight_no") != m.end() && !m["last_flight_no"].empty()) {
      lastFlightNo = make_shared<string>(boost::any_cast<string>(m["last_flight_no"]));
    }
    if (m.find("meal") != m.end() && !m["meal"].empty()) {
      meal = make_shared<string>(boost::any_cast<string>(m["meal"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("segment_type") != m.end() && !m["segment_type"].empty()) {
      segmentType = make_shared<long>(boost::any_cast<long>(m["segment_type"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
  }


  virtual ~FlightOrderDetailInfoResponseBodyModuleFlightInfoList() = default;
};
class FlightOrderDetailInfoResponseBodyModuleTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<string> openTicketStatus{};
  shared_ptr<string> pnrCode{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> ticketStatus{};

  FlightOrderDetailInfoResponseBodyModuleTicketInfoList() {}

  explicit FlightOrderDetailInfoResponseBodyModuleTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openTicketStatus) {
      res["open_ticket_status"] = boost::any(*openTicketStatus);
    }
    if (pnrCode) {
      res["pnr_code"] = boost::any(*pnrCode);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (ticketStatus) {
      res["ticket_status"] = boost::any(*ticketStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("open_ticket_status") != m.end() && !m["open_ticket_status"].empty()) {
      openTicketStatus = make_shared<string>(boost::any_cast<string>(m["open_ticket_status"]));
    }
    if (m.find("pnr_code") != m.end() && !m["pnr_code"].empty()) {
      pnrCode = make_shared<string>(boost::any_cast<string>(m["pnr_code"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("ticket_status") != m.end() && !m["ticket_status"].empty()) {
      ticketStatus = make_shared<string>(boost::any_cast<string>(m["ticket_status"]));
    }
  }


  virtual ~FlightOrderDetailInfoResponseBodyModuleTicketInfoList() = default;
};
class FlightOrderDetailInfoResponseBodyModuleTravelerInfoList : public Darabonba::Model {
public:
  shared_ptr<string> birthDate{};
  shared_ptr<string> certNo{};
  shared_ptr<string> certType{};
  shared_ptr<long> openTicketStatus{};
  shared_ptr<string> passengerName{};
  shared_ptr<string> passengerType{};
  shared_ptr<string> phone{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> userId{};

  FlightOrderDetailInfoResponseBodyModuleTravelerInfoList() {}

  explicit FlightOrderDetailInfoResponseBodyModuleTravelerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthDate) {
      res["birth_date"] = boost::any(*birthDate);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (openTicketStatus) {
      res["open_ticket_status"] = boost::any(*openTicketStatus);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birth_date") != m.end() && !m["birth_date"].empty()) {
      birthDate = make_shared<string>(boost::any_cast<string>(m["birth_date"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["cert_type"]));
    }
    if (m.find("open_ticket_status") != m.end() && !m["open_ticket_status"].empty()) {
      openTicketStatus = make_shared<long>(boost::any_cast<long>(m["open_ticket_status"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<string>(boost::any_cast<string>(m["passenger_type"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightOrderDetailInfoResponseBodyModuleTravelerInfoList() = default;
};
class FlightOrderDetailInfoResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<string> bookUserId{};
  shared_ptr<long> btripOrderId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactPhone{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> extra{};
  shared_ptr<vector<FlightOrderDetailInfoResponseBodyModuleFlightInfoList>> flightInfoList{};
  shared_ptr<string> lastPayTime{};
  shared_ptr<long> payStatus{};
  shared_ptr<string> payTime{};
  shared_ptr<long> promotionPrice{};
  shared_ptr<long> settleAmount{};
  shared_ptr<long> settleType{};
  shared_ptr<long> status{};
  shared_ptr<vector<FlightOrderDetailInfoResponseBodyModuleTicketInfoList>> ticketInfoList{};
  shared_ptr<long> totalBuildPrice{};
  shared_ptr<long> totalOilPrice{};
  shared_ptr<long> totalOrderPrice{};
  shared_ptr<vector<FlightOrderDetailInfoResponseBodyModuleTravelerInfoList>> travelerInfoList{};

  FlightOrderDetailInfoResponseBodyModule() {}

  explicit FlightOrderDetailInfoResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (bookUserId) {
      res["book_user_id"] = boost::any(*bookUserId);
    }
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (contactPhone) {
      res["contact_phone"] = boost::any(*contactPhone);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (flightInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_info_list"] = boost::any(temp1);
    }
    if (lastPayTime) {
      res["last_pay_time"] = boost::any(*lastPayTime);
    }
    if (payStatus) {
      res["pay_status"] = boost::any(*payStatus);
    }
    if (payTime) {
      res["pay_time"] = boost::any(*payTime);
    }
    if (promotionPrice) {
      res["promotion_price"] = boost::any(*promotionPrice);
    }
    if (settleAmount) {
      res["settle_amount"] = boost::any(*settleAmount);
    }
    if (settleType) {
      res["settle_type"] = boost::any(*settleType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (ticketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*ticketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ticket_info_list"] = boost::any(temp1);
    }
    if (totalBuildPrice) {
      res["total_build_price"] = boost::any(*totalBuildPrice);
    }
    if (totalOilPrice) {
      res["total_oil_price"] = boost::any(*totalOilPrice);
    }
    if (totalOrderPrice) {
      res["total_order_price"] = boost::any(*totalOrderPrice);
    }
    if (travelerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("book_user_id") != m.end() && !m["book_user_id"].empty()) {
      bookUserId = make_shared<string>(boost::any_cast<string>(m["book_user_id"]));
    }
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_order_id"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("contact_phone") != m.end() && !m["contact_phone"].empty()) {
      contactPhone = make_shared<string>(boost::any_cast<string>(m["contact_phone"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("flight_info_list") != m.end() && !m["flight_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_info_list"].type()) {
        vector<FlightOrderDetailInfoResponseBodyModuleFlightInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderDetailInfoResponseBodyModuleFlightInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightInfoList = make_shared<vector<FlightOrderDetailInfoResponseBodyModuleFlightInfoList>>(expect1);
      }
    }
    if (m.find("last_pay_time") != m.end() && !m["last_pay_time"].empty()) {
      lastPayTime = make_shared<string>(boost::any_cast<string>(m["last_pay_time"]));
    }
    if (m.find("pay_status") != m.end() && !m["pay_status"].empty()) {
      payStatus = make_shared<long>(boost::any_cast<long>(m["pay_status"]));
    }
    if (m.find("pay_time") != m.end() && !m["pay_time"].empty()) {
      payTime = make_shared<string>(boost::any_cast<string>(m["pay_time"]));
    }
    if (m.find("promotion_price") != m.end() && !m["promotion_price"].empty()) {
      promotionPrice = make_shared<long>(boost::any_cast<long>(m["promotion_price"]));
    }
    if (m.find("settle_amount") != m.end() && !m["settle_amount"].empty()) {
      settleAmount = make_shared<long>(boost::any_cast<long>(m["settle_amount"]));
    }
    if (m.find("settle_type") != m.end() && !m["settle_type"].empty()) {
      settleType = make_shared<long>(boost::any_cast<long>(m["settle_type"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("ticket_info_list") != m.end() && !m["ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["ticket_info_list"].type()) {
        vector<FlightOrderDetailInfoResponseBodyModuleTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderDetailInfoResponseBodyModuleTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ticketInfoList = make_shared<vector<FlightOrderDetailInfoResponseBodyModuleTicketInfoList>>(expect1);
      }
    }
    if (m.find("total_build_price") != m.end() && !m["total_build_price"].empty()) {
      totalBuildPrice = make_shared<long>(boost::any_cast<long>(m["total_build_price"]));
    }
    if (m.find("total_oil_price") != m.end() && !m["total_oil_price"].empty()) {
      totalOilPrice = make_shared<long>(boost::any_cast<long>(m["total_oil_price"]));
    }
    if (m.find("total_order_price") != m.end() && !m["total_order_price"].empty()) {
      totalOrderPrice = make_shared<long>(boost::any_cast<long>(m["total_order_price"]));
    }
    if (m.find("traveler_info_list") != m.end() && !m["traveler_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_info_list"].type()) {
        vector<FlightOrderDetailInfoResponseBodyModuleTravelerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderDetailInfoResponseBodyModuleTravelerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerInfoList = make_shared<vector<FlightOrderDetailInfoResponseBodyModuleTravelerInfoList>>(expect1);
      }
    }
  }


  virtual ~FlightOrderDetailInfoResponseBodyModule() = default;
};
class FlightOrderDetailInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightOrderDetailInfoResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightOrderDetailInfoResponseBody() {}

  explicit FlightOrderDetailInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightOrderDetailInfoResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightOrderDetailInfoResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightOrderDetailInfoResponseBody() = default;
};
class FlightOrderDetailInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightOrderDetailInfoResponseBody> body{};

  FlightOrderDetailInfoResponse() {}

  explicit FlightOrderDetailInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightOrderDetailInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightOrderDetailInfoResponseBody>(model1);
      }
    }
  }


  virtual ~FlightOrderDetailInfoResponse() = default;
};
class FlightOrderDetailV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightOrderDetailV2Headers() {}

  explicit FlightOrderDetailV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightOrderDetailV2Headers() = default;
};
class FlightOrderDetailV2Request : public Darabonba::Model {
public:
  shared_ptr<string> isvName{};
  shared_ptr<long> orderId{};
  shared_ptr<string> outOrderId{};

  FlightOrderDetailV2Request() {}

  explicit FlightOrderDetailV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
  }


  virtual ~FlightOrderDetailV2Request() = default;
};
class FlightOrderDetailV2ResponseBodyModuleContactInfoDTO : public Darabonba::Model {
public:
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactPhone{};
  shared_ptr<bool> sendMsgToPassenger{};

  FlightOrderDetailV2ResponseBodyModuleContactInfoDTO() {}

  explicit FlightOrderDetailV2ResponseBodyModuleContactInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactEmail) {
      res["contact_email"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (contactPhone) {
      res["contact_phone"] = boost::any(*contactPhone);
    }
    if (sendMsgToPassenger) {
      res["send_msg_to_passenger"] = boost::any(*sendMsgToPassenger);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contact_email") != m.end() && !m["contact_email"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["contact_email"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("contact_phone") != m.end() && !m["contact_phone"].empty()) {
      contactPhone = make_shared<string>(boost::any_cast<string>(m["contact_phone"]));
    }
    if (m.find("send_msg_to_passenger") != m.end() && !m["send_msg_to_passenger"].empty()) {
      sendMsgToPassenger = make_shared<bool>(boost::any_cast<bool>(m["send_msg_to_passenger"]));
    }
  }


  virtual ~FlightOrderDetailV2ResponseBodyModuleContactInfoDTO() = default;
};
class FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentListFlightChange : public Darabonba::Model {
public:
  shared_ptr<string> changeDesc{};
  shared_ptr<string> changeStatus{};
  shared_ptr<string> changeStatusCode{};
  shared_ptr<boost::any> newSegment{};
  shared_ptr<vector<string>> passengerNames{};

  FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentListFlightChange() {}

  explicit FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentListFlightChange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeDesc) {
      res["change_desc"] = boost::any(*changeDesc);
    }
    if (changeStatus) {
      res["change_status"] = boost::any(*changeStatus);
    }
    if (changeStatusCode) {
      res["change_status_code"] = boost::any(*changeStatusCode);
    }
    if (newSegment) {
      res["new_segment"] = boost::any(*newSegment);
    }
    if (passengerNames) {
      res["passenger_names"] = boost::any(*passengerNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("change_desc") != m.end() && !m["change_desc"].empty()) {
      changeDesc = make_shared<string>(boost::any_cast<string>(m["change_desc"]));
    }
    if (m.find("change_status") != m.end() && !m["change_status"].empty()) {
      changeStatus = make_shared<string>(boost::any_cast<string>(m["change_status"]));
    }
    if (m.find("change_status_code") != m.end() && !m["change_status_code"].empty()) {
      changeStatusCode = make_shared<string>(boost::any_cast<string>(m["change_status_code"]));
    }
    if (m.find("new_segment") != m.end() && !m["new_segment"].empty()) {
      newSegment = make_shared<boost::any>(boost::any_cast<boost::any>(m["new_segment"]));
    }
    if (m.find("passenger_names") != m.end() && !m["passenger_names"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["passenger_names"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["passenger_names"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      passengerNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentListFlightChange() = default;
};
class FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentListSegmentPosition : public Darabonba::Model {
public:
  shared_ptr<long> journeyIndex{};
  shared_ptr<long> segmentIndex{};

  FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentListSegmentPosition() {}

  explicit FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentListSegmentPosition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (journeyIndex) {
      res["journey_index"] = boost::any(*journeyIndex);
    }
    if (segmentIndex) {
      res["segment_index"] = boost::any(*segmentIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("journey_index") != m.end() && !m["journey_index"].empty()) {
      journeyIndex = make_shared<long>(boost::any_cast<long>(m["journey_index"]));
    }
    if (m.find("segment_index") != m.end() && !m["segment_index"].empty()) {
      segmentIndex = make_shared<long>(boost::any_cast<long>(m["segment_index"]));
    }
  }


  virtual ~FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentListSegmentPosition() = default;
};
class FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentList : public Darabonba::Model {
public:
  shared_ptr<string> airLineCode{};
  shared_ptr<string> airLineEnglishName{};
  shared_ptr<string> airLineName{};
  shared_ptr<string> airLinePhone{};
  shared_ptr<string> airlineIconUrl{};
  shared_ptr<string> airlineShortName{};
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrAirportName{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> arriveTerminal{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinAndDiscount{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<bool> codeShare{};
  shared_ptr<string> deadlineText{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depAirportName{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depDate{};
  shared_ptr<string> depTime{};
  shared_ptr<string> departTerminal{};
  shared_ptr<double> discount{};
  shared_ptr<FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentListFlightChange> flightChange{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> flightType{};
  shared_ptr<long> flyDuration{};
  shared_ptr<string> manufacturer{};
  shared_ptr<string> mealDesc{};
  shared_ptr<string> onTimeRate{};
  shared_ptr<string> operatingAirShortName{};
  shared_ptr<string> operatingAirlineCode{};
  shared_ptr<string> operatingAirlineEnglishName{};
  shared_ptr<string> operatingAirlineIconUrl{};
  shared_ptr<string> operatingAirlineName{};
  shared_ptr<string> operatingAirlinePhone{};
  shared_ptr<string> operatingFlightNo{};
  shared_ptr<string> planeType{};
  shared_ptr<long> raisePrice{};
  shared_ptr<string> segmentId{};
  shared_ptr<long> segmentIndex{};
  shared_ptr<FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentListSegmentPosition> segmentPosition{};
  shared_ptr<string> stopAirport{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopCityName{};
  shared_ptr<string> stopDepTime{};
  shared_ptr<long> stopQuantity{};

  FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentList() {}

  explicit FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airLineCode) {
      res["air_line_code"] = boost::any(*airLineCode);
    }
    if (airLineEnglishName) {
      res["air_line_english_name"] = boost::any(*airLineEnglishName);
    }
    if (airLineName) {
      res["air_line_name"] = boost::any(*airLineName);
    }
    if (airLinePhone) {
      res["air_line_phone"] = boost::any(*airLinePhone);
    }
    if (airlineIconUrl) {
      res["airline_icon_url"] = boost::any(*airlineIconUrl);
    }
    if (airlineShortName) {
      res["airline_short_name"] = boost::any(*airlineShortName);
    }
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrAirportName) {
      res["arr_airport_name"] = boost::any(*arrAirportName);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (arriveTerminal) {
      res["arrive_terminal"] = boost::any(*arriveTerminal);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinAndDiscount) {
      res["cabin_and_discount"] = boost::any(*cabinAndDiscount);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabin_class_name"] = boost::any(*cabinClassName);
    }
    if (codeShare) {
      res["code_share"] = boost::any(*codeShare);
    }
    if (deadlineText) {
      res["deadline_text"] = boost::any(*deadlineText);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depAirportName) {
      res["dep_airport_name"] = boost::any(*depAirportName);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (departTerminal) {
      res["depart_terminal"] = boost::any(*departTerminal);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightChange) {
      res["flight_change"] = flightChange ? boost::any(flightChange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (flyDuration) {
      res["fly_duration"] = boost::any(*flyDuration);
    }
    if (manufacturer) {
      res["manufacturer"] = boost::any(*manufacturer);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (onTimeRate) {
      res["on_time_rate"] = boost::any(*onTimeRate);
    }
    if (operatingAirShortName) {
      res["operating_air_short_name"] = boost::any(*operatingAirShortName);
    }
    if (operatingAirlineCode) {
      res["operating_airline_code"] = boost::any(*operatingAirlineCode);
    }
    if (operatingAirlineEnglishName) {
      res["operating_airline_english_name"] = boost::any(*operatingAirlineEnglishName);
    }
    if (operatingAirlineIconUrl) {
      res["operating_airline_icon_url"] = boost::any(*operatingAirlineIconUrl);
    }
    if (operatingAirlineName) {
      res["operating_airline_name"] = boost::any(*operatingAirlineName);
    }
    if (operatingAirlinePhone) {
      res["operating_airline_phone"] = boost::any(*operatingAirlinePhone);
    }
    if (operatingFlightNo) {
      res["operating_flight_no"] = boost::any(*operatingFlightNo);
    }
    if (planeType) {
      res["plane_type"] = boost::any(*planeType);
    }
    if (raisePrice) {
      res["raise_price"] = boost::any(*raisePrice);
    }
    if (segmentId) {
      res["segment_id"] = boost::any(*segmentId);
    }
    if (segmentIndex) {
      res["segment_index"] = boost::any(*segmentIndex);
    }
    if (segmentPosition) {
      res["segment_position"] = segmentPosition ? boost::any(segmentPosition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stopAirport) {
      res["stop_airport"] = boost::any(*stopAirport);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopCityName) {
      res["stop_city_name"] = boost::any(*stopCityName);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    if (stopQuantity) {
      res["stop_quantity"] = boost::any(*stopQuantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("air_line_code") != m.end() && !m["air_line_code"].empty()) {
      airLineCode = make_shared<string>(boost::any_cast<string>(m["air_line_code"]));
    }
    if (m.find("air_line_english_name") != m.end() && !m["air_line_english_name"].empty()) {
      airLineEnglishName = make_shared<string>(boost::any_cast<string>(m["air_line_english_name"]));
    }
    if (m.find("air_line_name") != m.end() && !m["air_line_name"].empty()) {
      airLineName = make_shared<string>(boost::any_cast<string>(m["air_line_name"]));
    }
    if (m.find("air_line_phone") != m.end() && !m["air_line_phone"].empty()) {
      airLinePhone = make_shared<string>(boost::any_cast<string>(m["air_line_phone"]));
    }
    if (m.find("airline_icon_url") != m.end() && !m["airline_icon_url"].empty()) {
      airlineIconUrl = make_shared<string>(boost::any_cast<string>(m["airline_icon_url"]));
    }
    if (m.find("airline_short_name") != m.end() && !m["airline_short_name"].empty()) {
      airlineShortName = make_shared<string>(boost::any_cast<string>(m["airline_short_name"]));
    }
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_airport_name") != m.end() && !m["arr_airport_name"].empty()) {
      arrAirportName = make_shared<string>(boost::any_cast<string>(m["arr_airport_name"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("arrive_terminal") != m.end() && !m["arrive_terminal"].empty()) {
      arriveTerminal = make_shared<string>(boost::any_cast<string>(m["arrive_terminal"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_and_discount") != m.end() && !m["cabin_and_discount"].empty()) {
      cabinAndDiscount = make_shared<string>(boost::any_cast<string>(m["cabin_and_discount"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_class_name") != m.end() && !m["cabin_class_name"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabin_class_name"]));
    }
    if (m.find("code_share") != m.end() && !m["code_share"].empty()) {
      codeShare = make_shared<bool>(boost::any_cast<bool>(m["code_share"]));
    }
    if (m.find("deadline_text") != m.end() && !m["deadline_text"].empty()) {
      deadlineText = make_shared<string>(boost::any_cast<string>(m["deadline_text"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_airport_name") != m.end() && !m["dep_airport_name"].empty()) {
      depAirportName = make_shared<string>(boost::any_cast<string>(m["dep_airport_name"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("depart_terminal") != m.end() && !m["depart_terminal"].empty()) {
      departTerminal = make_shared<string>(boost::any_cast<string>(m["depart_terminal"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<double>(boost::any_cast<double>(m["discount"]));
    }
    if (m.find("flight_change") != m.end() && !m["flight_change"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_change"].type()) {
        FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentListFlightChange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flight_change"]));
        flightChange = make_shared<FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentListFlightChange>(model1);
      }
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("fly_duration") != m.end() && !m["fly_duration"].empty()) {
      flyDuration = make_shared<long>(boost::any_cast<long>(m["fly_duration"]));
    }
    if (m.find("manufacturer") != m.end() && !m["manufacturer"].empty()) {
      manufacturer = make_shared<string>(boost::any_cast<string>(m["manufacturer"]));
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("on_time_rate") != m.end() && !m["on_time_rate"].empty()) {
      onTimeRate = make_shared<string>(boost::any_cast<string>(m["on_time_rate"]));
    }
    if (m.find("operating_air_short_name") != m.end() && !m["operating_air_short_name"].empty()) {
      operatingAirShortName = make_shared<string>(boost::any_cast<string>(m["operating_air_short_name"]));
    }
    if (m.find("operating_airline_code") != m.end() && !m["operating_airline_code"].empty()) {
      operatingAirlineCode = make_shared<string>(boost::any_cast<string>(m["operating_airline_code"]));
    }
    if (m.find("operating_airline_english_name") != m.end() && !m["operating_airline_english_name"].empty()) {
      operatingAirlineEnglishName = make_shared<string>(boost::any_cast<string>(m["operating_airline_english_name"]));
    }
    if (m.find("operating_airline_icon_url") != m.end() && !m["operating_airline_icon_url"].empty()) {
      operatingAirlineIconUrl = make_shared<string>(boost::any_cast<string>(m["operating_airline_icon_url"]));
    }
    if (m.find("operating_airline_name") != m.end() && !m["operating_airline_name"].empty()) {
      operatingAirlineName = make_shared<string>(boost::any_cast<string>(m["operating_airline_name"]));
    }
    if (m.find("operating_airline_phone") != m.end() && !m["operating_airline_phone"].empty()) {
      operatingAirlinePhone = make_shared<string>(boost::any_cast<string>(m["operating_airline_phone"]));
    }
    if (m.find("operating_flight_no") != m.end() && !m["operating_flight_no"].empty()) {
      operatingFlightNo = make_shared<string>(boost::any_cast<string>(m["operating_flight_no"]));
    }
    if (m.find("plane_type") != m.end() && !m["plane_type"].empty()) {
      planeType = make_shared<string>(boost::any_cast<string>(m["plane_type"]));
    }
    if (m.find("raise_price") != m.end() && !m["raise_price"].empty()) {
      raisePrice = make_shared<long>(boost::any_cast<long>(m["raise_price"]));
    }
    if (m.find("segment_id") != m.end() && !m["segment_id"].empty()) {
      segmentId = make_shared<string>(boost::any_cast<string>(m["segment_id"]));
    }
    if (m.find("segment_index") != m.end() && !m["segment_index"].empty()) {
      segmentIndex = make_shared<long>(boost::any_cast<long>(m["segment_index"]));
    }
    if (m.find("segment_position") != m.end() && !m["segment_position"].empty()) {
      if (typeid(map<string, boost::any>) == m["segment_position"].type()) {
        FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentListSegmentPosition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["segment_position"]));
        segmentPosition = make_shared<FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentListSegmentPosition>(model1);
      }
    }
    if (m.find("stop_airport") != m.end() && !m["stop_airport"].empty()) {
      stopAirport = make_shared<string>(boost::any_cast<string>(m["stop_airport"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_city_name") != m.end() && !m["stop_city_name"].empty()) {
      stopCityName = make_shared<string>(boost::any_cast<string>(m["stop_city_name"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
    if (m.find("stop_quantity") != m.end() && !m["stop_quantity"].empty()) {
      stopQuantity = make_shared<long>(boost::any_cast<long>(m["stop_quantity"]));
    }
  }


  virtual ~FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentList() = default;
};
class FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneys : public Darabonba::Model {
public:
  shared_ptr<long> allFlyDuration{};
  shared_ptr<long> allFlyDurationAfterChange{};
  shared_ptr<long> applyId{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> baggageDetails{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depTime{};
  shared_ptr<string> flightStatus{};
  shared_ptr<string> iataNo{};
  shared_ptr<bool> isReshopJourney{};
  shared_ptr<bool> isTransfer{};
  shared_ptr<string> journeyTitle{};
  shared_ptr<string> refundChangeDetails{};
  shared_ptr<vector<FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentList>> segmentList{};

  FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneys() {}

  explicit FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allFlyDuration) {
      res["all_fly_duration"] = boost::any(*allFlyDuration);
    }
    if (allFlyDurationAfterChange) {
      res["all_fly_duration_after_change"] = boost::any(*allFlyDurationAfterChange);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (baggageDetails) {
      res["baggage_details"] = boost::any(*baggageDetails);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (flightStatus) {
      res["flight_status"] = boost::any(*flightStatus);
    }
    if (iataNo) {
      res["iata_no"] = boost::any(*iataNo);
    }
    if (isReshopJourney) {
      res["is_reshop_journey"] = boost::any(*isReshopJourney);
    }
    if (isTransfer) {
      res["is_transfer"] = boost::any(*isTransfer);
    }
    if (journeyTitle) {
      res["journey_title"] = boost::any(*journeyTitle);
    }
    if (refundChangeDetails) {
      res["refund_change_details"] = boost::any(*refundChangeDetails);
    }
    if (segmentList) {
      vector<boost::any> temp1;
      for(auto item1:*segmentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["segment_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_fly_duration") != m.end() && !m["all_fly_duration"].empty()) {
      allFlyDuration = make_shared<long>(boost::any_cast<long>(m["all_fly_duration"]));
    }
    if (m.find("all_fly_duration_after_change") != m.end() && !m["all_fly_duration_after_change"].empty()) {
      allFlyDurationAfterChange = make_shared<long>(boost::any_cast<long>(m["all_fly_duration_after_change"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("baggage_details") != m.end() && !m["baggage_details"].empty()) {
      baggageDetails = make_shared<string>(boost::any_cast<string>(m["baggage_details"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("flight_status") != m.end() && !m["flight_status"].empty()) {
      flightStatus = make_shared<string>(boost::any_cast<string>(m["flight_status"]));
    }
    if (m.find("iata_no") != m.end() && !m["iata_no"].empty()) {
      iataNo = make_shared<string>(boost::any_cast<string>(m["iata_no"]));
    }
    if (m.find("is_reshop_journey") != m.end() && !m["is_reshop_journey"].empty()) {
      isReshopJourney = make_shared<bool>(boost::any_cast<bool>(m["is_reshop_journey"]));
    }
    if (m.find("is_transfer") != m.end() && !m["is_transfer"].empty()) {
      isTransfer = make_shared<bool>(boost::any_cast<bool>(m["is_transfer"]));
    }
    if (m.find("journey_title") != m.end() && !m["journey_title"].empty()) {
      journeyTitle = make_shared<string>(boost::any_cast<string>(m["journey_title"]));
    }
    if (m.find("refund_change_details") != m.end() && !m["refund_change_details"].empty()) {
      refundChangeDetails = make_shared<string>(boost::any_cast<string>(m["refund_change_details"]));
    }
    if (m.find("segment_list") != m.end() && !m["segment_list"].empty()) {
      if (typeid(vector<boost::any>) == m["segment_list"].type()) {
        vector<FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["segment_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        segmentList = make_shared<vector<FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneysSegmentList>>(expect1);
      }
    }
  }


  virtual ~FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneys() = default;
};
class FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTO : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneys>> journeys{};
  shared_ptr<string> noticeTips{};
  shared_ptr<string> tripType{};
  shared_ptr<long> tripTypeCode{};

  FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTO() {}

  explicit FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (journeys) {
      vector<boost::any> temp1;
      for(auto item1:*journeys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["journeys"] = boost::any(temp1);
    }
    if (noticeTips) {
      res["notice_tips"] = boost::any(*noticeTips);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    if (tripTypeCode) {
      res["trip_type_code"] = boost::any(*tripTypeCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("journeys") != m.end() && !m["journeys"].empty()) {
      if (typeid(vector<boost::any>) == m["journeys"].type()) {
        vector<FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["journeys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        journeys = make_shared<vector<FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTOJourneys>>(expect1);
      }
    }
    if (m.find("notice_tips") != m.end() && !m["notice_tips"].empty()) {
      noticeTips = make_shared<string>(boost::any_cast<string>(m["notice_tips"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<string>(boost::any_cast<string>(m["trip_type"]));
    }
    if (m.find("trip_type_code") != m.end() && !m["trip_type_code"].empty()) {
      tripTypeCode = make_shared<long>(boost::any_cast<long>(m["trip_type_code"]));
    }
  }


  virtual ~FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTO() = default;
};
class FlightOrderDetailV2ResponseBodyModulePassengerListCredential : public Darabonba::Model {
public:
  shared_ptr<string> birthDate{};
  shared_ptr<string> certIssueDate{};
  shared_ptr<string> certIssuePlace{};
  shared_ptr<string> credentialNo{};
  shared_ptr<string> driveLicenceFirst{};
  shared_ptr<string> driveLicenceType{};
  shared_ptr<string> expireDate{};
  shared_ptr<string> holderNationality{};
  shared_ptr<long> id{};
  shared_ptr<string> idCheckCode{};
  shared_ptr<string> issueCountry{};
  shared_ptr<long> type{};

  FlightOrderDetailV2ResponseBodyModulePassengerListCredential() {}

  explicit FlightOrderDetailV2ResponseBodyModulePassengerListCredential(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthDate) {
      res["birth_date"] = boost::any(*birthDate);
    }
    if (certIssueDate) {
      res["cert_issue_date"] = boost::any(*certIssueDate);
    }
    if (certIssuePlace) {
      res["cert_issue_place"] = boost::any(*certIssuePlace);
    }
    if (credentialNo) {
      res["credential_no"] = boost::any(*credentialNo);
    }
    if (driveLicenceFirst) {
      res["drive_licence_first"] = boost::any(*driveLicenceFirst);
    }
    if (driveLicenceType) {
      res["drive_licence_type"] = boost::any(*driveLicenceType);
    }
    if (expireDate) {
      res["expire_date"] = boost::any(*expireDate);
    }
    if (holderNationality) {
      res["holder_nationality"] = boost::any(*holderNationality);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (idCheckCode) {
      res["id_check_code"] = boost::any(*idCheckCode);
    }
    if (issueCountry) {
      res["issue_country"] = boost::any(*issueCountry);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birth_date") != m.end() && !m["birth_date"].empty()) {
      birthDate = make_shared<string>(boost::any_cast<string>(m["birth_date"]));
    }
    if (m.find("cert_issue_date") != m.end() && !m["cert_issue_date"].empty()) {
      certIssueDate = make_shared<string>(boost::any_cast<string>(m["cert_issue_date"]));
    }
    if (m.find("cert_issue_place") != m.end() && !m["cert_issue_place"].empty()) {
      certIssuePlace = make_shared<string>(boost::any_cast<string>(m["cert_issue_place"]));
    }
    if (m.find("credential_no") != m.end() && !m["credential_no"].empty()) {
      credentialNo = make_shared<string>(boost::any_cast<string>(m["credential_no"]));
    }
    if (m.find("drive_licence_first") != m.end() && !m["drive_licence_first"].empty()) {
      driveLicenceFirst = make_shared<string>(boost::any_cast<string>(m["drive_licence_first"]));
    }
    if (m.find("drive_licence_type") != m.end() && !m["drive_licence_type"].empty()) {
      driveLicenceType = make_shared<string>(boost::any_cast<string>(m["drive_licence_type"]));
    }
    if (m.find("expire_date") != m.end() && !m["expire_date"].empty()) {
      expireDate = make_shared<string>(boost::any_cast<string>(m["expire_date"]));
    }
    if (m.find("holder_nationality") != m.end() && !m["holder_nationality"].empty()) {
      holderNationality = make_shared<string>(boost::any_cast<string>(m["holder_nationality"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("id_check_code") != m.end() && !m["id_check_code"].empty()) {
      idCheckCode = make_shared<string>(boost::any_cast<string>(m["id_check_code"]));
    }
    if (m.find("issue_country") != m.end() && !m["issue_country"].empty()) {
      issueCountry = make_shared<string>(boost::any_cast<string>(m["issue_country"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOrderDetailV2ResponseBodyModulePassengerListCredential() = default;
};
class FlightOrderDetailV2ResponseBodyModulePassengerListCredentials : public Darabonba::Model {
public:
  shared_ptr<string> birthDate{};
  shared_ptr<string> certIssueDate{};
  shared_ptr<string> certIssuePlace{};
  shared_ptr<string> credentialNo{};
  shared_ptr<string> driveLicenceFirst{};
  shared_ptr<string> driveLicenceType{};
  shared_ptr<string> expireDate{};
  shared_ptr<string> holderNationality{};
  shared_ptr<long> id{};
  shared_ptr<string> idCheckCode{};
  shared_ptr<string> issueCountry{};
  shared_ptr<long> type{};

  FlightOrderDetailV2ResponseBodyModulePassengerListCredentials() {}

  explicit FlightOrderDetailV2ResponseBodyModulePassengerListCredentials(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthDate) {
      res["birth_date"] = boost::any(*birthDate);
    }
    if (certIssueDate) {
      res["cert_issue_date"] = boost::any(*certIssueDate);
    }
    if (certIssuePlace) {
      res["cert_issue_place"] = boost::any(*certIssuePlace);
    }
    if (credentialNo) {
      res["credential_no"] = boost::any(*credentialNo);
    }
    if (driveLicenceFirst) {
      res["drive_licence_first"] = boost::any(*driveLicenceFirst);
    }
    if (driveLicenceType) {
      res["drive_licence_type"] = boost::any(*driveLicenceType);
    }
    if (expireDate) {
      res["expire_date"] = boost::any(*expireDate);
    }
    if (holderNationality) {
      res["holder_nationality"] = boost::any(*holderNationality);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (idCheckCode) {
      res["id_check_code"] = boost::any(*idCheckCode);
    }
    if (issueCountry) {
      res["issue_country"] = boost::any(*issueCountry);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birth_date") != m.end() && !m["birth_date"].empty()) {
      birthDate = make_shared<string>(boost::any_cast<string>(m["birth_date"]));
    }
    if (m.find("cert_issue_date") != m.end() && !m["cert_issue_date"].empty()) {
      certIssueDate = make_shared<string>(boost::any_cast<string>(m["cert_issue_date"]));
    }
    if (m.find("cert_issue_place") != m.end() && !m["cert_issue_place"].empty()) {
      certIssuePlace = make_shared<string>(boost::any_cast<string>(m["cert_issue_place"]));
    }
    if (m.find("credential_no") != m.end() && !m["credential_no"].empty()) {
      credentialNo = make_shared<string>(boost::any_cast<string>(m["credential_no"]));
    }
    if (m.find("drive_licence_first") != m.end() && !m["drive_licence_first"].empty()) {
      driveLicenceFirst = make_shared<string>(boost::any_cast<string>(m["drive_licence_first"]));
    }
    if (m.find("drive_licence_type") != m.end() && !m["drive_licence_type"].empty()) {
      driveLicenceType = make_shared<string>(boost::any_cast<string>(m["drive_licence_type"]));
    }
    if (m.find("expire_date") != m.end() && !m["expire_date"].empty()) {
      expireDate = make_shared<string>(boost::any_cast<string>(m["expire_date"]));
    }
    if (m.find("holder_nationality") != m.end() && !m["holder_nationality"].empty()) {
      holderNationality = make_shared<string>(boost::any_cast<string>(m["holder_nationality"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("id_check_code") != m.end() && !m["id_check_code"].empty()) {
      idCheckCode = make_shared<string>(boost::any_cast<string>(m["id_check_code"]));
    }
    if (m.find("issue_country") != m.end() && !m["issue_country"].empty()) {
      issueCountry = make_shared<string>(boost::any_cast<string>(m["issue_country"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOrderDetailV2ResponseBodyModulePassengerListCredentials() = default;
};
class FlightOrderDetailV2ResponseBodyModulePassengerListTicketsSegmentOpenTicketList : public Darabonba::Model {
public:
  shared_ptr<long> journeyIndex{};
  shared_ptr<long> openTicketStatus{};
  shared_ptr<long> segmentIndex{};

  FlightOrderDetailV2ResponseBodyModulePassengerListTicketsSegmentOpenTicketList() {}

  explicit FlightOrderDetailV2ResponseBodyModulePassengerListTicketsSegmentOpenTicketList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (journeyIndex) {
      res["journey_index"] = boost::any(*journeyIndex);
    }
    if (openTicketStatus) {
      res["open_ticket_status"] = boost::any(*openTicketStatus);
    }
    if (segmentIndex) {
      res["segment_index"] = boost::any(*segmentIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("journey_index") != m.end() && !m["journey_index"].empty()) {
      journeyIndex = make_shared<long>(boost::any_cast<long>(m["journey_index"]));
    }
    if (m.find("open_ticket_status") != m.end() && !m["open_ticket_status"].empty()) {
      openTicketStatus = make_shared<long>(boost::any_cast<long>(m["open_ticket_status"]));
    }
    if (m.find("segment_index") != m.end() && !m["segment_index"].empty()) {
      segmentIndex = make_shared<long>(boost::any_cast<long>(m["segment_index"]));
    }
  }


  virtual ~FlightOrderDetailV2ResponseBodyModulePassengerListTicketsSegmentOpenTicketList() = default;
};
class FlightOrderDetailV2ResponseBodyModulePassengerListTickets : public Darabonba::Model {
public:
  shared_ptr<string> channel{};
  shared_ptr<string> journeyTitle{};
  shared_ptr<string> openTicketStatus{};
  shared_ptr<string> pcc{};
  shared_ptr<vector<FlightOrderDetailV2ResponseBodyModulePassengerListTicketsSegmentOpenTicketList>> segmentOpenTicketList{};
  shared_ptr<string> ticketAuthMemo{};
  shared_ptr<long> ticketAuthStatus{};
  shared_ptr<string> ticketNo{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<string> ticketStatus{};

  FlightOrderDetailV2ResponseBodyModulePassengerListTickets() {}

  explicit FlightOrderDetailV2ResponseBodyModulePassengerListTickets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["channel"] = boost::any(*channel);
    }
    if (journeyTitle) {
      res["journey_title"] = boost::any(*journeyTitle);
    }
    if (openTicketStatus) {
      res["open_ticket_status"] = boost::any(*openTicketStatus);
    }
    if (pcc) {
      res["pcc"] = boost::any(*pcc);
    }
    if (segmentOpenTicketList) {
      vector<boost::any> temp1;
      for(auto item1:*segmentOpenTicketList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["segment_open_ticket_list"] = boost::any(temp1);
    }
    if (ticketAuthMemo) {
      res["ticket_auth_memo"] = boost::any(*ticketAuthMemo);
    }
    if (ticketAuthStatus) {
      res["ticket_auth_status"] = boost::any(*ticketAuthStatus);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (ticketStatus) {
      res["ticket_status"] = boost::any(*ticketStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("channel") != m.end() && !m["channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["channel"]));
    }
    if (m.find("journey_title") != m.end() && !m["journey_title"].empty()) {
      journeyTitle = make_shared<string>(boost::any_cast<string>(m["journey_title"]));
    }
    if (m.find("open_ticket_status") != m.end() && !m["open_ticket_status"].empty()) {
      openTicketStatus = make_shared<string>(boost::any_cast<string>(m["open_ticket_status"]));
    }
    if (m.find("pcc") != m.end() && !m["pcc"].empty()) {
      pcc = make_shared<string>(boost::any_cast<string>(m["pcc"]));
    }
    if (m.find("segment_open_ticket_list") != m.end() && !m["segment_open_ticket_list"].empty()) {
      if (typeid(vector<boost::any>) == m["segment_open_ticket_list"].type()) {
        vector<FlightOrderDetailV2ResponseBodyModulePassengerListTicketsSegmentOpenTicketList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["segment_open_ticket_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderDetailV2ResponseBodyModulePassengerListTicketsSegmentOpenTicketList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        segmentOpenTicketList = make_shared<vector<FlightOrderDetailV2ResponseBodyModulePassengerListTicketsSegmentOpenTicketList>>(expect1);
      }
    }
    if (m.find("ticket_auth_memo") != m.end() && !m["ticket_auth_memo"].empty()) {
      ticketAuthMemo = make_shared<string>(boost::any_cast<string>(m["ticket_auth_memo"]));
    }
    if (m.find("ticket_auth_status") != m.end() && !m["ticket_auth_status"].empty()) {
      ticketAuthStatus = make_shared<long>(boost::any_cast<long>(m["ticket_auth_status"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("ticket_status") != m.end() && !m["ticket_status"].empty()) {
      ticketStatus = make_shared<string>(boost::any_cast<string>(m["ticket_status"]));
    }
  }


  virtual ~FlightOrderDetailV2ResponseBodyModulePassengerListTickets() = default;
};
class FlightOrderDetailV2ResponseBodyModulePassengerList : public Darabonba::Model {
public:
  shared_ptr<string> birthday{};
  shared_ptr<string> btripUserId{};
  shared_ptr<long> code{};
  shared_ptr<string> country{};
  shared_ptr<string> countryCode{};
  shared_ptr<FlightOrderDetailV2ResponseBodyModulePassengerListCredential> credential{};
  shared_ptr<vector<FlightOrderDetailV2ResponseBodyModulePassengerListCredentials>> credentials{};
  shared_ptr<string> email{};
  shared_ptr<string> enFirstName{};
  shared_ptr<string> enLastName{};
  shared_ptr<string> englishName{};
  shared_ptr<long> gender{};
  shared_ptr<string> id{};
  shared_ptr<bool> isComplete{};
  shared_ptr<bool> isFrequently{};
  shared_ptr<string> memo{};
  shared_ptr<string> mobileCountryCode{};
  shared_ptr<string> mobilePhoneNumber{};
  shared_ptr<string> name{};
  shared_ptr<bool> oneself{};
  shared_ptr<string> orderName{};
  shared_ptr<string> outPassengerId{};
  shared_ptr<string> phone{};
  shared_ptr<string> shengPiPinyin{};
  shared_ptr<vector<string>> ticketNos{};
  shared_ptr<vector<FlightOrderDetailV2ResponseBodyModulePassengerListTickets>> tickets{};
  shared_ptr<long> type{};
  shared_ptr<string> userId{};

  FlightOrderDetailV2ResponseBodyModulePassengerList() {}

  explicit FlightOrderDetailV2ResponseBodyModulePassengerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthday) {
      res["birthday"] = boost::any(*birthday);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (country) {
      res["country"] = boost::any(*country);
    }
    if (countryCode) {
      res["country_code"] = boost::any(*countryCode);
    }
    if (credential) {
      res["credential"] = credential ? boost::any(credential->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (credentials) {
      vector<boost::any> temp1;
      for(auto item1:*credentials){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["credentials"] = boost::any(temp1);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (enFirstName) {
      res["en_first_name"] = boost::any(*enFirstName);
    }
    if (enLastName) {
      res["en_last_name"] = boost::any(*enLastName);
    }
    if (englishName) {
      res["english_name"] = boost::any(*englishName);
    }
    if (gender) {
      res["gender"] = boost::any(*gender);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isComplete) {
      res["is_complete"] = boost::any(*isComplete);
    }
    if (isFrequently) {
      res["is_frequently"] = boost::any(*isFrequently);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (mobileCountryCode) {
      res["mobile_country_code"] = boost::any(*mobileCountryCode);
    }
    if (mobilePhoneNumber) {
      res["mobile_phone_number"] = boost::any(*mobilePhoneNumber);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (oneself) {
      res["oneself"] = boost::any(*oneself);
    }
    if (orderName) {
      res["order_name"] = boost::any(*orderName);
    }
    if (outPassengerId) {
      res["out_passenger_id"] = boost::any(*outPassengerId);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (shengPiPinyin) {
      res["sheng_pi_pinyin"] = boost::any(*shengPiPinyin);
    }
    if (ticketNos) {
      res["ticket_nos"] = boost::any(*ticketNos);
    }
    if (tickets) {
      vector<boost::any> temp1;
      for(auto item1:*tickets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tickets"] = boost::any(temp1);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birthday") != m.end() && !m["birthday"].empty()) {
      birthday = make_shared<string>(boost::any_cast<string>(m["birthday"]));
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["code"]));
    }
    if (m.find("country") != m.end() && !m["country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["country"]));
    }
    if (m.find("country_code") != m.end() && !m["country_code"].empty()) {
      countryCode = make_shared<string>(boost::any_cast<string>(m["country_code"]));
    }
    if (m.find("credential") != m.end() && !m["credential"].empty()) {
      if (typeid(map<string, boost::any>) == m["credential"].type()) {
        FlightOrderDetailV2ResponseBodyModulePassengerListCredential model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["credential"]));
        credential = make_shared<FlightOrderDetailV2ResponseBodyModulePassengerListCredential>(model1);
      }
    }
    if (m.find("credentials") != m.end() && !m["credentials"].empty()) {
      if (typeid(vector<boost::any>) == m["credentials"].type()) {
        vector<FlightOrderDetailV2ResponseBodyModulePassengerListCredentials> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["credentials"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderDetailV2ResponseBodyModulePassengerListCredentials model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        credentials = make_shared<vector<FlightOrderDetailV2ResponseBodyModulePassengerListCredentials>>(expect1);
      }
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("en_first_name") != m.end() && !m["en_first_name"].empty()) {
      enFirstName = make_shared<string>(boost::any_cast<string>(m["en_first_name"]));
    }
    if (m.find("en_last_name") != m.end() && !m["en_last_name"].empty()) {
      enLastName = make_shared<string>(boost::any_cast<string>(m["en_last_name"]));
    }
    if (m.find("english_name") != m.end() && !m["english_name"].empty()) {
      englishName = make_shared<string>(boost::any_cast<string>(m["english_name"]));
    }
    if (m.find("gender") != m.end() && !m["gender"].empty()) {
      gender = make_shared<long>(boost::any_cast<long>(m["gender"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("is_complete") != m.end() && !m["is_complete"].empty()) {
      isComplete = make_shared<bool>(boost::any_cast<bool>(m["is_complete"]));
    }
    if (m.find("is_frequently") != m.end() && !m["is_frequently"].empty()) {
      isFrequently = make_shared<bool>(boost::any_cast<bool>(m["is_frequently"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("mobile_country_code") != m.end() && !m["mobile_country_code"].empty()) {
      mobileCountryCode = make_shared<string>(boost::any_cast<string>(m["mobile_country_code"]));
    }
    if (m.find("mobile_phone_number") != m.end() && !m["mobile_phone_number"].empty()) {
      mobilePhoneNumber = make_shared<string>(boost::any_cast<string>(m["mobile_phone_number"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("oneself") != m.end() && !m["oneself"].empty()) {
      oneself = make_shared<bool>(boost::any_cast<bool>(m["oneself"]));
    }
    if (m.find("order_name") != m.end() && !m["order_name"].empty()) {
      orderName = make_shared<string>(boost::any_cast<string>(m["order_name"]));
    }
    if (m.find("out_passenger_id") != m.end() && !m["out_passenger_id"].empty()) {
      outPassengerId = make_shared<string>(boost::any_cast<string>(m["out_passenger_id"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("sheng_pi_pinyin") != m.end() && !m["sheng_pi_pinyin"].empty()) {
      shengPiPinyin = make_shared<string>(boost::any_cast<string>(m["sheng_pi_pinyin"]));
    }
    if (m.find("ticket_nos") != m.end() && !m["ticket_nos"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ticket_nos"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ticket_nos"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ticketNos = make_shared<vector<string>>(toVec1);
    }
    if (m.find("tickets") != m.end() && !m["tickets"].empty()) {
      if (typeid(vector<boost::any>) == m["tickets"].type()) {
        vector<FlightOrderDetailV2ResponseBodyModulePassengerListTickets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tickets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderDetailV2ResponseBodyModulePassengerListTickets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tickets = make_shared<vector<FlightOrderDetailV2ResponseBodyModulePassengerListTickets>>(expect1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightOrderDetailV2ResponseBodyModulePassengerList() = default;
};
class FlightOrderDetailV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> b2gVipCode{};
  shared_ptr<string> bookSuccTime{};
  shared_ptr<string> bookUserId{};
  shared_ptr<string> bookUserName{};
  shared_ptr<long> buildPrice{};
  shared_ptr<FlightOrderDetailV2ResponseBodyModuleContactInfoDTO> contactInfoDTO{};
  shared_ptr<string> createTime{};
  shared_ptr<long> facevalue{};
  shared_ptr<FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTO> flightTaleInfoDTO{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<bool> isemergency{};
  shared_ptr<bool> issendmessage{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> orderId{};
  shared_ptr<long> orderPrice{};
  shared_ptr<string> outOrderId{};
  shared_ptr<vector<FlightOrderDetailV2ResponseBodyModulePassengerList>> passengerList{};
  shared_ptr<map<string, string>> passengerSegmentMap{};
  shared_ptr<string> payTime{};
  shared_ptr<long> saleprice{};
  shared_ptr<bool> sendcpsms{};
  shared_ptr<long> status{};
  shared_ptr<long> totalServiceFeePrice{};

  FlightOrderDetailV2ResponseBodyModule() {}

  explicit FlightOrderDetailV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (b2gVipCode) {
      res["b2g_vip_code"] = boost::any(*b2gVipCode);
    }
    if (bookSuccTime) {
      res["book_succ_time"] = boost::any(*bookSuccTime);
    }
    if (bookUserId) {
      res["book_user_id"] = boost::any(*bookUserId);
    }
    if (bookUserName) {
      res["book_user_name"] = boost::any(*bookUserName);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (contactInfoDTO) {
      res["contact_info_d_t_o"] = contactInfoDTO ? boost::any(contactInfoDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["create_time"] = boost::any(*createTime);
    }
    if (facevalue) {
      res["facevalue"] = boost::any(*facevalue);
    }
    if (flightTaleInfoDTO) {
      res["flight_tale_info_d_t_o"] = flightTaleInfoDTO ? boost::any(flightTaleInfoDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (isemergency) {
      res["isemergency"] = boost::any(*isemergency);
    }
    if (issendmessage) {
      res["issendmessage"] = boost::any(*issendmessage);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderPrice) {
      res["order_price"] = boost::any(*orderPrice);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (passengerList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_list"] = boost::any(temp1);
    }
    if (passengerSegmentMap) {
      res["passenger_segment_map"] = boost::any(*passengerSegmentMap);
    }
    if (payTime) {
      res["pay_time"] = boost::any(*payTime);
    }
    if (saleprice) {
      res["saleprice"] = boost::any(*saleprice);
    }
    if (sendcpsms) {
      res["sendcpsms"] = boost::any(*sendcpsms);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (totalServiceFeePrice) {
      res["total_service_fee_price"] = boost::any(*totalServiceFeePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("b2g_vip_code") != m.end() && !m["b2g_vip_code"].empty()) {
      b2gVipCode = make_shared<string>(boost::any_cast<string>(m["b2g_vip_code"]));
    }
    if (m.find("book_succ_time") != m.end() && !m["book_succ_time"].empty()) {
      bookSuccTime = make_shared<string>(boost::any_cast<string>(m["book_succ_time"]));
    }
    if (m.find("book_user_id") != m.end() && !m["book_user_id"].empty()) {
      bookUserId = make_shared<string>(boost::any_cast<string>(m["book_user_id"]));
    }
    if (m.find("book_user_name") != m.end() && !m["book_user_name"].empty()) {
      bookUserName = make_shared<string>(boost::any_cast<string>(m["book_user_name"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("contact_info_d_t_o") != m.end() && !m["contact_info_d_t_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["contact_info_d_t_o"].type()) {
        FlightOrderDetailV2ResponseBodyModuleContactInfoDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["contact_info_d_t_o"]));
        contactInfoDTO = make_shared<FlightOrderDetailV2ResponseBodyModuleContactInfoDTO>(model1);
      }
    }
    if (m.find("create_time") != m.end() && !m["create_time"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["create_time"]));
    }
    if (m.find("facevalue") != m.end() && !m["facevalue"].empty()) {
      facevalue = make_shared<long>(boost::any_cast<long>(m["facevalue"]));
    }
    if (m.find("flight_tale_info_d_t_o") != m.end() && !m["flight_tale_info_d_t_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_tale_info_d_t_o"].type()) {
        FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flight_tale_info_d_t_o"]));
        flightTaleInfoDTO = make_shared<FlightOrderDetailV2ResponseBodyModuleFlightTaleInfoDTO>(model1);
      }
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("isemergency") != m.end() && !m["isemergency"].empty()) {
      isemergency = make_shared<bool>(boost::any_cast<bool>(m["isemergency"]));
    }
    if (m.find("issendmessage") != m.end() && !m["issendmessage"].empty()) {
      issendmessage = make_shared<bool>(boost::any_cast<bool>(m["issendmessage"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("order_price") != m.end() && !m["order_price"].empty()) {
      orderPrice = make_shared<long>(boost::any_cast<long>(m["order_price"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("passenger_list") != m.end() && !m["passenger_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_list"].type()) {
        vector<FlightOrderDetailV2ResponseBodyModulePassengerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderDetailV2ResponseBodyModulePassengerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerList = make_shared<vector<FlightOrderDetailV2ResponseBodyModulePassengerList>>(expect1);
      }
    }
    if (m.find("passenger_segment_map") != m.end() && !m["passenger_segment_map"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["passenger_segment_map"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      passengerSegmentMap = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("pay_time") != m.end() && !m["pay_time"].empty()) {
      payTime = make_shared<string>(boost::any_cast<string>(m["pay_time"]));
    }
    if (m.find("saleprice") != m.end() && !m["saleprice"].empty()) {
      saleprice = make_shared<long>(boost::any_cast<long>(m["saleprice"]));
    }
    if (m.find("sendcpsms") != m.end() && !m["sendcpsms"].empty()) {
      sendcpsms = make_shared<bool>(boost::any_cast<bool>(m["sendcpsms"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("total_service_fee_price") != m.end() && !m["total_service_fee_price"].empty()) {
      totalServiceFeePrice = make_shared<long>(boost::any_cast<long>(m["total_service_fee_price"]));
    }
  }


  virtual ~FlightOrderDetailV2ResponseBodyModule() = default;
};
class FlightOrderDetailV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightOrderDetailV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightOrderDetailV2ResponseBody() {}

  explicit FlightOrderDetailV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightOrderDetailV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightOrderDetailV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightOrderDetailV2ResponseBody() = default;
};
class FlightOrderDetailV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightOrderDetailV2ResponseBody> body{};

  FlightOrderDetailV2Response() {}

  explicit FlightOrderDetailV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightOrderDetailV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightOrderDetailV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightOrderDetailV2Response() = default;
};
class FlightOrderListQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  FlightOrderListQueryHeaders() {}

  explicit FlightOrderListQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~FlightOrderListQueryHeaders() = default;
};
class FlightOrderListQueryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allApply{};
  shared_ptr<long> applyId{};
  shared_ptr<string> departId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> updateEndTime{};
  shared_ptr<string> updateStartTime{};
  shared_ptr<string> userId{};

  FlightOrderListQueryRequest() {}

  explicit FlightOrderListQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allApply) {
      res["all_apply"] = boost::any(*allApply);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (updateEndTime) {
      res["update_end_time"] = boost::any(*updateEndTime);
    }
    if (updateStartTime) {
      res["update_start_time"] = boost::any(*updateStartTime);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_apply") != m.end() && !m["all_apply"].empty()) {
      allApply = make_shared<bool>(boost::any_cast<bool>(m["all_apply"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("update_end_time") != m.end() && !m["update_end_time"].empty()) {
      updateEndTime = make_shared<string>(boost::any_cast<string>(m["update_end_time"]));
    }
    if (m.find("update_start_time") != m.end() && !m["update_start_time"].empty()) {
      updateStartTime = make_shared<string>(boost::any_cast<string>(m["update_start_time"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightOrderListQueryRequest() = default;
};
class FlightOrderListQueryResponseBodyModuleCostCenter : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> number{};

  FlightOrderListQueryResponseBodyModuleCostCenter() {}

  explicit FlightOrderListQueryResponseBodyModuleCostCenter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (number) {
      res["number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("number") != m.end() && !m["number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["number"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBodyModuleCostCenter() = default;
};
class FlightOrderListQueryResponseBodyModuleInsureInfoList : public Darabonba::Model {
public:
  shared_ptr<string> insureNo{};
  shared_ptr<string> name{};
  shared_ptr<long> status{};

  FlightOrderListQueryResponseBodyModuleInsureInfoList() {}

  explicit FlightOrderListQueryResponseBodyModuleInsureInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (insureNo) {
      res["insure_no"] = boost::any(*insureNo);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("insure_no") != m.end() && !m["insure_no"].empty()) {
      insureNo = make_shared<string>(boost::any_cast<string>(m["insure_no"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBodyModuleInsureInfoList() = default;
};
class FlightOrderListQueryResponseBodyModuleInvoice : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  FlightOrderListQueryResponseBodyModuleInvoice() {}

  explicit FlightOrderListQueryResponseBodyModuleInvoice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBodyModuleInvoice() = default;
};
class FlightOrderListQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<long> categoryType{};
  shared_ptr<string> changeFlightNo{};
  shared_ptr<string> discount{};
  shared_ptr<string> endTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> originalTicketNo{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> payType{};
  shared_ptr<double> price{};
  shared_ptr<string> startTime{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  FlightOrderListQueryResponseBodyModulePriceInfoList() {}

  explicit FlightOrderListQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (categoryType) {
      res["category_type"] = boost::any(*categoryType);
    }
    if (changeFlightNo) {
      res["change_flight_no"] = boost::any(*changeFlightNo);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (originalTicketNo) {
      res["original_ticket_no"] = boost::any(*originalTicketNo);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("category_type") != m.end() && !m["category_type"].empty()) {
      categoryType = make_shared<long>(boost::any_cast<long>(m["category_type"]));
    }
    if (m.find("change_flight_no") != m.end() && !m["change_flight_no"].empty()) {
      changeFlightNo = make_shared<string>(boost::any_cast<string>(m["change_flight_no"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("original_ticket_no") != m.end() && !m["original_ticket_no"].empty()) {
      originalTicketNo = make_shared<string>(boost::any_cast<string>(m["original_ticket_no"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBodyModulePriceInfoList() = default;
};
class FlightOrderListQueryResponseBodyModuleUserAffiliateList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  FlightOrderListQueryResponseBodyModuleUserAffiliateList() {}

  explicit FlightOrderListQueryResponseBodyModuleUserAffiliateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBodyModuleUserAffiliateList() = default;
};
class FlightOrderListQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> arrAirport{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityAdCode{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> contactName{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<FlightOrderListQueryResponseBodyModuleCostCenter> costCenter{};
  shared_ptr<string> depAirport{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityAdCode{};
  shared_ptr<string> depDate{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> discount{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<vector<FlightOrderListQueryResponseBodyModuleInsureInfoList>> insureInfoList{};
  shared_ptr<FlightOrderListQueryResponseBodyModuleInvoice> invoice{};
  shared_ptr<long> passengerCount{};
  shared_ptr<string> passengerName{};
  shared_ptr<vector<FlightOrderListQueryResponseBodyModulePriceInfoList>> priceInfoList{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> retDate{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdPartProjectId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<long> tripType{};
  shared_ptr<vector<FlightOrderListQueryResponseBodyModuleUserAffiliateList>> userAffiliateList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  FlightOrderListQueryResponseBodyModule() {}

  explicit FlightOrderListQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (arrAirport) {
      res["arr_airport"] = boost::any(*arrAirport);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityAdCode) {
      res["arr_city_ad_code"] = boost::any(*arrCityAdCode);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (costCenter) {
      res["cost_center"] = costCenter ? boost::any(costCenter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depAirport) {
      res["dep_airport"] = boost::any(*depAirport);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityAdCode) {
      res["dep_city_ad_code"] = boost::any(*depCityAdCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (insureInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*insureInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["insure_info_list"] = boost::any(temp1);
    }
    if (invoice) {
      res["invoice"] = invoice ? boost::any(invoice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passengerCount) {
      res["passenger_count"] = boost::any(*passengerCount);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (retDate) {
      res["ret_date"] = boost::any(*retDate);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdPartProjectId) {
      res["third_part_project_id"] = boost::any(*thirdPartProjectId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    if (userAffiliateList) {
      vector<boost::any> temp1;
      for(auto item1:*userAffiliateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["user_affiliate_list"] = boost::any(temp1);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("arr_airport") != m.end() && !m["arr_airport"].empty()) {
      arrAirport = make_shared<string>(boost::any_cast<string>(m["arr_airport"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_ad_code") != m.end() && !m["arr_city_ad_code"].empty()) {
      arrCityAdCode = make_shared<string>(boost::any_cast<string>(m["arr_city_ad_code"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      if (typeid(map<string, boost::any>) == m["cost_center"].type()) {
        FlightOrderListQueryResponseBodyModuleCostCenter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cost_center"]));
        costCenter = make_shared<FlightOrderListQueryResponseBodyModuleCostCenter>(model1);
      }
    }
    if (m.find("dep_airport") != m.end() && !m["dep_airport"].empty()) {
      depAirport = make_shared<string>(boost::any_cast<string>(m["dep_airport"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_ad_code") != m.end() && !m["dep_city_ad_code"].empty()) {
      depCityAdCode = make_shared<string>(boost::any_cast<string>(m["dep_city_ad_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("insure_info_list") != m.end() && !m["insure_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["insure_info_list"].type()) {
        vector<FlightOrderListQueryResponseBodyModuleInsureInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["insure_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderListQueryResponseBodyModuleInsureInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        insureInfoList = make_shared<vector<FlightOrderListQueryResponseBodyModuleInsureInfoList>>(expect1);
      }
    }
    if (m.find("invoice") != m.end() && !m["invoice"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice"].type()) {
        FlightOrderListQueryResponseBodyModuleInvoice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice"]));
        invoice = make_shared<FlightOrderListQueryResponseBodyModuleInvoice>(model1);
      }
    }
    if (m.find("passenger_count") != m.end() && !m["passenger_count"].empty()) {
      passengerCount = make_shared<long>(boost::any_cast<long>(m["passenger_count"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<FlightOrderListQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderListQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<FlightOrderListQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("ret_date") != m.end() && !m["ret_date"].empty()) {
      retDate = make_shared<string>(boost::any_cast<string>(m["ret_date"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("third_part_project_id") != m.end() && !m["third_part_project_id"].empty()) {
      thirdPartProjectId = make_shared<string>(boost::any_cast<string>(m["third_part_project_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
    if (m.find("user_affiliate_list") != m.end() && !m["user_affiliate_list"].empty()) {
      if (typeid(vector<boost::any>) == m["user_affiliate_list"].type()) {
        vector<FlightOrderListQueryResponseBodyModuleUserAffiliateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["user_affiliate_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderListQueryResponseBodyModuleUserAffiliateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userAffiliateList = make_shared<vector<FlightOrderListQueryResponseBodyModuleUserAffiliateList>>(expect1);
      }
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBodyModule() = default;
};
class FlightOrderListQueryResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalNumber{};

  FlightOrderListQueryResponseBodyPageInfo() {}

  explicit FlightOrderListQueryResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalNumber) {
      res["total_number"] = boost::any(*totalNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_number") != m.end() && !m["total_number"].empty()) {
      totalNumber = make_shared<long>(boost::any_cast<long>(m["total_number"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBodyPageInfo() = default;
};
class FlightOrderListQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<FlightOrderListQueryResponseBodyModule>> module{};
  shared_ptr<FlightOrderListQueryResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightOrderListQueryResponseBody() {}

  explicit FlightOrderListQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<FlightOrderListQueryResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderListQueryResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<FlightOrderListQueryResponseBodyModule>>(expect1);
      }
    }
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        FlightOrderListQueryResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<FlightOrderListQueryResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightOrderListQueryResponseBody() = default;
};
class FlightOrderListQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightOrderListQueryResponseBody> body{};

  FlightOrderListQueryResponse() {}

  explicit FlightOrderListQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightOrderListQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightOrderListQueryResponseBody>(model1);
      }
    }
  }


  virtual ~FlightOrderListQueryResponse() = default;
};
class FlightOrderQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  FlightOrderQueryHeaders() {}

  explicit FlightOrderQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~FlightOrderQueryHeaders() = default;
};
class FlightOrderQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<string> userId{};

  FlightOrderQueryRequest() {}

  explicit FlightOrderQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightOrderQueryRequest() = default;
};
class FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<string> arrTime{};
  shared_ptr<string> changeCabin{};
  shared_ptr<string> changeCabinLevel{};
  shared_ptr<double> changeFee{};
  shared_ptr<string> changeFlightNo{};
  shared_ptr<long> changeOrderId{};
  shared_ptr<string> changeReason{};
  shared_ptr<long> changeType{};
  shared_ptr<string> depTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> originTicketNo{};
  shared_ptr<string> ticketNo{};
  shared_ptr<double> upgradeFee{};

  FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList() {}

  explicit FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (changeCabin) {
      res["change_cabin"] = boost::any(*changeCabin);
    }
    if (changeCabinLevel) {
      res["change_cabin_level"] = boost::any(*changeCabinLevel);
    }
    if (changeFee) {
      res["change_fee"] = boost::any(*changeFee);
    }
    if (changeFlightNo) {
      res["change_flight_no"] = boost::any(*changeFlightNo);
    }
    if (changeOrderId) {
      res["change_order_id"] = boost::any(*changeOrderId);
    }
    if (changeReason) {
      res["change_reason"] = boost::any(*changeReason);
    }
    if (changeType) {
      res["change_type"] = boost::any(*changeType);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (originTicketNo) {
      res["origin_ticket_no"] = boost::any(*originTicketNo);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (upgradeFee) {
      res["upgrade_fee"] = boost::any(*upgradeFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("change_cabin") != m.end() && !m["change_cabin"].empty()) {
      changeCabin = make_shared<string>(boost::any_cast<string>(m["change_cabin"]));
    }
    if (m.find("change_cabin_level") != m.end() && !m["change_cabin_level"].empty()) {
      changeCabinLevel = make_shared<string>(boost::any_cast<string>(m["change_cabin_level"]));
    }
    if (m.find("change_fee") != m.end() && !m["change_fee"].empty()) {
      changeFee = make_shared<double>(boost::any_cast<double>(m["change_fee"]));
    }
    if (m.find("change_flight_no") != m.end() && !m["change_flight_no"].empty()) {
      changeFlightNo = make_shared<string>(boost::any_cast<string>(m["change_flight_no"]));
    }
    if (m.find("change_order_id") != m.end() && !m["change_order_id"].empty()) {
      changeOrderId = make_shared<long>(boost::any_cast<long>(m["change_order_id"]));
    }
    if (m.find("change_reason") != m.end() && !m["change_reason"].empty()) {
      changeReason = make_shared<string>(boost::any_cast<string>(m["change_reason"]));
    }
    if (m.find("change_type") != m.end() && !m["change_type"].empty()) {
      changeType = make_shared<long>(boost::any_cast<long>(m["change_type"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("origin_ticket_no") != m.end() && !m["origin_ticket_no"].empty()) {
      originTicketNo = make_shared<string>(boost::any_cast<string>(m["origin_ticket_no"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("upgrade_fee") != m.end() && !m["upgrade_fee"].empty()) {
      upgradeFee = make_shared<double>(boost::any_cast<double>(m["upgrade_fee"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList() = default;
};
class FlightOrderQueryResponseBodyModuleFlightInfoList : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrAirportName{};
  shared_ptr<string> arrCityAdCode{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinLevel{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depAirportName{};
  shared_ptr<string> depCityAdCode{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depTime{};
  shared_ptr<long> flightMile{};
  shared_ptr<string> flightNo{};

  FlightOrderQueryResponseBodyModuleFlightInfoList() {}

  explicit FlightOrderQueryResponseBodyModuleFlightInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrAirportName) {
      res["arr_airport_name"] = boost::any(*arrAirportName);
    }
    if (arrCityAdCode) {
      res["arr_city_ad_code"] = boost::any(*arrCityAdCode);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinLevel) {
      res["cabin_level"] = boost::any(*cabinLevel);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depAirportName) {
      res["dep_airport_name"] = boost::any(*depAirportName);
    }
    if (depCityAdCode) {
      res["dep_city_ad_code"] = boost::any(*depCityAdCode);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (flightMile) {
      res["flight_mile"] = boost::any(*flightMile);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_airport_name") != m.end() && !m["arr_airport_name"].empty()) {
      arrAirportName = make_shared<string>(boost::any_cast<string>(m["arr_airport_name"]));
    }
    if (m.find("arr_city_ad_code") != m.end() && !m["arr_city_ad_code"].empty()) {
      arrCityAdCode = make_shared<string>(boost::any_cast<string>(m["arr_city_ad_code"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_level") != m.end() && !m["cabin_level"].empty()) {
      cabinLevel = make_shared<string>(boost::any_cast<string>(m["cabin_level"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_airport_name") != m.end() && !m["dep_airport_name"].empty()) {
      depAirportName = make_shared<string>(boost::any_cast<string>(m["dep_airport_name"]));
    }
    if (m.find("dep_city_ad_code") != m.end() && !m["dep_city_ad_code"].empty()) {
      depCityAdCode = make_shared<string>(boost::any_cast<string>(m["dep_city_ad_code"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("flight_mile") != m.end() && !m["flight_mile"].empty()) {
      flightMile = make_shared<long>(boost::any_cast<long>(m["flight_mile"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModuleFlightInfoList() = default;
};
class FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<long> refundOrderId{};
  shared_ptr<string> refundReason{};
  shared_ptr<double> refundTicketFee{};
  shared_ptr<long> refundType{};
  shared_ptr<string> ticketNo{};

  FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList() {}

  explicit FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (refundOrderId) {
      res["refund_order_id"] = boost::any(*refundOrderId);
    }
    if (refundReason) {
      res["refund_reason"] = boost::any(*refundReason);
    }
    if (refundTicketFee) {
      res["refund_ticket_fee"] = boost::any(*refundTicketFee);
    }
    if (refundType) {
      res["refund_type"] = boost::any(*refundType);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("refund_order_id") != m.end() && !m["refund_order_id"].empty()) {
      refundOrderId = make_shared<long>(boost::any_cast<long>(m["refund_order_id"]));
    }
    if (m.find("refund_reason") != m.end() && !m["refund_reason"].empty()) {
      refundReason = make_shared<string>(boost::any_cast<string>(m["refund_reason"]));
    }
    if (m.find("refund_ticket_fee") != m.end() && !m["refund_ticket_fee"].empty()) {
      refundTicketFee = make_shared<double>(boost::any_cast<double>(m["refund_ticket_fee"]));
    }
    if (m.find("refund_type") != m.end() && !m["refund_type"].empty()) {
      refundType = make_shared<long>(boost::any_cast<long>(m["refund_type"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList() = default;
};
class FlightOrderQueryResponseBodyModuleFlightTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<double> buildPrice{};
  shared_ptr<bool> changed{};
  shared_ptr<long> discount{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<double> oilPrice{};
  shared_ptr<long> payType{};
  shared_ptr<double> settlePrice{};
  shared_ptr<string> ticketNo{};
  shared_ptr<double> ticketPrice{};
  shared_ptr<string> ticketStatus{};
  shared_ptr<long> ticketStatusCode{};
  shared_ptr<string> userId{};

  FlightOrderQueryResponseBodyModuleFlightTicketInfoList() {}

  explicit FlightOrderQueryResponseBodyModuleFlightTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (changed) {
      res["changed"] = boost::any(*changed);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (settlePrice) {
      res["settle_price"] = boost::any(*settlePrice);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (ticketStatus) {
      res["ticket_status"] = boost::any(*ticketStatus);
    }
    if (ticketStatusCode) {
      res["ticket_status_code"] = boost::any(*ticketStatusCode);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<double>(boost::any_cast<double>(m["build_price"]));
    }
    if (m.find("changed") != m.end() && !m["changed"].empty()) {
      changed = make_shared<bool>(boost::any_cast<bool>(m["changed"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<long>(boost::any_cast<long>(m["discount"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<double>(boost::any_cast<double>(m["oil_price"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("settle_price") != m.end() && !m["settle_price"].empty()) {
      settlePrice = make_shared<double>(boost::any_cast<double>(m["settle_price"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<double>(boost::any_cast<double>(m["ticket_price"]));
    }
    if (m.find("ticket_status") != m.end() && !m["ticket_status"].empty()) {
      ticketStatus = make_shared<string>(boost::any_cast<string>(m["ticket_status"]));
    }
    if (m.find("ticket_status_code") != m.end() && !m["ticket_status_code"].empty()) {
      ticketStatusCode = make_shared<long>(boost::any_cast<long>(m["ticket_status_code"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModuleFlightTicketInfoList() = default;
};
class FlightOrderQueryResponseBodyModuleInsuranceInfoList : public Darabonba::Model {
public:
  shared_ptr<double> amount{};
  shared_ptr<string> insuranceNo{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  FlightOrderQueryResponseBodyModuleInsuranceInfoList() {}

  explicit FlightOrderQueryResponseBodyModuleInsuranceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (insuranceNo) {
      res["insurance_no"] = boost::any(*insuranceNo);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<double>(boost::any_cast<double>(m["amount"]));
    }
    if (m.find("insurance_no") != m.end() && !m["insurance_no"].empty()) {
      insuranceNo = make_shared<string>(boost::any_cast<string>(m["insurance_no"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModuleInsuranceInfoList() = default;
};
class FlightOrderQueryResponseBodyModuleInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  FlightOrderQueryResponseBodyModuleInvoiceInfo() {}

  explicit FlightOrderQueryResponseBodyModuleInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModuleInvoiceInfo() = default;
};
class FlightOrderQueryResponseBodyModuleOrderBaseInfo : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> contactName{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> itineraryId{};
  shared_ptr<long> orderId{};
  shared_ptr<long> orderStatus{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartCorpId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<long> tripType{};
  shared_ptr<string> userId{};

  FlightOrderQueryResponseBodyModuleOrderBaseInfo() {}

  explicit FlightOrderQueryResponseBodyModuleOrderBaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartCorpId) {
      res["thirdpart_corp_id"] = boost::any(*thirdpartCorpId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_corp_id") != m.end() && !m["thirdpart_corp_id"].empty()) {
      thirdpartCorpId = make_shared<string>(boost::any_cast<string>(m["thirdpart_corp_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModuleOrderBaseInfo() = default;
};
class FlightOrderQueryResponseBodyModulePassengerInfoList : public Darabonba::Model {
public:
  shared_ptr<long> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdpartProjectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> userType{};

  FlightOrderQueryResponseBodyModulePassengerInfoList() {}

  explicit FlightOrderQueryResponseBodyModulePassengerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdpartProjectId) {
      res["thirdpart_project_id"] = boost::any(*thirdpartProjectId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (userType) {
      res["user_type"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("thirdpart_project_id") != m.end() && !m["thirdpart_project_id"].empty()) {
      thirdpartProjectId = make_shared<string>(boost::any_cast<string>(m["thirdpart_project_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("user_type") != m.end() && !m["user_type"].empty()) {
      userType = make_shared<long>(boost::any_cast<long>(m["user_type"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModulePassengerInfoList() = default;
};
class FlightOrderQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> payType{};
  shared_ptr<double> price{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  FlightOrderQueryResponseBodyModulePriceInfoList() {}

  explicit FlightOrderQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOrderQueryResponseBodyModulePriceInfoList() = default;
};
class FlightOrderQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList>> flightChangeTicketInfoList{};
  shared_ptr<vector<FlightOrderQueryResponseBodyModuleFlightInfoList>> flightInfoList{};
  shared_ptr<vector<FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList>> flightRefundTicketInfoList{};
  shared_ptr<vector<FlightOrderQueryResponseBodyModuleFlightTicketInfoList>> flightTicketInfoList{};
  shared_ptr<vector<FlightOrderQueryResponseBodyModuleInsuranceInfoList>> insuranceInfoList{};
  shared_ptr<FlightOrderQueryResponseBodyModuleInvoiceInfo> invoiceInfo{};
  shared_ptr<FlightOrderQueryResponseBodyModuleOrderBaseInfo> orderBaseInfo{};
  shared_ptr<vector<FlightOrderQueryResponseBodyModulePassengerInfoList>> passengerInfoList{};
  shared_ptr<vector<FlightOrderQueryResponseBodyModulePriceInfoList>> priceInfoList{};

  FlightOrderQueryResponseBodyModule() {}

  explicit FlightOrderQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightChangeTicketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightChangeTicketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_change_ticket_info_list"] = boost::any(temp1);
    }
    if (flightInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_info_list"] = boost::any(temp1);
    }
    if (flightRefundTicketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightRefundTicketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_refund_ticket_info_list"] = boost::any(temp1);
    }
    if (flightTicketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightTicketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_ticket_info_list"] = boost::any(temp1);
    }
    if (insuranceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*insuranceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["insurance_info_list"] = boost::any(temp1);
    }
    if (invoiceInfo) {
      res["invoice_info"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderBaseInfo) {
      res["order_base_info"] = orderBaseInfo ? boost::any(orderBaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passengerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_info_list"] = boost::any(temp1);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_change_ticket_info_list") != m.end() && !m["flight_change_ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_change_ticket_info_list"].type()) {
        vector<FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_change_ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightChangeTicketInfoList = make_shared<vector<FlightOrderQueryResponseBodyModuleFlightChangeTicketInfoList>>(expect1);
      }
    }
    if (m.find("flight_info_list") != m.end() && !m["flight_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_info_list"].type()) {
        vector<FlightOrderQueryResponseBodyModuleFlightInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderQueryResponseBodyModuleFlightInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightInfoList = make_shared<vector<FlightOrderQueryResponseBodyModuleFlightInfoList>>(expect1);
      }
    }
    if (m.find("flight_refund_ticket_info_list") != m.end() && !m["flight_refund_ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_refund_ticket_info_list"].type()) {
        vector<FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_refund_ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightRefundTicketInfoList = make_shared<vector<FlightOrderQueryResponseBodyModuleFlightRefundTicketInfoList>>(expect1);
      }
    }
    if (m.find("flight_ticket_info_list") != m.end() && !m["flight_ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_ticket_info_list"].type()) {
        vector<FlightOrderQueryResponseBodyModuleFlightTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderQueryResponseBodyModuleFlightTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightTicketInfoList = make_shared<vector<FlightOrderQueryResponseBodyModuleFlightTicketInfoList>>(expect1);
      }
    }
    if (m.find("insurance_info_list") != m.end() && !m["insurance_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["insurance_info_list"].type()) {
        vector<FlightOrderQueryResponseBodyModuleInsuranceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["insurance_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderQueryResponseBodyModuleInsuranceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        insuranceInfoList = make_shared<vector<FlightOrderQueryResponseBodyModuleInsuranceInfoList>>(expect1);
      }
    }
    if (m.find("invoice_info") != m.end() && !m["invoice_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice_info"].type()) {
        FlightOrderQueryResponseBodyModuleInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice_info"]));
        invoiceInfo = make_shared<FlightOrderQueryResponseBodyModuleInvoiceInfo>(model1);
      }
    }
    if (m.find("order_base_info") != m.end() && !m["order_base_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["order_base_info"].type()) {
        FlightOrderQueryResponseBodyModuleOrderBaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["order_base_info"]));
        orderBaseInfo = make_shared<FlightOrderQueryResponseBodyModuleOrderBaseInfo>(model1);
      }
    }
    if (m.find("passenger_info_list") != m.end() && !m["passenger_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_info_list"].type()) {
        vector<FlightOrderQueryResponseBodyModulePassengerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderQueryResponseBodyModulePassengerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerInfoList = make_shared<vector<FlightOrderQueryResponseBodyModulePassengerInfoList>>(expect1);
      }
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<FlightOrderQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOrderQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<FlightOrderQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
  }


  virtual ~FlightOrderQueryResponseBodyModule() = default;
};
class FlightOrderQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightOrderQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightOrderQueryResponseBody() {}

  explicit FlightOrderQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightOrderQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightOrderQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightOrderQueryResponseBody() = default;
};
class FlightOrderQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightOrderQueryResponseBody> body{};

  FlightOrderQueryResponse() {}

  explicit FlightOrderQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightOrderQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightOrderQueryResponseBody>(model1);
      }
    }
  }


  virtual ~FlightOrderQueryResponse() = default;
};
class FlightOtaItemDetailHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightOtaItemDetailHeaders() {}

  explicit FlightOtaItemDetailHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightOtaItemDetailHeaders() = default;
};
class FlightOtaItemDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> isvName{};
  shared_ptr<string> otaItemId{};

  FlightOtaItemDetailRequest() {}

  explicit FlightOtaItemDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
  }


  virtual ~FlightOtaItemDetailRequest() = default;
};
class FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["image_d_o"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("image_d_o") != m.end() && !m["image_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["image_d_o"].type()) {
        FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["image_d_o"]));
        imageDO = make_shared<FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<boost::any>> extraContentVisualizes{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItems() {}

  explicit FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (extraContentVisualizes) {
      res["extra_content_visualizes"] = boost::any(*extraContentVisualizes);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("extra_content_visualizes") != m.end() && !m["extra_content_visualizes"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["extra_content_visualizes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extra_content_visualizes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      extraContentVisualizes = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItems() = default;
};
class FlightOtaItemDetailResponseBodyModuleBaggageRuleTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  FlightOtaItemDetailResponseBodyModuleBaggageRuleTips() {}

  explicit FlightOtaItemDetailResponseBodyModuleBaggageRuleTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModuleBaggageRuleTips() = default;
};
class FlightOtaItemDetailResponseBodyModuleBaggageRule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<FlightOtaItemDetailResponseBodyModuleBaggageRuleTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaItemDetailResponseBodyModuleBaggageRule() {}

  explicit FlightOtaItemDetailResponseBodyModuleBaggageRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<FlightOtaItemDetailResponseBodyModuleBaggageRuleBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        FlightOtaItemDetailResponseBodyModuleBaggageRuleTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<FlightOtaItemDetailResponseBodyModuleBaggageRuleTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModuleBaggageRule() = default;
};
class FlightOtaItemDetailResponseBodyModuleChangeRuleExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightOtaItemDetailResponseBodyModuleChangeRuleExtraContents() {}

  explicit FlightOtaItemDetailResponseBodyModuleChangeRuleExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModuleChangeRuleExtraContents() = default;
};
class FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItemsRefundSubContents() {}

  explicit FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItemsRefundSubContents() = default;
};
class FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItems() {}

  explicit FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItems() = default;
};
class FlightOtaItemDetailResponseBodyModuleChangeRule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaItemDetailResponseBodyModuleChangeRuleExtraContents>> extraContents{};
  shared_ptr<string> flightNo{};
  shared_ptr<long> freeBaggage{};
  shared_ptr<long> index{};
  shared_ptr<long> level{};
  shared_ptr<vector<FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaItemDetailResponseBodyModuleChangeRule() {}

  explicit FlightOtaItemDetailResponseBodyModuleChangeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (freeBaggage) {
      res["free_baggage"] = boost::any(*freeBaggage);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightOtaItemDetailResponseBodyModuleChangeRuleExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaItemDetailResponseBodyModuleChangeRuleExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightOtaItemDetailResponseBodyModuleChangeRuleExtraContents>>(expect1);
      }
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("free_baggage") != m.end() && !m["free_baggage"].empty()) {
      freeBaggage = make_shared<long>(boost::any_cast<long>(m["free_baggage"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["level"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightOtaItemDetailResponseBodyModuleChangeRuleRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModuleChangeRule() = default;
};
class FlightOtaItemDetailResponseBodyModuleRefundRuleExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightOtaItemDetailResponseBodyModuleRefundRuleExtraContents() {}

  explicit FlightOtaItemDetailResponseBodyModuleRefundRuleExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModuleRefundRuleExtraContents() = default;
};
class FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItemsRefundSubContents() {}

  explicit FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItemsRefundSubContents() = default;
};
class FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItems() {}

  explicit FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItems() = default;
};
class FlightOtaItemDetailResponseBodyModuleRefundRule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaItemDetailResponseBodyModuleRefundRuleExtraContents>> extraContents{};
  shared_ptr<string> flightNo{};
  shared_ptr<long> freeBaggage{};
  shared_ptr<long> index{};
  shared_ptr<long> level{};
  shared_ptr<vector<FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaItemDetailResponseBodyModuleRefundRule() {}

  explicit FlightOtaItemDetailResponseBodyModuleRefundRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (freeBaggage) {
      res["free_baggage"] = boost::any(*freeBaggage);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightOtaItemDetailResponseBodyModuleRefundRuleExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaItemDetailResponseBodyModuleRefundRuleExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightOtaItemDetailResponseBodyModuleRefundRuleExtraContents>>(expect1);
      }
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("free_baggage") != m.end() && !m["free_baggage"].empty()) {
      freeBaggage = make_shared<long>(boost::any_cast<long>(m["free_baggage"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["level"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightOtaItemDetailResponseBodyModuleRefundRuleRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModuleRefundRule() = default;
};
class FlightOtaItemDetailResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaItemDetailResponseBodyModuleBaggageRule>> baggageRule{};
  shared_ptr<vector<FlightOtaItemDetailResponseBodyModuleChangeRule>> changeRule{};
  shared_ptr<vector<FlightOtaItemDetailResponseBodyModuleRefundRule>> refundRule{};
  shared_ptr<long> sellPrice{};
  shared_ptr<vector<long>> sellPriceList{};
  shared_ptr<long> tripType{};

  FlightOtaItemDetailResponseBodyModule() {}

  explicit FlightOtaItemDetailResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageRule) {
      vector<boost::any> temp1;
      for(auto item1:*baggageRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_rule"] = boost::any(temp1);
    }
    if (changeRule) {
      vector<boost::any> temp1;
      for(auto item1:*changeRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["change_rule"] = boost::any(temp1);
    }
    if (refundRule) {
      vector<boost::any> temp1;
      for(auto item1:*refundRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_rule"] = boost::any(temp1);
    }
    if (sellPrice) {
      res["sell_price"] = boost::any(*sellPrice);
    }
    if (sellPriceList) {
      res["sell_price_list"] = boost::any(*sellPriceList);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_rule") != m.end() && !m["baggage_rule"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_rule"].type()) {
        vector<FlightOtaItemDetailResponseBodyModuleBaggageRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaItemDetailResponseBodyModuleBaggageRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageRule = make_shared<vector<FlightOtaItemDetailResponseBodyModuleBaggageRule>>(expect1);
      }
    }
    if (m.find("change_rule") != m.end() && !m["change_rule"].empty()) {
      if (typeid(vector<boost::any>) == m["change_rule"].type()) {
        vector<FlightOtaItemDetailResponseBodyModuleChangeRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["change_rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaItemDetailResponseBodyModuleChangeRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeRule = make_shared<vector<FlightOtaItemDetailResponseBodyModuleChangeRule>>(expect1);
      }
    }
    if (m.find("refund_rule") != m.end() && !m["refund_rule"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_rule"].type()) {
        vector<FlightOtaItemDetailResponseBodyModuleRefundRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaItemDetailResponseBodyModuleRefundRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundRule = make_shared<vector<FlightOtaItemDetailResponseBodyModuleRefundRule>>(expect1);
      }
    }
    if (m.find("sell_price") != m.end() && !m["sell_price"].empty()) {
      sellPrice = make_shared<long>(boost::any_cast<long>(m["sell_price"]));
    }
    if (m.find("sell_price_list") != m.end() && !m["sell_price_list"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["sell_price_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sell_price_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      sellPriceList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBodyModule() = default;
};
class FlightOtaItemDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightOtaItemDetailResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightOtaItemDetailResponseBody() {}

  explicit FlightOtaItemDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightOtaItemDetailResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightOtaItemDetailResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightOtaItemDetailResponseBody() = default;
};
class FlightOtaItemDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightOtaItemDetailResponseBody> body{};

  FlightOtaItemDetailResponse() {}

  explicit FlightOtaItemDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightOtaItemDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightOtaItemDetailResponseBody>(model1);
      }
    }
  }


  virtual ~FlightOtaItemDetailResponse() = default;
};
class FlightOtaSearchHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightOtaSearchHeaders() {}

  explicit FlightOtaSearchHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightOtaSearchHeaders() = default;
};
class FlightOtaSearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> carrierFlightNo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<string> flightNo{};

  FlightOtaSearchRequest() {}

  explicit FlightOtaSearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (carrierFlightNo) {
      res["carrier_flight_no"] = boost::any(*carrierFlightNo);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("carrier_flight_no") != m.end() && !m["carrier_flight_no"].empty()) {
      carrierFlightNo = make_shared<string>(boost::any_cast<string>(m["carrier_flight_no"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
  }


  virtual ~FlightOtaSearchRequest() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};

  FlightOtaSearchResponseBodyModuleFlightListAirlineInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListAirlineInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightOtaSearchResponseBodyModuleFlightListArrAirportInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListArrAirportInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["image_d_o"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("image_d_o") != m.end() && !m["image_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["image_d_o"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["image_d_o"]));
        imageDO = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<boost::any>> extraContentVisualizes{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (extraContentVisualizes) {
      res["extra_content_visualizes"] = boost::any(*extraContentVisualizes);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("extra_content_visualizes") != m.end() && !m["extra_content_visualizes"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["extra_content_visualizes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extra_content_visualizes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      extraContentVisualizes = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList : public Darabonba::Model {
public:
  shared_ptr<string> baggageInfo{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem> baggageItem{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule> changeRule{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem> changeRuleItem{};
  shared_ptr<string> extra{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule> refundRule{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem> refundRuleItem{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule> signRule{};
  shared_ptr<string> tuigaiqianInfo{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule> upgradeRule{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageInfo) {
      res["baggage_info"] = boost::any(*baggageInfo);
    }
    if (baggageItem) {
      res["baggage_item"] = baggageItem ? boost::any(baggageItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRule) {
      res["change_rule"] = changeRule ? boost::any(changeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRuleItem) {
      res["change_rule_item"] = changeRuleItem ? boost::any(changeRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (refundRule) {
      res["refund_rule"] = refundRule ? boost::any(refundRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundRuleItem) {
      res["refund_rule_item"] = refundRuleItem ? boost::any(refundRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signRule) {
      res["sign_rule"] = signRule ? boost::any(signRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    if (upgradeRule) {
      res["upgrade_rule"] = upgradeRule ? boost::any(upgradeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_info") != m.end() && !m["baggage_info"].empty()) {
      baggageInfo = make_shared<string>(boost::any_cast<string>(m["baggage_info"]));
    }
    if (m.find("baggage_item") != m.end() && !m["baggage_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["baggage_item"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["baggage_item"]));
        baggageItem = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem>(model1);
      }
    }
    if (m.find("change_rule") != m.end() && !m["change_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule"]));
        changeRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule>(model1);
      }
    }
    if (m.find("change_rule_item") != m.end() && !m["change_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule_item"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule_item"]));
        changeRuleItem = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem>(model1);
      }
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("refund_rule") != m.end() && !m["refund_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule"]));
        refundRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule>(model1);
      }
    }
    if (m.find("refund_rule_item") != m.end() && !m["refund_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule_item"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule_item"]));
        refundRuleItem = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem>(model1);
      }
    }
    if (m.find("sign_rule") != m.end() && !m["sign_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["sign_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sign_rule"]));
        signRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule>(model1);
      }
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
    if (m.find("upgrade_rule") != m.end() && !m["upgrade_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_rule"]));
        upgradeRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule>(model1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListCabinInfoList : public Darabonba::Model {
public:
  shared_ptr<long> agentId{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<string> childCabin{};
  shared_ptr<string> className{};
  shared_ptr<string> classRule{};
  shared_ptr<string> discount{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList>> flightRuleList{};
  shared_ptr<string> flightRuleListStr{};
  shared_ptr<long> invoiceType{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<long> oilPrice{};
  shared_ptr<string> orderParams{};
  shared_ptr<string> otaItemId{};
  shared_ptr<long> price{};
  shared_ptr<long> productType{};
  shared_ptr<string> productTypeDesc{};
  shared_ptr<string> promotionPrice{};
  shared_ptr<string> remainedSeatCount{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> totalPrice{};

  FlightOtaSearchResponseBodyModuleFlightListCabinInfoList() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListCabinInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["agent_id"] = boost::any(*agentId);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabin_class_name"] = boost::any(*cabinClassName);
    }
    if (childCabin) {
      res["child_cabin"] = boost::any(*childCabin);
    }
    if (className) {
      res["class_name"] = boost::any(*className);
    }
    if (classRule) {
      res["class_rule"] = boost::any(*classRule);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*flightRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_rule_list"] = boost::any(temp1);
    }
    if (flightRuleListStr) {
      res["flight_rule_list_str"] = boost::any(*flightRuleListStr);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (orderParams) {
      res["order_params"] = boost::any(*orderParams);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (productType) {
      res["product_type"] = boost::any(*productType);
    }
    if (productTypeDesc) {
      res["product_type_desc"] = boost::any(*productTypeDesc);
    }
    if (promotionPrice) {
      res["promotion_price"] = boost::any(*promotionPrice);
    }
    if (remainedSeatCount) {
      res["remained_seat_count"] = boost::any(*remainedSeatCount);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("agent_id") != m.end() && !m["agent_id"].empty()) {
      agentId = make_shared<long>(boost::any_cast<long>(m["agent_id"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_class_name") != m.end() && !m["cabin_class_name"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabin_class_name"]));
    }
    if (m.find("child_cabin") != m.end() && !m["child_cabin"].empty()) {
      childCabin = make_shared<string>(boost::any_cast<string>(m["child_cabin"]));
    }
    if (m.find("class_name") != m.end() && !m["class_name"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["class_name"]));
    }
    if (m.find("class_rule") != m.end() && !m["class_rule"].empty()) {
      classRule = make_shared<string>(boost::any_cast<string>(m["class_rule"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("flight_rule_list") != m.end() && !m["flight_rule_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_rule_list"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_rule_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightRuleList = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoListFlightRuleList>>(expect1);
      }
    }
    if (m.find("flight_rule_list_str") != m.end() && !m["flight_rule_list_str"].empty()) {
      flightRuleListStr = make_shared<string>(boost::any_cast<string>(m["flight_rule_list_str"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("order_params") != m.end() && !m["order_params"].empty()) {
      orderParams = make_shared<string>(boost::any_cast<string>(m["order_params"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("product_type") != m.end() && !m["product_type"].empty()) {
      productType = make_shared<long>(boost::any_cast<long>(m["product_type"]));
    }
    if (m.find("product_type_desc") != m.end() && !m["product_type_desc"].empty()) {
      productTypeDesc = make_shared<string>(boost::any_cast<string>(m["product_type_desc"]));
    }
    if (m.find("promotion_price") != m.end() && !m["promotion_price"].empty()) {
      promotionPrice = make_shared<string>(boost::any_cast<string>(m["promotion_price"]));
    }
    if (m.find("remained_seat_count") != m.end() && !m["remained_seat_count"].empty()) {
      remainedSeatCount = make_shared<string>(boost::any_cast<string>(m["remained_seat_count"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<long>(boost::any_cast<long>(m["total_price"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListCabinInfoList() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightOtaSearchResponseBodyModuleFlightListDepAirportInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListDepAirportInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["image_d_o"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("image_d_o") != m.end() && !m["image_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["image_d_o"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["image_d_o"]));
        imageDO = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<boost::any>> extraContentVisualizes{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (extraContentVisualizes) {
      res["extra_content_visualizes"] = boost::any(*extraContentVisualizes);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("extra_content_visualizes") != m.end() && !m["extra_content_visualizes"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["extra_content_visualizes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extra_content_visualizes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      extraContentVisualizes = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItem() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItemTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItem() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo>> info{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule() = default;
};
class FlightOtaSearchResponseBodyModuleFlightListFlightRuleList : public Darabonba::Model {
public:
  shared_ptr<string> baggageInfo{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItem> baggageItem{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRule> changeRule{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem> changeRuleItem{};
  shared_ptr<string> extra{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRule> refundRule{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem> refundRuleItem{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRule> signRule{};
  shared_ptr<string> tuigaiqianInfo{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule> upgradeRule{};

  FlightOtaSearchResponseBodyModuleFlightListFlightRuleList() {}

  explicit FlightOtaSearchResponseBodyModuleFlightListFlightRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageInfo) {
      res["baggage_info"] = boost::any(*baggageInfo);
    }
    if (baggageItem) {
      res["baggage_item"] = baggageItem ? boost::any(baggageItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRule) {
      res["change_rule"] = changeRule ? boost::any(changeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRuleItem) {
      res["change_rule_item"] = changeRuleItem ? boost::any(changeRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (refundRule) {
      res["refund_rule"] = refundRule ? boost::any(refundRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundRuleItem) {
      res["refund_rule_item"] = refundRuleItem ? boost::any(refundRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signRule) {
      res["sign_rule"] = signRule ? boost::any(signRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    if (upgradeRule) {
      res["upgrade_rule"] = upgradeRule ? boost::any(upgradeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_info") != m.end() && !m["baggage_info"].empty()) {
      baggageInfo = make_shared<string>(boost::any_cast<string>(m["baggage_info"]));
    }
    if (m.find("baggage_item") != m.end() && !m["baggage_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["baggage_item"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["baggage_item"]));
        baggageItem = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListBaggageItem>(model1);
      }
    }
    if (m.find("change_rule") != m.end() && !m["change_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule"]));
        changeRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRule>(model1);
      }
    }
    if (m.find("change_rule_item") != m.end() && !m["change_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule_item"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule_item"]));
        changeRuleItem = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListChangeRuleItem>(model1);
      }
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("refund_rule") != m.end() && !m["refund_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule"]));
        refundRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRule>(model1);
      }
    }
    if (m.find("refund_rule_item") != m.end() && !m["refund_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule_item"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule_item"]));
        refundRuleItem = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListRefundRuleItem>(model1);
      }
    }
    if (m.find("sign_rule") != m.end() && !m["sign_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["sign_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sign_rule"]));
        signRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListSignRule>(model1);
      }
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
    if (m.find("upgrade_rule") != m.end() && !m["upgrade_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_rule"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_rule"]));
        upgradeRule = make_shared<FlightOtaSearchResponseBodyModuleFlightListFlightRuleListUpgradeRule>(model1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightListFlightRuleList() = default;
};
class FlightOtaSearchResponseBodyModuleFlightList : public Darabonba::Model {
public:
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListAirlineInfo> airlineInfo{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListArrAirportInfo> arrAirportInfo{};
  shared_ptr<string> arrDate{};
  shared_ptr<long> buildPrice{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoList>> cabinInfoList{};
  shared_ptr<string> carrierAirline{};
  shared_ptr<string> carrierNo{};
  shared_ptr<FlightOtaSearchResponseBodyModuleFlightListDepAirportInfo> depAirportInfo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<long> discount{};
  shared_ptr<string> flightNo{};
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleList>> flightRuleList{};
  shared_ptr<string> flightRuleListStr{};
  shared_ptr<string> flightSize{};
  shared_ptr<string> flightType{};
  shared_ptr<long> invoiceType{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<bool> isShare{};
  shared_ptr<bool> isStop{};
  shared_ptr<bool> isTransfer{};
  shared_ptr<string> mealDesc{};
  shared_ptr<long> oilPrice{};
  shared_ptr<string> otaItemId{};
  shared_ptr<long> price{};
  shared_ptr<long> productType{};
  shared_ptr<string> productTypeDesc{};
  shared_ptr<string> promotionPrice{};
  shared_ptr<string> remainedSeatCount{};
  shared_ptr<string> secretParams{};
  shared_ptr<string> segmentNumber{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopDepTime{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<string> totalPrice{};
  shared_ptr<long> tripType{};

  FlightOtaSearchResponseBodyModuleFlightList() {}

  explicit FlightOtaSearchResponseBodyModuleFlightList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*cabinInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cabin_info_list"] = boost::any(temp1);
    }
    if (carrierAirline) {
      res["carrier_airline"] = boost::any(*carrierAirline);
    }
    if (carrierNo) {
      res["carrier_no"] = boost::any(*carrierNo);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*flightRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_rule_list"] = boost::any(temp1);
    }
    if (flightRuleListStr) {
      res["flight_rule_list_str"] = boost::any(*flightRuleListStr);
    }
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (isShare) {
      res["is_share"] = boost::any(*isShare);
    }
    if (isStop) {
      res["is_stop"] = boost::any(*isStop);
    }
    if (isTransfer) {
      res["is_transfer"] = boost::any(*isTransfer);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (productType) {
      res["product_type"] = boost::any(*productType);
    }
    if (productTypeDesc) {
      res["product_type_desc"] = boost::any(*productTypeDesc);
    }
    if (promotionPrice) {
      res["promotion_price"] = boost::any(*promotionPrice);
    }
    if (remainedSeatCount) {
      res["remained_seat_count"] = boost::any(*remainedSeatCount);
    }
    if (secretParams) {
      res["secret_params"] = boost::any(*secretParams);
    }
    if (segmentNumber) {
      res["segment_number"] = boost::any(*segmentNumber);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<FlightOtaSearchResponseBodyModuleFlightListAirlineInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<FlightOtaSearchResponseBodyModuleFlightListArrAirportInfo>(model1);
      }
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_info_list") != m.end() && !m["cabin_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["cabin_info_list"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cabin_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListCabinInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cabinInfoList = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListCabinInfoList>>(expect1);
      }
    }
    if (m.find("carrier_airline") != m.end() && !m["carrier_airline"].empty()) {
      carrierAirline = make_shared<string>(boost::any_cast<string>(m["carrier_airline"]));
    }
    if (m.find("carrier_no") != m.end() && !m["carrier_no"].empty()) {
      carrierNo = make_shared<string>(boost::any_cast<string>(m["carrier_no"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        FlightOtaSearchResponseBodyModuleFlightListDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<FlightOtaSearchResponseBodyModuleFlightListDepAirportInfo>(model1);
      }
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<long>(boost::any_cast<long>(m["discount"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_rule_list") != m.end() && !m["flight_rule_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_rule_list"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_rule_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightListFlightRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightRuleList = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightListFlightRuleList>>(expect1);
      }
    }
    if (m.find("flight_rule_list_str") != m.end() && !m["flight_rule_list_str"].empty()) {
      flightRuleListStr = make_shared<string>(boost::any_cast<string>(m["flight_rule_list_str"]));
    }
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("is_share") != m.end() && !m["is_share"].empty()) {
      isShare = make_shared<bool>(boost::any_cast<bool>(m["is_share"]));
    }
    if (m.find("is_stop") != m.end() && !m["is_stop"].empty()) {
      isStop = make_shared<bool>(boost::any_cast<bool>(m["is_stop"]));
    }
    if (m.find("is_transfer") != m.end() && !m["is_transfer"].empty()) {
      isTransfer = make_shared<bool>(boost::any_cast<bool>(m["is_transfer"]));
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("product_type") != m.end() && !m["product_type"].empty()) {
      productType = make_shared<long>(boost::any_cast<long>(m["product_type"]));
    }
    if (m.find("product_type_desc") != m.end() && !m["product_type_desc"].empty()) {
      productTypeDesc = make_shared<string>(boost::any_cast<string>(m["product_type_desc"]));
    }
    if (m.find("promotion_price") != m.end() && !m["promotion_price"].empty()) {
      promotionPrice = make_shared<string>(boost::any_cast<string>(m["promotion_price"]));
    }
    if (m.find("remained_seat_count") != m.end() && !m["remained_seat_count"].empty()) {
      remainedSeatCount = make_shared<string>(boost::any_cast<string>(m["remained_seat_count"]));
    }
    if (m.find("secret_params") != m.end() && !m["secret_params"].empty()) {
      secretParams = make_shared<string>(boost::any_cast<string>(m["secret_params"]));
    }
    if (m.find("segment_number") != m.end() && !m["segment_number"].empty()) {
      segmentNumber = make_shared<string>(boost::any_cast<string>(m["segment_number"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<string>(boost::any_cast<string>(m["total_price"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightOtaSearchResponseBodyModuleFlightList() = default;
};
class FlightOtaSearchResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchResponseBodyModuleFlightList>> flightList{};

  FlightOtaSearchResponseBodyModule() {}

  explicit FlightOtaSearchResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightList) {
      vector<boost::any> temp1;
      for(auto item1:*flightList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_list") != m.end() && !m["flight_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_list"].type()) {
        vector<FlightOtaSearchResponseBodyModuleFlightList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchResponseBodyModuleFlightList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightList = make_shared<vector<FlightOtaSearchResponseBodyModuleFlightList>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchResponseBodyModule() = default;
};
class FlightOtaSearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightOtaSearchResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightOtaSearchResponseBody() {}

  explicit FlightOtaSearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightOtaSearchResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightOtaSearchResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightOtaSearchResponseBody() = default;
};
class FlightOtaSearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightOtaSearchResponseBody> body{};

  FlightOtaSearchResponse() {}

  explicit FlightOtaSearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightOtaSearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightOtaSearchResponseBody>(model1);
      }
    }
  }


  virtual ~FlightOtaSearchResponse() = default;
};
class FlightOtaSearchV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightOtaSearchV2Headers() {}

  explicit FlightOtaSearchV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightOtaSearchV2Headers() = default;
};
class FlightOtaSearchV2RequestSearchJourneysSelectedFlights : public Darabonba::Model {
public:
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> flightTime{};
  shared_ptr<string> marketFlightNo{};
  shared_ptr<string> operateFlightNo{};

  FlightOtaSearchV2RequestSearchJourneysSelectedFlights() {}

  explicit FlightOtaSearchV2RequestSearchJourneysSelectedFlights(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (flightTime) {
      res["flight_time"] = boost::any(*flightTime);
    }
    if (marketFlightNo) {
      res["market_flight_no"] = boost::any(*marketFlightNo);
    }
    if (operateFlightNo) {
      res["operate_flight_no"] = boost::any(*operateFlightNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("flight_time") != m.end() && !m["flight_time"].empty()) {
      flightTime = make_shared<string>(boost::any_cast<string>(m["flight_time"]));
    }
    if (m.find("market_flight_no") != m.end() && !m["market_flight_no"].empty()) {
      marketFlightNo = make_shared<string>(boost::any_cast<string>(m["market_flight_no"]));
    }
    if (m.find("operate_flight_no") != m.end() && !m["operate_flight_no"].empty()) {
      operateFlightNo = make_shared<string>(boost::any_cast<string>(m["operate_flight_no"]));
    }
  }


  virtual ~FlightOtaSearchV2RequestSearchJourneysSelectedFlights() = default;
};
class FlightOtaSearchV2RequestSearchJourneys : public Darabonba::Model {
public:
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<vector<FlightOtaSearchV2RequestSearchJourneysSelectedFlights>> selectedFlights{};

  FlightOtaSearchV2RequestSearchJourneys() {}

  explicit FlightOtaSearchV2RequestSearchJourneys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (selectedFlights) {
      vector<boost::any> temp1;
      for(auto item1:*selectedFlights){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["selected_flights"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("selected_flights") != m.end() && !m["selected_flights"].empty()) {
      if (typeid(vector<boost::any>) == m["selected_flights"].type()) {
        vector<FlightOtaSearchV2RequestSearchJourneysSelectedFlights> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["selected_flights"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchV2RequestSearchJourneysSelectedFlights model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        selectedFlights = make_shared<vector<FlightOtaSearchV2RequestSearchJourneysSelectedFlights>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchV2RequestSearchJourneys() = default;
};
class FlightOtaSearchV2Request : public Darabonba::Model {
public:
  shared_ptr<vector<long>> cabinTypeList{};
  shared_ptr<bool> directOnly{};
  shared_ptr<string> isvName{};
  shared_ptr<bool> needShareFlight{};
  shared_ptr<vector<FlightOtaSearchV2RequestSearchJourneys>> searchJourneys{};
  shared_ptr<long> searchMode{};
  shared_ptr<long> tripType{};

  FlightOtaSearchV2Request() {}

  explicit FlightOtaSearchV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabinTypeList) {
      res["cabin_type_list"] = boost::any(*cabinTypeList);
    }
    if (directOnly) {
      res["direct_only"] = boost::any(*directOnly);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (needShareFlight) {
      res["need_share_flight"] = boost::any(*needShareFlight);
    }
    if (searchJourneys) {
      vector<boost::any> temp1;
      for(auto item1:*searchJourneys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["search_journeys"] = boost::any(temp1);
    }
    if (searchMode) {
      res["search_mode"] = boost::any(*searchMode);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin_type_list") != m.end() && !m["cabin_type_list"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["cabin_type_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["cabin_type_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      cabinTypeList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("direct_only") != m.end() && !m["direct_only"].empty()) {
      directOnly = make_shared<bool>(boost::any_cast<bool>(m["direct_only"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("need_share_flight") != m.end() && !m["need_share_flight"].empty()) {
      needShareFlight = make_shared<bool>(boost::any_cast<bool>(m["need_share_flight"]));
    }
    if (m.find("search_journeys") != m.end() && !m["search_journeys"].empty()) {
      if (typeid(vector<boost::any>) == m["search_journeys"].type()) {
        vector<FlightOtaSearchV2RequestSearchJourneys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["search_journeys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchV2RequestSearchJourneys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchJourneys = make_shared<vector<FlightOtaSearchV2RequestSearchJourneys>>(expect1);
      }
    }
    if (m.find("search_mode") != m.end() && !m["search_mode"].empty()) {
      searchMode = make_shared<long>(boost::any_cast<long>(m["search_mode"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightOtaSearchV2Request() = default;
};
class FlightOtaSearchV2ShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cabinTypeListShrink{};
  shared_ptr<bool> directOnly{};
  shared_ptr<string> isvName{};
  shared_ptr<bool> needShareFlight{};
  shared_ptr<string> searchJourneysShrink{};
  shared_ptr<long> searchMode{};
  shared_ptr<long> tripType{};

  FlightOtaSearchV2ShrinkRequest() {}

  explicit FlightOtaSearchV2ShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabinTypeListShrink) {
      res["cabin_type_list"] = boost::any(*cabinTypeListShrink);
    }
    if (directOnly) {
      res["direct_only"] = boost::any(*directOnly);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (needShareFlight) {
      res["need_share_flight"] = boost::any(*needShareFlight);
    }
    if (searchJourneysShrink) {
      res["search_journeys"] = boost::any(*searchJourneysShrink);
    }
    if (searchMode) {
      res["search_mode"] = boost::any(*searchMode);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin_type_list") != m.end() && !m["cabin_type_list"].empty()) {
      cabinTypeListShrink = make_shared<string>(boost::any_cast<string>(m["cabin_type_list"]));
    }
    if (m.find("direct_only") != m.end() && !m["direct_only"].empty()) {
      directOnly = make_shared<bool>(boost::any_cast<bool>(m["direct_only"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("need_share_flight") != m.end() && !m["need_share_flight"].empty()) {
      needShareFlight = make_shared<bool>(boost::any_cast<bool>(m["need_share_flight"]));
    }
    if (m.find("search_journeys") != m.end() && !m["search_journeys"].empty()) {
      searchJourneysShrink = make_shared<string>(boost::any_cast<string>(m["search_journeys"]));
    }
    if (m.find("search_mode") != m.end() && !m["search_mode"].empty()) {
      searchMode = make_shared<long>(boost::any_cast<long>(m["search_mode"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightOtaSearchV2ShrinkRequest() = default;
};
class FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineChineseName{};
  shared_ptr<string> airlineChineseShortName{};
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineIcon{};
  shared_ptr<bool> cheapFlight{};

  FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosAirlineInfo() {}

  explicit FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineChineseName) {
      res["airline_chinese_name"] = boost::any(*airlineChineseName);
    }
    if (airlineChineseShortName) {
      res["airline_chinese_short_name"] = boost::any(*airlineChineseShortName);
    }
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineIcon) {
      res["airline_icon"] = boost::any(*airlineIcon);
    }
    if (cheapFlight) {
      res["cheap_flight"] = boost::any(*cheapFlight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_chinese_name") != m.end() && !m["airline_chinese_name"].empty()) {
      airlineChineseName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_name"]));
    }
    if (m.find("airline_chinese_short_name") != m.end() && !m["airline_chinese_short_name"].empty()) {
      airlineChineseShortName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_short_name"]));
    }
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_icon") != m.end() && !m["airline_icon"].empty()) {
      airlineIcon = make_shared<string>(boost::any_cast<string>(m["airline_icon"]));
    }
    if (m.find("cheap_flight") != m.end() && !m["cheap_flight"].empty()) {
      cheapFlight = make_shared<bool>(boost::any_cast<bool>(m["cheap_flight"]));
    }
  }


  virtual ~FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosAirlineInfo() = default;
};
class FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> airportNameColor{};
  shared_ptr<string> airportShortName{};
  shared_ptr<string> terminal{};

  FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosArrAirportInfo() {}

  explicit FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (airportNameColor) {
      res["airport_name_color"] = boost::any(*airportNameColor);
    }
    if (airportShortName) {
      res["airport_short_name"] = boost::any(*airportShortName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("airport_name_color") != m.end() && !m["airport_name_color"].empty()) {
      airportNameColor = make_shared<string>(boost::any_cast<string>(m["airport_name_color"]));
    }
    if (m.find("airport_short_name") != m.end() && !m["airport_short_name"].empty()) {
      airportShortName = make_shared<string>(boost::any_cast<string>(m["airport_short_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosArrAirportInfo() = default;
};
class FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> airportNameColor{};
  shared_ptr<string> airportShortName{};
  shared_ptr<string> terminal{};

  FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosDepAirportInfo() {}

  explicit FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (airportNameColor) {
      res["airport_name_color"] = boost::any(*airportNameColor);
    }
    if (airportShortName) {
      res["airport_short_name"] = boost::any(*airportShortName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("airport_name_color") != m.end() && !m["airport_name_color"].empty()) {
      airportNameColor = make_shared<string>(boost::any_cast<string>(m["airport_name_color"]));
    }
    if (m.find("airport_short_name") != m.end() && !m["airport_short_name"].empty()) {
      airportShortName = make_shared<string>(boost::any_cast<string>(m["airport_short_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosDepAirportInfo() = default;
};
class FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightShareInfoOperatingAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineChineseName{};
  shared_ptr<string> airlineChineseShortName{};
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineIcon{};
  shared_ptr<bool> cheapFlight{};

  FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightShareInfoOperatingAirlineInfo() {}

  explicit FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightShareInfoOperatingAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineChineseName) {
      res["airline_chinese_name"] = boost::any(*airlineChineseName);
    }
    if (airlineChineseShortName) {
      res["airline_chinese_short_name"] = boost::any(*airlineChineseShortName);
    }
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineIcon) {
      res["airline_icon"] = boost::any(*airlineIcon);
    }
    if (cheapFlight) {
      res["cheap_flight"] = boost::any(*cheapFlight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_chinese_name") != m.end() && !m["airline_chinese_name"].empty()) {
      airlineChineseName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_name"]));
    }
    if (m.find("airline_chinese_short_name") != m.end() && !m["airline_chinese_short_name"].empty()) {
      airlineChineseShortName = make_shared<string>(boost::any_cast<string>(m["airline_chinese_short_name"]));
    }
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_icon") != m.end() && !m["airline_icon"].empty()) {
      airlineIcon = make_shared<string>(boost::any_cast<string>(m["airline_icon"]));
    }
    if (m.find("cheap_flight") != m.end() && !m["cheap_flight"].empty()) {
      cheapFlight = make_shared<bool>(boost::any_cast<bool>(m["cheap_flight"]));
    }
  }


  virtual ~FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightShareInfoOperatingAirlineInfo() = default;
};
class FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightShareInfo : public Darabonba::Model {
public:
  shared_ptr<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightShareInfoOperatingAirlineInfo> operatingAirlineInfo{};
  shared_ptr<string> operatingFlightNo{};

  FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightShareInfo() {}

  explicit FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightShareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operatingAirlineInfo) {
      res["operating_airline_info"] = operatingAirlineInfo ? boost::any(operatingAirlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operatingFlightNo) {
      res["operating_flight_no"] = boost::any(*operatingFlightNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("operating_airline_info") != m.end() && !m["operating_airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["operating_airline_info"].type()) {
        FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightShareInfoOperatingAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["operating_airline_info"]));
        operatingAirlineInfo = make_shared<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightShareInfoOperatingAirlineInfo>(model1);
      }
    }
    if (m.find("operating_flight_no") != m.end() && !m["operating_flight_no"].empty()) {
      operatingFlightNo = make_shared<string>(boost::any_cast<string>(m["operating_flight_no"]));
    }
  }


  virtual ~FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightShareInfo() = default;
};
class FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightStopInfo : public Darabonba::Model {
public:
  shared_ptr<string> stopAirport{};
  shared_ptr<string> stopAirportName{};
  shared_ptr<string> stopArrTerm{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCityCode{};
  shared_ptr<string> stopCityName{};
  shared_ptr<vector<string>> stopCityNames{};
  shared_ptr<string> stopDepTerm{};
  shared_ptr<string> stopDepTime{};
  shared_ptr<string> stopTime{};

  FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightStopInfo() {}

  explicit FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightStopInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stopAirport) {
      res["stop_airport"] = boost::any(*stopAirport);
    }
    if (stopAirportName) {
      res["stop_airport_name"] = boost::any(*stopAirportName);
    }
    if (stopArrTerm) {
      res["stop_arr_term"] = boost::any(*stopArrTerm);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCityCode) {
      res["stop_city_code"] = boost::any(*stopCityCode);
    }
    if (stopCityName) {
      res["stop_city_name"] = boost::any(*stopCityName);
    }
    if (stopCityNames) {
      res["stop_city_names"] = boost::any(*stopCityNames);
    }
    if (stopDepTerm) {
      res["stop_dep_term"] = boost::any(*stopDepTerm);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    if (stopTime) {
      res["stop_time"] = boost::any(*stopTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("stop_airport") != m.end() && !m["stop_airport"].empty()) {
      stopAirport = make_shared<string>(boost::any_cast<string>(m["stop_airport"]));
    }
    if (m.find("stop_airport_name") != m.end() && !m["stop_airport_name"].empty()) {
      stopAirportName = make_shared<string>(boost::any_cast<string>(m["stop_airport_name"]));
    }
    if (m.find("stop_arr_term") != m.end() && !m["stop_arr_term"].empty()) {
      stopArrTerm = make_shared<string>(boost::any_cast<string>(m["stop_arr_term"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city_code") != m.end() && !m["stop_city_code"].empty()) {
      stopCityCode = make_shared<string>(boost::any_cast<string>(m["stop_city_code"]));
    }
    if (m.find("stop_city_name") != m.end() && !m["stop_city_name"].empty()) {
      stopCityName = make_shared<string>(boost::any_cast<string>(m["stop_city_name"]));
    }
    if (m.find("stop_city_names") != m.end() && !m["stop_city_names"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["stop_city_names"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["stop_city_names"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      stopCityNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("stop_dep_term") != m.end() && !m["stop_dep_term"].empty()) {
      stopDepTerm = make_shared<string>(boost::any_cast<string>(m["stop_dep_term"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
    if (m.find("stop_time") != m.end() && !m["stop_time"].empty()) {
      stopTime = make_shared<string>(boost::any_cast<string>(m["stop_time"]));
    }
  }


  virtual ~FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightStopInfo() = default;
};
class FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfos : public Darabonba::Model {
public:
  shared_ptr<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosAirlineInfo> airlineInfo{};
  shared_ptr<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosArrAirportInfo> arrAirportInfo{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> baggageDesc{};
  shared_ptr<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosDepAirportInfo> depAirportInfo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depTime{};
  shared_ptr<long> duration{};
  shared_ptr<map<string, boost::any>> extraInfo{};
  shared_ptr<string> flightNo{};
  shared_ptr<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightShareInfo> flightShareInfo{};
  shared_ptr<string> flightSize{};
  shared_ptr<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightStopInfo> flightStopInfo{};
  shared_ptr<string> flightType{};
  shared_ptr<string> manufacturer{};
  shared_ptr<string> mealDesc{};
  shared_ptr<long> miles{};
  shared_ptr<string> onTimeRate{};
  shared_ptr<long> oneMore{};
  shared_ptr<string> oneMoreShow{};
  shared_ptr<long> segmentIndex{};
  shared_ptr<bool> share{};
  shared_ptr<string> shortFlightSize{};
  shared_ptr<bool> stop{};
  shared_ptr<string> totalTime{};
  shared_ptr<string> transferTime{};
  shared_ptr<long> transferTimeNumber{};

  FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfos() {}

  explicit FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (extraInfo) {
      res["extra_info"] = boost::any(*extraInfo);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightShareInfo) {
      res["flight_share_info"] = flightShareInfo ? boost::any(flightShareInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (flightStopInfo) {
      res["flight_stop_info"] = flightStopInfo ? boost::any(flightStopInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (manufacturer) {
      res["manufacturer"] = boost::any(*manufacturer);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (miles) {
      res["miles"] = boost::any(*miles);
    }
    if (onTimeRate) {
      res["on_time_rate"] = boost::any(*onTimeRate);
    }
    if (oneMore) {
      res["one_more"] = boost::any(*oneMore);
    }
    if (oneMoreShow) {
      res["one_more_show"] = boost::any(*oneMoreShow);
    }
    if (segmentIndex) {
      res["segment_index"] = boost::any(*segmentIndex);
    }
    if (share) {
      res["share"] = boost::any(*share);
    }
    if (shortFlightSize) {
      res["short_flight_size"] = boost::any(*shortFlightSize);
    }
    if (stop) {
      res["stop"] = boost::any(*stop);
    }
    if (totalTime) {
      res["total_time"] = boost::any(*totalTime);
    }
    if (transferTime) {
      res["transfer_time"] = boost::any(*transferTime);
    }
    if (transferTimeNumber) {
      res["transfer_time_number"] = boost::any(*transferTimeNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosAirlineInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosArrAirportInfo>(model1);
      }
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      baggageDesc = make_shared<string>(boost::any_cast<string>(m["baggage_desc"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosDepAirportInfo>(model1);
      }
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("extra_info") != m.end() && !m["extra_info"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["extra_info"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_share_info") != m.end() && !m["flight_share_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_share_info"].type()) {
        FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightShareInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flight_share_info"]));
        flightShareInfo = make_shared<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightShareInfo>(model1);
      }
    }
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("flight_stop_info") != m.end() && !m["flight_stop_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_stop_info"].type()) {
        FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightStopInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["flight_stop_info"]));
        flightStopInfo = make_shared<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfosFlightStopInfo>(model1);
      }
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("manufacturer") != m.end() && !m["manufacturer"].empty()) {
      manufacturer = make_shared<string>(boost::any_cast<string>(m["manufacturer"]));
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("miles") != m.end() && !m["miles"].empty()) {
      miles = make_shared<long>(boost::any_cast<long>(m["miles"]));
    }
    if (m.find("on_time_rate") != m.end() && !m["on_time_rate"].empty()) {
      onTimeRate = make_shared<string>(boost::any_cast<string>(m["on_time_rate"]));
    }
    if (m.find("one_more") != m.end() && !m["one_more"].empty()) {
      oneMore = make_shared<long>(boost::any_cast<long>(m["one_more"]));
    }
    if (m.find("one_more_show") != m.end() && !m["one_more_show"].empty()) {
      oneMoreShow = make_shared<string>(boost::any_cast<string>(m["one_more_show"]));
    }
    if (m.find("segment_index") != m.end() && !m["segment_index"].empty()) {
      segmentIndex = make_shared<long>(boost::any_cast<long>(m["segment_index"]));
    }
    if (m.find("share") != m.end() && !m["share"].empty()) {
      share = make_shared<bool>(boost::any_cast<bool>(m["share"]));
    }
    if (m.find("short_flight_size") != m.end() && !m["short_flight_size"].empty()) {
      shortFlightSize = make_shared<string>(boost::any_cast<string>(m["short_flight_size"]));
    }
    if (m.find("stop") != m.end() && !m["stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["stop"]));
    }
    if (m.find("total_time") != m.end() && !m["total_time"].empty()) {
      totalTime = make_shared<string>(boost::any_cast<string>(m["total_time"]));
    }
    if (m.find("transfer_time") != m.end() && !m["transfer_time"].empty()) {
      transferTime = make_shared<string>(boost::any_cast<string>(m["transfer_time"]));
    }
    if (m.find("transfer_time_number") != m.end() && !m["transfer_time_number"].empty()) {
      transferTimeNumber = make_shared<long>(boost::any_cast<long>(m["transfer_time_number"]));
    }
  }


  virtual ~FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfos() = default;
};
class FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfos : public Darabonba::Model {
public:
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depTime{};
  shared_ptr<long> duration{};
  shared_ptr<map<string, string>> extensions{};
  shared_ptr<vector<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfos>> flightSegmentInfos{};
  shared_ptr<long> journeyIndex{};
  shared_ptr<long> transferTime{};

  FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfos() {}

  explicit FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (extensions) {
      res["extensions"] = boost::any(*extensions);
    }
    if (flightSegmentInfos) {
      vector<boost::any> temp1;
      for(auto item1:*flightSegmentInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_segment_infos"] = boost::any(temp1);
    }
    if (journeyIndex) {
      res["journey_index"] = boost::any(*journeyIndex);
    }
    if (transferTime) {
      res["transfer_time"] = boost::any(*transferTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("extensions") != m.end() && !m["extensions"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["extensions"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extensions = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("flight_segment_infos") != m.end() && !m["flight_segment_infos"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_segment_infos"].type()) {
        vector<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_segment_infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightSegmentInfos = make_shared<vector<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfosFlightSegmentInfos>>(expect1);
      }
    }
    if (m.find("journey_index") != m.end() && !m["journey_index"].empty()) {
      journeyIndex = make_shared<long>(boost::any_cast<long>(m["journey_index"]));
    }
    if (m.find("transfer_time") != m.end() && !m["transfer_time"].empty()) {
      transferTime = make_shared<long>(boost::any_cast<long>(m["transfer_time"]));
    }
  }


  virtual ~FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfos() = default;
};
class FlightOtaSearchV2ResponseBodyModuleItemListSubItems : public Darabonba::Model {
public:
  shared_ptr<map<string, ModuleItemListSubItemsShoppingItemMapValue>> shoppingItemMap{};
  shared_ptr<string> uniqKey{};

  FlightOtaSearchV2ResponseBodyModuleItemListSubItems() {}

  explicit FlightOtaSearchV2ResponseBodyModuleItemListSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (shoppingItemMap) {
      map<string, boost::any> temp1;
      for(auto item1:*shoppingItemMap){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["shopping_item_map"] = boost::any(temp1);
    }
    if (uniqKey) {
      res["uniq_key"] = boost::any(*uniqKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("shopping_item_map") != m.end() && !m["shopping_item_map"].empty()) {
      if (typeid(map<string, boost::any>) == m["shopping_item_map"].type()) {
        map<string, ModuleItemListSubItemsShoppingItemMapValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["shopping_item_map"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleItemListSubItemsShoppingItemMapValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        shoppingItemMap = make_shared<map<string, ModuleItemListSubItemsShoppingItemMapValue>>(expect1);
      }
    }
    if (m.find("uniq_key") != m.end() && !m["uniq_key"].empty()) {
      uniqKey = make_shared<string>(boost::any_cast<string>(m["uniq_key"]));
    }
  }


  virtual ~FlightOtaSearchV2ResponseBodyModuleItemListSubItems() = default;
};
class FlightOtaSearchV2ResponseBodyModuleItemList : public Darabonba::Model {
public:
  shared_ptr<map<string, ModuleItemListFlightRuleInfosValue>> flightRuleInfos{};
  shared_ptr<string> itemId{};
  shared_ptr<map<string, ModuleItemListShoppingItemMapValue>> shoppingItemMap{};
  shared_ptr<map<string, vector<ModuleItemListSubItemPositionMapValue>>> subItemPositionMap{};
  shared_ptr<vector<FlightOtaSearchV2ResponseBodyModuleItemListSubItems>> subItems{};

  FlightOtaSearchV2ResponseBodyModuleItemList() {}

  explicit FlightOtaSearchV2ResponseBodyModuleItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightRuleInfos) {
      map<string, boost::any> temp1;
      for(auto item1:*flightRuleInfos){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["flight_rule_infos"] = boost::any(temp1);
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (shoppingItemMap) {
      map<string, boost::any> temp1;
      for(auto item1:*shoppingItemMap){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["shopping_item_map"] = boost::any(temp1);
    }
    if (subItemPositionMap) {
      map<string, boost::any> temp1;
      for(auto item1:*subItemPositionMap){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["sub_item_position_map"] = boost::any(temp1);
    }
    if (subItems) {
      vector<boost::any> temp1;
      for(auto item1:*subItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["sub_items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_rule_infos") != m.end() && !m["flight_rule_infos"].empty()) {
      if (typeid(map<string, boost::any>) == m["flight_rule_infos"].type()) {
        map<string, ModuleItemListFlightRuleInfosValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["flight_rule_infos"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleItemListFlightRuleInfosValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        flightRuleInfos = make_shared<map<string, ModuleItemListFlightRuleInfosValue>>(expect1);
      }
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["item_id"]));
    }
    if (m.find("shopping_item_map") != m.end() && !m["shopping_item_map"].empty()) {
      if (typeid(map<string, boost::any>) == m["shopping_item_map"].type()) {
        map<string, ModuleItemListShoppingItemMapValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["shopping_item_map"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ModuleItemListShoppingItemMapValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        shoppingItemMap = make_shared<map<string, ModuleItemListShoppingItemMapValue>>(expect1);
      }
    }
    if (m.find("sub_item_position_map") != m.end() && !m["sub_item_position_map"].empty()) {
      if (typeid(map<string, boost::any>) == m["sub_item_position_map"].type()) {
        map<string, vector<ModuleItemListSubItemPositionMapValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["sub_item_position_map"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<ModuleItemListSubItemPositionMapValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                ModuleItemListSubItemPositionMapValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        subItemPositionMap = make_shared<map<string, vector<ModuleItemListSubItemPositionMapValue>>>(expect1);
      }
    }
    if (m.find("sub_items") != m.end() && !m["sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["sub_items"].type()) {
        vector<FlightOtaSearchV2ResponseBodyModuleItemListSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchV2ResponseBodyModuleItemListSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subItems = make_shared<vector<FlightOtaSearchV2ResponseBodyModuleItemListSubItems>>(expect1);
      }
    }
  }


  virtual ~FlightOtaSearchV2ResponseBodyModuleItemList() = default;
};
class FlightOtaSearchV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfos>> flightJourneyInfos{};
  shared_ptr<vector<FlightOtaSearchV2ResponseBodyModuleItemList>> itemList{};
  shared_ptr<long> searchMode{};
  shared_ptr<long> tripType{};

  FlightOtaSearchV2ResponseBodyModule() {}

  explicit FlightOtaSearchV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightJourneyInfos) {
      vector<boost::any> temp1;
      for(auto item1:*flightJourneyInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_journey_infos"] = boost::any(temp1);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["item_list"] = boost::any(temp1);
    }
    if (searchMode) {
      res["search_mode"] = boost::any(*searchMode);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_journey_infos") != m.end() && !m["flight_journey_infos"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_journey_infos"].type()) {
        vector<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_journey_infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightJourneyInfos = make_shared<vector<FlightOtaSearchV2ResponseBodyModuleFlightJourneyInfos>>(expect1);
      }
    }
    if (m.find("item_list") != m.end() && !m["item_list"].empty()) {
      if (typeid(vector<boost::any>) == m["item_list"].type()) {
        vector<FlightOtaSearchV2ResponseBodyModuleItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["item_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightOtaSearchV2ResponseBodyModuleItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<FlightOtaSearchV2ResponseBodyModuleItemList>>(expect1);
      }
    }
    if (m.find("search_mode") != m.end() && !m["search_mode"].empty()) {
      searchMode = make_shared<long>(boost::any_cast<long>(m["search_mode"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightOtaSearchV2ResponseBodyModule() = default;
};
class FlightOtaSearchV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightOtaSearchV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightOtaSearchV2ResponseBody() {}

  explicit FlightOtaSearchV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightOtaSearchV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightOtaSearchV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightOtaSearchV2ResponseBody() = default;
};
class FlightOtaSearchV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightOtaSearchV2ResponseBody> body{};

  FlightOtaSearchV2Response() {}

  explicit FlightOtaSearchV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightOtaSearchV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightOtaSearchV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightOtaSearchV2Response() = default;
};
class FlightPayOrderHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightPayOrderHeaders() {}

  explicit FlightPayOrderHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightPayOrderHeaders() = default;
};
class FlightPayOrderRequest : public Darabonba::Model {
public:
  shared_ptr<long> corpPayPrice{};
  shared_ptr<string> disOrderId{};
  shared_ptr<map<string, string>> extra{};
  shared_ptr<long> personalPayPrice{};
  shared_ptr<long> totalPayPrice{};

  FlightPayOrderRequest() {}

  explicit FlightPayOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpPayPrice) {
      res["corp_pay_price"] = boost::any(*corpPayPrice);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (personalPayPrice) {
      res["personal_pay_price"] = boost::any(*personalPayPrice);
    }
    if (totalPayPrice) {
      res["total_pay_price"] = boost::any(*totalPayPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_pay_price") != m.end() && !m["corp_pay_price"].empty()) {
      corpPayPrice = make_shared<long>(boost::any_cast<long>(m["corp_pay_price"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["extra"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extra = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("personal_pay_price") != m.end() && !m["personal_pay_price"].empty()) {
      personalPayPrice = make_shared<long>(boost::any_cast<long>(m["personal_pay_price"]));
    }
    if (m.find("total_pay_price") != m.end() && !m["total_pay_price"].empty()) {
      totalPayPrice = make_shared<long>(boost::any_cast<long>(m["total_pay_price"]));
    }
  }


  virtual ~FlightPayOrderRequest() = default;
};
class FlightPayOrderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> corpPayPrice{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> extraShrink{};
  shared_ptr<long> personalPayPrice{};
  shared_ptr<long> totalPayPrice{};

  FlightPayOrderShrinkRequest() {}

  explicit FlightPayOrderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpPayPrice) {
      res["corp_pay_price"] = boost::any(*corpPayPrice);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (extraShrink) {
      res["extra"] = boost::any(*extraShrink);
    }
    if (personalPayPrice) {
      res["personal_pay_price"] = boost::any(*personalPayPrice);
    }
    if (totalPayPrice) {
      res["total_pay_price"] = boost::any(*totalPayPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_pay_price") != m.end() && !m["corp_pay_price"].empty()) {
      corpPayPrice = make_shared<long>(boost::any_cast<long>(m["corp_pay_price"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extraShrink = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("personal_pay_price") != m.end() && !m["personal_pay_price"].empty()) {
      personalPayPrice = make_shared<long>(boost::any_cast<long>(m["personal_pay_price"]));
    }
    if (m.find("total_pay_price") != m.end() && !m["total_pay_price"].empty()) {
      totalPayPrice = make_shared<long>(boost::any_cast<long>(m["total_pay_price"]));
    }
  }


  virtual ~FlightPayOrderShrinkRequest() = default;
};
class FlightPayOrderResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> actualPayPrice{};
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<string> lastPayTime{};
  shared_ptr<long> payStatus{};

  FlightPayOrderResponseBodyModule() {}

  explicit FlightPayOrderResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualPayPrice) {
      res["actual_pay_price"] = boost::any(*actualPayPrice);
    }
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (lastPayTime) {
      res["last_pay_time"] = boost::any(*lastPayTime);
    }
    if (payStatus) {
      res["pay_status"] = boost::any(*payStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actual_pay_price") != m.end() && !m["actual_pay_price"].empty()) {
      actualPayPrice = make_shared<long>(boost::any_cast<long>(m["actual_pay_price"]));
    }
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("last_pay_time") != m.end() && !m["last_pay_time"].empty()) {
      lastPayTime = make_shared<string>(boost::any_cast<string>(m["last_pay_time"]));
    }
    if (m.find("pay_status") != m.end() && !m["pay_status"].empty()) {
      payStatus = make_shared<long>(boost::any_cast<long>(m["pay_status"]));
    }
  }


  virtual ~FlightPayOrderResponseBodyModule() = default;
};
class FlightPayOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightPayOrderResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightPayOrderResponseBody() {}

  explicit FlightPayOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightPayOrderResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightPayOrderResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightPayOrderResponseBody() = default;
};
class FlightPayOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightPayOrderResponseBody> body{};

  FlightPayOrderResponse() {}

  explicit FlightPayOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightPayOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightPayOrderResponseBody>(model1);
      }
    }
  }


  virtual ~FlightPayOrderResponse() = default;
};
class FlightPayOrderV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightPayOrderV2Headers() {}

  explicit FlightPayOrderV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightPayOrderV2Headers() = default;
};
class FlightPayOrderV2Request : public Darabonba::Model {
public:
  shared_ptr<string> isvName{};
  shared_ptr<string> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<long> totalPrice{};
  shared_ptr<long> totalServiceFeePrice{};

  FlightPayOrderV2Request() {}

  explicit FlightPayOrderV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    if (totalServiceFeePrice) {
      res["total_service_fee_price"] = boost::any(*totalServiceFeePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<long>(boost::any_cast<long>(m["total_price"]));
    }
    if (m.find("total_service_fee_price") != m.end() && !m["total_service_fee_price"].empty()) {
      totalServiceFeePrice = make_shared<long>(boost::any_cast<long>(m["total_service_fee_price"]));
    }
  }


  virtual ~FlightPayOrderV2Request() = default;
};
class FlightPayOrderV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> price{};

  FlightPayOrderV2ResponseBodyModule() {}

  explicit FlightPayOrderV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (price) {
      res["price"] = boost::any(*price);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
  }


  virtual ~FlightPayOrderV2ResponseBodyModule() = default;
};
class FlightPayOrderV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightPayOrderV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightPayOrderV2ResponseBody() {}

  explicit FlightPayOrderV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightPayOrderV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightPayOrderV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightPayOrderV2ResponseBody() = default;
};
class FlightPayOrderV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightPayOrderV2ResponseBody> body{};

  FlightPayOrderV2Response() {}

  explicit FlightPayOrderV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightPayOrderV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightPayOrderV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightPayOrderV2Response() = default;
};
class FlightRefundApplyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightRefundApplyHeaders() {}

  explicit FlightRefundApplyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightRefundApplyHeaders() = default;
};
class FlightRefundApplyRequestPassengerSegmentInfoList : public Darabonba::Model {
public:
  shared_ptr<string> flightNo{};
  shared_ptr<string> passengerName{};
  shared_ptr<string> userId{};

  FlightRefundApplyRequestPassengerSegmentInfoList() {}

  explicit FlightRefundApplyRequestPassengerSegmentInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightRefundApplyRequestPassengerSegmentInfoList() = default;
};
class FlightRefundApplyRequest : public Darabonba::Model {
public:
  shared_ptr<long> corpRefundPrice{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<string> displayRefundMoney{};
  shared_ptr<map<string, string>> extra{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<string> itemUnitIds{};
  shared_ptr<vector<FlightRefundApplyRequestPassengerSegmentInfoList>> passengerSegmentInfoList{};
  shared_ptr<long> personalRefundPrice{};
  shared_ptr<string> reasonDetail{};
  shared_ptr<long> reasonType{};
  shared_ptr<vector<string>> refundVoucherInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<long> totalRefundPrice{};

  FlightRefundApplyRequest() {}

  explicit FlightRefundApplyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpRefundPrice) {
      res["corp_refund_price"] = boost::any(*corpRefundPrice);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (displayRefundMoney) {
      res["display_refund_money"] = boost::any(*displayRefundMoney);
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (itemUnitIds) {
      res["item_unit_ids"] = boost::any(*itemUnitIds);
    }
    if (passengerSegmentInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerSegmentInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_segment_info_list"] = boost::any(temp1);
    }
    if (personalRefundPrice) {
      res["personal_refund_price"] = boost::any(*personalRefundPrice);
    }
    if (reasonDetail) {
      res["reason_detail"] = boost::any(*reasonDetail);
    }
    if (reasonType) {
      res["reason_type"] = boost::any(*reasonType);
    }
    if (refundVoucherInfo) {
      res["refund_voucher_info"] = boost::any(*refundVoucherInfo);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (totalRefundPrice) {
      res["total_refund_price"] = boost::any(*totalRefundPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_refund_price") != m.end() && !m["corp_refund_price"].empty()) {
      corpRefundPrice = make_shared<long>(boost::any_cast<long>(m["corp_refund_price"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("display_refund_money") != m.end() && !m["display_refund_money"].empty()) {
      displayRefundMoney = make_shared<string>(boost::any_cast<string>(m["display_refund_money"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["extra"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extra = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("item_unit_ids") != m.end() && !m["item_unit_ids"].empty()) {
      itemUnitIds = make_shared<string>(boost::any_cast<string>(m["item_unit_ids"]));
    }
    if (m.find("passenger_segment_info_list") != m.end() && !m["passenger_segment_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_segment_info_list"].type()) {
        vector<FlightRefundApplyRequestPassengerSegmentInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_segment_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundApplyRequestPassengerSegmentInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerSegmentInfoList = make_shared<vector<FlightRefundApplyRequestPassengerSegmentInfoList>>(expect1);
      }
    }
    if (m.find("personal_refund_price") != m.end() && !m["personal_refund_price"].empty()) {
      personalRefundPrice = make_shared<long>(boost::any_cast<long>(m["personal_refund_price"]));
    }
    if (m.find("reason_detail") != m.end() && !m["reason_detail"].empty()) {
      reasonDetail = make_shared<string>(boost::any_cast<string>(m["reason_detail"]));
    }
    if (m.find("reason_type") != m.end() && !m["reason_type"].empty()) {
      reasonType = make_shared<long>(boost::any_cast<long>(m["reason_type"]));
    }
    if (m.find("refund_voucher_info") != m.end() && !m["refund_voucher_info"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["refund_voucher_info"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["refund_voucher_info"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      refundVoucherInfo = make_shared<vector<string>>(toVec1);
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("total_refund_price") != m.end() && !m["total_refund_price"].empty()) {
      totalRefundPrice = make_shared<long>(boost::any_cast<long>(m["total_refund_price"]));
    }
  }


  virtual ~FlightRefundApplyRequest() = default;
};
class FlightRefundApplyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> corpRefundPrice{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<string> displayRefundMoney{};
  shared_ptr<string> extraShrink{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<string> itemUnitIds{};
  shared_ptr<string> passengerSegmentInfoListShrink{};
  shared_ptr<long> personalRefundPrice{};
  shared_ptr<string> reasonDetail{};
  shared_ptr<long> reasonType{};
  shared_ptr<string> refundVoucherInfoShrink{};
  shared_ptr<string> sessionId{};
  shared_ptr<long> totalRefundPrice{};

  FlightRefundApplyShrinkRequest() {}

  explicit FlightRefundApplyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpRefundPrice) {
      res["corp_refund_price"] = boost::any(*corpRefundPrice);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (displayRefundMoney) {
      res["display_refund_money"] = boost::any(*displayRefundMoney);
    }
    if (extraShrink) {
      res["extra"] = boost::any(*extraShrink);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (itemUnitIds) {
      res["item_unit_ids"] = boost::any(*itemUnitIds);
    }
    if (passengerSegmentInfoListShrink) {
      res["passenger_segment_info_list"] = boost::any(*passengerSegmentInfoListShrink);
    }
    if (personalRefundPrice) {
      res["personal_refund_price"] = boost::any(*personalRefundPrice);
    }
    if (reasonDetail) {
      res["reason_detail"] = boost::any(*reasonDetail);
    }
    if (reasonType) {
      res["reason_type"] = boost::any(*reasonType);
    }
    if (refundVoucherInfoShrink) {
      res["refund_voucher_info"] = boost::any(*refundVoucherInfoShrink);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (totalRefundPrice) {
      res["total_refund_price"] = boost::any(*totalRefundPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_refund_price") != m.end() && !m["corp_refund_price"].empty()) {
      corpRefundPrice = make_shared<long>(boost::any_cast<long>(m["corp_refund_price"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("display_refund_money") != m.end() && !m["display_refund_money"].empty()) {
      displayRefundMoney = make_shared<string>(boost::any_cast<string>(m["display_refund_money"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extraShrink = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("item_unit_ids") != m.end() && !m["item_unit_ids"].empty()) {
      itemUnitIds = make_shared<string>(boost::any_cast<string>(m["item_unit_ids"]));
    }
    if (m.find("passenger_segment_info_list") != m.end() && !m["passenger_segment_info_list"].empty()) {
      passengerSegmentInfoListShrink = make_shared<string>(boost::any_cast<string>(m["passenger_segment_info_list"]));
    }
    if (m.find("personal_refund_price") != m.end() && !m["personal_refund_price"].empty()) {
      personalRefundPrice = make_shared<long>(boost::any_cast<long>(m["personal_refund_price"]));
    }
    if (m.find("reason_detail") != m.end() && !m["reason_detail"].empty()) {
      reasonDetail = make_shared<string>(boost::any_cast<string>(m["reason_detail"]));
    }
    if (m.find("reason_type") != m.end() && !m["reason_type"].empty()) {
      reasonType = make_shared<long>(boost::any_cast<long>(m["reason_type"]));
    }
    if (m.find("refund_voucher_info") != m.end() && !m["refund_voucher_info"].empty()) {
      refundVoucherInfoShrink = make_shared<string>(boost::any_cast<string>(m["refund_voucher_info"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("total_refund_price") != m.end() && !m["total_refund_price"].empty()) {
      totalRefundPrice = make_shared<long>(boost::any_cast<long>(m["total_refund_price"]));
    }
  }


  virtual ~FlightRefundApplyShrinkRequest() = default;
};
class FlightRefundApplyResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<long> refundApplyId{};
  shared_ptr<long> refundFee{};
  shared_ptr<long> refundMoney{};

  FlightRefundApplyResponseBodyModule() {}

  explicit FlightRefundApplyResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (refundApplyId) {
      res["refund_apply_id"] = boost::any(*refundApplyId);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (refundMoney) {
      res["refund_money"] = boost::any(*refundMoney);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("refund_apply_id") != m.end() && !m["refund_apply_id"].empty()) {
      refundApplyId = make_shared<long>(boost::any_cast<long>(m["refund_apply_id"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["refund_fee"]));
    }
    if (m.find("refund_money") != m.end() && !m["refund_money"].empty()) {
      refundMoney = make_shared<long>(boost::any_cast<long>(m["refund_money"]));
    }
  }


  virtual ~FlightRefundApplyResponseBodyModule() = default;
};
class FlightRefundApplyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightRefundApplyResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightRefundApplyResponseBody() {}

  explicit FlightRefundApplyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightRefundApplyResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightRefundApplyResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightRefundApplyResponseBody() = default;
};
class FlightRefundApplyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightRefundApplyResponseBody> body{};

  FlightRefundApplyResponse() {}

  explicit FlightRefundApplyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightRefundApplyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightRefundApplyResponseBody>(model1);
      }
    }
  }


  virtual ~FlightRefundApplyResponse() = default;
};
class FlightRefundApplyV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightRefundApplyV2Headers() {}

  explicit FlightRefundApplyV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightRefundApplyV2Headers() = default;
};
class FlightRefundApplyV2RequestPassengerSegmentRelations : public Darabonba::Model {
public:
  shared_ptr<string> passengerId{};
  shared_ptr<vector<string>> segmentIdList{};

  FlightRefundApplyV2RequestPassengerSegmentRelations() {}

  explicit FlightRefundApplyV2RequestPassengerSegmentRelations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passengerId) {
      res["passenger_id"] = boost::any(*passengerId);
    }
    if (segmentIdList) {
      res["segment_id_list"] = boost::any(*segmentIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("passenger_id") != m.end() && !m["passenger_id"].empty()) {
      passengerId = make_shared<string>(boost::any_cast<string>(m["passenger_id"]));
    }
    if (m.find("segment_id_list") != m.end() && !m["segment_id_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["segment_id_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["segment_id_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      segmentIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~FlightRefundApplyV2RequestPassengerSegmentRelations() = default;
};
class FlightRefundApplyV2Request : public Darabonba::Model {
public:
  shared_ptr<string> isvName{};
  shared_ptr<string> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<vector<FlightRefundApplyV2RequestPassengerSegmentRelations>> passengerSegmentRelations{};
  shared_ptr<long> preCalType{};
  shared_ptr<string> refundReason{};
  shared_ptr<long> refundReasonType{};
  shared_ptr<vector<string>> ticketNos{};
  shared_ptr<long> totalRefundPrice{};
  shared_ptr<string> uploadPictUrls{};
  shared_ptr<bool> voluntary{};

  FlightRefundApplyV2Request() {}

  explicit FlightRefundApplyV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (passengerSegmentRelations) {
      vector<boost::any> temp1;
      for(auto item1:*passengerSegmentRelations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_segment_relations"] = boost::any(temp1);
    }
    if (preCalType) {
      res["pre_cal_type"] = boost::any(*preCalType);
    }
    if (refundReason) {
      res["refund_reason"] = boost::any(*refundReason);
    }
    if (refundReasonType) {
      res["refund_reason_type"] = boost::any(*refundReasonType);
    }
    if (ticketNos) {
      res["ticket_nos"] = boost::any(*ticketNos);
    }
    if (totalRefundPrice) {
      res["total_refund_price"] = boost::any(*totalRefundPrice);
    }
    if (uploadPictUrls) {
      res["upload_pict_urls"] = boost::any(*uploadPictUrls);
    }
    if (voluntary) {
      res["voluntary"] = boost::any(*voluntary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("passenger_segment_relations") != m.end() && !m["passenger_segment_relations"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_segment_relations"].type()) {
        vector<FlightRefundApplyV2RequestPassengerSegmentRelations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_segment_relations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundApplyV2RequestPassengerSegmentRelations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerSegmentRelations = make_shared<vector<FlightRefundApplyV2RequestPassengerSegmentRelations>>(expect1);
      }
    }
    if (m.find("pre_cal_type") != m.end() && !m["pre_cal_type"].empty()) {
      preCalType = make_shared<long>(boost::any_cast<long>(m["pre_cal_type"]));
    }
    if (m.find("refund_reason") != m.end() && !m["refund_reason"].empty()) {
      refundReason = make_shared<string>(boost::any_cast<string>(m["refund_reason"]));
    }
    if (m.find("refund_reason_type") != m.end() && !m["refund_reason_type"].empty()) {
      refundReasonType = make_shared<long>(boost::any_cast<long>(m["refund_reason_type"]));
    }
    if (m.find("ticket_nos") != m.end() && !m["ticket_nos"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ticket_nos"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ticket_nos"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ticketNos = make_shared<vector<string>>(toVec1);
    }
    if (m.find("total_refund_price") != m.end() && !m["total_refund_price"].empty()) {
      totalRefundPrice = make_shared<long>(boost::any_cast<long>(m["total_refund_price"]));
    }
    if (m.find("upload_pict_urls") != m.end() && !m["upload_pict_urls"].empty()) {
      uploadPictUrls = make_shared<string>(boost::any_cast<string>(m["upload_pict_urls"]));
    }
    if (m.find("voluntary") != m.end() && !m["voluntary"].empty()) {
      voluntary = make_shared<bool>(boost::any_cast<bool>(m["voluntary"]));
    }
  }


  virtual ~FlightRefundApplyV2Request() = default;
};
class FlightRefundApplyV2ShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> isvName{};
  shared_ptr<string> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<string> passengerSegmentRelationsShrink{};
  shared_ptr<long> preCalType{};
  shared_ptr<string> refundReason{};
  shared_ptr<long> refundReasonType{};
  shared_ptr<string> ticketNosShrink{};
  shared_ptr<long> totalRefundPrice{};
  shared_ptr<string> uploadPictUrls{};
  shared_ptr<bool> voluntary{};

  FlightRefundApplyV2ShrinkRequest() {}

  explicit FlightRefundApplyV2ShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (passengerSegmentRelationsShrink) {
      res["passenger_segment_relations"] = boost::any(*passengerSegmentRelationsShrink);
    }
    if (preCalType) {
      res["pre_cal_type"] = boost::any(*preCalType);
    }
    if (refundReason) {
      res["refund_reason"] = boost::any(*refundReason);
    }
    if (refundReasonType) {
      res["refund_reason_type"] = boost::any(*refundReasonType);
    }
    if (ticketNosShrink) {
      res["ticket_nos"] = boost::any(*ticketNosShrink);
    }
    if (totalRefundPrice) {
      res["total_refund_price"] = boost::any(*totalRefundPrice);
    }
    if (uploadPictUrls) {
      res["upload_pict_urls"] = boost::any(*uploadPictUrls);
    }
    if (voluntary) {
      res["voluntary"] = boost::any(*voluntary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("passenger_segment_relations") != m.end() && !m["passenger_segment_relations"].empty()) {
      passengerSegmentRelationsShrink = make_shared<string>(boost::any_cast<string>(m["passenger_segment_relations"]));
    }
    if (m.find("pre_cal_type") != m.end() && !m["pre_cal_type"].empty()) {
      preCalType = make_shared<long>(boost::any_cast<long>(m["pre_cal_type"]));
    }
    if (m.find("refund_reason") != m.end() && !m["refund_reason"].empty()) {
      refundReason = make_shared<string>(boost::any_cast<string>(m["refund_reason"]));
    }
    if (m.find("refund_reason_type") != m.end() && !m["refund_reason_type"].empty()) {
      refundReasonType = make_shared<long>(boost::any_cast<long>(m["refund_reason_type"]));
    }
    if (m.find("ticket_nos") != m.end() && !m["ticket_nos"].empty()) {
      ticketNosShrink = make_shared<string>(boost::any_cast<string>(m["ticket_nos"]));
    }
    if (m.find("total_refund_price") != m.end() && !m["total_refund_price"].empty()) {
      totalRefundPrice = make_shared<long>(boost::any_cast<long>(m["total_refund_price"]));
    }
    if (m.find("upload_pict_urls") != m.end() && !m["upload_pict_urls"].empty()) {
      uploadPictUrls = make_shared<string>(boost::any_cast<string>(m["upload_pict_urls"]));
    }
    if (m.find("voluntary") != m.end() && !m["voluntary"].empty()) {
      voluntary = make_shared<bool>(boost::any_cast<bool>(m["voluntary"]));
    }
  }


  virtual ~FlightRefundApplyV2ShrinkRequest() = default;
};
class FlightRefundApplyV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<string> subOrderId{};

  FlightRefundApplyV2ResponseBodyModule() {}

  explicit FlightRefundApplyV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<string>(boost::any_cast<string>(m["sub_order_id"]));
    }
  }


  virtual ~FlightRefundApplyV2ResponseBodyModule() = default;
};
class FlightRefundApplyV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightRefundApplyV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightRefundApplyV2ResponseBody() {}

  explicit FlightRefundApplyV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightRefundApplyV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightRefundApplyV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightRefundApplyV2ResponseBody() = default;
};
class FlightRefundApplyV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightRefundApplyV2ResponseBody> body{};

  FlightRefundApplyV2Response() {}

  explicit FlightRefundApplyV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightRefundApplyV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightRefundApplyV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightRefundApplyV2Response() = default;
};
class FlightRefundDetailHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightRefundDetailHeaders() {}

  explicit FlightRefundDetailHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightRefundDetailHeaders() = default;
};
class FlightRefundDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};

  FlightRefundDetailRequest() {}

  explicit FlightRefundDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
  }


  virtual ~FlightRefundDetailRequest() = default;
};
class FlightRefundDetailResponseBodyModuleRefundFeeList : public Darabonba::Model {
public:
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<long> refundFee{};
  shared_ptr<long> refundPrice{};
  shared_ptr<string> status{};

  FlightRefundDetailResponseBodyModuleRefundFeeList() {}

  explicit FlightRefundDetailResponseBodyModuleRefundFeeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (refundPrice) {
      res["refund_price"] = boost::any(*refundPrice);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["refund_fee"]));
    }
    if (m.find("refund_price") != m.end() && !m["refund_price"].empty()) {
      refundPrice = make_shared<long>(boost::any_cast<long>(m["refund_price"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~FlightRefundDetailResponseBodyModuleRefundFeeList() = default;
};
class FlightRefundDetailResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> btripOrderId{};
  shared_ptr<long> btripSubOrderId{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<string> reason{};
  shared_ptr<long> refundFee{};
  shared_ptr<vector<FlightRefundDetailResponseBodyModuleRefundFeeList>> refundFeeList{};
  shared_ptr<long> refundPrice{};
  shared_ptr<string> status{};

  FlightRefundDetailResponseBodyModule() {}

  explicit FlightRefundDetailResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (btripSubOrderId) {
      res["btrip_sub_order_id"] = boost::any(*btripSubOrderId);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (refundFeeList) {
      vector<boost::any> temp1;
      for(auto item1:*refundFeeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_fee_list"] = boost::any(temp1);
    }
    if (refundPrice) {
      res["refund_price"] = boost::any(*refundPrice);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_order_id"]));
    }
    if (m.find("btrip_sub_order_id") != m.end() && !m["btrip_sub_order_id"].empty()) {
      btripSubOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_sub_order_id"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["refund_fee"]));
    }
    if (m.find("refund_fee_list") != m.end() && !m["refund_fee_list"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_fee_list"].type()) {
        vector<FlightRefundDetailResponseBodyModuleRefundFeeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_fee_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundDetailResponseBodyModuleRefundFeeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundFeeList = make_shared<vector<FlightRefundDetailResponseBodyModuleRefundFeeList>>(expect1);
      }
    }
    if (m.find("refund_price") != m.end() && !m["refund_price"].empty()) {
      refundPrice = make_shared<long>(boost::any_cast<long>(m["refund_price"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~FlightRefundDetailResponseBodyModule() = default;
};
class FlightRefundDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightRefundDetailResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightRefundDetailResponseBody() {}

  explicit FlightRefundDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightRefundDetailResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightRefundDetailResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightRefundDetailResponseBody() = default;
};
class FlightRefundDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightRefundDetailResponseBody> body{};

  FlightRefundDetailResponse() {}

  explicit FlightRefundDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightRefundDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightRefundDetailResponseBody>(model1);
      }
    }
  }


  virtual ~FlightRefundDetailResponse() = default;
};
class FlightRefundDetailV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightRefundDetailV2Headers() {}

  explicit FlightRefundDetailV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightRefundDetailV2Headers() = default;
};
class FlightRefundDetailV2Request : public Darabonba::Model {
public:
  shared_ptr<string> isvName{};
  shared_ptr<string> orderId{};
  shared_ptr<string> refundApplyId{};

  FlightRefundDetailV2Request() {}

  explicit FlightRefundDetailV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (refundApplyId) {
      res["refund_apply_id"] = boost::any(*refundApplyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("refund_apply_id") != m.end() && !m["refund_apply_id"].empty()) {
      refundApplyId = make_shared<string>(boost::any_cast<string>(m["refund_apply_id"]));
    }
  }


  virtual ~FlightRefundDetailV2Request() = default;
};
class FlightRefundDetailV2ResponseBodyModuleContactInfoDTO : public Darabonba::Model {
public:
  shared_ptr<string> contactEmail{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactPhone{};
  shared_ptr<bool> sendMsgToPassenger{};

  FlightRefundDetailV2ResponseBodyModuleContactInfoDTO() {}

  explicit FlightRefundDetailV2ResponseBodyModuleContactInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactEmail) {
      res["contact_email"] = boost::any(*contactEmail);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (contactPhone) {
      res["contact_phone"] = boost::any(*contactPhone);
    }
    if (sendMsgToPassenger) {
      res["send_msg_to_passenger"] = boost::any(*sendMsgToPassenger);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contact_email") != m.end() && !m["contact_email"].empty()) {
      contactEmail = make_shared<string>(boost::any_cast<string>(m["contact_email"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("contact_phone") != m.end() && !m["contact_phone"].empty()) {
      contactPhone = make_shared<string>(boost::any_cast<string>(m["contact_phone"]));
    }
    if (m.find("send_msg_to_passenger") != m.end() && !m["send_msg_to_passenger"].empty()) {
      sendMsgToPassenger = make_shared<bool>(boost::any_cast<bool>(m["send_msg_to_passenger"]));
    }
  }


  virtual ~FlightRefundDetailV2ResponseBodyModuleContactInfoDTO() = default;
};
class FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOSSegmentPosition : public Darabonba::Model {
public:
  shared_ptr<long> journeyIndex{};
  shared_ptr<long> segmentIndex{};

  FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOSSegmentPosition() {}

  explicit FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOSSegmentPosition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (journeyIndex) {
      res["journey_index"] = boost::any(*journeyIndex);
    }
    if (segmentIndex) {
      res["segment_index"] = boost::any(*segmentIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("journey_index") != m.end() && !m["journey_index"].empty()) {
      journeyIndex = make_shared<long>(boost::any_cast<long>(m["journey_index"]));
    }
    if (m.find("segment_index") != m.end() && !m["segment_index"].empty()) {
      segmentIndex = make_shared<long>(boost::any_cast<long>(m["segment_index"]));
    }
  }


  virtual ~FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOSSegmentPosition() = default;
};
class FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOS : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineIconUrl{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrAirportName{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrTerminal{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<long> cabinDiscount{};
  shared_ptr<string> carrierAirlineCode{};
  shared_ptr<string> carrierAirlineIconUrl{};
  shared_ptr<string> carrierAirlineName{};
  shared_ptr<string> carrierFlightNo{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depAirportName{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depTerminal{};
  shared_ptr<string> depTime{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> flightType{};
  shared_ptr<string> mealDesc{};
  shared_ptr<string> segmentId{};
  shared_ptr<FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOSSegmentPosition> segmentPosition{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopDepTime{};

  FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOS() {}

  explicit FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineIconUrl) {
      res["airline_icon_url"] = boost::any(*airlineIconUrl);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrAirportName) {
      res["arr_airport_name"] = boost::any(*arrAirportName);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrTerminal) {
      res["arr_terminal"] = boost::any(*arrTerminal);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabin_class_name"] = boost::any(*cabinClassName);
    }
    if (cabinDiscount) {
      res["cabin_discount"] = boost::any(*cabinDiscount);
    }
    if (carrierAirlineCode) {
      res["carrier_airline_code"] = boost::any(*carrierAirlineCode);
    }
    if (carrierAirlineIconUrl) {
      res["carrier_airline_icon_url"] = boost::any(*carrierAirlineIconUrl);
    }
    if (carrierAirlineName) {
      res["carrier_airline_name"] = boost::any(*carrierAirlineName);
    }
    if (carrierFlightNo) {
      res["carrier_flight_no"] = boost::any(*carrierFlightNo);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depAirportName) {
      res["dep_airport_name"] = boost::any(*depAirportName);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depTerminal) {
      res["dep_terminal"] = boost::any(*depTerminal);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (segmentId) {
      res["segment_id"] = boost::any(*segmentId);
    }
    if (segmentPosition) {
      res["segment_position"] = segmentPosition ? boost::any(segmentPosition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_icon_url") != m.end() && !m["airline_icon_url"].empty()) {
      airlineIconUrl = make_shared<string>(boost::any_cast<string>(m["airline_icon_url"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_airport_name") != m.end() && !m["arr_airport_name"].empty()) {
      arrAirportName = make_shared<string>(boost::any_cast<string>(m["arr_airport_name"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_terminal") != m.end() && !m["arr_terminal"].empty()) {
      arrTerminal = make_shared<string>(boost::any_cast<string>(m["arr_terminal"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_class_name") != m.end() && !m["cabin_class_name"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabin_class_name"]));
    }
    if (m.find("cabin_discount") != m.end() && !m["cabin_discount"].empty()) {
      cabinDiscount = make_shared<long>(boost::any_cast<long>(m["cabin_discount"]));
    }
    if (m.find("carrier_airline_code") != m.end() && !m["carrier_airline_code"].empty()) {
      carrierAirlineCode = make_shared<string>(boost::any_cast<string>(m["carrier_airline_code"]));
    }
    if (m.find("carrier_airline_icon_url") != m.end() && !m["carrier_airline_icon_url"].empty()) {
      carrierAirlineIconUrl = make_shared<string>(boost::any_cast<string>(m["carrier_airline_icon_url"]));
    }
    if (m.find("carrier_airline_name") != m.end() && !m["carrier_airline_name"].empty()) {
      carrierAirlineName = make_shared<string>(boost::any_cast<string>(m["carrier_airline_name"]));
    }
    if (m.find("carrier_flight_no") != m.end() && !m["carrier_flight_no"].empty()) {
      carrierFlightNo = make_shared<string>(boost::any_cast<string>(m["carrier_flight_no"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_airport_name") != m.end() && !m["dep_airport_name"].empty()) {
      depAirportName = make_shared<string>(boost::any_cast<string>(m["dep_airport_name"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_terminal") != m.end() && !m["dep_terminal"].empty()) {
      depTerminal = make_shared<string>(boost::any_cast<string>(m["dep_terminal"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("segment_id") != m.end() && !m["segment_id"].empty()) {
      segmentId = make_shared<string>(boost::any_cast<string>(m["segment_id"]));
    }
    if (m.find("segment_position") != m.end() && !m["segment_position"].empty()) {
      if (typeid(map<string, boost::any>) == m["segment_position"].type()) {
        FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOSSegmentPosition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["segment_position"]));
        segmentPosition = make_shared<FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOSSegmentPosition>(model1);
      }
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
  }


  virtual ~FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOS() = default;
};
class FlightRefundDetailV2ResponseBodyModuleTravelerInfoDTOS : public Darabonba::Model {
public:
  shared_ptr<string> birthDate{};
  shared_ptr<string> certNo{};
  shared_ptr<long> certType{};
  shared_ptr<long> gender{};
  shared_ptr<vector<string>> originTicketNos{};
  shared_ptr<string> passengerId{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> passengerType{};
  shared_ptr<string> phone{};
  shared_ptr<long> pid{};
  shared_ptr<vector<string>> ticketNos{};

  FlightRefundDetailV2ResponseBodyModuleTravelerInfoDTOS() {}

  explicit FlightRefundDetailV2ResponseBodyModuleTravelerInfoDTOS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthDate) {
      res["birth_date"] = boost::any(*birthDate);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (gender) {
      res["gender"] = boost::any(*gender);
    }
    if (originTicketNos) {
      res["origin_ticket_nos"] = boost::any(*originTicketNos);
    }
    if (passengerId) {
      res["passenger_id"] = boost::any(*passengerId);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (pid) {
      res["pid"] = boost::any(*pid);
    }
    if (ticketNos) {
      res["ticket_nos"] = boost::any(*ticketNos);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birth_date") != m.end() && !m["birth_date"].empty()) {
      birthDate = make_shared<string>(boost::any_cast<string>(m["birth_date"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<long>(boost::any_cast<long>(m["cert_type"]));
    }
    if (m.find("gender") != m.end() && !m["gender"].empty()) {
      gender = make_shared<long>(boost::any_cast<long>(m["gender"]));
    }
    if (m.find("origin_ticket_nos") != m.end() && !m["origin_ticket_nos"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["origin_ticket_nos"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["origin_ticket_nos"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      originTicketNos = make_shared<vector<string>>(toVec1);
    }
    if (m.find("passenger_id") != m.end() && !m["passenger_id"].empty()) {
      passengerId = make_shared<string>(boost::any_cast<string>(m["passenger_id"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<long>(boost::any_cast<long>(m["passenger_type"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("pid") != m.end() && !m["pid"].empty()) {
      pid = make_shared<long>(boost::any_cast<long>(m["pid"]));
    }
    if (m.find("ticket_nos") != m.end() && !m["ticket_nos"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ticket_nos"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ticket_nos"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ticketNos = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~FlightRefundDetailV2ResponseBodyModuleTravelerInfoDTOS() = default;
};
class FlightRefundDetailV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> applyTime{};
  shared_ptr<FlightRefundDetailV2ResponseBodyModuleContactInfoDTO> contactInfoDTO{};
  shared_ptr<vector<FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOS>> flightInfoDTOS{};
  shared_ptr<long> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<string> reason{};
  shared_ptr<string> reasonCode{};
  shared_ptr<string> refundFailReason{};
  shared_ptr<long> refundHandlingFee{};
  shared_ptr<long> refundMoney{};
  shared_ptr<long> status{};
  shared_ptr<long> subOrderId{};
  shared_ptr<vector<FlightRefundDetailV2ResponseBodyModuleTravelerInfoDTOS>> travelerInfoDTOS{};

  FlightRefundDetailV2ResponseBodyModule() {}

  explicit FlightRefundDetailV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyTime) {
      res["apply_time"] = boost::any(*applyTime);
    }
    if (contactInfoDTO) {
      res["contact_info_d_t_o"] = contactInfoDTO ? boost::any(contactInfoDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightInfoDTOS) {
      vector<boost::any> temp1;
      for(auto item1:*flightInfoDTOS){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_info_d_t_o_s"] = boost::any(temp1);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (reasonCode) {
      res["reason_code"] = boost::any(*reasonCode);
    }
    if (refundFailReason) {
      res["refund_fail_reason"] = boost::any(*refundFailReason);
    }
    if (refundHandlingFee) {
      res["refund_handling_fee"] = boost::any(*refundHandlingFee);
    }
    if (refundMoney) {
      res["refund_money"] = boost::any(*refundMoney);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    if (travelerInfoDTOS) {
      vector<boost::any> temp1;
      for(auto item1:*travelerInfoDTOS){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_info_d_t_o_s"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_time") != m.end() && !m["apply_time"].empty()) {
      applyTime = make_shared<string>(boost::any_cast<string>(m["apply_time"]));
    }
    if (m.find("contact_info_d_t_o") != m.end() && !m["contact_info_d_t_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["contact_info_d_t_o"].type()) {
        FlightRefundDetailV2ResponseBodyModuleContactInfoDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["contact_info_d_t_o"]));
        contactInfoDTO = make_shared<FlightRefundDetailV2ResponseBodyModuleContactInfoDTO>(model1);
      }
    }
    if (m.find("flight_info_d_t_o_s") != m.end() && !m["flight_info_d_t_o_s"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_info_d_t_o_s"].type()) {
        vector<FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOS> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_info_d_t_o_s"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOS model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightInfoDTOS = make_shared<vector<FlightRefundDetailV2ResponseBodyModuleFlightInfoDTOS>>(expect1);
      }
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("reason_code") != m.end() && !m["reason_code"].empty()) {
      reasonCode = make_shared<string>(boost::any_cast<string>(m["reason_code"]));
    }
    if (m.find("refund_fail_reason") != m.end() && !m["refund_fail_reason"].empty()) {
      refundFailReason = make_shared<string>(boost::any_cast<string>(m["refund_fail_reason"]));
    }
    if (m.find("refund_handling_fee") != m.end() && !m["refund_handling_fee"].empty()) {
      refundHandlingFee = make_shared<long>(boost::any_cast<long>(m["refund_handling_fee"]));
    }
    if (m.find("refund_money") != m.end() && !m["refund_money"].empty()) {
      refundMoney = make_shared<long>(boost::any_cast<long>(m["refund_money"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<long>(boost::any_cast<long>(m["sub_order_id"]));
    }
    if (m.find("traveler_info_d_t_o_s") != m.end() && !m["traveler_info_d_t_o_s"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_info_d_t_o_s"].type()) {
        vector<FlightRefundDetailV2ResponseBodyModuleTravelerInfoDTOS> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_info_d_t_o_s"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundDetailV2ResponseBodyModuleTravelerInfoDTOS model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerInfoDTOS = make_shared<vector<FlightRefundDetailV2ResponseBodyModuleTravelerInfoDTOS>>(expect1);
      }
    }
  }


  virtual ~FlightRefundDetailV2ResponseBodyModule() = default;
};
class FlightRefundDetailV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightRefundDetailV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightRefundDetailV2ResponseBody() {}

  explicit FlightRefundDetailV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightRefundDetailV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightRefundDetailV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightRefundDetailV2ResponseBody() = default;
};
class FlightRefundDetailV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightRefundDetailV2ResponseBody> body{};

  FlightRefundDetailV2Response() {}

  explicit FlightRefundDetailV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightRefundDetailV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightRefundDetailV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightRefundDetailV2Response() = default;
};
class FlightRefundPreCalHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightRefundPreCalHeaders() {}

  explicit FlightRefundPreCalHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightRefundPreCalHeaders() = default;
};
class FlightRefundPreCalRequestPassengerSegmentInfoList : public Darabonba::Model {
public:
  shared_ptr<string> flightNo{};
  shared_ptr<string> passengerName{};
  shared_ptr<string> userId{};

  FlightRefundPreCalRequestPassengerSegmentInfoList() {}

  explicit FlightRefundPreCalRequestPassengerSegmentInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightRefundPreCalRequestPassengerSegmentInfoList() = default;
};
class FlightRefundPreCalRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> isVoluntary{};
  shared_ptr<vector<FlightRefundPreCalRequestPassengerSegmentInfoList>> passengerSegmentInfoList{};

  FlightRefundPreCalRequest() {}

  explicit FlightRefundPreCalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (passengerSegmentInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerSegmentInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_segment_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<string>(boost::any_cast<string>(m["is_voluntary"]));
    }
    if (m.find("passenger_segment_info_list") != m.end() && !m["passenger_segment_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_segment_info_list"].type()) {
        vector<FlightRefundPreCalRequestPassengerSegmentInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_segment_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundPreCalRequestPassengerSegmentInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerSegmentInfoList = make_shared<vector<FlightRefundPreCalRequestPassengerSegmentInfoList>>(expect1);
      }
    }
  }


  virtual ~FlightRefundPreCalRequest() = default;
};
class FlightRefundPreCalShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> isVoluntary{};
  shared_ptr<string> passengerSegmentInfoListShrink{};

  FlightRefundPreCalShrinkRequest() {}

  explicit FlightRefundPreCalShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (passengerSegmentInfoListShrink) {
      res["passenger_segment_info_list"] = boost::any(*passengerSegmentInfoListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<string>(boost::any_cast<string>(m["is_voluntary"]));
    }
    if (m.find("passenger_segment_info_list") != m.end() && !m["passenger_segment_info_list"].empty()) {
      passengerSegmentInfoListShrink = make_shared<string>(boost::any_cast<string>(m["passenger_segment_info_list"]));
    }
  }


  virtual ~FlightRefundPreCalShrinkRequest() = default;
};
class FlightRefundPreCalResponseBodyModuleMultiRefundCalList : public Darabonba::Model {
public:
  shared_ptr<bool> canApplyRefund{};
  shared_ptr<string> name{};
  shared_ptr<long> preRefundMoney{};
  shared_ptr<long> refundFee{};
  shared_ptr<string> userId{};

  FlightRefundPreCalResponseBodyModuleMultiRefundCalList() {}

  explicit FlightRefundPreCalResponseBodyModuleMultiRefundCalList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canApplyRefund) {
      res["can_apply_refund"] = boost::any(*canApplyRefund);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (preRefundMoney) {
      res["pre_refund_money"] = boost::any(*preRefundMoney);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("can_apply_refund") != m.end() && !m["can_apply_refund"].empty()) {
      canApplyRefund = make_shared<bool>(boost::any_cast<bool>(m["can_apply_refund"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("pre_refund_money") != m.end() && !m["pre_refund_money"].empty()) {
      preRefundMoney = make_shared<long>(boost::any_cast<long>(m["pre_refund_money"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["refund_fee"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~FlightRefundPreCalResponseBodyModuleMultiRefundCalList() = default;
};
class FlightRefundPreCalResponseBodyModuleReturnReason : public Darabonba::Model {
public:
  shared_ptr<string> extendDesc{};
  shared_ptr<long> person{};
  shared_ptr<long> reasonCode{};
  shared_ptr<string> reasonShow{};
  shared_ptr<long> reasonType{};
  shared_ptr<long> volunteer{};

  FlightRefundPreCalResponseBodyModuleReturnReason() {}

  explicit FlightRefundPreCalResponseBodyModuleReturnReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extendDesc) {
      res["extend_desc"] = boost::any(*extendDesc);
    }
    if (person) {
      res["person"] = boost::any(*person);
    }
    if (reasonCode) {
      res["reason_code"] = boost::any(*reasonCode);
    }
    if (reasonShow) {
      res["reason_show"] = boost::any(*reasonShow);
    }
    if (reasonType) {
      res["reason_type"] = boost::any(*reasonType);
    }
    if (volunteer) {
      res["volunteer"] = boost::any(*volunteer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extend_desc") != m.end() && !m["extend_desc"].empty()) {
      extendDesc = make_shared<string>(boost::any_cast<string>(m["extend_desc"]));
    }
    if (m.find("person") != m.end() && !m["person"].empty()) {
      person = make_shared<long>(boost::any_cast<long>(m["person"]));
    }
    if (m.find("reason_code") != m.end() && !m["reason_code"].empty()) {
      reasonCode = make_shared<long>(boost::any_cast<long>(m["reason_code"]));
    }
    if (m.find("reason_show") != m.end() && !m["reason_show"].empty()) {
      reasonShow = make_shared<string>(boost::any_cast<string>(m["reason_show"]));
    }
    if (m.find("reason_type") != m.end() && !m["reason_type"].empty()) {
      reasonType = make_shared<long>(boost::any_cast<long>(m["reason_type"]));
    }
    if (m.find("volunteer") != m.end() && !m["volunteer"].empty()) {
      volunteer = make_shared<long>(boost::any_cast<long>(m["volunteer"]));
    }
  }


  virtual ~FlightRefundPreCalResponseBodyModuleReturnReason() = default;
};
class FlightRefundPreCalResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<bool> flightChange{};
  shared_ptr<string> itemUnitId{};
  shared_ptr<vector<FlightRefundPreCalResponseBodyModuleMultiRefundCalList>> multiRefundCalList{};
  shared_ptr<long> preRefundMoney{};
  shared_ptr<long> refundFee{};
  shared_ptr<vector<FlightRefundPreCalResponseBodyModuleReturnReason>> returnReason{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> tips{};

  FlightRefundPreCalResponseBodyModule() {}

  explicit FlightRefundPreCalResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightChange) {
      res["flight_change"] = boost::any(*flightChange);
    }
    if (itemUnitId) {
      res["item_unit_id"] = boost::any(*itemUnitId);
    }
    if (multiRefundCalList) {
      vector<boost::any> temp1;
      for(auto item1:*multiRefundCalList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["multi_refund_cal_list"] = boost::any(temp1);
    }
    if (preRefundMoney) {
      res["pre_refund_money"] = boost::any(*preRefundMoney);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (returnReason) {
      vector<boost::any> temp1;
      for(auto item1:*returnReason){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["return_reason"] = boost::any(temp1);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (tips) {
      res["tips"] = boost::any(*tips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_change") != m.end() && !m["flight_change"].empty()) {
      flightChange = make_shared<bool>(boost::any_cast<bool>(m["flight_change"]));
    }
    if (m.find("item_unit_id") != m.end() && !m["item_unit_id"].empty()) {
      itemUnitId = make_shared<string>(boost::any_cast<string>(m["item_unit_id"]));
    }
    if (m.find("multi_refund_cal_list") != m.end() && !m["multi_refund_cal_list"].empty()) {
      if (typeid(vector<boost::any>) == m["multi_refund_cal_list"].type()) {
        vector<FlightRefundPreCalResponseBodyModuleMultiRefundCalList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["multi_refund_cal_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundPreCalResponseBodyModuleMultiRefundCalList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multiRefundCalList = make_shared<vector<FlightRefundPreCalResponseBodyModuleMultiRefundCalList>>(expect1);
      }
    }
    if (m.find("pre_refund_money") != m.end() && !m["pre_refund_money"].empty()) {
      preRefundMoney = make_shared<long>(boost::any_cast<long>(m["pre_refund_money"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["refund_fee"]));
    }
    if (m.find("return_reason") != m.end() && !m["return_reason"].empty()) {
      if (typeid(vector<boost::any>) == m["return_reason"].type()) {
        vector<FlightRefundPreCalResponseBodyModuleReturnReason> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["return_reason"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundPreCalResponseBodyModuleReturnReason model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        returnReason = make_shared<vector<FlightRefundPreCalResponseBodyModuleReturnReason>>(expect1);
      }
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      tips = make_shared<string>(boost::any_cast<string>(m["tips"]));
    }
  }


  virtual ~FlightRefundPreCalResponseBodyModule() = default;
};
class FlightRefundPreCalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightRefundPreCalResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightRefundPreCalResponseBody() {}

  explicit FlightRefundPreCalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightRefundPreCalResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightRefundPreCalResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightRefundPreCalResponseBody() = default;
};
class FlightRefundPreCalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightRefundPreCalResponseBody> body{};

  FlightRefundPreCalResponse() {}

  explicit FlightRefundPreCalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightRefundPreCalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightRefundPreCalResponseBody>(model1);
      }
    }
  }


  virtual ~FlightRefundPreCalResponse() = default;
};
class FlightRefundPreCalV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightRefundPreCalV2Headers() {}

  explicit FlightRefundPreCalV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightRefundPreCalV2Headers() = default;
};
class FlightRefundPreCalV2RequestPassengerSegmentRelations : public Darabonba::Model {
public:
  shared_ptr<string> passengerId{};
  shared_ptr<vector<string>> segmentIdList{};

  FlightRefundPreCalV2RequestPassengerSegmentRelations() {}

  explicit FlightRefundPreCalV2RequestPassengerSegmentRelations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passengerId) {
      res["passenger_id"] = boost::any(*passengerId);
    }
    if (segmentIdList) {
      res["segment_id_list"] = boost::any(*segmentIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("passenger_id") != m.end() && !m["passenger_id"].empty()) {
      passengerId = make_shared<string>(boost::any_cast<string>(m["passenger_id"]));
    }
    if (m.find("segment_id_list") != m.end() && !m["segment_id_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["segment_id_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["segment_id_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      segmentIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~FlightRefundPreCalV2RequestPassengerSegmentRelations() = default;
};
class FlightRefundPreCalV2Request : public Darabonba::Model {
public:
  shared_ptr<string> isvName{};
  shared_ptr<string> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<vector<FlightRefundPreCalV2RequestPassengerSegmentRelations>> passengerSegmentRelations{};
  shared_ptr<long> preCalType{};
  shared_ptr<vector<string>> ticketNos{};
  shared_ptr<bool> voluntary{};

  FlightRefundPreCalV2Request() {}

  explicit FlightRefundPreCalV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (passengerSegmentRelations) {
      vector<boost::any> temp1;
      for(auto item1:*passengerSegmentRelations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_segment_relations"] = boost::any(temp1);
    }
    if (preCalType) {
      res["pre_cal_type"] = boost::any(*preCalType);
    }
    if (ticketNos) {
      res["ticket_nos"] = boost::any(*ticketNos);
    }
    if (voluntary) {
      res["voluntary"] = boost::any(*voluntary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("passenger_segment_relations") != m.end() && !m["passenger_segment_relations"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_segment_relations"].type()) {
        vector<FlightRefundPreCalV2RequestPassengerSegmentRelations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_segment_relations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundPreCalV2RequestPassengerSegmentRelations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerSegmentRelations = make_shared<vector<FlightRefundPreCalV2RequestPassengerSegmentRelations>>(expect1);
      }
    }
    if (m.find("pre_cal_type") != m.end() && !m["pre_cal_type"].empty()) {
      preCalType = make_shared<long>(boost::any_cast<long>(m["pre_cal_type"]));
    }
    if (m.find("ticket_nos") != m.end() && !m["ticket_nos"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ticket_nos"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ticket_nos"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ticketNos = make_shared<vector<string>>(toVec1);
    }
    if (m.find("voluntary") != m.end() && !m["voluntary"].empty()) {
      voluntary = make_shared<bool>(boost::any_cast<bool>(m["voluntary"]));
    }
  }


  virtual ~FlightRefundPreCalV2Request() = default;
};
class FlightRefundPreCalV2ShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> isvName{};
  shared_ptr<string> orderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> passengerSegmentRelationsShrink{};
  shared_ptr<long> preCalType{};
  shared_ptr<string> ticketNosShrink{};
  shared_ptr<bool> voluntary{};

  FlightRefundPreCalV2ShrinkRequest() {}

  explicit FlightRefundPreCalV2ShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (passengerSegmentRelationsShrink) {
      res["passenger_segment_relations"] = boost::any(*passengerSegmentRelationsShrink);
    }
    if (preCalType) {
      res["pre_cal_type"] = boost::any(*preCalType);
    }
    if (ticketNosShrink) {
      res["ticket_nos"] = boost::any(*ticketNosShrink);
    }
    if (voluntary) {
      res["voluntary"] = boost::any(*voluntary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("passenger_segment_relations") != m.end() && !m["passenger_segment_relations"].empty()) {
      passengerSegmentRelationsShrink = make_shared<string>(boost::any_cast<string>(m["passenger_segment_relations"]));
    }
    if (m.find("pre_cal_type") != m.end() && !m["pre_cal_type"].empty()) {
      preCalType = make_shared<long>(boost::any_cast<long>(m["pre_cal_type"]));
    }
    if (m.find("ticket_nos") != m.end() && !m["ticket_nos"].empty()) {
      ticketNosShrink = make_shared<string>(boost::any_cast<string>(m["ticket_nos"]));
    }
    if (m.find("voluntary") != m.end() && !m["voluntary"].empty()) {
      voluntary = make_shared<bool>(boost::any_cast<bool>(m["voluntary"]));
    }
  }


  virtual ~FlightRefundPreCalV2ShrinkRequest() = default;
};
class FlightRefundPreCalV2ResponseBodyModuleMultiRefundFeeDTOS : public Darabonba::Model {
public:
  shared_ptr<string> passengerId{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> preRefundMoney{};
  shared_ptr<long> refundChargeFee{};

  FlightRefundPreCalV2ResponseBodyModuleMultiRefundFeeDTOS() {}

  explicit FlightRefundPreCalV2ResponseBodyModuleMultiRefundFeeDTOS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passengerId) {
      res["passenger_id"] = boost::any(*passengerId);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (preRefundMoney) {
      res["pre_refund_money"] = boost::any(*preRefundMoney);
    }
    if (refundChargeFee) {
      res["refund_charge_fee"] = boost::any(*refundChargeFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("passenger_id") != m.end() && !m["passenger_id"].empty()) {
      passengerId = make_shared<string>(boost::any_cast<string>(m["passenger_id"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pre_refund_money") != m.end() && !m["pre_refund_money"].empty()) {
      preRefundMoney = make_shared<long>(boost::any_cast<long>(m["pre_refund_money"]));
    }
    if (m.find("refund_charge_fee") != m.end() && !m["refund_charge_fee"].empty()) {
      refundChargeFee = make_shared<long>(boost::any_cast<long>(m["refund_charge_fee"]));
    }
  }


  virtual ~FlightRefundPreCalV2ResponseBodyModuleMultiRefundFeeDTOS() = default;
};
class FlightRefundPreCalV2ResponseBodyModuleRefundReasonOptionDTOS : public Darabonba::Model {
public:
  shared_ptr<string> reason{};
  shared_ptr<long> reasonType{};
  shared_ptr<bool> volunteer{};

  FlightRefundPreCalV2ResponseBodyModuleRefundReasonOptionDTOS() {}

  explicit FlightRefundPreCalV2ResponseBodyModuleRefundReasonOptionDTOS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (reasonType) {
      res["reason_type"] = boost::any(*reasonType);
    }
    if (volunteer) {
      res["volunteer"] = boost::any(*volunteer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("reason_type") != m.end() && !m["reason_type"].empty()) {
      reasonType = make_shared<long>(boost::any_cast<long>(m["reason_type"]));
    }
    if (m.find("volunteer") != m.end() && !m["volunteer"].empty()) {
      volunteer = make_shared<bool>(boost::any_cast<bool>(m["volunteer"]));
    }
  }


  virtual ~FlightRefundPreCalV2ResponseBodyModuleRefundReasonOptionDTOS() = default;
};
class FlightRefundPreCalV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightRefundPreCalV2ResponseBodyModuleMultiRefundFeeDTOS>> multiRefundFeeDTOS{};
  shared_ptr<long> preRefundMoney{};
  shared_ptr<long> refundChargeFee{};
  shared_ptr<vector<FlightRefundPreCalV2ResponseBodyModuleRefundReasonOptionDTOS>> refundReasonOptionDTOS{};
  shared_ptr<long> serviceChargeFee{};

  FlightRefundPreCalV2ResponseBodyModule() {}

  explicit FlightRefundPreCalV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (multiRefundFeeDTOS) {
      vector<boost::any> temp1;
      for(auto item1:*multiRefundFeeDTOS){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["multi_refund_fee_d_t_o_s"] = boost::any(temp1);
    }
    if (preRefundMoney) {
      res["pre_refund_money"] = boost::any(*preRefundMoney);
    }
    if (refundChargeFee) {
      res["refund_charge_fee"] = boost::any(*refundChargeFee);
    }
    if (refundReasonOptionDTOS) {
      vector<boost::any> temp1;
      for(auto item1:*refundReasonOptionDTOS){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_reason_option_d_t_o_s"] = boost::any(temp1);
    }
    if (serviceChargeFee) {
      res["service_charge_fee"] = boost::any(*serviceChargeFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("multi_refund_fee_d_t_o_s") != m.end() && !m["multi_refund_fee_d_t_o_s"].empty()) {
      if (typeid(vector<boost::any>) == m["multi_refund_fee_d_t_o_s"].type()) {
        vector<FlightRefundPreCalV2ResponseBodyModuleMultiRefundFeeDTOS> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["multi_refund_fee_d_t_o_s"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundPreCalV2ResponseBodyModuleMultiRefundFeeDTOS model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multiRefundFeeDTOS = make_shared<vector<FlightRefundPreCalV2ResponseBodyModuleMultiRefundFeeDTOS>>(expect1);
      }
    }
    if (m.find("pre_refund_money") != m.end() && !m["pre_refund_money"].empty()) {
      preRefundMoney = make_shared<long>(boost::any_cast<long>(m["pre_refund_money"]));
    }
    if (m.find("refund_charge_fee") != m.end() && !m["refund_charge_fee"].empty()) {
      refundChargeFee = make_shared<long>(boost::any_cast<long>(m["refund_charge_fee"]));
    }
    if (m.find("refund_reason_option_d_t_o_s") != m.end() && !m["refund_reason_option_d_t_o_s"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_reason_option_d_t_o_s"].type()) {
        vector<FlightRefundPreCalV2ResponseBodyModuleRefundReasonOptionDTOS> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_reason_option_d_t_o_s"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightRefundPreCalV2ResponseBodyModuleRefundReasonOptionDTOS model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundReasonOptionDTOS = make_shared<vector<FlightRefundPreCalV2ResponseBodyModuleRefundReasonOptionDTOS>>(expect1);
      }
    }
    if (m.find("service_charge_fee") != m.end() && !m["service_charge_fee"].empty()) {
      serviceChargeFee = make_shared<long>(boost::any_cast<long>(m["service_charge_fee"]));
    }
  }


  virtual ~FlightRefundPreCalV2ResponseBodyModule() = default;
};
class FlightRefundPreCalV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightRefundPreCalV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightRefundPreCalV2ResponseBody() {}

  explicit FlightRefundPreCalV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightRefundPreCalV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightRefundPreCalV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightRefundPreCalV2ResponseBody() = default;
};
class FlightRefundPreCalV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightRefundPreCalV2ResponseBody> body{};

  FlightRefundPreCalV2Response() {}

  explicit FlightRefundPreCalV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightRefundPreCalV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightRefundPreCalV2ResponseBody>(model1);
      }
    }
  }


  virtual ~FlightRefundPreCalV2Response() = default;
};
class FlightSearchListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  FlightSearchListHeaders() {}

  explicit FlightSearchListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~FlightSearchListHeaders() = default;
};
class FlightSearchListRequest : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depDate{};
  shared_ptr<string> flightNo{};
  shared_ptr<bool> needMultiClassPrice{};
  shared_ptr<string> transferCityCode{};
  shared_ptr<string> transferFlightNo{};
  shared_ptr<string> transferLeaveDate{};
  shared_ptr<string> tripType{};

  FlightSearchListRequest() {}

  explicit FlightSearchListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (needMultiClassPrice) {
      res["need_multi_class_price"] = boost::any(*needMultiClassPrice);
    }
    if (transferCityCode) {
      res["transfer_city_code"] = boost::any(*transferCityCode);
    }
    if (transferFlightNo) {
      res["transfer_flight_no"] = boost::any(*transferFlightNo);
    }
    if (transferLeaveDate) {
      res["transfer_leave_date"] = boost::any(*transferLeaveDate);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("need_multi_class_price") != m.end() && !m["need_multi_class_price"].empty()) {
      needMultiClassPrice = make_shared<bool>(boost::any_cast<bool>(m["need_multi_class_price"]));
    }
    if (m.find("transfer_city_code") != m.end() && !m["transfer_city_code"].empty()) {
      transferCityCode = make_shared<string>(boost::any_cast<string>(m["transfer_city_code"]));
    }
    if (m.find("transfer_flight_no") != m.end() && !m["transfer_flight_no"].empty()) {
      transferFlightNo = make_shared<string>(boost::any_cast<string>(m["transfer_flight_no"]));
    }
    if (m.find("transfer_leave_date") != m.end() && !m["transfer_leave_date"].empty()) {
      transferLeaveDate = make_shared<string>(boost::any_cast<string>(m["transfer_leave_date"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<string>(boost::any_cast<string>(m["trip_type"]));
    }
  }


  virtual ~FlightSearchListRequest() = default;
};
class FlightSearchListResponseBodyModuleFlightListAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};

  FlightSearchListResponseBodyModuleFlightListAirlineInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListAirlineInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightSearchListResponseBodyModuleFlightListArrAirportInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListArrAirportInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["image_d_o"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("image_d_o") != m.end() && !m["image_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["image_d_o"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["image_d_o"]));
        imageDO = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<boost::any>> extraContentVisualizes{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (extraContentVisualizes) {
      res["extra_content_visualizes"] = boost::any(*extraContentVisualizes);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("extra_content_visualizes") != m.end() && !m["extra_content_visualizes"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["extra_content_visualizes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extra_content_visualizes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      extraContentVisualizes = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItemTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList : public Darabonba::Model {
public:
  shared_ptr<string> baggageInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem> baggageItem{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule> changeRule{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem> changeRuleItem{};
  shared_ptr<string> extra{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule> refundRule{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem> refundRuleItem{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule> signRule{};
  shared_ptr<string> tuigaiqianInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule> upgradeRule{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageInfo) {
      res["baggage_info"] = boost::any(*baggageInfo);
    }
    if (baggageItem) {
      res["baggage_item"] = baggageItem ? boost::any(baggageItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRule) {
      res["change_rule"] = changeRule ? boost::any(changeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRuleItem) {
      res["change_rule_item"] = changeRuleItem ? boost::any(changeRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (refundRule) {
      res["refund_rule"] = refundRule ? boost::any(refundRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundRuleItem) {
      res["refund_rule_item"] = refundRuleItem ? boost::any(refundRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signRule) {
      res["sign_rule"] = signRule ? boost::any(signRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    if (upgradeRule) {
      res["upgrade_rule"] = upgradeRule ? boost::any(upgradeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_info") != m.end() && !m["baggage_info"].empty()) {
      baggageInfo = make_shared<string>(boost::any_cast<string>(m["baggage_info"]));
    }
    if (m.find("baggage_item") != m.end() && !m["baggage_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["baggage_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["baggage_item"]));
        baggageItem = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListBaggageItem>(model1);
      }
    }
    if (m.find("change_rule") != m.end() && !m["change_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule"]));
        changeRule = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRule>(model1);
      }
    }
    if (m.find("change_rule_item") != m.end() && !m["change_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule_item"]));
        changeRuleItem = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListChangeRuleItem>(model1);
      }
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("refund_rule") != m.end() && !m["refund_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule"]));
        refundRule = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRule>(model1);
      }
    }
    if (m.find("refund_rule_item") != m.end() && !m["refund_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule_item"]));
        refundRuleItem = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListRefundRuleItem>(model1);
      }
    }
    if (m.find("sign_rule") != m.end() && !m["sign_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["sign_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sign_rule"]));
        signRule = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListSignRule>(model1);
      }
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
    if (m.find("upgrade_rule") != m.end() && !m["upgrade_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_rule"]));
        upgradeRule = make_shared<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleListUpgradeRule>(model1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList() = default;
};
class FlightSearchListResponseBodyModuleFlightListCabinInfoList : public Darabonba::Model {
public:
  shared_ptr<long> agentId{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinClassName{};
  shared_ptr<string> childCabin{};
  shared_ptr<string> className{};
  shared_ptr<string> classRule{};
  shared_ptr<string> discount{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList>> flightRuleList{};
  shared_ptr<string> flightRuleListStr{};
  shared_ptr<long> invoiceType{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<string> memo{};
  shared_ptr<long> oilPrice{};
  shared_ptr<string> orderParams{};
  shared_ptr<string> otaItemId{};
  shared_ptr<long> price{};
  shared_ptr<long> productType{};
  shared_ptr<string> productTypeDesc{};
  shared_ptr<string> promotionPrice{};
  shared_ptr<string> remainedSeatCount{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> totalPrice{};

  FlightSearchListResponseBodyModuleFlightListCabinInfoList() {}

  explicit FlightSearchListResponseBodyModuleFlightListCabinInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["agent_id"] = boost::any(*agentId);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinClassName) {
      res["cabin_class_name"] = boost::any(*cabinClassName);
    }
    if (childCabin) {
      res["child_cabin"] = boost::any(*childCabin);
    }
    if (className) {
      res["class_name"] = boost::any(*className);
    }
    if (classRule) {
      res["class_rule"] = boost::any(*classRule);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*flightRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_rule_list"] = boost::any(temp1);
    }
    if (flightRuleListStr) {
      res["flight_rule_list_str"] = boost::any(*flightRuleListStr);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (orderParams) {
      res["order_params"] = boost::any(*orderParams);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (productType) {
      res["product_type"] = boost::any(*productType);
    }
    if (productTypeDesc) {
      res["product_type_desc"] = boost::any(*productTypeDesc);
    }
    if (promotionPrice) {
      res["promotion_price"] = boost::any(*promotionPrice);
    }
    if (remainedSeatCount) {
      res["remained_seat_count"] = boost::any(*remainedSeatCount);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("agent_id") != m.end() && !m["agent_id"].empty()) {
      agentId = make_shared<long>(boost::any_cast<long>(m["agent_id"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_class_name") != m.end() && !m["cabin_class_name"].empty()) {
      cabinClassName = make_shared<string>(boost::any_cast<string>(m["cabin_class_name"]));
    }
    if (m.find("child_cabin") != m.end() && !m["child_cabin"].empty()) {
      childCabin = make_shared<string>(boost::any_cast<string>(m["child_cabin"]));
    }
    if (m.find("class_name") != m.end() && !m["class_name"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["class_name"]));
    }
    if (m.find("class_rule") != m.end() && !m["class_rule"].empty()) {
      classRule = make_shared<string>(boost::any_cast<string>(m["class_rule"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("flight_rule_list") != m.end() && !m["flight_rule_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_rule_list"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_rule_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightRuleList = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoListFlightRuleList>>(expect1);
      }
    }
    if (m.find("flight_rule_list_str") != m.end() && !m["flight_rule_list_str"].empty()) {
      flightRuleListStr = make_shared<string>(boost::any_cast<string>(m["flight_rule_list_str"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("order_params") != m.end() && !m["order_params"].empty()) {
      orderParams = make_shared<string>(boost::any_cast<string>(m["order_params"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("product_type") != m.end() && !m["product_type"].empty()) {
      productType = make_shared<long>(boost::any_cast<long>(m["product_type"]));
    }
    if (m.find("product_type_desc") != m.end() && !m["product_type_desc"].empty()) {
      productTypeDesc = make_shared<string>(boost::any_cast<string>(m["product_type_desc"]));
    }
    if (m.find("promotion_price") != m.end() && !m["promotion_price"].empty()) {
      promotionPrice = make_shared<string>(boost::any_cast<string>(m["promotion_price"]));
    }
    if (m.find("remained_seat_count") != m.end() && !m["remained_seat_count"].empty()) {
      remainedSeatCount = make_shared<string>(boost::any_cast<string>(m["remained_seat_count"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<long>(boost::any_cast<long>(m["total_price"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListCabinInfoList() = default;
};
class FlightSearchListResponseBodyModuleFlightListDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightSearchListResponseBodyModuleFlightListDepAirportInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListDepAirportInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["image_d_o"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("image_d_o") != m.end() && !m["image_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["image_d_o"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["image_d_o"]));
        imageDO = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<boost::any>> extraContentVisualizes{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (extraContentVisualizes) {
      res["extra_content_visualizes"] = boost::any(*extraContentVisualizes);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("extra_content_visualizes") != m.end() && !m["extra_content_visualizes"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["extra_content_visualizes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extra_content_visualizes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      extraContentVisualizes = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemTips() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemTips() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItemTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListFlightRuleList : public Darabonba::Model {
public:
  shared_ptr<string> baggageInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItem> baggageItem{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRule> changeRule{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItem> changeRuleItem{};
  shared_ptr<string> extra{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRule> refundRule{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItem> refundRuleItem{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRule> signRule{};
  shared_ptr<string> tuigaiqianInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRule> upgradeRule{};

  FlightSearchListResponseBodyModuleFlightListFlightRuleList() {}

  explicit FlightSearchListResponseBodyModuleFlightListFlightRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageInfo) {
      res["baggage_info"] = boost::any(*baggageInfo);
    }
    if (baggageItem) {
      res["baggage_item"] = baggageItem ? boost::any(baggageItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRule) {
      res["change_rule"] = changeRule ? boost::any(changeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRuleItem) {
      res["change_rule_item"] = changeRuleItem ? boost::any(changeRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (refundRule) {
      res["refund_rule"] = refundRule ? boost::any(refundRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundRuleItem) {
      res["refund_rule_item"] = refundRuleItem ? boost::any(refundRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signRule) {
      res["sign_rule"] = signRule ? boost::any(signRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    if (upgradeRule) {
      res["upgrade_rule"] = upgradeRule ? boost::any(upgradeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_info") != m.end() && !m["baggage_info"].empty()) {
      baggageInfo = make_shared<string>(boost::any_cast<string>(m["baggage_info"]));
    }
    if (m.find("baggage_item") != m.end() && !m["baggage_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["baggage_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["baggage_item"]));
        baggageItem = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListBaggageItem>(model1);
      }
    }
    if (m.find("change_rule") != m.end() && !m["change_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule"]));
        changeRule = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRule>(model1);
      }
    }
    if (m.find("change_rule_item") != m.end() && !m["change_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule_item"]));
        changeRuleItem = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListChangeRuleItem>(model1);
      }
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("refund_rule") != m.end() && !m["refund_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule"]));
        refundRule = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRule>(model1);
      }
    }
    if (m.find("refund_rule_item") != m.end() && !m["refund_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule_item"]));
        refundRuleItem = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListRefundRuleItem>(model1);
      }
    }
    if (m.find("sign_rule") != m.end() && !m["sign_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["sign_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sign_rule"]));
        signRule = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListSignRule>(model1);
      }
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
    if (m.find("upgrade_rule") != m.end() && !m["upgrade_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_rule"]));
        upgradeRule = make_shared<FlightSearchListResponseBodyModuleFlightListFlightRuleListUpgradeRule>(model1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListFlightRuleList() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferAirlineInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferAirlineInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferArrAirportInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferArrAirportInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferDepAirportInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferDepAirportInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["image_d_o"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("image_d_o") != m.end() && !m["image_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["image_d_o"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["image_d_o"]));
        imageDO = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<boost::any>> extraContentVisualizes{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (extraContentVisualizes) {
      res["extra_content_visualizes"] = boost::any(*extraContentVisualizes);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("extra_content_visualizes") != m.end() && !m["extra_content_visualizes"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["extra_content_visualizes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extra_content_visualizes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      extraContentVisualizes = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemTips() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemTips() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItemTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<long> style{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItem : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems>> refundSubItems{};
  shared_ptr<vector<string>> subTableHead{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItem() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (subTableHead) {
      res["sub_table_head"] = boost::any(*subTableHead);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItemRefundSubItems>>(expect1);
      }
    }
    if (m.find("sub_table_head") != m.end() && !m["sub_table_head"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_table_head"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_table_head"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTableHead = make_shared<vector<string>>(toVec1);
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItem() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> cost{};
  shared_ptr<long> costPercent{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> timeType{};
  shared_ptr<string> title{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (cost) {
      res["cost"] = boost::any(*cost);
    }
    if (costPercent) {
      res["cost_percent"] = boost::any(*costPercent);
    }
    if (timeStamp) {
      res["time_stamp"] = boost::any(*timeStamp);
    }
    if (timeType) {
      res["time_type"] = boost::any(*timeType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("cost") != m.end() && !m["cost"].empty()) {
      cost = make_shared<long>(boost::any_cast<long>(m["cost"]));
    }
    if (m.find("cost_percent") != m.end() && !m["cost_percent"].empty()) {
      costPercent = make_shared<long>(boost::any_cast<long>(m["cost_percent"]));
    }
    if (m.find("time_stamp") != m.end() && !m["time_stamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["time_stamp"]));
    }
    if (m.find("time_type") != m.end() && !m["time_type"].empty()) {
      timeType = make_shared<string>(boost::any_cast<string>(m["time_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRule : public Darabonba::Model {
public:
  shared_ptr<bool> able{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo>> info{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRule() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (able) {
      res["able"] = boost::any(*able);
    }
    if (info) {
      vector<boost::any> temp1;
      for(auto item1:*info){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("able") != m.end() && !m["able"].empty()) {
      able = make_shared<bool>(boost::any_cast<bool>(m["able"]));
    }
    if (m.find("info") != m.end() && !m["info"].empty()) {
      if (typeid(vector<boost::any>) == m["info"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        info = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRuleInfo>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRule() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList : public Darabonba::Model {
public:
  shared_ptr<string> baggageInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItem> baggageItem{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRule> changeRule{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItem> changeRuleItem{};
  shared_ptr<string> extra{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRule> refundRule{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItem> refundRuleItem{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRule> signRule{};
  shared_ptr<string> tuigaiqianInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRule> upgradeRule{};

  FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageInfo) {
      res["baggage_info"] = boost::any(*baggageInfo);
    }
    if (baggageItem) {
      res["baggage_item"] = baggageItem ? boost::any(baggageItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRule) {
      res["change_rule"] = changeRule ? boost::any(changeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (changeRuleItem) {
      res["change_rule_item"] = changeRuleItem ? boost::any(changeRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (refundRule) {
      res["refund_rule"] = refundRule ? boost::any(refundRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundRuleItem) {
      res["refund_rule_item"] = refundRuleItem ? boost::any(refundRuleItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (signRule) {
      res["sign_rule"] = signRule ? boost::any(signRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    if (upgradeRule) {
      res["upgrade_rule"] = upgradeRule ? boost::any(upgradeRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_info") != m.end() && !m["baggage_info"].empty()) {
      baggageInfo = make_shared<string>(boost::any_cast<string>(m["baggage_info"]));
    }
    if (m.find("baggage_item") != m.end() && !m["baggage_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["baggage_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["baggage_item"]));
        baggageItem = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListBaggageItem>(model1);
      }
    }
    if (m.find("change_rule") != m.end() && !m["change_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule"]));
        changeRule = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRule>(model1);
      }
    }
    if (m.find("change_rule_item") != m.end() && !m["change_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_rule_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_rule_item"]));
        changeRuleItem = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListChangeRuleItem>(model1);
      }
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("refund_rule") != m.end() && !m["refund_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule"]));
        refundRule = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRule>(model1);
      }
    }
    if (m.find("refund_rule_item") != m.end() && !m["refund_rule_item"].empty()) {
      if (typeid(map<string, boost::any>) == m["refund_rule_item"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["refund_rule_item"]));
        refundRuleItem = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListRefundRuleItem>(model1);
      }
    }
    if (m.find("sign_rule") != m.end() && !m["sign_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["sign_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sign_rule"]));
        signRule = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListSignRule>(model1);
      }
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
    if (m.find("upgrade_rule") != m.end() && !m["upgrade_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["upgrade_rule"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["upgrade_rule"]));
        upgradeRule = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleListUpgradeRule>(model1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList() = default;
};
class FlightSearchListResponseBodyModuleFlightListTransferInfo : public Darabonba::Model {
public:
  shared_ptr<string> flightSize{};
  shared_ptr<string> flightType{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferAirlineInfo> transferAirlineInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferArrAirportInfo> transferArrAirportInfo{};
  shared_ptr<string> transferArrDate{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferDepAirportInfo> transferDepAirportInfo{};
  shared_ptr<string> transferDepDate{};
  shared_ptr<string> transferFlightNo{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList>> transferFlightRuleList{};

  FlightSearchListResponseBodyModuleFlightListTransferInfo() {}

  explicit FlightSearchListResponseBodyModuleFlightListTransferInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (transferAirlineInfo) {
      res["transfer_airline_info"] = transferAirlineInfo ? boost::any(transferAirlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transferArrAirportInfo) {
      res["transfer_arr_airport_info"] = transferArrAirportInfo ? boost::any(transferArrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transferArrDate) {
      res["transfer_arr_date"] = boost::any(*transferArrDate);
    }
    if (transferDepAirportInfo) {
      res["transfer_dep_airport_info"] = transferDepAirportInfo ? boost::any(transferDepAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transferDepDate) {
      res["transfer_dep_date"] = boost::any(*transferDepDate);
    }
    if (transferFlightNo) {
      res["transfer_flight_no"] = boost::any(*transferFlightNo);
    }
    if (transferFlightRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*transferFlightRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["transfer_flight_rule_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("transfer_airline_info") != m.end() && !m["transfer_airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["transfer_airline_info"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["transfer_airline_info"]));
        transferAirlineInfo = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferAirlineInfo>(model1);
      }
    }
    if (m.find("transfer_arr_airport_info") != m.end() && !m["transfer_arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["transfer_arr_airport_info"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["transfer_arr_airport_info"]));
        transferArrAirportInfo = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferArrAirportInfo>(model1);
      }
    }
    if (m.find("transfer_arr_date") != m.end() && !m["transfer_arr_date"].empty()) {
      transferArrDate = make_shared<string>(boost::any_cast<string>(m["transfer_arr_date"]));
    }
    if (m.find("transfer_dep_airport_info") != m.end() && !m["transfer_dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["transfer_dep_airport_info"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfoTransferDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["transfer_dep_airport_info"]));
        transferDepAirportInfo = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferDepAirportInfo>(model1);
      }
    }
    if (m.find("transfer_dep_date") != m.end() && !m["transfer_dep_date"].empty()) {
      transferDepDate = make_shared<string>(boost::any_cast<string>(m["transfer_dep_date"]));
    }
    if (m.find("transfer_flight_no") != m.end() && !m["transfer_flight_no"].empty()) {
      transferFlightNo = make_shared<string>(boost::any_cast<string>(m["transfer_flight_no"]));
    }
    if (m.find("transfer_flight_rule_list") != m.end() && !m["transfer_flight_rule_list"].empty()) {
      if (typeid(vector<boost::any>) == m["transfer_flight_rule_list"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["transfer_flight_rule_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transferFlightRuleList = make_shared<vector<FlightSearchListResponseBodyModuleFlightListTransferInfoTransferFlightRuleList>>(expect1);
      }
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightListTransferInfo() = default;
};
class FlightSearchListResponseBodyModuleFlightList : public Darabonba::Model {
public:
  shared_ptr<FlightSearchListResponseBodyModuleFlightListAirlineInfo> airlineInfo{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListArrAirportInfo> arrAirportInfo{};
  shared_ptr<string> arrDate{};
  shared_ptr<long> basicCabinPrice{};
  shared_ptr<long> buildPrice{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoList>> cabinInfoList{};
  shared_ptr<string> carrierAirline{};
  shared_ptr<string> carrierNo{};
  shared_ptr<string> classRule{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListDepAirportInfo> depAirportInfo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depDate{};
  shared_ptr<long> discount{};
  shared_ptr<string> flightNo{};
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleList>> flightRuleList{};
  shared_ptr<string> flightRuleListStr{};
  shared_ptr<string> flightSize{};
  shared_ptr<string> flightType{};
  shared_ptr<long> invoiceType{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<bool> isShare{};
  shared_ptr<bool> isStop{};
  shared_ptr<bool> isTransfer{};
  shared_ptr<string> mealDesc{};
  shared_ptr<string> memo{};
  shared_ptr<long> oilPrice{};
  shared_ptr<string> otaItemId{};
  shared_ptr<long> price{};
  shared_ptr<long> productType{};
  shared_ptr<string> productTypeDesc{};
  shared_ptr<string> promotionPrice{};
  shared_ptr<string> remainedSeatCount{};
  shared_ptr<string> secretParams{};
  shared_ptr<string> segmentNumber{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopDepTime{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<string> totalPrice{};
  shared_ptr<FlightSearchListResponseBodyModuleFlightListTransferInfo> transferInfo{};
  shared_ptr<long> tripType{};

  FlightSearchListResponseBodyModuleFlightList() {}

  explicit FlightSearchListResponseBodyModuleFlightList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (basicCabinPrice) {
      res["basic_cabin_price"] = boost::any(*basicCabinPrice);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*cabinInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cabin_info_list"] = boost::any(temp1);
    }
    if (carrierAirline) {
      res["carrier_airline"] = boost::any(*carrierAirline);
    }
    if (carrierNo) {
      res["carrier_no"] = boost::any(*carrierNo);
    }
    if (classRule) {
      res["class_rule"] = boost::any(*classRule);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*flightRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_rule_list"] = boost::any(temp1);
    }
    if (flightRuleListStr) {
      res["flight_rule_list_str"] = boost::any(*flightRuleListStr);
    }
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (isShare) {
      res["is_share"] = boost::any(*isShare);
    }
    if (isStop) {
      res["is_stop"] = boost::any(*isStop);
    }
    if (isTransfer) {
      res["is_transfer"] = boost::any(*isTransfer);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (memo) {
      res["memo"] = boost::any(*memo);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (productType) {
      res["product_type"] = boost::any(*productType);
    }
    if (productTypeDesc) {
      res["product_type_desc"] = boost::any(*productTypeDesc);
    }
    if (promotionPrice) {
      res["promotion_price"] = boost::any(*promotionPrice);
    }
    if (remainedSeatCount) {
      res["remained_seat_count"] = boost::any(*remainedSeatCount);
    }
    if (secretParams) {
      res["secret_params"] = boost::any(*secretParams);
    }
    if (segmentNumber) {
      res["segment_number"] = boost::any(*segmentNumber);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    if (transferInfo) {
      res["transfer_info"] = transferInfo ? boost::any(transferInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        FlightSearchListResponseBodyModuleFlightListAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<FlightSearchListResponseBodyModuleFlightListAirlineInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        FlightSearchListResponseBodyModuleFlightListArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<FlightSearchListResponseBodyModuleFlightListArrAirportInfo>(model1);
      }
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("basic_cabin_price") != m.end() && !m["basic_cabin_price"].empty()) {
      basicCabinPrice = make_shared<long>(boost::any_cast<long>(m["basic_cabin_price"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_info_list") != m.end() && !m["cabin_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["cabin_info_list"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListCabinInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cabin_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListCabinInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cabinInfoList = make_shared<vector<FlightSearchListResponseBodyModuleFlightListCabinInfoList>>(expect1);
      }
    }
    if (m.find("carrier_airline") != m.end() && !m["carrier_airline"].empty()) {
      carrierAirline = make_shared<string>(boost::any_cast<string>(m["carrier_airline"]));
    }
    if (m.find("carrier_no") != m.end() && !m["carrier_no"].empty()) {
      carrierNo = make_shared<string>(boost::any_cast<string>(m["carrier_no"]));
    }
    if (m.find("class_rule") != m.end() && !m["class_rule"].empty()) {
      classRule = make_shared<string>(boost::any_cast<string>(m["class_rule"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        FlightSearchListResponseBodyModuleFlightListDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<FlightSearchListResponseBodyModuleFlightListDepAirportInfo>(model1);
      }
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<long>(boost::any_cast<long>(m["discount"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_rule_list") != m.end() && !m["flight_rule_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_rule_list"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightListFlightRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_rule_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightListFlightRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightRuleList = make_shared<vector<FlightSearchListResponseBodyModuleFlightListFlightRuleList>>(expect1);
      }
    }
    if (m.find("flight_rule_list_str") != m.end() && !m["flight_rule_list_str"].empty()) {
      flightRuleListStr = make_shared<string>(boost::any_cast<string>(m["flight_rule_list_str"]));
    }
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("is_share") != m.end() && !m["is_share"].empty()) {
      isShare = make_shared<bool>(boost::any_cast<bool>(m["is_share"]));
    }
    if (m.find("is_stop") != m.end() && !m["is_stop"].empty()) {
      isStop = make_shared<bool>(boost::any_cast<bool>(m["is_stop"]));
    }
    if (m.find("is_transfer") != m.end() && !m["is_transfer"].empty()) {
      isTransfer = make_shared<bool>(boost::any_cast<bool>(m["is_transfer"]));
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("memo") != m.end() && !m["memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["memo"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("product_type") != m.end() && !m["product_type"].empty()) {
      productType = make_shared<long>(boost::any_cast<long>(m["product_type"]));
    }
    if (m.find("product_type_desc") != m.end() && !m["product_type_desc"].empty()) {
      productTypeDesc = make_shared<string>(boost::any_cast<string>(m["product_type_desc"]));
    }
    if (m.find("promotion_price") != m.end() && !m["promotion_price"].empty()) {
      promotionPrice = make_shared<string>(boost::any_cast<string>(m["promotion_price"]));
    }
    if (m.find("remained_seat_count") != m.end() && !m["remained_seat_count"].empty()) {
      remainedSeatCount = make_shared<string>(boost::any_cast<string>(m["remained_seat_count"]));
    }
    if (m.find("secret_params") != m.end() && !m["secret_params"].empty()) {
      secretParams = make_shared<string>(boost::any_cast<string>(m["secret_params"]));
    }
    if (m.find("segment_number") != m.end() && !m["segment_number"].empty()) {
      segmentNumber = make_shared<string>(boost::any_cast<string>(m["segment_number"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<string>(boost::any_cast<string>(m["total_price"]));
    }
    if (m.find("transfer_info") != m.end() && !m["transfer_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["transfer_info"].type()) {
        FlightSearchListResponseBodyModuleFlightListTransferInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["transfer_info"]));
        transferInfo = make_shared<FlightSearchListResponseBodyModuleFlightListTransferInfo>(model1);
      }
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModuleFlightList() = default;
};
class FlightSearchListResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<FlightSearchListResponseBodyModuleFlightList>> flightList{};
  shared_ptr<bool> isReplacePnr{};

  FlightSearchListResponseBodyModule() {}

  explicit FlightSearchListResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightList) {
      vector<boost::any> temp1;
      for(auto item1:*flightList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_list"] = boost::any(temp1);
    }
    if (isReplacePnr) {
      res["is_replace_pnr"] = boost::any(*isReplacePnr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_list") != m.end() && !m["flight_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_list"].type()) {
        vector<FlightSearchListResponseBodyModuleFlightList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FlightSearchListResponseBodyModuleFlightList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightList = make_shared<vector<FlightSearchListResponseBodyModuleFlightList>>(expect1);
      }
    }
    if (m.find("is_replace_pnr") != m.end() && !m["is_replace_pnr"].empty()) {
      isReplacePnr = make_shared<bool>(boost::any_cast<bool>(m["is_replace_pnr"]));
    }
  }


  virtual ~FlightSearchListResponseBodyModule() = default;
};
class FlightSearchListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FlightSearchListResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  FlightSearchListResponseBody() {}

  explicit FlightSearchListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        FlightSearchListResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<FlightSearchListResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~FlightSearchListResponseBody() = default;
};
class FlightSearchListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FlightSearchListResponseBody> body{};

  FlightSearchListResponse() {}

  explicit FlightSearchListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FlightSearchListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FlightSearchListResponseBody>(model1);
      }
    }
  }


  virtual ~FlightSearchListResponse() = default;
};
class GroupCorpTokenHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripAccessToken{};

  GroupCorpTokenHeaders() {}

  explicit GroupCorpTokenHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripAccessToken) {
      res["x-acs-btrip-access-token"] = boost::any(*xAcsBtripAccessToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-access-token") != m.end() && !m["x-acs-btrip-access-token"].empty()) {
      xAcsBtripAccessToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-access-token"]));
    }
  }


  virtual ~GroupCorpTokenHeaders() = default;
};
class GroupCorpTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> appSecret{};
  shared_ptr<string> corpId{};
  shared_ptr<string> subCorpId{};

  GroupCorpTokenRequest() {}

  explicit GroupCorpTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appSecret) {
      res["app_secret"] = boost::any(*appSecret);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("app_secret") != m.end() && !m["app_secret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["app_secret"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
  }


  virtual ~GroupCorpTokenRequest() = default;
};
class GroupCorpTokenResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> expire{};
  shared_ptr<long> start{};
  shared_ptr<string> token{};

  GroupCorpTokenResponseBodyModule() {}

  explicit GroupCorpTokenResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expire) {
      res["expire"] = boost::any(*expire);
    }
    if (start) {
      res["start"] = boost::any(*start);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("expire") != m.end() && !m["expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["expire"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["start"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~GroupCorpTokenResponseBodyModule() = default;
};
class GroupCorpTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<GroupCorpTokenResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<string> traceId{};

  GroupCorpTokenResponseBody() {}

  explicit GroupCorpTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        GroupCorpTokenResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<GroupCorpTokenResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~GroupCorpTokenResponseBody() = default;
};
class GroupCorpTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GroupCorpTokenResponseBody> body{};

  GroupCorpTokenResponse() {}

  explicit GroupCorpTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GroupCorpTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GroupCorpTokenResponseBody>(model1);
      }
    }
  }


  virtual ~GroupCorpTokenResponse() = default;
};
class GroupDepartSaveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  GroupDepartSaveHeaders() {}

  explicit GroupDepartSaveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~GroupDepartSaveHeaders() = default;
};
class GroupDepartSaveRequest : public Darabonba::Model {
public:
  shared_ptr<string> deptName{};
  shared_ptr<string> managerIds{};
  shared_ptr<string> outerDeptId{};
  shared_ptr<string> outerDeptPid{};
  shared_ptr<long> status{};
  shared_ptr<vector<string>> subCorpIdList{};
  shared_ptr<bool> syncGroup{};

  GroupDepartSaveRequest() {}

  explicit GroupDepartSaveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptName) {
      res["dept_name"] = boost::any(*deptName);
    }
    if (managerIds) {
      res["manager_ids"] = boost::any(*managerIds);
    }
    if (outerDeptId) {
      res["outer_dept_id"] = boost::any(*outerDeptId);
    }
    if (outerDeptPid) {
      res["outer_dept_pid"] = boost::any(*outerDeptPid);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subCorpIdList) {
      res["sub_corp_id_list"] = boost::any(*subCorpIdList);
    }
    if (syncGroup) {
      res["sync_group"] = boost::any(*syncGroup);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dept_name") != m.end() && !m["dept_name"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["dept_name"]));
    }
    if (m.find("manager_ids") != m.end() && !m["manager_ids"].empty()) {
      managerIds = make_shared<string>(boost::any_cast<string>(m["manager_ids"]));
    }
    if (m.find("outer_dept_id") != m.end() && !m["outer_dept_id"].empty()) {
      outerDeptId = make_shared<string>(boost::any_cast<string>(m["outer_dept_id"]));
    }
    if (m.find("outer_dept_pid") != m.end() && !m["outer_dept_pid"].empty()) {
      outerDeptPid = make_shared<string>(boost::any_cast<string>(m["outer_dept_pid"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("sub_corp_id_list") != m.end() && !m["sub_corp_id_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_corp_id_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_corp_id_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subCorpIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("sync_group") != m.end() && !m["sync_group"].empty()) {
      syncGroup = make_shared<bool>(boost::any_cast<bool>(m["sync_group"]));
    }
  }


  virtual ~GroupDepartSaveRequest() = default;
};
class GroupDepartSaveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deptName{};
  shared_ptr<string> managerIds{};
  shared_ptr<string> outerDeptId{};
  shared_ptr<string> outerDeptPid{};
  shared_ptr<long> status{};
  shared_ptr<string> subCorpIdListShrink{};
  shared_ptr<bool> syncGroup{};

  GroupDepartSaveShrinkRequest() {}

  explicit GroupDepartSaveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptName) {
      res["dept_name"] = boost::any(*deptName);
    }
    if (managerIds) {
      res["manager_ids"] = boost::any(*managerIds);
    }
    if (outerDeptId) {
      res["outer_dept_id"] = boost::any(*outerDeptId);
    }
    if (outerDeptPid) {
      res["outer_dept_pid"] = boost::any(*outerDeptPid);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subCorpIdListShrink) {
      res["sub_corp_id_list"] = boost::any(*subCorpIdListShrink);
    }
    if (syncGroup) {
      res["sync_group"] = boost::any(*syncGroup);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dept_name") != m.end() && !m["dept_name"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["dept_name"]));
    }
    if (m.find("manager_ids") != m.end() && !m["manager_ids"].empty()) {
      managerIds = make_shared<string>(boost::any_cast<string>(m["manager_ids"]));
    }
    if (m.find("outer_dept_id") != m.end() && !m["outer_dept_id"].empty()) {
      outerDeptId = make_shared<string>(boost::any_cast<string>(m["outer_dept_id"]));
    }
    if (m.find("outer_dept_pid") != m.end() && !m["outer_dept_pid"].empty()) {
      outerDeptPid = make_shared<string>(boost::any_cast<string>(m["outer_dept_pid"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("sub_corp_id_list") != m.end() && !m["sub_corp_id_list"].empty()) {
      subCorpIdListShrink = make_shared<string>(boost::any_cast<string>(m["sub_corp_id_list"]));
    }
    if (m.find("sync_group") != m.end() && !m["sync_group"].empty()) {
      syncGroup = make_shared<bool>(boost::any_cast<bool>(m["sync_group"]));
    }
  }


  virtual ~GroupDepartSaveShrinkRequest() = default;
};
class GroupDepartSaveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  GroupDepartSaveResponseBody() {}

  explicit GroupDepartSaveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~GroupDepartSaveResponseBody() = default;
};
class GroupDepartSaveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GroupDepartSaveResponseBody> body{};

  GroupDepartSaveResponse() {}

  explicit GroupDepartSaveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GroupDepartSaveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GroupDepartSaveResponseBody>(model1);
      }
    }
  }


  virtual ~GroupDepartSaveResponse() = default;
};
class GroupUserSaveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  GroupUserSaveHeaders() {}

  explicit GroupUserSaveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~GroupUserSaveHeaders() = default;
};
class GroupUserSaveRequestCertList : public Darabonba::Model {
public:
  shared_ptr<string> certExpiredTime{};
  shared_ptr<string> certNation{};
  shared_ptr<string> certNo{};
  shared_ptr<long> certType{};
  shared_ptr<string> nationality{};

  GroupUserSaveRequestCertList() {}

  explicit GroupUserSaveRequestCertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certExpiredTime) {
      res["cert_expired_time"] = boost::any(*certExpiredTime);
    }
    if (certNation) {
      res["cert_nation"] = boost::any(*certNation);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (nationality) {
      res["nationality"] = boost::any(*nationality);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cert_expired_time") != m.end() && !m["cert_expired_time"].empty()) {
      certExpiredTime = make_shared<string>(boost::any_cast<string>(m["cert_expired_time"]));
    }
    if (m.find("cert_nation") != m.end() && !m["cert_nation"].empty()) {
      certNation = make_shared<string>(boost::any_cast<string>(m["cert_nation"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<long>(boost::any_cast<long>(m["cert_type"]));
    }
    if (m.find("nationality") != m.end() && !m["nationality"].empty()) {
      nationality = make_shared<string>(boost::any_cast<string>(m["nationality"]));
    }
  }


  virtual ~GroupUserSaveRequestCertList() = default;
};
class GroupUserSaveRequestSubCorpIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> departIds{};
  shared_ptr<string> email{};
  shared_ptr<long> leaveStatus{};
  shared_ptr<string> managerUserId{};
  shared_ptr<string> positionLevel{};
  shared_ptr<string> subCorpId{};

  GroupUserSaveRequestSubCorpIdList() {}

  explicit GroupUserSaveRequestSubCorpIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departIds) {
      res["depart_ids"] = boost::any(*departIds);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (leaveStatus) {
      res["leave_status"] = boost::any(*leaveStatus);
    }
    if (managerUserId) {
      res["manager_user_id"] = boost::any(*managerUserId);
    }
    if (positionLevel) {
      res["position_level"] = boost::any(*positionLevel);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("depart_ids") != m.end() && !m["depart_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["depart_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["depart_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      departIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("leave_status") != m.end() && !m["leave_status"].empty()) {
      leaveStatus = make_shared<long>(boost::any_cast<long>(m["leave_status"]));
    }
    if (m.find("manager_user_id") != m.end() && !m["manager_user_id"].empty()) {
      managerUserId = make_shared<string>(boost::any_cast<string>(m["manager_user_id"]));
    }
    if (m.find("position_level") != m.end() && !m["position_level"].empty()) {
      positionLevel = make_shared<string>(boost::any_cast<string>(m["position_level"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
  }


  virtual ~GroupUserSaveRequestSubCorpIdList() = default;
};
class GroupUserSaveRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseCityCode{};
  shared_ptr<string> birthday{};
  shared_ptr<vector<GroupUserSaveRequestCertList>> certList{};
  shared_ptr<string> gender{};
  shared_ptr<string> jobNo{};
  shared_ptr<string> phone{};
  shared_ptr<string> realNameEn{};
  shared_ptr<vector<GroupUserSaveRequestSubCorpIdList>> subCorpIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  GroupUserSaveRequest() {}

  explicit GroupUserSaveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseCityCode) {
      res["base_city_code"] = boost::any(*baseCityCode);
    }
    if (birthday) {
      res["birthday"] = boost::any(*birthday);
    }
    if (certList) {
      vector<boost::any> temp1;
      for(auto item1:*certList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cert_list"] = boost::any(temp1);
    }
    if (gender) {
      res["gender"] = boost::any(*gender);
    }
    if (jobNo) {
      res["job_no"] = boost::any(*jobNo);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (realNameEn) {
      res["real_name_en"] = boost::any(*realNameEn);
    }
    if (subCorpIdList) {
      vector<boost::any> temp1;
      for(auto item1:*subCorpIdList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["sub_corp_id_list"] = boost::any(temp1);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("base_city_code") != m.end() && !m["base_city_code"].empty()) {
      baseCityCode = make_shared<string>(boost::any_cast<string>(m["base_city_code"]));
    }
    if (m.find("birthday") != m.end() && !m["birthday"].empty()) {
      birthday = make_shared<string>(boost::any_cast<string>(m["birthday"]));
    }
    if (m.find("cert_list") != m.end() && !m["cert_list"].empty()) {
      if (typeid(vector<boost::any>) == m["cert_list"].type()) {
        vector<GroupUserSaveRequestCertList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cert_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GroupUserSaveRequestCertList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certList = make_shared<vector<GroupUserSaveRequestCertList>>(expect1);
      }
    }
    if (m.find("gender") != m.end() && !m["gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["gender"]));
    }
    if (m.find("job_no") != m.end() && !m["job_no"].empty()) {
      jobNo = make_shared<string>(boost::any_cast<string>(m["job_no"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("real_name_en") != m.end() && !m["real_name_en"].empty()) {
      realNameEn = make_shared<string>(boost::any_cast<string>(m["real_name_en"]));
    }
    if (m.find("sub_corp_id_list") != m.end() && !m["sub_corp_id_list"].empty()) {
      if (typeid(vector<boost::any>) == m["sub_corp_id_list"].type()) {
        vector<GroupUserSaveRequestSubCorpIdList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["sub_corp_id_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GroupUserSaveRequestSubCorpIdList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subCorpIdList = make_shared<vector<GroupUserSaveRequestSubCorpIdList>>(expect1);
      }
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~GroupUserSaveRequest() = default;
};
class GroupUserSaveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseCityCode{};
  shared_ptr<string> birthday{};
  shared_ptr<string> certListShrink{};
  shared_ptr<string> gender{};
  shared_ptr<string> jobNo{};
  shared_ptr<string> phone{};
  shared_ptr<string> realNameEn{};
  shared_ptr<string> subCorpIdListShrink{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  GroupUserSaveShrinkRequest() {}

  explicit GroupUserSaveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseCityCode) {
      res["base_city_code"] = boost::any(*baseCityCode);
    }
    if (birthday) {
      res["birthday"] = boost::any(*birthday);
    }
    if (certListShrink) {
      res["cert_list"] = boost::any(*certListShrink);
    }
    if (gender) {
      res["gender"] = boost::any(*gender);
    }
    if (jobNo) {
      res["job_no"] = boost::any(*jobNo);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (realNameEn) {
      res["real_name_en"] = boost::any(*realNameEn);
    }
    if (subCorpIdListShrink) {
      res["sub_corp_id_list"] = boost::any(*subCorpIdListShrink);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("base_city_code") != m.end() && !m["base_city_code"].empty()) {
      baseCityCode = make_shared<string>(boost::any_cast<string>(m["base_city_code"]));
    }
    if (m.find("birthday") != m.end() && !m["birthday"].empty()) {
      birthday = make_shared<string>(boost::any_cast<string>(m["birthday"]));
    }
    if (m.find("cert_list") != m.end() && !m["cert_list"].empty()) {
      certListShrink = make_shared<string>(boost::any_cast<string>(m["cert_list"]));
    }
    if (m.find("gender") != m.end() && !m["gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["gender"]));
    }
    if (m.find("job_no") != m.end() && !m["job_no"].empty()) {
      jobNo = make_shared<string>(boost::any_cast<string>(m["job_no"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("real_name_en") != m.end() && !m["real_name_en"].empty()) {
      realNameEn = make_shared<string>(boost::any_cast<string>(m["real_name_en"]));
    }
    if (m.find("sub_corp_id_list") != m.end() && !m["sub_corp_id_list"].empty()) {
      subCorpIdListShrink = make_shared<string>(boost::any_cast<string>(m["sub_corp_id_list"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~GroupUserSaveShrinkRequest() = default;
};
class GroupUserSaveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  GroupUserSaveResponseBody() {}

  explicit GroupUserSaveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~GroupUserSaveResponseBody() = default;
};
class GroupUserSaveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GroupUserSaveResponseBody> body{};

  GroupUserSaveResponse() {}

  explicit GroupUserSaveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GroupUserSaveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GroupUserSaveResponseBody>(model1);
      }
    }
  }


  virtual ~GroupUserSaveResponse() = default;
};
class HotelAskingPriceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  HotelAskingPriceHeaders() {}

  explicit HotelAskingPriceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~HotelAskingPriceHeaders() = default;
};
class HotelAskingPriceRequest : public Darabonba::Model {
public:
  shared_ptr<string> adultNum{};
  shared_ptr<string> btripUserId{};
  shared_ptr<string> checkInDate{};
  shared_ptr<string> checkOutDate{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> dir{};
  shared_ptr<string> hotelStar{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<long> paymentType{};
  shared_ptr<vector<long>> shids{};
  shared_ptr<long> sortCode{};

  HotelAskingPriceRequest() {}

  explicit HotelAskingPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adultNum) {
      res["adult_num"] = boost::any(*adultNum);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (checkInDate) {
      res["check_in_date"] = boost::any(*checkInDate);
    }
    if (checkOutDate) {
      res["check_out_date"] = boost::any(*checkOutDate);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (dir) {
      res["dir"] = boost::any(*dir);
    }
    if (hotelStar) {
      res["hotel_star"] = boost::any(*hotelStar);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (paymentType) {
      res["payment_type"] = boost::any(*paymentType);
    }
    if (shids) {
      res["shids"] = boost::any(*shids);
    }
    if (sortCode) {
      res["sort_code"] = boost::any(*sortCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("adult_num") != m.end() && !m["adult_num"].empty()) {
      adultNum = make_shared<string>(boost::any_cast<string>(m["adult_num"]));
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("check_in_date") != m.end() && !m["check_in_date"].empty()) {
      checkInDate = make_shared<string>(boost::any_cast<string>(m["check_in_date"]));
    }
    if (m.find("check_out_date") != m.end() && !m["check_out_date"].empty()) {
      checkOutDate = make_shared<string>(boost::any_cast<string>(m["check_out_date"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("dir") != m.end() && !m["dir"].empty()) {
      dir = make_shared<long>(boost::any_cast<long>(m["dir"]));
    }
    if (m.find("hotel_star") != m.end() && !m["hotel_star"].empty()) {
      hotelStar = make_shared<string>(boost::any_cast<string>(m["hotel_star"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("payment_type") != m.end() && !m["payment_type"].empty()) {
      paymentType = make_shared<long>(boost::any_cast<long>(m["payment_type"]));
    }
    if (m.find("shids") != m.end() && !m["shids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["shids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["shids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      shids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("sort_code") != m.end() && !m["sort_code"].empty()) {
      sortCode = make_shared<long>(boost::any_cast<long>(m["sort_code"]));
    }
  }


  virtual ~HotelAskingPriceRequest() = default;
};
class HotelAskingPriceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> adultNum{};
  shared_ptr<string> btripUserId{};
  shared_ptr<string> checkInDate{};
  shared_ptr<string> checkOutDate{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> dir{};
  shared_ptr<string> hotelStar{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<long> paymentType{};
  shared_ptr<string> shidsShrink{};
  shared_ptr<long> sortCode{};

  HotelAskingPriceShrinkRequest() {}

  explicit HotelAskingPriceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adultNum) {
      res["adult_num"] = boost::any(*adultNum);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (checkInDate) {
      res["check_in_date"] = boost::any(*checkInDate);
    }
    if (checkOutDate) {
      res["check_out_date"] = boost::any(*checkOutDate);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (dir) {
      res["dir"] = boost::any(*dir);
    }
    if (hotelStar) {
      res["hotel_star"] = boost::any(*hotelStar);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (paymentType) {
      res["payment_type"] = boost::any(*paymentType);
    }
    if (shidsShrink) {
      res["shids"] = boost::any(*shidsShrink);
    }
    if (sortCode) {
      res["sort_code"] = boost::any(*sortCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("adult_num") != m.end() && !m["adult_num"].empty()) {
      adultNum = make_shared<string>(boost::any_cast<string>(m["adult_num"]));
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("check_in_date") != m.end() && !m["check_in_date"].empty()) {
      checkInDate = make_shared<string>(boost::any_cast<string>(m["check_in_date"]));
    }
    if (m.find("check_out_date") != m.end() && !m["check_out_date"].empty()) {
      checkOutDate = make_shared<string>(boost::any_cast<string>(m["check_out_date"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("dir") != m.end() && !m["dir"].empty()) {
      dir = make_shared<long>(boost::any_cast<long>(m["dir"]));
    }
    if (m.find("hotel_star") != m.end() && !m["hotel_star"].empty()) {
      hotelStar = make_shared<string>(boost::any_cast<string>(m["hotel_star"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("payment_type") != m.end() && !m["payment_type"].empty()) {
      paymentType = make_shared<long>(boost::any_cast<long>(m["payment_type"]));
    }
    if (m.find("shids") != m.end() && !m["shids"].empty()) {
      shidsShrink = make_shared<string>(boost::any_cast<string>(m["shids"]));
    }
    if (m.find("sort_code") != m.end() && !m["sort_code"].empty()) {
      sortCode = make_shared<long>(boost::any_cast<long>(m["sort_code"]));
    }
  }


  virtual ~HotelAskingPriceShrinkRequest() = default;
};
class HotelAskingPriceResponseBodyModuleHotelAskingPriceDetails : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> hotelAddress{};
  shared_ptr<string> hotelCode{};
  shared_ptr<string> hotelName{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<double> minPrice{};
  shared_ptr<double> originalMinPrice{};

  HotelAskingPriceResponseBodyModuleHotelAskingPriceDetails() {}

  explicit HotelAskingPriceResponseBodyModuleHotelAskingPriceDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (hotelAddress) {
      res["hotel_address"] = boost::any(*hotelAddress);
    }
    if (hotelCode) {
      res["hotel_code"] = boost::any(*hotelCode);
    }
    if (hotelName) {
      res["hotel_name"] = boost::any(*hotelName);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (minPrice) {
      res["min_price"] = boost::any(*minPrice);
    }
    if (originalMinPrice) {
      res["original_min_price"] = boost::any(*originalMinPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("hotel_address") != m.end() && !m["hotel_address"].empty()) {
      hotelAddress = make_shared<string>(boost::any_cast<string>(m["hotel_address"]));
    }
    if (m.find("hotel_code") != m.end() && !m["hotel_code"].empty()) {
      hotelCode = make_shared<string>(boost::any_cast<string>(m["hotel_code"]));
    }
    if (m.find("hotel_name") != m.end() && !m["hotel_name"].empty()) {
      hotelName = make_shared<string>(boost::any_cast<string>(m["hotel_name"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("min_price") != m.end() && !m["min_price"].empty()) {
      minPrice = make_shared<double>(boost::any_cast<double>(m["min_price"]));
    }
    if (m.find("original_min_price") != m.end() && !m["original_min_price"].empty()) {
      originalMinPrice = make_shared<double>(boost::any_cast<double>(m["original_min_price"]));
    }
  }


  virtual ~HotelAskingPriceResponseBodyModuleHotelAskingPriceDetails() = default;
};
class HotelAskingPriceResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<HotelAskingPriceResponseBodyModuleHotelAskingPriceDetails>> hotelAskingPriceDetails{};

  HotelAskingPriceResponseBodyModule() {}

  explicit HotelAskingPriceResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelAskingPriceDetails) {
      vector<boost::any> temp1;
      for(auto item1:*hotelAskingPriceDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_asking_price_details"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_asking_price_details") != m.end() && !m["hotel_asking_price_details"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_asking_price_details"].type()) {
        vector<HotelAskingPriceResponseBodyModuleHotelAskingPriceDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_asking_price_details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelAskingPriceResponseBodyModuleHotelAskingPriceDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelAskingPriceDetails = make_shared<vector<HotelAskingPriceResponseBodyModuleHotelAskingPriceDetails>>(expect1);
      }
    }
  }


  virtual ~HotelAskingPriceResponseBodyModule() = default;
};
class HotelAskingPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelAskingPriceResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelAskingPriceResponseBody() {}

  explicit HotelAskingPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelAskingPriceResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelAskingPriceResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelAskingPriceResponseBody() = default;
};
class HotelAskingPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelAskingPriceResponseBody> body{};

  HotelAskingPriceResponse() {}

  explicit HotelAskingPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelAskingPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelAskingPriceResponseBody>(model1);
      }
    }
  }


  virtual ~HotelAskingPriceResponse() = default;
};
class HotelBillSettlementQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  HotelBillSettlementQueryHeaders() {}

  explicit HotelBillSettlementQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~HotelBillSettlementQueryHeaders() = default;
};
class HotelBillSettlementQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};

  HotelBillSettlementQueryRequest() {}

  explicit HotelBillSettlementQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
  }


  virtual ~HotelBillSettlementQueryRequest() = default;
};
class HotelBillSettlementQueryResponseBodyModuleDataList : public Darabonba::Model {
public:
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<string> applyArrCityCode{};
  shared_ptr<string> applyArrCityName{};
  shared_ptr<string> applyDepCityCode{};
  shared_ptr<string> applyDepCityName{};
  shared_ptr<string> applyExtendField{};
  shared_ptr<string> applyId{};
  shared_ptr<string> averageNights{};
  shared_ptr<string> billRecordTime{};
  shared_ptr<string> bookReason{};
  shared_ptr<string> bookTime{};
  shared_ptr<string> bookerId{};
  shared_ptr<string> bookerJobNo{};
  shared_ptr<string> bookerName{};
  shared_ptr<string> brandGroup{};
  shared_ptr<string> brandName{};
  shared_ptr<string> businessTripResult{};
  shared_ptr<string> capitalDirection{};
  shared_ptr<string> cascadeDepartment{};
  shared_ptr<string> checkInDate{};
  shared_ptr<string> checkoutDate{};
  shared_ptr<string> city{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityCounty{};
  shared_ptr<string> cityCountyCode{};
  shared_ptr<double> corpRefundFee{};
  shared_ptr<double> corpTotalFee{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<string> department{};
  shared_ptr<string> departmentId{};
  shared_ptr<string> exceedReason{};
  shared_ptr<string> feeType{};
  shared_ptr<double> fees{};
  shared_ptr<double> fines{};
  shared_ptr<double> fuPointFee{};
  shared_ptr<string> hotelName{};
  shared_ptr<string> index{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> isEarlyDeparture{};
  shared_ptr<string> isNegotiation{};
  shared_ptr<string> isShareStr{};
  shared_ptr<long> nights{};
  shared_ptr<string> orderId{};
  shared_ptr<double> orderPrice{};
  shared_ptr<string> orderType{};
  shared_ptr<string> overApplyId{};
  shared_ptr<double> personRefundFee{};
  shared_ptr<double> personSettlePrice{};
  shared_ptr<long> primaryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectName{};
  shared_ptr<double> promotionFee{};
  shared_ptr<string> remark{};
  shared_ptr<string> reserveRule{};
  shared_ptr<string> roomNo{};
  shared_ptr<long> roomNumber{};
  shared_ptr<double> roomPrice{};
  shared_ptr<string> roomType{};
  shared_ptr<double> serviceFee{};
  shared_ptr<double> settlementFee{};
  shared_ptr<double> settlementGrantFee{};
  shared_ptr<string> settlementTime{};
  shared_ptr<string> settlementType{};
  shared_ptr<string> star{};
  shared_ptr<long> status{};
  shared_ptr<string> taxRate{};
  shared_ptr<string> thirdItineraryId{};
  shared_ptr<long> totalNights{};
  shared_ptr<string> travelerId{};
  shared_ptr<string> travelerJobNo{};
  shared_ptr<string> travelerMemberTypeName{};
  shared_ptr<string> travelerName{};
  shared_ptr<long> voucherType{};

  HotelBillSettlementQueryResponseBodyModuleDataList() {}

  explicit HotelBillSettlementQueryResponseBodyModuleDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (applyArrCityCode) {
      res["apply_arr_city_code"] = boost::any(*applyArrCityCode);
    }
    if (applyArrCityName) {
      res["apply_arr_city_name"] = boost::any(*applyArrCityName);
    }
    if (applyDepCityCode) {
      res["apply_dep_city_code"] = boost::any(*applyDepCityCode);
    }
    if (applyDepCityName) {
      res["apply_dep_city_name"] = boost::any(*applyDepCityName);
    }
    if (applyExtendField) {
      res["apply_extend_field"] = boost::any(*applyExtendField);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (averageNights) {
      res["average_nights"] = boost::any(*averageNights);
    }
    if (billRecordTime) {
      res["bill_record_time"] = boost::any(*billRecordTime);
    }
    if (bookReason) {
      res["book_reason"] = boost::any(*bookReason);
    }
    if (bookTime) {
      res["book_time"] = boost::any(*bookTime);
    }
    if (bookerId) {
      res["booker_id"] = boost::any(*bookerId);
    }
    if (bookerJobNo) {
      res["booker_job_no"] = boost::any(*bookerJobNo);
    }
    if (bookerName) {
      res["booker_name"] = boost::any(*bookerName);
    }
    if (brandGroup) {
      res["brand_group"] = boost::any(*brandGroup);
    }
    if (brandName) {
      res["brand_name"] = boost::any(*brandName);
    }
    if (businessTripResult) {
      res["business_trip_result"] = boost::any(*businessTripResult);
    }
    if (capitalDirection) {
      res["capital_direction"] = boost::any(*capitalDirection);
    }
    if (cascadeDepartment) {
      res["cascade_department"] = boost::any(*cascadeDepartment);
    }
    if (checkInDate) {
      res["check_in_date"] = boost::any(*checkInDate);
    }
    if (checkoutDate) {
      res["checkout_date"] = boost::any(*checkoutDate);
    }
    if (city) {
      res["city"] = boost::any(*city);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityCounty) {
      res["city_county"] = boost::any(*cityCounty);
    }
    if (cityCountyCode) {
      res["city_county_code"] = boost::any(*cityCountyCode);
    }
    if (corpRefundFee) {
      res["corp_refund_fee"] = boost::any(*corpRefundFee);
    }
    if (corpTotalFee) {
      res["corp_total_fee"] = boost::any(*corpTotalFee);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (departmentId) {
      res["department_id"] = boost::any(*departmentId);
    }
    if (exceedReason) {
      res["exceed_reason"] = boost::any(*exceedReason);
    }
    if (feeType) {
      res["fee_type"] = boost::any(*feeType);
    }
    if (fees) {
      res["fees"] = boost::any(*fees);
    }
    if (fines) {
      res["fines"] = boost::any(*fines);
    }
    if (fuPointFee) {
      res["fu_point_fee"] = boost::any(*fuPointFee);
    }
    if (hotelName) {
      res["hotel_name"] = boost::any(*hotelName);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (isEarlyDeparture) {
      res["is_early_departure"] = boost::any(*isEarlyDeparture);
    }
    if (isNegotiation) {
      res["is_negotiation"] = boost::any(*isNegotiation);
    }
    if (isShareStr) {
      res["is_share_str"] = boost::any(*isShareStr);
    }
    if (nights) {
      res["nights"] = boost::any(*nights);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderPrice) {
      res["order_price"] = boost::any(*orderPrice);
    }
    if (orderType) {
      res["order_type"] = boost::any(*orderType);
    }
    if (overApplyId) {
      res["over_apply_id"] = boost::any(*overApplyId);
    }
    if (personRefundFee) {
      res["person_refund_fee"] = boost::any(*personRefundFee);
    }
    if (personSettlePrice) {
      res["person_settle_price"] = boost::any(*personSettlePrice);
    }
    if (primaryId) {
      res["primary_id"] = boost::any(*primaryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (promotionFee) {
      res["promotion_fee"] = boost::any(*promotionFee);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (reserveRule) {
      res["reserve_rule"] = boost::any(*reserveRule);
    }
    if (roomNo) {
      res["room_no"] = boost::any(*roomNo);
    }
    if (roomNumber) {
      res["room_number"] = boost::any(*roomNumber);
    }
    if (roomPrice) {
      res["room_price"] = boost::any(*roomPrice);
    }
    if (roomType) {
      res["room_type"] = boost::any(*roomType);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (settlementFee) {
      res["settlement_fee"] = boost::any(*settlementFee);
    }
    if (settlementGrantFee) {
      res["settlement_grant_fee"] = boost::any(*settlementGrantFee);
    }
    if (settlementTime) {
      res["settlement_time"] = boost::any(*settlementTime);
    }
    if (settlementType) {
      res["settlement_type"] = boost::any(*settlementType);
    }
    if (star) {
      res["star"] = boost::any(*star);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (taxRate) {
      res["tax_rate"] = boost::any(*taxRate);
    }
    if (thirdItineraryId) {
      res["third_itinerary_id"] = boost::any(*thirdItineraryId);
    }
    if (totalNights) {
      res["total_nights"] = boost::any(*totalNights);
    }
    if (travelerId) {
      res["traveler_id"] = boost::any(*travelerId);
    }
    if (travelerJobNo) {
      res["traveler_job_no"] = boost::any(*travelerJobNo);
    }
    if (travelerMemberTypeName) {
      res["traveler_member_type_name"] = boost::any(*travelerMemberTypeName);
    }
    if (travelerName) {
      res["traveler_name"] = boost::any(*travelerName);
    }
    if (voucherType) {
      res["voucher_type"] = boost::any(*voucherType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("apply_arr_city_code") != m.end() && !m["apply_arr_city_code"].empty()) {
      applyArrCityCode = make_shared<string>(boost::any_cast<string>(m["apply_arr_city_code"]));
    }
    if (m.find("apply_arr_city_name") != m.end() && !m["apply_arr_city_name"].empty()) {
      applyArrCityName = make_shared<string>(boost::any_cast<string>(m["apply_arr_city_name"]));
    }
    if (m.find("apply_dep_city_code") != m.end() && !m["apply_dep_city_code"].empty()) {
      applyDepCityCode = make_shared<string>(boost::any_cast<string>(m["apply_dep_city_code"]));
    }
    if (m.find("apply_dep_city_name") != m.end() && !m["apply_dep_city_name"].empty()) {
      applyDepCityName = make_shared<string>(boost::any_cast<string>(m["apply_dep_city_name"]));
    }
    if (m.find("apply_extend_field") != m.end() && !m["apply_extend_field"].empty()) {
      applyExtendField = make_shared<string>(boost::any_cast<string>(m["apply_extend_field"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("average_nights") != m.end() && !m["average_nights"].empty()) {
      averageNights = make_shared<string>(boost::any_cast<string>(m["average_nights"]));
    }
    if (m.find("bill_record_time") != m.end() && !m["bill_record_time"].empty()) {
      billRecordTime = make_shared<string>(boost::any_cast<string>(m["bill_record_time"]));
    }
    if (m.find("book_reason") != m.end() && !m["book_reason"].empty()) {
      bookReason = make_shared<string>(boost::any_cast<string>(m["book_reason"]));
    }
    if (m.find("book_time") != m.end() && !m["book_time"].empty()) {
      bookTime = make_shared<string>(boost::any_cast<string>(m["book_time"]));
    }
    if (m.find("booker_id") != m.end() && !m["booker_id"].empty()) {
      bookerId = make_shared<string>(boost::any_cast<string>(m["booker_id"]));
    }
    if (m.find("booker_job_no") != m.end() && !m["booker_job_no"].empty()) {
      bookerJobNo = make_shared<string>(boost::any_cast<string>(m["booker_job_no"]));
    }
    if (m.find("booker_name") != m.end() && !m["booker_name"].empty()) {
      bookerName = make_shared<string>(boost::any_cast<string>(m["booker_name"]));
    }
    if (m.find("brand_group") != m.end() && !m["brand_group"].empty()) {
      brandGroup = make_shared<string>(boost::any_cast<string>(m["brand_group"]));
    }
    if (m.find("brand_name") != m.end() && !m["brand_name"].empty()) {
      brandName = make_shared<string>(boost::any_cast<string>(m["brand_name"]));
    }
    if (m.find("business_trip_result") != m.end() && !m["business_trip_result"].empty()) {
      businessTripResult = make_shared<string>(boost::any_cast<string>(m["business_trip_result"]));
    }
    if (m.find("capital_direction") != m.end() && !m["capital_direction"].empty()) {
      capitalDirection = make_shared<string>(boost::any_cast<string>(m["capital_direction"]));
    }
    if (m.find("cascade_department") != m.end() && !m["cascade_department"].empty()) {
      cascadeDepartment = make_shared<string>(boost::any_cast<string>(m["cascade_department"]));
    }
    if (m.find("check_in_date") != m.end() && !m["check_in_date"].empty()) {
      checkInDate = make_shared<string>(boost::any_cast<string>(m["check_in_date"]));
    }
    if (m.find("checkout_date") != m.end() && !m["checkout_date"].empty()) {
      checkoutDate = make_shared<string>(boost::any_cast<string>(m["checkout_date"]));
    }
    if (m.find("city") != m.end() && !m["city"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["city"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_county") != m.end() && !m["city_county"].empty()) {
      cityCounty = make_shared<string>(boost::any_cast<string>(m["city_county"]));
    }
    if (m.find("city_county_code") != m.end() && !m["city_county_code"].empty()) {
      cityCountyCode = make_shared<string>(boost::any_cast<string>(m["city_county_code"]));
    }
    if (m.find("corp_refund_fee") != m.end() && !m["corp_refund_fee"].empty()) {
      corpRefundFee = make_shared<double>(boost::any_cast<double>(m["corp_refund_fee"]));
    }
    if (m.find("corp_total_fee") != m.end() && !m["corp_total_fee"].empty()) {
      corpTotalFee = make_shared<double>(boost::any_cast<double>(m["corp_total_fee"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("department_id") != m.end() && !m["department_id"].empty()) {
      departmentId = make_shared<string>(boost::any_cast<string>(m["department_id"]));
    }
    if (m.find("exceed_reason") != m.end() && !m["exceed_reason"].empty()) {
      exceedReason = make_shared<string>(boost::any_cast<string>(m["exceed_reason"]));
    }
    if (m.find("fee_type") != m.end() && !m["fee_type"].empty()) {
      feeType = make_shared<string>(boost::any_cast<string>(m["fee_type"]));
    }
    if (m.find("fees") != m.end() && !m["fees"].empty()) {
      fees = make_shared<double>(boost::any_cast<double>(m["fees"]));
    }
    if (m.find("fines") != m.end() && !m["fines"].empty()) {
      fines = make_shared<double>(boost::any_cast<double>(m["fines"]));
    }
    if (m.find("fu_point_fee") != m.end() && !m["fu_point_fee"].empty()) {
      fuPointFee = make_shared<double>(boost::any_cast<double>(m["fu_point_fee"]));
    }
    if (m.find("hotel_name") != m.end() && !m["hotel_name"].empty()) {
      hotelName = make_shared<string>(boost::any_cast<string>(m["hotel_name"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("is_early_departure") != m.end() && !m["is_early_departure"].empty()) {
      isEarlyDeparture = make_shared<string>(boost::any_cast<string>(m["is_early_departure"]));
    }
    if (m.find("is_negotiation") != m.end() && !m["is_negotiation"].empty()) {
      isNegotiation = make_shared<string>(boost::any_cast<string>(m["is_negotiation"]));
    }
    if (m.find("is_share_str") != m.end() && !m["is_share_str"].empty()) {
      isShareStr = make_shared<string>(boost::any_cast<string>(m["is_share_str"]));
    }
    if (m.find("nights") != m.end() && !m["nights"].empty()) {
      nights = make_shared<long>(boost::any_cast<long>(m["nights"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("order_price") != m.end() && !m["order_price"].empty()) {
      orderPrice = make_shared<double>(boost::any_cast<double>(m["order_price"]));
    }
    if (m.find("order_type") != m.end() && !m["order_type"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["order_type"]));
    }
    if (m.find("over_apply_id") != m.end() && !m["over_apply_id"].empty()) {
      overApplyId = make_shared<string>(boost::any_cast<string>(m["over_apply_id"]));
    }
    if (m.find("person_refund_fee") != m.end() && !m["person_refund_fee"].empty()) {
      personRefundFee = make_shared<double>(boost::any_cast<double>(m["person_refund_fee"]));
    }
    if (m.find("person_settle_price") != m.end() && !m["person_settle_price"].empty()) {
      personSettlePrice = make_shared<double>(boost::any_cast<double>(m["person_settle_price"]));
    }
    if (m.find("primary_id") != m.end() && !m["primary_id"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["primary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("promotion_fee") != m.end() && !m["promotion_fee"].empty()) {
      promotionFee = make_shared<double>(boost::any_cast<double>(m["promotion_fee"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("reserve_rule") != m.end() && !m["reserve_rule"].empty()) {
      reserveRule = make_shared<string>(boost::any_cast<string>(m["reserve_rule"]));
    }
    if (m.find("room_no") != m.end() && !m["room_no"].empty()) {
      roomNo = make_shared<string>(boost::any_cast<string>(m["room_no"]));
    }
    if (m.find("room_number") != m.end() && !m["room_number"].empty()) {
      roomNumber = make_shared<long>(boost::any_cast<long>(m["room_number"]));
    }
    if (m.find("room_price") != m.end() && !m["room_price"].empty()) {
      roomPrice = make_shared<double>(boost::any_cast<double>(m["room_price"]));
    }
    if (m.find("room_type") != m.end() && !m["room_type"].empty()) {
      roomType = make_shared<string>(boost::any_cast<string>(m["room_type"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<double>(boost::any_cast<double>(m["service_fee"]));
    }
    if (m.find("settlement_fee") != m.end() && !m["settlement_fee"].empty()) {
      settlementFee = make_shared<double>(boost::any_cast<double>(m["settlement_fee"]));
    }
    if (m.find("settlement_grant_fee") != m.end() && !m["settlement_grant_fee"].empty()) {
      settlementGrantFee = make_shared<double>(boost::any_cast<double>(m["settlement_grant_fee"]));
    }
    if (m.find("settlement_time") != m.end() && !m["settlement_time"].empty()) {
      settlementTime = make_shared<string>(boost::any_cast<string>(m["settlement_time"]));
    }
    if (m.find("settlement_type") != m.end() && !m["settlement_type"].empty()) {
      settlementType = make_shared<string>(boost::any_cast<string>(m["settlement_type"]));
    }
    if (m.find("star") != m.end() && !m["star"].empty()) {
      star = make_shared<string>(boost::any_cast<string>(m["star"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("tax_rate") != m.end() && !m["tax_rate"].empty()) {
      taxRate = make_shared<string>(boost::any_cast<string>(m["tax_rate"]));
    }
    if (m.find("third_itinerary_id") != m.end() && !m["third_itinerary_id"].empty()) {
      thirdItineraryId = make_shared<string>(boost::any_cast<string>(m["third_itinerary_id"]));
    }
    if (m.find("total_nights") != m.end() && !m["total_nights"].empty()) {
      totalNights = make_shared<long>(boost::any_cast<long>(m["total_nights"]));
    }
    if (m.find("traveler_id") != m.end() && !m["traveler_id"].empty()) {
      travelerId = make_shared<string>(boost::any_cast<string>(m["traveler_id"]));
    }
    if (m.find("traveler_job_no") != m.end() && !m["traveler_job_no"].empty()) {
      travelerJobNo = make_shared<string>(boost::any_cast<string>(m["traveler_job_no"]));
    }
    if (m.find("traveler_member_type_name") != m.end() && !m["traveler_member_type_name"].empty()) {
      travelerMemberTypeName = make_shared<string>(boost::any_cast<string>(m["traveler_member_type_name"]));
    }
    if (m.find("traveler_name") != m.end() && !m["traveler_name"].empty()) {
      travelerName = make_shared<string>(boost::any_cast<string>(m["traveler_name"]));
    }
    if (m.find("voucher_type") != m.end() && !m["voucher_type"].empty()) {
      voucherType = make_shared<long>(boost::any_cast<long>(m["voucher_type"]));
    }
  }


  virtual ~HotelBillSettlementQueryResponseBodyModuleDataList() = default;
};
class HotelBillSettlementQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> category{};
  shared_ptr<string> corpId{};
  shared_ptr<vector<HotelBillSettlementQueryResponseBodyModuleDataList>> dataList{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};
  shared_ptr<long> totalNum{};

  HotelBillSettlementQueryResponseBodyModule() {}

  explicit HotelBillSettlementQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_list"] = boost::any(temp1);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    if (totalNum) {
      res["total_num"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["category"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("data_list") != m.end() && !m["data_list"].empty()) {
      if (typeid(vector<boost::any>) == m["data_list"].type()) {
        vector<HotelBillSettlementQueryResponseBodyModuleDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelBillSettlementQueryResponseBodyModuleDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<HotelBillSettlementQueryResponseBodyModuleDataList>>(expect1);
      }
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
    if (m.find("total_num") != m.end() && !m["total_num"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["total_num"]));
    }
  }


  virtual ~HotelBillSettlementQueryResponseBodyModule() = default;
};
class HotelBillSettlementQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelBillSettlementQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelBillSettlementQueryResponseBody() {}

  explicit HotelBillSettlementQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelBillSettlementQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelBillSettlementQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelBillSettlementQueryResponseBody() = default;
};
class HotelBillSettlementQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelBillSettlementQueryResponseBody> body{};

  HotelBillSettlementQueryResponse() {}

  explicit HotelBillSettlementQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelBillSettlementQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelBillSettlementQueryResponseBody>(model1);
      }
    }
  }


  virtual ~HotelBillSettlementQueryResponse() = default;
};
class HotelCityCodeListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  HotelCityCodeListHeaders() {}

  explicit HotelCityCodeListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~HotelCityCodeListHeaders() = default;
};
class HotelCityCodeListRequest : public Darabonba::Model {
public:
  shared_ptr<string> countryCode{};

  HotelCityCodeListRequest() {}

  explicit HotelCityCodeListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (countryCode) {
      res["country_code"] = boost::any(*countryCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("country_code") != m.end() && !m["country_code"].empty()) {
      countryCode = make_shared<string>(boost::any_cast<string>(m["country_code"]));
    }
  }


  virtual ~HotelCityCodeListRequest() = default;
};
class HotelCityCodeListResponseBodyModuleCitysDistricts : public Darabonba::Model {
public:
  shared_ptr<string> districtCode{};
  shared_ptr<string> districtName{};

  HotelCityCodeListResponseBodyModuleCitysDistricts() {}

  explicit HotelCityCodeListResponseBodyModuleCitysDistricts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (districtCode) {
      res["district_code"] = boost::any(*districtCode);
    }
    if (districtName) {
      res["district_name"] = boost::any(*districtName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("district_code") != m.end() && !m["district_code"].empty()) {
      districtCode = make_shared<string>(boost::any_cast<string>(m["district_code"]));
    }
    if (m.find("district_name") != m.end() && !m["district_name"].empty()) {
      districtName = make_shared<string>(boost::any_cast<string>(m["district_name"]));
    }
  }


  virtual ~HotelCityCodeListResponseBodyModuleCitysDistricts() = default;
};
class HotelCityCodeListResponseBodyModuleCitys : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<vector<HotelCityCodeListResponseBodyModuleCitysDistricts>> districts{};

  HotelCityCodeListResponseBodyModuleCitys() {}

  explicit HotelCityCodeListResponseBodyModuleCitys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (districts) {
      vector<boost::any> temp1;
      for(auto item1:*districts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["districts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("districts") != m.end() && !m["districts"].empty()) {
      if (typeid(vector<boost::any>) == m["districts"].type()) {
        vector<HotelCityCodeListResponseBodyModuleCitysDistricts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["districts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelCityCodeListResponseBodyModuleCitysDistricts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        districts = make_shared<vector<HotelCityCodeListResponseBodyModuleCitysDistricts>>(expect1);
      }
    }
  }


  virtual ~HotelCityCodeListResponseBodyModuleCitys() = default;
};
class HotelCityCodeListResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<HotelCityCodeListResponseBodyModuleCitys>> citys{};
  shared_ptr<string> proviceCode{};
  shared_ptr<string> provinceName{};

  HotelCityCodeListResponseBodyModule() {}

  explicit HotelCityCodeListResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (citys) {
      vector<boost::any> temp1;
      for(auto item1:*citys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["citys"] = boost::any(temp1);
    }
    if (proviceCode) {
      res["provice_code"] = boost::any(*proviceCode);
    }
    if (provinceName) {
      res["province_name"] = boost::any(*provinceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("citys") != m.end() && !m["citys"].empty()) {
      if (typeid(vector<boost::any>) == m["citys"].type()) {
        vector<HotelCityCodeListResponseBodyModuleCitys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["citys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelCityCodeListResponseBodyModuleCitys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        citys = make_shared<vector<HotelCityCodeListResponseBodyModuleCitys>>(expect1);
      }
    }
    if (m.find("provice_code") != m.end() && !m["provice_code"].empty()) {
      proviceCode = make_shared<string>(boost::any_cast<string>(m["provice_code"]));
    }
    if (m.find("province_name") != m.end() && !m["province_name"].empty()) {
      provinceName = make_shared<string>(boost::any_cast<string>(m["province_name"]));
    }
  }


  virtual ~HotelCityCodeListResponseBodyModule() = default;
};
class HotelCityCodeListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<HotelCityCodeListResponseBodyModule>> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelCityCodeListResponseBody() {}

  explicit HotelCityCodeListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<HotelCityCodeListResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelCityCodeListResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<HotelCityCodeListResponseBodyModule>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelCityCodeListResponseBody() = default;
};
class HotelCityCodeListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelCityCodeListResponseBody> body{};

  HotelCityCodeListResponse() {}

  explicit HotelCityCodeListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelCityCodeListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelCityCodeListResponseBody>(model1);
      }
    }
  }


  virtual ~HotelCityCodeListResponse() = default;
};
class HotelExceedApplyQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  HotelExceedApplyQueryHeaders() {}

  explicit HotelExceedApplyQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~HotelExceedApplyQueryHeaders() = default;
};
class HotelExceedApplyQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};

  HotelExceedApplyQueryRequest() {}

  explicit HotelExceedApplyQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
  }


  virtual ~HotelExceedApplyQueryRequest() = default;
};
class HotelExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo : public Darabonba::Model {
public:
  shared_ptr<string> checkIn{};
  shared_ptr<string> checkOut{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<long> price{};
  shared_ptr<bool> together{};
  shared_ptr<long> type{};

  HotelExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo() {}

  explicit HotelExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (together) {
      res["together"] = boost::any(*together);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<string>(boost::any_cast<string>(m["check_out"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("together") != m.end() && !m["together"].empty()) {
      together = make_shared<bool>(boost::any_cast<bool>(m["together"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~HotelExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo() = default;
};
class HotelExceedApplyQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<HotelExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo> applyIntentionInfoDo{};
  shared_ptr<string> btripCause{};
  shared_ptr<string> corpId{};
  shared_ptr<string> exceedReason{};
  shared_ptr<long> exceedType{};
  shared_ptr<string> originStandard{};
  shared_ptr<long> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartCorpId{};
  shared_ptr<string> userId{};

  HotelExceedApplyQueryResponseBodyModule() {}

  explicit HotelExceedApplyQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (applyIntentionInfoDo) {
      res["apply_intention_info_do"] = applyIntentionInfoDo ? boost::any(applyIntentionInfoDo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (btripCause) {
      res["btrip_cause"] = boost::any(*btripCause);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (exceedReason) {
      res["exceed_reason"] = boost::any(*exceedReason);
    }
    if (exceedType) {
      res["exceed_type"] = boost::any(*exceedType);
    }
    if (originStandard) {
      res["origin_standard"] = boost::any(*originStandard);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (submitTime) {
      res["submit_time"] = boost::any(*submitTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartCorpId) {
      res["thirdpart_corp_id"] = boost::any(*thirdpartCorpId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("apply_intention_info_do") != m.end() && !m["apply_intention_info_do"].empty()) {
      if (typeid(map<string, boost::any>) == m["apply_intention_info_do"].type()) {
        HotelExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["apply_intention_info_do"]));
        applyIntentionInfoDo = make_shared<HotelExceedApplyQueryResponseBodyModuleApplyIntentionInfoDo>(model1);
      }
    }
    if (m.find("btrip_cause") != m.end() && !m["btrip_cause"].empty()) {
      btripCause = make_shared<string>(boost::any_cast<string>(m["btrip_cause"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("exceed_reason") != m.end() && !m["exceed_reason"].empty()) {
      exceedReason = make_shared<string>(boost::any_cast<string>(m["exceed_reason"]));
    }
    if (m.find("exceed_type") != m.end() && !m["exceed_type"].empty()) {
      exceedType = make_shared<long>(boost::any_cast<long>(m["exceed_type"]));
    }
    if (m.find("origin_standard") != m.end() && !m["origin_standard"].empty()) {
      originStandard = make_shared<string>(boost::any_cast<string>(m["origin_standard"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("submit_time") != m.end() && !m["submit_time"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["submit_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_corp_id") != m.end() && !m["thirdpart_corp_id"].empty()) {
      thirdpartCorpId = make_shared<string>(boost::any_cast<string>(m["thirdpart_corp_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~HotelExceedApplyQueryResponseBodyModule() = default;
};
class HotelExceedApplyQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelExceedApplyQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelExceedApplyQueryResponseBody() {}

  explicit HotelExceedApplyQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelExceedApplyQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelExceedApplyQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelExceedApplyQueryResponseBody() = default;
};
class HotelExceedApplyQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelExceedApplyQueryResponseBody> body{};

  HotelExceedApplyQueryResponse() {}

  explicit HotelExceedApplyQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelExceedApplyQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelExceedApplyQueryResponseBody>(model1);
      }
    }
  }


  virtual ~HotelExceedApplyQueryResponse() = default;
};
class HotelGoodsQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  HotelGoodsQueryHeaders() {}

  explicit HotelGoodsQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~HotelGoodsQueryHeaders() = default;
};
class HotelGoodsQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> adultNum{};
  shared_ptr<bool> agreementPrice{};
  shared_ptr<string> beginDate{};
  shared_ptr<bool> breakfastIncluded{};
  shared_ptr<string> btripUserId{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> endDate{};
  shared_ptr<string> hotelId{};
  shared_ptr<long> payOverType{};
  shared_ptr<long> paymentType{};
  shared_ptr<bool> specialInvoice{};
  shared_ptr<long> superMan{};

  HotelGoodsQueryRequest() {}

  explicit HotelGoodsQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adultNum) {
      res["adult_num"] = boost::any(*adultNum);
    }
    if (agreementPrice) {
      res["agreement_price"] = boost::any(*agreementPrice);
    }
    if (beginDate) {
      res["begin_date"] = boost::any(*beginDate);
    }
    if (breakfastIncluded) {
      res["breakfast_included"] = boost::any(*breakfastIncluded);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (endDate) {
      res["end_date"] = boost::any(*endDate);
    }
    if (hotelId) {
      res["hotel_id"] = boost::any(*hotelId);
    }
    if (payOverType) {
      res["pay_over_type"] = boost::any(*payOverType);
    }
    if (paymentType) {
      res["payment_type"] = boost::any(*paymentType);
    }
    if (specialInvoice) {
      res["special_invoice"] = boost::any(*specialInvoice);
    }
    if (superMan) {
      res["super_man"] = boost::any(*superMan);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("adult_num") != m.end() && !m["adult_num"].empty()) {
      adultNum = make_shared<string>(boost::any_cast<string>(m["adult_num"]));
    }
    if (m.find("agreement_price") != m.end() && !m["agreement_price"].empty()) {
      agreementPrice = make_shared<bool>(boost::any_cast<bool>(m["agreement_price"]));
    }
    if (m.find("begin_date") != m.end() && !m["begin_date"].empty()) {
      beginDate = make_shared<string>(boost::any_cast<string>(m["begin_date"]));
    }
    if (m.find("breakfast_included") != m.end() && !m["breakfast_included"].empty()) {
      breakfastIncluded = make_shared<bool>(boost::any_cast<bool>(m["breakfast_included"]));
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("end_date") != m.end() && !m["end_date"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["end_date"]));
    }
    if (m.find("hotel_id") != m.end() && !m["hotel_id"].empty()) {
      hotelId = make_shared<string>(boost::any_cast<string>(m["hotel_id"]));
    }
    if (m.find("pay_over_type") != m.end() && !m["pay_over_type"].empty()) {
      payOverType = make_shared<long>(boost::any_cast<long>(m["pay_over_type"]));
    }
    if (m.find("payment_type") != m.end() && !m["payment_type"].empty()) {
      paymentType = make_shared<long>(boost::any_cast<long>(m["payment_type"]));
    }
    if (m.find("special_invoice") != m.end() && !m["special_invoice"].empty()) {
      specialInvoice = make_shared<bool>(boost::any_cast<bool>(m["special_invoice"]));
    }
    if (m.find("super_man") != m.end() && !m["super_man"].empty()) {
      superMan = make_shared<long>(boost::any_cast<long>(m["super_man"]));
    }
  }


  virtual ~HotelGoodsQueryRequest() = default;
};
class HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList : public Darabonba::Model {
public:
  shared_ptr<long> hour{};
  shared_ptr<long> value{};

  HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList() {}

  explicit HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hour) {
      res["hour"] = boost::any(*hour);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hour") != m.end() && !m["hour"].empty()) {
      hour = make_shared<long>(boost::any_cast<long>(m["hour"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["value"]));
    }
  }


  virtual ~HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList() = default;
};
class HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTO : public Darabonba::Model {
public:
  shared_ptr<vector<HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList>> btripHotelCancelPolicyInfoDTOList{};
  shared_ptr<long> cancelPolicyType{};

  HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTO() {}

  explicit HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripHotelCancelPolicyInfoDTOList) {
      vector<boost::any> temp1;
      for(auto item1:*btripHotelCancelPolicyInfoDTOList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["btrip_hotel_cancel_policy_info_d_t_o_list"] = boost::any(temp1);
    }
    if (cancelPolicyType) {
      res["cancel_policy_type"] = boost::any(*cancelPolicyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_hotel_cancel_policy_info_d_t_o_list") != m.end() && !m["btrip_hotel_cancel_policy_info_d_t_o_list"].empty()) {
      if (typeid(vector<boost::any>) == m["btrip_hotel_cancel_policy_info_d_t_o_list"].type()) {
        vector<HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["btrip_hotel_cancel_policy_info_d_t_o_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        btripHotelCancelPolicyInfoDTOList = make_shared<vector<HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList>>(expect1);
      }
    }
    if (m.find("cancel_policy_type") != m.end() && !m["cancel_policy_type"].empty()) {
      cancelPolicyType = make_shared<long>(boost::any_cast<long>(m["cancel_policy_type"]));
    }
  }


  virtual ~HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTO() = default;
};
class HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRule : public Darabonba::Model {
public:
  shared_ptr<HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTO> btripHotelCancelPolicyDTO{};
  shared_ptr<string> cancelPolicyTitle{};
  shared_ptr<string> checkIn{};

  HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRule() {}

  explicit HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripHotelCancelPolicyDTO) {
      res["btrip_hotel_cancel_policy_d_t_o"] = btripHotelCancelPolicyDTO ? boost::any(btripHotelCancelPolicyDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cancelPolicyTitle) {
      res["cancel_policy_title"] = boost::any(*cancelPolicyTitle);
    }
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_hotel_cancel_policy_d_t_o") != m.end() && !m["btrip_hotel_cancel_policy_d_t_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["btrip_hotel_cancel_policy_d_t_o"].type()) {
        HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["btrip_hotel_cancel_policy_d_t_o"]));
        btripHotelCancelPolicyDTO = make_shared<HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRuleBtripHotelCancelPolicyDTO>(model1);
      }
    }
    if (m.find("cancel_policy_title") != m.end() && !m["cancel_policy_title"].empty()) {
      cancelPolicyTitle = make_shared<string>(boost::any_cast<string>(m["cancel_policy_title"]));
    }
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
  }


  virtual ~HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRule() = default;
};
class HotelGoodsQueryResponseBodyModuleRoomsRatesBtripHotelCancelDesc : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> title{};

  HotelGoodsQueryResponseBodyModuleRoomsRatesBtripHotelCancelDesc() {}

  explicit HotelGoodsQueryResponseBodyModuleRoomsRatesBtripHotelCancelDesc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~HotelGoodsQueryResponseBodyModuleRoomsRatesBtripHotelCancelDesc() = default;
};
class HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDescDiscountDetail : public Darabonba::Model {
public:
  shared_ptr<vector<string>> labelName{};
  shared_ptr<string> moneyDesc{};

  HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDescDiscountDetail() {}

  explicit HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDescDiscountDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labelName) {
      res["label_name"] = boost::any(*labelName);
    }
    if (moneyDesc) {
      res["money_desc"] = boost::any(*moneyDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("label_name") != m.end() && !m["label_name"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["label_name"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["label_name"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labelName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("money_desc") != m.end() && !m["money_desc"].empty()) {
      moneyDesc = make_shared<string>(boost::any_cast<string>(m["money_desc"]));
    }
  }


  virtual ~HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDescDiscountDetail() = default;
};
class HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDesc : public Darabonba::Model {
public:
  shared_ptr<string> cashReduceTotal{};
  shared_ptr<string> dinamicLabel{};
  shared_ptr<vector<HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDescDiscountDetail>> discountDetail{};
  shared_ptr<string> subTitle{};
  shared_ptr<string> title{};

  HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDesc() {}

  explicit HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDesc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cashReduceTotal) {
      res["cash_reduce_total"] = boost::any(*cashReduceTotal);
    }
    if (dinamicLabel) {
      res["dinamic_label"] = boost::any(*dinamicLabel);
    }
    if (discountDetail) {
      vector<boost::any> temp1;
      for(auto item1:*discountDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["discount_detail"] = boost::any(temp1);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cash_reduce_total") != m.end() && !m["cash_reduce_total"].empty()) {
      cashReduceTotal = make_shared<string>(boost::any_cast<string>(m["cash_reduce_total"]));
    }
    if (m.find("dinamic_label") != m.end() && !m["dinamic_label"].empty()) {
      dinamicLabel = make_shared<string>(boost::any_cast<string>(m["dinamic_label"]));
    }
    if (m.find("discount_detail") != m.end() && !m["discount_detail"].empty()) {
      if (typeid(vector<boost::any>) == m["discount_detail"].type()) {
        vector<HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDescDiscountDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["discount_detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDescDiscountDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        discountDetail = make_shared<vector<HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDescDiscountDetail>>(expect1);
      }
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDesc() = default;
};
class HotelGoodsQueryResponseBodyModuleRoomsRatesHotelDetailRatePriceDTO : public Darabonba::Model {
public:
  shared_ptr<long> beforeDiscountPrice{};
  shared_ptr<string> breakfast{};
  shared_ptr<long> discountPrice{};
  shared_ptr<long> lastDiscountsPrice{};
  shared_ptr<long> lastDiscountsRoundingPrice{};
  shared_ptr<long> lastNum{};
  shared_ptr<string> rateStartTime{};
  shared_ptr<long> status{};

  HotelGoodsQueryResponseBodyModuleRoomsRatesHotelDetailRatePriceDTO() {}

  explicit HotelGoodsQueryResponseBodyModuleRoomsRatesHotelDetailRatePriceDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beforeDiscountPrice) {
      res["before_discount_price"] = boost::any(*beforeDiscountPrice);
    }
    if (breakfast) {
      res["breakfast"] = boost::any(*breakfast);
    }
    if (discountPrice) {
      res["discount_price"] = boost::any(*discountPrice);
    }
    if (lastDiscountsPrice) {
      res["last_discounts_price"] = boost::any(*lastDiscountsPrice);
    }
    if (lastDiscountsRoundingPrice) {
      res["last_discounts_rounding_price"] = boost::any(*lastDiscountsRoundingPrice);
    }
    if (lastNum) {
      res["last_num"] = boost::any(*lastNum);
    }
    if (rateStartTime) {
      res["rate_start_time"] = boost::any(*rateStartTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("before_discount_price") != m.end() && !m["before_discount_price"].empty()) {
      beforeDiscountPrice = make_shared<long>(boost::any_cast<long>(m["before_discount_price"]));
    }
    if (m.find("breakfast") != m.end() && !m["breakfast"].empty()) {
      breakfast = make_shared<string>(boost::any_cast<string>(m["breakfast"]));
    }
    if (m.find("discount_price") != m.end() && !m["discount_price"].empty()) {
      discountPrice = make_shared<long>(boost::any_cast<long>(m["discount_price"]));
    }
    if (m.find("last_discounts_price") != m.end() && !m["last_discounts_price"].empty()) {
      lastDiscountsPrice = make_shared<long>(boost::any_cast<long>(m["last_discounts_price"]));
    }
    if (m.find("last_discounts_rounding_price") != m.end() && !m["last_discounts_rounding_price"].empty()) {
      lastDiscountsRoundingPrice = make_shared<long>(boost::any_cast<long>(m["last_discounts_rounding_price"]));
    }
    if (m.find("last_num") != m.end() && !m["last_num"].empty()) {
      lastNum = make_shared<long>(boost::any_cast<long>(m["last_num"]));
    }
    if (m.find("rate_start_time") != m.end() && !m["rate_start_time"].empty()) {
      rateStartTime = make_shared<string>(boost::any_cast<string>(m["rate_start_time"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
  }


  virtual ~HotelGoodsQueryResponseBodyModuleRoomsRatesHotelDetailRatePriceDTO() = default;
};
class HotelGoodsQueryResponseBodyModuleRoomsRates : public Darabonba::Model {
public:
  shared_ptr<string> bedDesc{};
  shared_ptr<string> bedType{};
  shared_ptr<string> breakfast{};
  shared_ptr<HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRule> btripCancelRule{};
  shared_ptr<vector<HotelGoodsQueryResponseBodyModuleRoomsRatesBtripHotelCancelDesc>> btripHotelCancelDesc{};
  shared_ptr<bool> canSmoking{};
  shared_ptr<string> cancelPolicyDesc{};
  shared_ptr<long> cancelPolicyType{};
  shared_ptr<string> companyAassist{};
  shared_ptr<long> confirmType{};
  shared_ptr<string> currencyCode{};
  shared_ptr<string> dailyPriceFormatYuan{};
  shared_ptr<string> dailyPriceView{};
  shared_ptr<HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDesc> discountDesc{};
  shared_ptr<string> endTimeDaily{};
  shared_ptr<vector<HotelGoodsQueryResponseBodyModuleRoomsRatesHotelDetailRatePriceDTO>> hotelDetailRatePriceDTO{};
  shared_ptr<bool> instantConfirm{};
  shared_ptr<string> inventoryPrice{};
  shared_ptr<bool> isBusinessPay4Goods{};
  shared_ptr<long> isGuarantee{};
  shared_ptr<bool> isNeedEmail{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lastCancelTime{};
  shared_ptr<long> maxOccupancy{};
  shared_ptr<long> minAdvHours{};
  shared_ptr<long> minDays{};
  shared_ptr<long> nod{};
  shared_ptr<long> nop{};
  shared_ptr<long> orderShipTime{};
  shared_ptr<long> paymentType{};
  shared_ptr<long> priceType{};
  shared_ptr<string> promotionInfo{};
  shared_ptr<long> rateId{};
  shared_ptr<string> ratePlanName{};
  shared_ptr<long> rpId{};
  shared_ptr<long> sellerId{};
  shared_ptr<string> startTimeDaily{};
  shared_ptr<long> status{};
  shared_ptr<string> supplierCode{};
  shared_ptr<string> supplierName{};
  shared_ptr<bool> supportSpecialInvoice{};
  shared_ptr<string> unroundingDailyPriceFormatYuan{};

  HotelGoodsQueryResponseBodyModuleRoomsRates() {}

  explicit HotelGoodsQueryResponseBodyModuleRoomsRates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bedDesc) {
      res["bed_desc"] = boost::any(*bedDesc);
    }
    if (bedType) {
      res["bed_type"] = boost::any(*bedType);
    }
    if (breakfast) {
      res["breakfast"] = boost::any(*breakfast);
    }
    if (btripCancelRule) {
      res["btrip_cancel_rule"] = btripCancelRule ? boost::any(btripCancelRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (btripHotelCancelDesc) {
      vector<boost::any> temp1;
      for(auto item1:*btripHotelCancelDesc){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["btrip_hotel_cancel_desc"] = boost::any(temp1);
    }
    if (canSmoking) {
      res["can_smoking"] = boost::any(*canSmoking);
    }
    if (cancelPolicyDesc) {
      res["cancel_policy_desc"] = boost::any(*cancelPolicyDesc);
    }
    if (cancelPolicyType) {
      res["cancel_policy_type"] = boost::any(*cancelPolicyType);
    }
    if (companyAassist) {
      res["company_aassist"] = boost::any(*companyAassist);
    }
    if (confirmType) {
      res["confirm_type"] = boost::any(*confirmType);
    }
    if (currencyCode) {
      res["currency_code"] = boost::any(*currencyCode);
    }
    if (dailyPriceFormatYuan) {
      res["daily_price_format_yuan"] = boost::any(*dailyPriceFormatYuan);
    }
    if (dailyPriceView) {
      res["daily_price_view"] = boost::any(*dailyPriceView);
    }
    if (discountDesc) {
      res["discount_desc"] = discountDesc ? boost::any(discountDesc->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (endTimeDaily) {
      res["end_time_daily"] = boost::any(*endTimeDaily);
    }
    if (hotelDetailRatePriceDTO) {
      vector<boost::any> temp1;
      for(auto item1:*hotelDetailRatePriceDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_detail_rate_price_d_t_o"] = boost::any(temp1);
    }
    if (instantConfirm) {
      res["instant_confirm"] = boost::any(*instantConfirm);
    }
    if (inventoryPrice) {
      res["inventory_price"] = boost::any(*inventoryPrice);
    }
    if (isBusinessPay4Goods) {
      res["is_business_pay4_goods"] = boost::any(*isBusinessPay4Goods);
    }
    if (isGuarantee) {
      res["is_guarantee"] = boost::any(*isGuarantee);
    }
    if (isNeedEmail) {
      res["is_need_email"] = boost::any(*isNeedEmail);
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (lastCancelTime) {
      res["last_cancel_time"] = boost::any(*lastCancelTime);
    }
    if (maxOccupancy) {
      res["max_occupancy"] = boost::any(*maxOccupancy);
    }
    if (minAdvHours) {
      res["min_adv_hours"] = boost::any(*minAdvHours);
    }
    if (minDays) {
      res["min_days"] = boost::any(*minDays);
    }
    if (nod) {
      res["nod"] = boost::any(*nod);
    }
    if (nop) {
      res["nop"] = boost::any(*nop);
    }
    if (orderShipTime) {
      res["order_ship_time"] = boost::any(*orderShipTime);
    }
    if (paymentType) {
      res["payment_type"] = boost::any(*paymentType);
    }
    if (priceType) {
      res["price_type"] = boost::any(*priceType);
    }
    if (promotionInfo) {
      res["promotion_info"] = boost::any(*promotionInfo);
    }
    if (rateId) {
      res["rate_id"] = boost::any(*rateId);
    }
    if (ratePlanName) {
      res["rate_plan_name"] = boost::any(*ratePlanName);
    }
    if (rpId) {
      res["rp_id"] = boost::any(*rpId);
    }
    if (sellerId) {
      res["seller_id"] = boost::any(*sellerId);
    }
    if (startTimeDaily) {
      res["start_time_daily"] = boost::any(*startTimeDaily);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (supplierCode) {
      res["supplier_code"] = boost::any(*supplierCode);
    }
    if (supplierName) {
      res["supplier_name"] = boost::any(*supplierName);
    }
    if (supportSpecialInvoice) {
      res["support_special_invoice"] = boost::any(*supportSpecialInvoice);
    }
    if (unroundingDailyPriceFormatYuan) {
      res["unrounding_daily_price_format_yuan"] = boost::any(*unroundingDailyPriceFormatYuan);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bed_desc") != m.end() && !m["bed_desc"].empty()) {
      bedDesc = make_shared<string>(boost::any_cast<string>(m["bed_desc"]));
    }
    if (m.find("bed_type") != m.end() && !m["bed_type"].empty()) {
      bedType = make_shared<string>(boost::any_cast<string>(m["bed_type"]));
    }
    if (m.find("breakfast") != m.end() && !m["breakfast"].empty()) {
      breakfast = make_shared<string>(boost::any_cast<string>(m["breakfast"]));
    }
    if (m.find("btrip_cancel_rule") != m.end() && !m["btrip_cancel_rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["btrip_cancel_rule"].type()) {
        HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["btrip_cancel_rule"]));
        btripCancelRule = make_shared<HotelGoodsQueryResponseBodyModuleRoomsRatesBtripCancelRule>(model1);
      }
    }
    if (m.find("btrip_hotel_cancel_desc") != m.end() && !m["btrip_hotel_cancel_desc"].empty()) {
      if (typeid(vector<boost::any>) == m["btrip_hotel_cancel_desc"].type()) {
        vector<HotelGoodsQueryResponseBodyModuleRoomsRatesBtripHotelCancelDesc> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["btrip_hotel_cancel_desc"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelGoodsQueryResponseBodyModuleRoomsRatesBtripHotelCancelDesc model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        btripHotelCancelDesc = make_shared<vector<HotelGoodsQueryResponseBodyModuleRoomsRatesBtripHotelCancelDesc>>(expect1);
      }
    }
    if (m.find("can_smoking") != m.end() && !m["can_smoking"].empty()) {
      canSmoking = make_shared<bool>(boost::any_cast<bool>(m["can_smoking"]));
    }
    if (m.find("cancel_policy_desc") != m.end() && !m["cancel_policy_desc"].empty()) {
      cancelPolicyDesc = make_shared<string>(boost::any_cast<string>(m["cancel_policy_desc"]));
    }
    if (m.find("cancel_policy_type") != m.end() && !m["cancel_policy_type"].empty()) {
      cancelPolicyType = make_shared<long>(boost::any_cast<long>(m["cancel_policy_type"]));
    }
    if (m.find("company_aassist") != m.end() && !m["company_aassist"].empty()) {
      companyAassist = make_shared<string>(boost::any_cast<string>(m["company_aassist"]));
    }
    if (m.find("confirm_type") != m.end() && !m["confirm_type"].empty()) {
      confirmType = make_shared<long>(boost::any_cast<long>(m["confirm_type"]));
    }
    if (m.find("currency_code") != m.end() && !m["currency_code"].empty()) {
      currencyCode = make_shared<string>(boost::any_cast<string>(m["currency_code"]));
    }
    if (m.find("daily_price_format_yuan") != m.end() && !m["daily_price_format_yuan"].empty()) {
      dailyPriceFormatYuan = make_shared<string>(boost::any_cast<string>(m["daily_price_format_yuan"]));
    }
    if (m.find("daily_price_view") != m.end() && !m["daily_price_view"].empty()) {
      dailyPriceView = make_shared<string>(boost::any_cast<string>(m["daily_price_view"]));
    }
    if (m.find("discount_desc") != m.end() && !m["discount_desc"].empty()) {
      if (typeid(map<string, boost::any>) == m["discount_desc"].type()) {
        HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDesc model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["discount_desc"]));
        discountDesc = make_shared<HotelGoodsQueryResponseBodyModuleRoomsRatesDiscountDesc>(model1);
      }
    }
    if (m.find("end_time_daily") != m.end() && !m["end_time_daily"].empty()) {
      endTimeDaily = make_shared<string>(boost::any_cast<string>(m["end_time_daily"]));
    }
    if (m.find("hotel_detail_rate_price_d_t_o") != m.end() && !m["hotel_detail_rate_price_d_t_o"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_detail_rate_price_d_t_o"].type()) {
        vector<HotelGoodsQueryResponseBodyModuleRoomsRatesHotelDetailRatePriceDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_detail_rate_price_d_t_o"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelGoodsQueryResponseBodyModuleRoomsRatesHotelDetailRatePriceDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelDetailRatePriceDTO = make_shared<vector<HotelGoodsQueryResponseBodyModuleRoomsRatesHotelDetailRatePriceDTO>>(expect1);
      }
    }
    if (m.find("instant_confirm") != m.end() && !m["instant_confirm"].empty()) {
      instantConfirm = make_shared<bool>(boost::any_cast<bool>(m["instant_confirm"]));
    }
    if (m.find("inventory_price") != m.end() && !m["inventory_price"].empty()) {
      inventoryPrice = make_shared<string>(boost::any_cast<string>(m["inventory_price"]));
    }
    if (m.find("is_business_pay4_goods") != m.end() && !m["is_business_pay4_goods"].empty()) {
      isBusinessPay4Goods = make_shared<bool>(boost::any_cast<bool>(m["is_business_pay4_goods"]));
    }
    if (m.find("is_guarantee") != m.end() && !m["is_guarantee"].empty()) {
      isGuarantee = make_shared<long>(boost::any_cast<long>(m["is_guarantee"]));
    }
    if (m.find("is_need_email") != m.end() && !m["is_need_email"].empty()) {
      isNeedEmail = make_shared<bool>(boost::any_cast<bool>(m["is_need_email"]));
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["item_id"]));
    }
    if (m.find("last_cancel_time") != m.end() && !m["last_cancel_time"].empty()) {
      lastCancelTime = make_shared<string>(boost::any_cast<string>(m["last_cancel_time"]));
    }
    if (m.find("max_occupancy") != m.end() && !m["max_occupancy"].empty()) {
      maxOccupancy = make_shared<long>(boost::any_cast<long>(m["max_occupancy"]));
    }
    if (m.find("min_adv_hours") != m.end() && !m["min_adv_hours"].empty()) {
      minAdvHours = make_shared<long>(boost::any_cast<long>(m["min_adv_hours"]));
    }
    if (m.find("min_days") != m.end() && !m["min_days"].empty()) {
      minDays = make_shared<long>(boost::any_cast<long>(m["min_days"]));
    }
    if (m.find("nod") != m.end() && !m["nod"].empty()) {
      nod = make_shared<long>(boost::any_cast<long>(m["nod"]));
    }
    if (m.find("nop") != m.end() && !m["nop"].empty()) {
      nop = make_shared<long>(boost::any_cast<long>(m["nop"]));
    }
    if (m.find("order_ship_time") != m.end() && !m["order_ship_time"].empty()) {
      orderShipTime = make_shared<long>(boost::any_cast<long>(m["order_ship_time"]));
    }
    if (m.find("payment_type") != m.end() && !m["payment_type"].empty()) {
      paymentType = make_shared<long>(boost::any_cast<long>(m["payment_type"]));
    }
    if (m.find("price_type") != m.end() && !m["price_type"].empty()) {
      priceType = make_shared<long>(boost::any_cast<long>(m["price_type"]));
    }
    if (m.find("promotion_info") != m.end() && !m["promotion_info"].empty()) {
      promotionInfo = make_shared<string>(boost::any_cast<string>(m["promotion_info"]));
    }
    if (m.find("rate_id") != m.end() && !m["rate_id"].empty()) {
      rateId = make_shared<long>(boost::any_cast<long>(m["rate_id"]));
    }
    if (m.find("rate_plan_name") != m.end() && !m["rate_plan_name"].empty()) {
      ratePlanName = make_shared<string>(boost::any_cast<string>(m["rate_plan_name"]));
    }
    if (m.find("rp_id") != m.end() && !m["rp_id"].empty()) {
      rpId = make_shared<long>(boost::any_cast<long>(m["rp_id"]));
    }
    if (m.find("seller_id") != m.end() && !m["seller_id"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["seller_id"]));
    }
    if (m.find("start_time_daily") != m.end() && !m["start_time_daily"].empty()) {
      startTimeDaily = make_shared<string>(boost::any_cast<string>(m["start_time_daily"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("supplier_code") != m.end() && !m["supplier_code"].empty()) {
      supplierCode = make_shared<string>(boost::any_cast<string>(m["supplier_code"]));
    }
    if (m.find("supplier_name") != m.end() && !m["supplier_name"].empty()) {
      supplierName = make_shared<string>(boost::any_cast<string>(m["supplier_name"]));
    }
    if (m.find("support_special_invoice") != m.end() && !m["support_special_invoice"].empty()) {
      supportSpecialInvoice = make_shared<bool>(boost::any_cast<bool>(m["support_special_invoice"]));
    }
    if (m.find("unrounding_daily_price_format_yuan") != m.end() && !m["unrounding_daily_price_format_yuan"].empty()) {
      unroundingDailyPriceFormatYuan = make_shared<string>(boost::any_cast<string>(m["unrounding_daily_price_format_yuan"]));
    }
  }


  virtual ~HotelGoodsQueryResponseBodyModuleRoomsRates() = default;
};
class HotelGoodsQueryResponseBodyModuleRoomsRoomService : public Darabonba::Model {
public:
  shared_ptr<string> color{};
  shared_ptr<string> desc{};
  shared_ptr<string> highlightColorColor{};
  shared_ptr<string> title{};

  HotelGoodsQueryResponseBodyModuleRoomsRoomService() {}

  explicit HotelGoodsQueryResponseBodyModuleRoomsRoomService(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (color) {
      res["color"] = boost::any(*color);
    }
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (highlightColorColor) {
      res["highlight_color_color"] = boost::any(*highlightColorColor);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("color") != m.end() && !m["color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["color"]));
    }
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("highlight_color_color") != m.end() && !m["highlight_color_color"].empty()) {
      highlightColorColor = make_shared<string>(boost::any_cast<string>(m["highlight_color_color"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~HotelGoodsQueryResponseBodyModuleRoomsRoomService() = default;
};
class HotelGoodsQueryResponseBodyModuleRooms : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> bedTypeString{};
  shared_ptr<bool> extraBed{};
  shared_ptr<string> facility{};
  shared_ptr<string> floor{};
  shared_ptr<long> maxOccupancy{};
  shared_ptr<string> name{};
  shared_ptr<string> networkService{};
  shared_ptr<string> pics{};
  shared_ptr<vector<HotelGoodsQueryResponseBodyModuleRoomsRates>> rates{};
  shared_ptr<string> roomDasc{};
  shared_ptr<vector<string>> roomFacility{};
  shared_ptr<vector<HotelGoodsQueryResponseBodyModuleRoomsRoomService>> roomService{};
  shared_ptr<long> srid{};
  shared_ptr<long> status{};
  shared_ptr<string> windowType{};

  HotelGoodsQueryResponseBodyModuleRooms() {}

  explicit HotelGoodsQueryResponseBodyModuleRooms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["area"] = boost::any(*area);
    }
    if (bedTypeString) {
      res["bed_type_string"] = boost::any(*bedTypeString);
    }
    if (extraBed) {
      res["extra_bed"] = boost::any(*extraBed);
    }
    if (facility) {
      res["facility"] = boost::any(*facility);
    }
    if (floor) {
      res["floor"] = boost::any(*floor);
    }
    if (maxOccupancy) {
      res["max_occupancy"] = boost::any(*maxOccupancy);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (networkService) {
      res["network_service"] = boost::any(*networkService);
    }
    if (pics) {
      res["pics"] = boost::any(*pics);
    }
    if (rates) {
      vector<boost::any> temp1;
      for(auto item1:*rates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["rates"] = boost::any(temp1);
    }
    if (roomDasc) {
      res["room_dasc"] = boost::any(*roomDasc);
    }
    if (roomFacility) {
      res["room_facility"] = boost::any(*roomFacility);
    }
    if (roomService) {
      vector<boost::any> temp1;
      for(auto item1:*roomService){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["room_service"] = boost::any(temp1);
    }
    if (srid) {
      res["srid"] = boost::any(*srid);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (windowType) {
      res["window_type"] = boost::any(*windowType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("area") != m.end() && !m["area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["area"]));
    }
    if (m.find("bed_type_string") != m.end() && !m["bed_type_string"].empty()) {
      bedTypeString = make_shared<string>(boost::any_cast<string>(m["bed_type_string"]));
    }
    if (m.find("extra_bed") != m.end() && !m["extra_bed"].empty()) {
      extraBed = make_shared<bool>(boost::any_cast<bool>(m["extra_bed"]));
    }
    if (m.find("facility") != m.end() && !m["facility"].empty()) {
      facility = make_shared<string>(boost::any_cast<string>(m["facility"]));
    }
    if (m.find("floor") != m.end() && !m["floor"].empty()) {
      floor = make_shared<string>(boost::any_cast<string>(m["floor"]));
    }
    if (m.find("max_occupancy") != m.end() && !m["max_occupancy"].empty()) {
      maxOccupancy = make_shared<long>(boost::any_cast<long>(m["max_occupancy"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("network_service") != m.end() && !m["network_service"].empty()) {
      networkService = make_shared<string>(boost::any_cast<string>(m["network_service"]));
    }
    if (m.find("pics") != m.end() && !m["pics"].empty()) {
      pics = make_shared<string>(boost::any_cast<string>(m["pics"]));
    }
    if (m.find("rates") != m.end() && !m["rates"].empty()) {
      if (typeid(vector<boost::any>) == m["rates"].type()) {
        vector<HotelGoodsQueryResponseBodyModuleRoomsRates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["rates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelGoodsQueryResponseBodyModuleRoomsRates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rates = make_shared<vector<HotelGoodsQueryResponseBodyModuleRoomsRates>>(expect1);
      }
    }
    if (m.find("room_dasc") != m.end() && !m["room_dasc"].empty()) {
      roomDasc = make_shared<string>(boost::any_cast<string>(m["room_dasc"]));
    }
    if (m.find("room_facility") != m.end() && !m["room_facility"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["room_facility"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["room_facility"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roomFacility = make_shared<vector<string>>(toVec1);
    }
    if (m.find("room_service") != m.end() && !m["room_service"].empty()) {
      if (typeid(vector<boost::any>) == m["room_service"].type()) {
        vector<HotelGoodsQueryResponseBodyModuleRoomsRoomService> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["room_service"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelGoodsQueryResponseBodyModuleRoomsRoomService model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roomService = make_shared<vector<HotelGoodsQueryResponseBodyModuleRoomsRoomService>>(expect1);
      }
    }
    if (m.find("srid") != m.end() && !m["srid"].empty()) {
      srid = make_shared<long>(boost::any_cast<long>(m["srid"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("window_type") != m.end() && !m["window_type"].empty()) {
      windowType = make_shared<string>(boost::any_cast<string>(m["window_type"]));
    }
  }


  virtual ~HotelGoodsQueryResponseBodyModuleRooms() = default;
};
class HotelGoodsQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<map<string, string>> bookingInstructions{};
  shared_ptr<bool> canForeigner{};
  shared_ptr<string> checkIn{};
  shared_ptr<string> checkOut{};
  shared_ptr<vector<string>> descriptions{};
  shared_ptr<vector<string>> dinamicBannerPicUrls{};
  shared_ptr<string> earlyArrivalTime{};
  shared_ptr<long> hotelId{};
  shared_ptr<string> hotelName{};
  shared_ptr<string> lateArrivalTime{};
  shared_ptr<vector<HotelGoodsQueryResponseBodyModuleRooms>> rooms{};
  shared_ptr<string> searchId{};

  HotelGoodsQueryResponseBodyModule() {}

  explicit HotelGoodsQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["address"] = boost::any(*address);
    }
    if (bookingInstructions) {
      res["booking_instructions"] = boost::any(*bookingInstructions);
    }
    if (canForeigner) {
      res["can_foreigner"] = boost::any(*canForeigner);
    }
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (descriptions) {
      res["descriptions"] = boost::any(*descriptions);
    }
    if (dinamicBannerPicUrls) {
      res["dinamic_banner_pic_urls"] = boost::any(*dinamicBannerPicUrls);
    }
    if (earlyArrivalTime) {
      res["early_arrival_time"] = boost::any(*earlyArrivalTime);
    }
    if (hotelId) {
      res["hotel_id"] = boost::any(*hotelId);
    }
    if (hotelName) {
      res["hotel_name"] = boost::any(*hotelName);
    }
    if (lateArrivalTime) {
      res["late_arrival_time"] = boost::any(*lateArrivalTime);
    }
    if (rooms) {
      vector<boost::any> temp1;
      for(auto item1:*rooms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["rooms"] = boost::any(temp1);
    }
    if (searchId) {
      res["search_id"] = boost::any(*searchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("address") != m.end() && !m["address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["address"]));
    }
    if (m.find("booking_instructions") != m.end() && !m["booking_instructions"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["booking_instructions"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      bookingInstructions = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("can_foreigner") != m.end() && !m["can_foreigner"].empty()) {
      canForeigner = make_shared<bool>(boost::any_cast<bool>(m["can_foreigner"]));
    }
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<string>(boost::any_cast<string>(m["check_out"]));
    }
    if (m.find("descriptions") != m.end() && !m["descriptions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["descriptions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["descriptions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      descriptions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("dinamic_banner_pic_urls") != m.end() && !m["dinamic_banner_pic_urls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["dinamic_banner_pic_urls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["dinamic_banner_pic_urls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dinamicBannerPicUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("early_arrival_time") != m.end() && !m["early_arrival_time"].empty()) {
      earlyArrivalTime = make_shared<string>(boost::any_cast<string>(m["early_arrival_time"]));
    }
    if (m.find("hotel_id") != m.end() && !m["hotel_id"].empty()) {
      hotelId = make_shared<long>(boost::any_cast<long>(m["hotel_id"]));
    }
    if (m.find("hotel_name") != m.end() && !m["hotel_name"].empty()) {
      hotelName = make_shared<string>(boost::any_cast<string>(m["hotel_name"]));
    }
    if (m.find("late_arrival_time") != m.end() && !m["late_arrival_time"].empty()) {
      lateArrivalTime = make_shared<string>(boost::any_cast<string>(m["late_arrival_time"]));
    }
    if (m.find("rooms") != m.end() && !m["rooms"].empty()) {
      if (typeid(vector<boost::any>) == m["rooms"].type()) {
        vector<HotelGoodsQueryResponseBodyModuleRooms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["rooms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelGoodsQueryResponseBodyModuleRooms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rooms = make_shared<vector<HotelGoodsQueryResponseBodyModuleRooms>>(expect1);
      }
    }
    if (m.find("search_id") != m.end() && !m["search_id"].empty()) {
      searchId = make_shared<string>(boost::any_cast<string>(m["search_id"]));
    }
  }


  virtual ~HotelGoodsQueryResponseBodyModule() = default;
};
class HotelGoodsQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelGoodsQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelGoodsQueryResponseBody() {}

  explicit HotelGoodsQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelGoodsQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelGoodsQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelGoodsQueryResponseBody() = default;
};
class HotelGoodsQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelGoodsQueryResponseBody> body{};

  HotelGoodsQueryResponse() {}

  explicit HotelGoodsQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelGoodsQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelGoodsQueryResponseBody>(model1);
      }
    }
  }


  virtual ~HotelGoodsQueryResponse() = default;
};
class HotelIndexInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  HotelIndexInfoHeaders() {}

  explicit HotelIndexInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~HotelIndexInfoHeaders() = default;
};
class HotelIndexInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> cityCode{};
  shared_ptr<long> hotelStatus{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pageToken{};

  HotelIndexInfoRequest() {}

  explicit HotelIndexInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (hotelStatus) {
      res["hotel_status"] = boost::any(*hotelStatus);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (pageToken) {
      res["page_token"] = boost::any(*pageToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("hotel_status") != m.end() && !m["hotel_status"].empty()) {
      hotelStatus = make_shared<long>(boost::any_cast<long>(m["hotel_status"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("page_token") != m.end() && !m["page_token"].empty()) {
      pageToken = make_shared<string>(boost::any_cast<string>(m["page_token"]));
    }
  }


  virtual ~HotelIndexInfoRequest() = default;
};
class HotelIndexInfoResponseBodyModuleItems : public Darabonba::Model {
public:
  shared_ptr<string> hotelId{};
  shared_ptr<string> hotelStatus{};

  HotelIndexInfoResponseBodyModuleItems() {}

  explicit HotelIndexInfoResponseBodyModuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelId) {
      res["hotel_id"] = boost::any(*hotelId);
    }
    if (hotelStatus) {
      res["hotel_status"] = boost::any(*hotelStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_id") != m.end() && !m["hotel_id"].empty()) {
      hotelId = make_shared<string>(boost::any_cast<string>(m["hotel_id"]));
    }
    if (m.find("hotel_status") != m.end() && !m["hotel_status"].empty()) {
      hotelStatus = make_shared<string>(boost::any_cast<string>(m["hotel_status"]));
    }
  }


  virtual ~HotelIndexInfoResponseBodyModuleItems() = default;
};
class HotelIndexInfoResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<HotelIndexInfoResponseBodyModuleItems>> items{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pageToken{};

  HotelIndexInfoResponseBodyModule() {}

  explicit HotelIndexInfoResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (pageToken) {
      res["page_token"] = boost::any(*pageToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<HotelIndexInfoResponseBodyModuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelIndexInfoResponseBodyModuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<HotelIndexInfoResponseBodyModuleItems>>(expect1);
      }
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("page_token") != m.end() && !m["page_token"].empty()) {
      pageToken = make_shared<string>(boost::any_cast<string>(m["page_token"]));
    }
  }


  virtual ~HotelIndexInfoResponseBodyModule() = default;
};
class HotelIndexInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelIndexInfoResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelIndexInfoResponseBody() {}

  explicit HotelIndexInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelIndexInfoResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelIndexInfoResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelIndexInfoResponseBody() = default;
};
class HotelIndexInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelIndexInfoResponseBody> body{};

  HotelIndexInfoResponse() {}

  explicit HotelIndexInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelIndexInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelIndexInfoResponseBody>(model1);
      }
    }
  }


  virtual ~HotelIndexInfoResponse() = default;
};
class HotelOrderCancelHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  HotelOrderCancelHeaders() {}

  explicit HotelOrderCancelHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~HotelOrderCancelHeaders() = default;
};
class HotelOrderCancelRequest : public Darabonba::Model {
public:
  shared_ptr<string> btripOrderId{};
  shared_ptr<string> disOrderId{};

  HotelOrderCancelRequest() {}

  explicit HotelOrderCancelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<string>(boost::any_cast<string>(m["btrip_order_id"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
  }


  virtual ~HotelOrderCancelRequest() = default;
};
class HotelOrderCancelResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<bool> cancelSuccess{};
  shared_ptr<string> code{};
  shared_ptr<string> desc{};
  shared_ptr<long> forfeitFee{};

  HotelOrderCancelResponseBodyModule() {}

  explicit HotelOrderCancelResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelSuccess) {
      res["cancel_success"] = boost::any(*cancelSuccess);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (forfeitFee) {
      res["forfeit_fee"] = boost::any(*forfeitFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cancel_success") != m.end() && !m["cancel_success"].empty()) {
      cancelSuccess = make_shared<bool>(boost::any_cast<bool>(m["cancel_success"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("forfeit_fee") != m.end() && !m["forfeit_fee"].empty()) {
      forfeitFee = make_shared<long>(boost::any_cast<long>(m["forfeit_fee"]));
    }
  }


  virtual ~HotelOrderCancelResponseBodyModule() = default;
};
class HotelOrderCancelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelOrderCancelResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelOrderCancelResponseBody() {}

  explicit HotelOrderCancelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelOrderCancelResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelOrderCancelResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelOrderCancelResponseBody() = default;
};
class HotelOrderCancelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelOrderCancelResponseBody> body{};

  HotelOrderCancelResponse() {}

  explicit HotelOrderCancelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelOrderCancelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelOrderCancelResponseBody>(model1);
      }
    }
  }


  virtual ~HotelOrderCancelResponse() = default;
};
class HotelOrderCreateHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  HotelOrderCreateHeaders() {}

  explicit HotelOrderCreateHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~HotelOrderCreateHeaders() = default;
};
class HotelOrderCreateRequestInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<string> buyerAdd{};
  shared_ptr<string> buyerBankAcc{};
  shared_ptr<string> buyerBankAdd{};
  shared_ptr<string> buyerPhone{};
  shared_ptr<string> buyerTaxNum{};
  shared_ptr<string> deliveryAddress{};
  shared_ptr<string> deliveryArea{};
  shared_ptr<string> deliveryCity{};
  shared_ptr<string> deliveryProvince{};
  shared_ptr<string> deliveryStreet{};
  shared_ptr<string> email{};
  shared_ptr<long> invoiceMaterial{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<long> invoiceType{};
  shared_ptr<string> receiverName{};
  shared_ptr<string> receiverPhone{};
  shared_ptr<string> remark{};

  HotelOrderCreateRequestInvoiceInfo() {}

  explicit HotelOrderCreateRequestInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buyerAdd) {
      res["buyer_add"] = boost::any(*buyerAdd);
    }
    if (buyerBankAcc) {
      res["buyer_bank_acc"] = boost::any(*buyerBankAcc);
    }
    if (buyerBankAdd) {
      res["buyer_bank_add"] = boost::any(*buyerBankAdd);
    }
    if (buyerPhone) {
      res["buyer_phone"] = boost::any(*buyerPhone);
    }
    if (buyerTaxNum) {
      res["buyer_tax_num"] = boost::any(*buyerTaxNum);
    }
    if (deliveryAddress) {
      res["delivery_address"] = boost::any(*deliveryAddress);
    }
    if (deliveryArea) {
      res["delivery_area"] = boost::any(*deliveryArea);
    }
    if (deliveryCity) {
      res["delivery_city"] = boost::any(*deliveryCity);
    }
    if (deliveryProvince) {
      res["delivery_province"] = boost::any(*deliveryProvince);
    }
    if (deliveryStreet) {
      res["delivery_street"] = boost::any(*deliveryStreet);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (invoiceMaterial) {
      res["invoice_material"] = boost::any(*invoiceMaterial);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (receiverName) {
      res["receiver_name"] = boost::any(*receiverName);
    }
    if (receiverPhone) {
      res["receiver_phone"] = boost::any(*receiverPhone);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("buyer_add") != m.end() && !m["buyer_add"].empty()) {
      buyerAdd = make_shared<string>(boost::any_cast<string>(m["buyer_add"]));
    }
    if (m.find("buyer_bank_acc") != m.end() && !m["buyer_bank_acc"].empty()) {
      buyerBankAcc = make_shared<string>(boost::any_cast<string>(m["buyer_bank_acc"]));
    }
    if (m.find("buyer_bank_add") != m.end() && !m["buyer_bank_add"].empty()) {
      buyerBankAdd = make_shared<string>(boost::any_cast<string>(m["buyer_bank_add"]));
    }
    if (m.find("buyer_phone") != m.end() && !m["buyer_phone"].empty()) {
      buyerPhone = make_shared<string>(boost::any_cast<string>(m["buyer_phone"]));
    }
    if (m.find("buyer_tax_num") != m.end() && !m["buyer_tax_num"].empty()) {
      buyerTaxNum = make_shared<string>(boost::any_cast<string>(m["buyer_tax_num"]));
    }
    if (m.find("delivery_address") != m.end() && !m["delivery_address"].empty()) {
      deliveryAddress = make_shared<string>(boost::any_cast<string>(m["delivery_address"]));
    }
    if (m.find("delivery_area") != m.end() && !m["delivery_area"].empty()) {
      deliveryArea = make_shared<string>(boost::any_cast<string>(m["delivery_area"]));
    }
    if (m.find("delivery_city") != m.end() && !m["delivery_city"].empty()) {
      deliveryCity = make_shared<string>(boost::any_cast<string>(m["delivery_city"]));
    }
    if (m.find("delivery_province") != m.end() && !m["delivery_province"].empty()) {
      deliveryProvince = make_shared<string>(boost::any_cast<string>(m["delivery_province"]));
    }
    if (m.find("delivery_street") != m.end() && !m["delivery_street"].empty()) {
      deliveryStreet = make_shared<string>(boost::any_cast<string>(m["delivery_street"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("invoice_material") != m.end() && !m["invoice_material"].empty()) {
      invoiceMaterial = make_shared<long>(boost::any_cast<long>(m["invoice_material"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("receiver_name") != m.end() && !m["receiver_name"].empty()) {
      receiverName = make_shared<string>(boost::any_cast<string>(m["receiver_name"]));
    }
    if (m.find("receiver_phone") != m.end() && !m["receiver_phone"].empty()) {
      receiverPhone = make_shared<string>(boost::any_cast<string>(m["receiver_phone"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
  }


  virtual ~HotelOrderCreateRequestInvoiceInfo() = default;
};
class HotelOrderCreateRequestOccupantInfoList : public Darabonba::Model {
public:
  shared_ptr<string> cardNo{};
  shared_ptr<long> cardType{};
  shared_ptr<long> customerType{};
  shared_ptr<string> departmentId{};
  shared_ptr<string> departmentName{};
  shared_ptr<string> email{};
  shared_ptr<long> employeeType{};
  shared_ptr<string> firstName{};
  shared_ptr<string> lastName{};
  shared_ptr<string> name{};
  shared_ptr<string> phone{};
  shared_ptr<long> roomNo{};
  shared_ptr<string> staffNo{};
  shared_ptr<long> userType{};

  HotelOrderCreateRequestOccupantInfoList() {}

  explicit HotelOrderCreateRequestOccupantInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardNo) {
      res["card_no"] = boost::any(*cardNo);
    }
    if (cardType) {
      res["card_type"] = boost::any(*cardType);
    }
    if (customerType) {
      res["customer_type"] = boost::any(*customerType);
    }
    if (departmentId) {
      res["department_id"] = boost::any(*departmentId);
    }
    if (departmentName) {
      res["department_name"] = boost::any(*departmentName);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (employeeType) {
      res["employee_type"] = boost::any(*employeeType);
    }
    if (firstName) {
      res["first_name"] = boost::any(*firstName);
    }
    if (lastName) {
      res["last_name"] = boost::any(*lastName);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (roomNo) {
      res["room_no"] = boost::any(*roomNo);
    }
    if (staffNo) {
      res["staff_no"] = boost::any(*staffNo);
    }
    if (userType) {
      res["user_type"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("card_no") != m.end() && !m["card_no"].empty()) {
      cardNo = make_shared<string>(boost::any_cast<string>(m["card_no"]));
    }
    if (m.find("card_type") != m.end() && !m["card_type"].empty()) {
      cardType = make_shared<long>(boost::any_cast<long>(m["card_type"]));
    }
    if (m.find("customer_type") != m.end() && !m["customer_type"].empty()) {
      customerType = make_shared<long>(boost::any_cast<long>(m["customer_type"]));
    }
    if (m.find("department_id") != m.end() && !m["department_id"].empty()) {
      departmentId = make_shared<string>(boost::any_cast<string>(m["department_id"]));
    }
    if (m.find("department_name") != m.end() && !m["department_name"].empty()) {
      departmentName = make_shared<string>(boost::any_cast<string>(m["department_name"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("employee_type") != m.end() && !m["employee_type"].empty()) {
      employeeType = make_shared<long>(boost::any_cast<long>(m["employee_type"]));
    }
    if (m.find("first_name") != m.end() && !m["first_name"].empty()) {
      firstName = make_shared<string>(boost::any_cast<string>(m["first_name"]));
    }
    if (m.find("last_name") != m.end() && !m["last_name"].empty()) {
      lastName = make_shared<string>(boost::any_cast<string>(m["last_name"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("room_no") != m.end() && !m["room_no"].empty()) {
      roomNo = make_shared<long>(boost::any_cast<long>(m["room_no"]));
    }
    if (m.find("staff_no") != m.end() && !m["staff_no"].empty()) {
      staffNo = make_shared<string>(boost::any_cast<string>(m["staff_no"]));
    }
    if (m.find("user_type") != m.end() && !m["user_type"].empty()) {
      userType = make_shared<long>(boost::any_cast<long>(m["user_type"]));
    }
  }


  virtual ~HotelOrderCreateRequestOccupantInfoList() = default;
};
class HotelOrderCreateRequestPromotionInfoPromotionDetailInfoList : public Darabonba::Model {
public:
  shared_ptr<bool> checkStatus{};
  shared_ptr<bool> needCheck{};
  shared_ptr<string> promotionCode{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> promotionName{};
  shared_ptr<long> promotionPrice{};
  shared_ptr<string> promotionType{};

  HotelOrderCreateRequestPromotionInfoPromotionDetailInfoList() {}

  explicit HotelOrderCreateRequestPromotionInfoPromotionDetailInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkStatus) {
      res["check_status"] = boost::any(*checkStatus);
    }
    if (needCheck) {
      res["need_check"] = boost::any(*needCheck);
    }
    if (promotionCode) {
      res["promotion_code"] = boost::any(*promotionCode);
    }
    if (promotionId) {
      res["promotion_id"] = boost::any(*promotionId);
    }
    if (promotionName) {
      res["promotion_name"] = boost::any(*promotionName);
    }
    if (promotionPrice) {
      res["promotion_price"] = boost::any(*promotionPrice);
    }
    if (promotionType) {
      res["promotion_type"] = boost::any(*promotionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("check_status") != m.end() && !m["check_status"].empty()) {
      checkStatus = make_shared<bool>(boost::any_cast<bool>(m["check_status"]));
    }
    if (m.find("need_check") != m.end() && !m["need_check"].empty()) {
      needCheck = make_shared<bool>(boost::any_cast<bool>(m["need_check"]));
    }
    if (m.find("promotion_code") != m.end() && !m["promotion_code"].empty()) {
      promotionCode = make_shared<string>(boost::any_cast<string>(m["promotion_code"]));
    }
    if (m.find("promotion_id") != m.end() && !m["promotion_id"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["promotion_id"]));
    }
    if (m.find("promotion_name") != m.end() && !m["promotion_name"].empty()) {
      promotionName = make_shared<string>(boost::any_cast<string>(m["promotion_name"]));
    }
    if (m.find("promotion_price") != m.end() && !m["promotion_price"].empty()) {
      promotionPrice = make_shared<long>(boost::any_cast<long>(m["promotion_price"]));
    }
    if (m.find("promotion_type") != m.end() && !m["promotion_type"].empty()) {
      promotionType = make_shared<string>(boost::any_cast<string>(m["promotion_type"]));
    }
  }


  virtual ~HotelOrderCreateRequestPromotionInfoPromotionDetailInfoList() = default;
};
class HotelOrderCreateRequestPromotionInfo : public Darabonba::Model {
public:
  shared_ptr<vector<HotelOrderCreateRequestPromotionInfoPromotionDetailInfoList>> promotionDetailInfoList{};
  shared_ptr<long> promotionTotalPrice{};

  HotelOrderCreateRequestPromotionInfo() {}

  explicit HotelOrderCreateRequestPromotionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (promotionDetailInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*promotionDetailInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["promotion_detail_info_list"] = boost::any(temp1);
    }
    if (promotionTotalPrice) {
      res["promotion_total_price"] = boost::any(*promotionTotalPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("promotion_detail_info_list") != m.end() && !m["promotion_detail_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["promotion_detail_info_list"].type()) {
        vector<HotelOrderCreateRequestPromotionInfoPromotionDetailInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["promotion_detail_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderCreateRequestPromotionInfoPromotionDetailInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        promotionDetailInfoList = make_shared<vector<HotelOrderCreateRequestPromotionInfoPromotionDetailInfoList>>(expect1);
      }
    }
    if (m.find("promotion_total_price") != m.end() && !m["promotion_total_price"].empty()) {
      promotionTotalPrice = make_shared<long>(boost::any_cast<long>(m["promotion_total_price"]));
    }
  }


  virtual ~HotelOrderCreateRequestPromotionInfo() = default;
};
class HotelOrderCreateRequest : public Darabonba::Model {
public:
  shared_ptr<string> btripUserId{};
  shared_ptr<string> checkIn{};
  shared_ptr<string> checkOut{};
  shared_ptr<string> contractEmail{};
  shared_ptr<string> contractName{};
  shared_ptr<string> contractPhone{};
  shared_ptr<long> corpPayPrice{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> extra{};
  shared_ptr<HotelOrderCreateRequestInvoiceInfo> invoiceInfo{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itineraryNo{};
  shared_ptr<vector<HotelOrderCreateRequestOccupantInfoList>> occupantInfoList{};
  shared_ptr<long> personPayPrice{};
  shared_ptr<HotelOrderCreateRequestPromotionInfo> promotionInfo{};
  shared_ptr<long> ratePlanId{};
  shared_ptr<long> roomId{};
  shared_ptr<long> roomNum{};
  shared_ptr<long> sellerId{};
  shared_ptr<long> shid{};
  shared_ptr<long> totalOrderPrice{};
  shared_ptr<string> validateResKey{};

  HotelOrderCreateRequest() {}

  explicit HotelOrderCreateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (contractEmail) {
      res["contract_email"] = boost::any(*contractEmail);
    }
    if (contractName) {
      res["contract_name"] = boost::any(*contractName);
    }
    if (contractPhone) {
      res["contract_phone"] = boost::any(*contractPhone);
    }
    if (corpPayPrice) {
      res["corp_pay_price"] = boost::any(*corpPayPrice);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (invoiceInfo) {
      res["invoice_info"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (itineraryNo) {
      res["itinerary_no"] = boost::any(*itineraryNo);
    }
    if (occupantInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*occupantInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["occupant_info_list"] = boost::any(temp1);
    }
    if (personPayPrice) {
      res["person_pay_price"] = boost::any(*personPayPrice);
    }
    if (promotionInfo) {
      res["promotion_info"] = promotionInfo ? boost::any(promotionInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ratePlanId) {
      res["rate_plan_id"] = boost::any(*ratePlanId);
    }
    if (roomId) {
      res["room_id"] = boost::any(*roomId);
    }
    if (roomNum) {
      res["room_num"] = boost::any(*roomNum);
    }
    if (sellerId) {
      res["seller_id"] = boost::any(*sellerId);
    }
    if (shid) {
      res["shid"] = boost::any(*shid);
    }
    if (totalOrderPrice) {
      res["total_order_price"] = boost::any(*totalOrderPrice);
    }
    if (validateResKey) {
      res["validate_res_key"] = boost::any(*validateResKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<string>(boost::any_cast<string>(m["check_out"]));
    }
    if (m.find("contract_email") != m.end() && !m["contract_email"].empty()) {
      contractEmail = make_shared<string>(boost::any_cast<string>(m["contract_email"]));
    }
    if (m.find("contract_name") != m.end() && !m["contract_name"].empty()) {
      contractName = make_shared<string>(boost::any_cast<string>(m["contract_name"]));
    }
    if (m.find("contract_phone") != m.end() && !m["contract_phone"].empty()) {
      contractPhone = make_shared<string>(boost::any_cast<string>(m["contract_phone"]));
    }
    if (m.find("corp_pay_price") != m.end() && !m["corp_pay_price"].empty()) {
      corpPayPrice = make_shared<long>(boost::any_cast<long>(m["corp_pay_price"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("invoice_info") != m.end() && !m["invoice_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice_info"].type()) {
        HotelOrderCreateRequestInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice_info"]));
        invoiceInfo = make_shared<HotelOrderCreateRequestInvoiceInfo>(model1);
      }
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["item_id"]));
    }
    if (m.find("itinerary_no") != m.end() && !m["itinerary_no"].empty()) {
      itineraryNo = make_shared<string>(boost::any_cast<string>(m["itinerary_no"]));
    }
    if (m.find("occupant_info_list") != m.end() && !m["occupant_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["occupant_info_list"].type()) {
        vector<HotelOrderCreateRequestOccupantInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["occupant_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderCreateRequestOccupantInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        occupantInfoList = make_shared<vector<HotelOrderCreateRequestOccupantInfoList>>(expect1);
      }
    }
    if (m.find("person_pay_price") != m.end() && !m["person_pay_price"].empty()) {
      personPayPrice = make_shared<long>(boost::any_cast<long>(m["person_pay_price"]));
    }
    if (m.find("promotion_info") != m.end() && !m["promotion_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["promotion_info"].type()) {
        HotelOrderCreateRequestPromotionInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["promotion_info"]));
        promotionInfo = make_shared<HotelOrderCreateRequestPromotionInfo>(model1);
      }
    }
    if (m.find("rate_plan_id") != m.end() && !m["rate_plan_id"].empty()) {
      ratePlanId = make_shared<long>(boost::any_cast<long>(m["rate_plan_id"]));
    }
    if (m.find("room_id") != m.end() && !m["room_id"].empty()) {
      roomId = make_shared<long>(boost::any_cast<long>(m["room_id"]));
    }
    if (m.find("room_num") != m.end() && !m["room_num"].empty()) {
      roomNum = make_shared<long>(boost::any_cast<long>(m["room_num"]));
    }
    if (m.find("seller_id") != m.end() && !m["seller_id"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["seller_id"]));
    }
    if (m.find("shid") != m.end() && !m["shid"].empty()) {
      shid = make_shared<long>(boost::any_cast<long>(m["shid"]));
    }
    if (m.find("total_order_price") != m.end() && !m["total_order_price"].empty()) {
      totalOrderPrice = make_shared<long>(boost::any_cast<long>(m["total_order_price"]));
    }
    if (m.find("validate_res_key") != m.end() && !m["validate_res_key"].empty()) {
      validateResKey = make_shared<string>(boost::any_cast<string>(m["validate_res_key"]));
    }
  }


  virtual ~HotelOrderCreateRequest() = default;
};
class HotelOrderCreateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> btripUserId{};
  shared_ptr<string> checkIn{};
  shared_ptr<string> checkOut{};
  shared_ptr<string> contractEmail{};
  shared_ptr<string> contractName{};
  shared_ptr<string> contractPhone{};
  shared_ptr<long> corpPayPrice{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> extra{};
  shared_ptr<string> invoiceInfoShrink{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itineraryNo{};
  shared_ptr<string> occupantInfoListShrink{};
  shared_ptr<long> personPayPrice{};
  shared_ptr<string> promotionInfoShrink{};
  shared_ptr<long> ratePlanId{};
  shared_ptr<long> roomId{};
  shared_ptr<long> roomNum{};
  shared_ptr<long> sellerId{};
  shared_ptr<long> shid{};
  shared_ptr<long> totalOrderPrice{};
  shared_ptr<string> validateResKey{};

  HotelOrderCreateShrinkRequest() {}

  explicit HotelOrderCreateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (contractEmail) {
      res["contract_email"] = boost::any(*contractEmail);
    }
    if (contractName) {
      res["contract_name"] = boost::any(*contractName);
    }
    if (contractPhone) {
      res["contract_phone"] = boost::any(*contractPhone);
    }
    if (corpPayPrice) {
      res["corp_pay_price"] = boost::any(*corpPayPrice);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (invoiceInfoShrink) {
      res["invoice_info"] = boost::any(*invoiceInfoShrink);
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (itineraryNo) {
      res["itinerary_no"] = boost::any(*itineraryNo);
    }
    if (occupantInfoListShrink) {
      res["occupant_info_list"] = boost::any(*occupantInfoListShrink);
    }
    if (personPayPrice) {
      res["person_pay_price"] = boost::any(*personPayPrice);
    }
    if (promotionInfoShrink) {
      res["promotion_info"] = boost::any(*promotionInfoShrink);
    }
    if (ratePlanId) {
      res["rate_plan_id"] = boost::any(*ratePlanId);
    }
    if (roomId) {
      res["room_id"] = boost::any(*roomId);
    }
    if (roomNum) {
      res["room_num"] = boost::any(*roomNum);
    }
    if (sellerId) {
      res["seller_id"] = boost::any(*sellerId);
    }
    if (shid) {
      res["shid"] = boost::any(*shid);
    }
    if (totalOrderPrice) {
      res["total_order_price"] = boost::any(*totalOrderPrice);
    }
    if (validateResKey) {
      res["validate_res_key"] = boost::any(*validateResKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<string>(boost::any_cast<string>(m["check_out"]));
    }
    if (m.find("contract_email") != m.end() && !m["contract_email"].empty()) {
      contractEmail = make_shared<string>(boost::any_cast<string>(m["contract_email"]));
    }
    if (m.find("contract_name") != m.end() && !m["contract_name"].empty()) {
      contractName = make_shared<string>(boost::any_cast<string>(m["contract_name"]));
    }
    if (m.find("contract_phone") != m.end() && !m["contract_phone"].empty()) {
      contractPhone = make_shared<string>(boost::any_cast<string>(m["contract_phone"]));
    }
    if (m.find("corp_pay_price") != m.end() && !m["corp_pay_price"].empty()) {
      corpPayPrice = make_shared<long>(boost::any_cast<long>(m["corp_pay_price"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("invoice_info") != m.end() && !m["invoice_info"].empty()) {
      invoiceInfoShrink = make_shared<string>(boost::any_cast<string>(m["invoice_info"]));
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["item_id"]));
    }
    if (m.find("itinerary_no") != m.end() && !m["itinerary_no"].empty()) {
      itineraryNo = make_shared<string>(boost::any_cast<string>(m["itinerary_no"]));
    }
    if (m.find("occupant_info_list") != m.end() && !m["occupant_info_list"].empty()) {
      occupantInfoListShrink = make_shared<string>(boost::any_cast<string>(m["occupant_info_list"]));
    }
    if (m.find("person_pay_price") != m.end() && !m["person_pay_price"].empty()) {
      personPayPrice = make_shared<long>(boost::any_cast<long>(m["person_pay_price"]));
    }
    if (m.find("promotion_info") != m.end() && !m["promotion_info"].empty()) {
      promotionInfoShrink = make_shared<string>(boost::any_cast<string>(m["promotion_info"]));
    }
    if (m.find("rate_plan_id") != m.end() && !m["rate_plan_id"].empty()) {
      ratePlanId = make_shared<long>(boost::any_cast<long>(m["rate_plan_id"]));
    }
    if (m.find("room_id") != m.end() && !m["room_id"].empty()) {
      roomId = make_shared<long>(boost::any_cast<long>(m["room_id"]));
    }
    if (m.find("room_num") != m.end() && !m["room_num"].empty()) {
      roomNum = make_shared<long>(boost::any_cast<long>(m["room_num"]));
    }
    if (m.find("seller_id") != m.end() && !m["seller_id"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["seller_id"]));
    }
    if (m.find("shid") != m.end() && !m["shid"].empty()) {
      shid = make_shared<long>(boost::any_cast<long>(m["shid"]));
    }
    if (m.find("total_order_price") != m.end() && !m["total_order_price"].empty()) {
      totalOrderPrice = make_shared<long>(boost::any_cast<long>(m["total_order_price"]));
    }
    if (m.find("validate_res_key") != m.end() && !m["validate_res_key"].empty()) {
      validateResKey = make_shared<string>(boost::any_cast<string>(m["validate_res_key"]));
    }
  }


  virtual ~HotelOrderCreateShrinkRequest() = default;
};
class HotelOrderCreateResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> btripOrderId{};
  shared_ptr<long> totalPrice{};

  HotelOrderCreateResponseBodyModule() {}

  explicit HotelOrderCreateResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_order_id"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<long>(boost::any_cast<long>(m["total_price"]));
    }
  }


  virtual ~HotelOrderCreateResponseBodyModule() = default;
};
class HotelOrderCreateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelOrderCreateResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelOrderCreateResponseBody() {}

  explicit HotelOrderCreateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelOrderCreateResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelOrderCreateResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelOrderCreateResponseBody() = default;
};
class HotelOrderCreateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelOrderCreateResponseBody> body{};

  HotelOrderCreateResponse() {}

  explicit HotelOrderCreateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelOrderCreateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelOrderCreateResponseBody>(model1);
      }
    }
  }


  virtual ~HotelOrderCreateResponse() = default;
};
class HotelOrderDetailInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  HotelOrderDetailInfoHeaders() {}

  explicit HotelOrderDetailInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~HotelOrderDetailInfoHeaders() = default;
};
class HotelOrderDetailInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> btripOrderId{};
  shared_ptr<string> disOrderId{};

  HotelOrderDetailInfoRequest() {}

  explicit HotelOrderDetailInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<string>(boost::any_cast<string>(m["btrip_order_id"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
  }


  virtual ~HotelOrderDetailInfoRequest() = default;
};
class HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList : public Darabonba::Model {
public:
  shared_ptr<long> hour{};
  shared_ptr<long> value{};

  HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList() {}

  explicit HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hour) {
      res["hour"] = boost::any(*hour);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hour") != m.end() && !m["hour"].empty()) {
      hour = make_shared<long>(boost::any_cast<long>(m["hour"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["value"]));
    }
  }


  virtual ~HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList() = default;
};
class HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTO : public Darabonba::Model {
public:
  shared_ptr<vector<HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList>> btripHotelCancelPolicyInfoDTOList{};
  shared_ptr<long> cancelPolicyType{};

  HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTO() {}

  explicit HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripHotelCancelPolicyInfoDTOList) {
      vector<boost::any> temp1;
      for(auto item1:*btripHotelCancelPolicyInfoDTOList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["btrip_hotel_cancel_policy_info_d_t_o_list"] = boost::any(temp1);
    }
    if (cancelPolicyType) {
      res["cancel_policy_type"] = boost::any(*cancelPolicyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_hotel_cancel_policy_info_d_t_o_list") != m.end() && !m["btrip_hotel_cancel_policy_info_d_t_o_list"].empty()) {
      if (typeid(vector<boost::any>) == m["btrip_hotel_cancel_policy_info_d_t_o_list"].type()) {
        vector<HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["btrip_hotel_cancel_policy_info_d_t_o_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        btripHotelCancelPolicyInfoDTOList = make_shared<vector<HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList>>(expect1);
      }
    }
    if (m.find("cancel_policy_type") != m.end() && !m["cancel_policy_type"].empty()) {
      cancelPolicyType = make_shared<long>(boost::any_cast<long>(m["cancel_policy_type"]));
    }
  }


  virtual ~HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTO() = default;
};
class HotelOrderDetailInfoResponseBodyModuleCancelInfo : public Darabonba::Model {
public:
  shared_ptr<string> cancelEndTime{};
  shared_ptr<string> cancelStartTime{};

  HotelOrderDetailInfoResponseBodyModuleCancelInfo() {}

  explicit HotelOrderDetailInfoResponseBodyModuleCancelInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelEndTime) {
      res["cancel_end_time"] = boost::any(*cancelEndTime);
    }
    if (cancelStartTime) {
      res["cancel_start_time"] = boost::any(*cancelStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cancel_end_time") != m.end() && !m["cancel_end_time"].empty()) {
      cancelEndTime = make_shared<string>(boost::any_cast<string>(m["cancel_end_time"]));
    }
    if (m.find("cancel_start_time") != m.end() && !m["cancel_start_time"].empty()) {
      cancelStartTime = make_shared<string>(boost::any_cast<string>(m["cancel_start_time"]));
    }
  }


  virtual ~HotelOrderDetailInfoResponseBodyModuleCancelInfo() = default;
};
class HotelOrderDetailInfoResponseBodyModuleHotelDetailInfo : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> cityName{};
  shared_ptr<string> hotelName{};
  shared_ptr<string> hotelTel{};
  shared_ptr<long> shid{};

  HotelOrderDetailInfoResponseBodyModuleHotelDetailInfo() {}

  explicit HotelOrderDetailInfoResponseBodyModuleHotelDetailInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["address"] = boost::any(*address);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (hotelName) {
      res["hotel_name"] = boost::any(*hotelName);
    }
    if (hotelTel) {
      res["hotel_tel"] = boost::any(*hotelTel);
    }
    if (shid) {
      res["shid"] = boost::any(*shid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("address") != m.end() && !m["address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["address"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("hotel_name") != m.end() && !m["hotel_name"].empty()) {
      hotelName = make_shared<string>(boost::any_cast<string>(m["hotel_name"]));
    }
    if (m.find("hotel_tel") != m.end() && !m["hotel_tel"].empty()) {
      hotelTel = make_shared<string>(boost::any_cast<string>(m["hotel_tel"]));
    }
    if (m.find("shid") != m.end() && !m["shid"].empty()) {
      shid = make_shared<long>(boost::any_cast<long>(m["shid"]));
    }
  }


  virtual ~HotelOrderDetailInfoResponseBodyModuleHotelDetailInfo() = default;
};
class HotelOrderDetailInfoResponseBodyModuleInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<long> billingMoney{};
  shared_ptr<string> buyerAdd{};
  shared_ptr<string> buyerBankAcc{};
  shared_ptr<string> buyerBankAdd{};
  shared_ptr<string> buyerPhone{};
  shared_ptr<string> buyerTaxNum{};
  shared_ptr<string> deliveryAddress{};
  shared_ptr<string> deliveryArea{};
  shared_ptr<string> deliveryCity{};
  shared_ptr<string> deliveryProvince{};
  shared_ptr<string> deliveryStreet{};
  shared_ptr<string> email{};
  shared_ptr<long> invoiceMaterial{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<long> invoiceType{};
  shared_ptr<long> postage{};
  shared_ptr<string> receiverName{};
  shared_ptr<string> receiverPhone{};
  shared_ptr<string> remark{};

  HotelOrderDetailInfoResponseBodyModuleInvoiceInfo() {}

  explicit HotelOrderDetailInfoResponseBodyModuleInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billingMoney) {
      res["billing_money"] = boost::any(*billingMoney);
    }
    if (buyerAdd) {
      res["buyer_add"] = boost::any(*buyerAdd);
    }
    if (buyerBankAcc) {
      res["buyer_bank_acc"] = boost::any(*buyerBankAcc);
    }
    if (buyerBankAdd) {
      res["buyer_bank_add"] = boost::any(*buyerBankAdd);
    }
    if (buyerPhone) {
      res["buyer_phone"] = boost::any(*buyerPhone);
    }
    if (buyerTaxNum) {
      res["buyer_tax_num"] = boost::any(*buyerTaxNum);
    }
    if (deliveryAddress) {
      res["delivery_address"] = boost::any(*deliveryAddress);
    }
    if (deliveryArea) {
      res["delivery_area"] = boost::any(*deliveryArea);
    }
    if (deliveryCity) {
      res["delivery_city"] = boost::any(*deliveryCity);
    }
    if (deliveryProvince) {
      res["delivery_province"] = boost::any(*deliveryProvince);
    }
    if (deliveryStreet) {
      res["delivery_street"] = boost::any(*deliveryStreet);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (invoiceMaterial) {
      res["invoice_material"] = boost::any(*invoiceMaterial);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (postage) {
      res["postage"] = boost::any(*postage);
    }
    if (receiverName) {
      res["receiver_name"] = boost::any(*receiverName);
    }
    if (receiverPhone) {
      res["receiver_phone"] = boost::any(*receiverPhone);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("billing_money") != m.end() && !m["billing_money"].empty()) {
      billingMoney = make_shared<long>(boost::any_cast<long>(m["billing_money"]));
    }
    if (m.find("buyer_add") != m.end() && !m["buyer_add"].empty()) {
      buyerAdd = make_shared<string>(boost::any_cast<string>(m["buyer_add"]));
    }
    if (m.find("buyer_bank_acc") != m.end() && !m["buyer_bank_acc"].empty()) {
      buyerBankAcc = make_shared<string>(boost::any_cast<string>(m["buyer_bank_acc"]));
    }
    if (m.find("buyer_bank_add") != m.end() && !m["buyer_bank_add"].empty()) {
      buyerBankAdd = make_shared<string>(boost::any_cast<string>(m["buyer_bank_add"]));
    }
    if (m.find("buyer_phone") != m.end() && !m["buyer_phone"].empty()) {
      buyerPhone = make_shared<string>(boost::any_cast<string>(m["buyer_phone"]));
    }
    if (m.find("buyer_tax_num") != m.end() && !m["buyer_tax_num"].empty()) {
      buyerTaxNum = make_shared<string>(boost::any_cast<string>(m["buyer_tax_num"]));
    }
    if (m.find("delivery_address") != m.end() && !m["delivery_address"].empty()) {
      deliveryAddress = make_shared<string>(boost::any_cast<string>(m["delivery_address"]));
    }
    if (m.find("delivery_area") != m.end() && !m["delivery_area"].empty()) {
      deliveryArea = make_shared<string>(boost::any_cast<string>(m["delivery_area"]));
    }
    if (m.find("delivery_city") != m.end() && !m["delivery_city"].empty()) {
      deliveryCity = make_shared<string>(boost::any_cast<string>(m["delivery_city"]));
    }
    if (m.find("delivery_province") != m.end() && !m["delivery_province"].empty()) {
      deliveryProvince = make_shared<string>(boost::any_cast<string>(m["delivery_province"]));
    }
    if (m.find("delivery_street") != m.end() && !m["delivery_street"].empty()) {
      deliveryStreet = make_shared<string>(boost::any_cast<string>(m["delivery_street"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("invoice_material") != m.end() && !m["invoice_material"].empty()) {
      invoiceMaterial = make_shared<long>(boost::any_cast<long>(m["invoice_material"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("postage") != m.end() && !m["postage"].empty()) {
      postage = make_shared<long>(boost::any_cast<long>(m["postage"]));
    }
    if (m.find("receiver_name") != m.end() && !m["receiver_name"].empty()) {
      receiverName = make_shared<string>(boost::any_cast<string>(m["receiver_name"]));
    }
    if (m.find("receiver_phone") != m.end() && !m["receiver_phone"].empty()) {
      receiverPhone = make_shared<string>(boost::any_cast<string>(m["receiver_phone"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
  }


  virtual ~HotelOrderDetailInfoResponseBodyModuleInvoiceInfo() = default;
};
class HotelOrderDetailInfoResponseBodyModuleOccupantInfoListCostCenterInfoList : public Darabonba::Model {
public:
  shared_ptr<string> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> costCenterNo{};
  shared_ptr<long> costCenterPrices{};
  shared_ptr<long> costCenterRatios{};
  shared_ptr<string> costCenterSubjectCode{};
  shared_ptr<string> costCenterSubjectName{};
  shared_ptr<string> settleSubjectId{};
  shared_ptr<string> settleSubjectName{};
  shared_ptr<string> settleSubjectNo{};

  HotelOrderDetailInfoResponseBodyModuleOccupantInfoListCostCenterInfoList() {}

  explicit HotelOrderDetailInfoResponseBodyModuleOccupantInfoListCostCenterInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (costCenterNo) {
      res["cost_center_no"] = boost::any(*costCenterNo);
    }
    if (costCenterPrices) {
      res["cost_center_prices"] = boost::any(*costCenterPrices);
    }
    if (costCenterRatios) {
      res["cost_center_ratios"] = boost::any(*costCenterRatios);
    }
    if (costCenterSubjectCode) {
      res["cost_center_subject_code"] = boost::any(*costCenterSubjectCode);
    }
    if (costCenterSubjectName) {
      res["cost_center_subject_name"] = boost::any(*costCenterSubjectName);
    }
    if (settleSubjectId) {
      res["settle_subject_id"] = boost::any(*settleSubjectId);
    }
    if (settleSubjectName) {
      res["settle_subject_name"] = boost::any(*settleSubjectName);
    }
    if (settleSubjectNo) {
      res["settle_subject_no"] = boost::any(*settleSubjectNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<string>(boost::any_cast<string>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("cost_center_no") != m.end() && !m["cost_center_no"].empty()) {
      costCenterNo = make_shared<string>(boost::any_cast<string>(m["cost_center_no"]));
    }
    if (m.find("cost_center_prices") != m.end() && !m["cost_center_prices"].empty()) {
      costCenterPrices = make_shared<long>(boost::any_cast<long>(m["cost_center_prices"]));
    }
    if (m.find("cost_center_ratios") != m.end() && !m["cost_center_ratios"].empty()) {
      costCenterRatios = make_shared<long>(boost::any_cast<long>(m["cost_center_ratios"]));
    }
    if (m.find("cost_center_subject_code") != m.end() && !m["cost_center_subject_code"].empty()) {
      costCenterSubjectCode = make_shared<string>(boost::any_cast<string>(m["cost_center_subject_code"]));
    }
    if (m.find("cost_center_subject_name") != m.end() && !m["cost_center_subject_name"].empty()) {
      costCenterSubjectName = make_shared<string>(boost::any_cast<string>(m["cost_center_subject_name"]));
    }
    if (m.find("settle_subject_id") != m.end() && !m["settle_subject_id"].empty()) {
      settleSubjectId = make_shared<string>(boost::any_cast<string>(m["settle_subject_id"]));
    }
    if (m.find("settle_subject_name") != m.end() && !m["settle_subject_name"].empty()) {
      settleSubjectName = make_shared<string>(boost::any_cast<string>(m["settle_subject_name"]));
    }
    if (m.find("settle_subject_no") != m.end() && !m["settle_subject_no"].empty()) {
      settleSubjectNo = make_shared<string>(boost::any_cast<string>(m["settle_subject_no"]));
    }
  }


  virtual ~HotelOrderDetailInfoResponseBodyModuleOccupantInfoListCostCenterInfoList() = default;
};
class HotelOrderDetailInfoResponseBodyModuleOccupantInfoList : public Darabonba::Model {
public:
  shared_ptr<string> cardNo{};
  shared_ptr<long> cardType{};
  shared_ptr<vector<HotelOrderDetailInfoResponseBodyModuleOccupantInfoListCostCenterInfoList>> costCenterInfoList{};
  shared_ptr<long> customerType{};
  shared_ptr<string> departmentId{};
  shared_ptr<string> departmentName{};
  shared_ptr<string> email{};
  shared_ptr<long> employeeType{};
  shared_ptr<string> firstName{};
  shared_ptr<bool> isBooker{};
  shared_ptr<string> lastName{};
  shared_ptr<string> name{};
  shared_ptr<string> phone{};
  shared_ptr<long> roomNo{};
  shared_ptr<bool> selected{};
  shared_ptr<string> staffNo{};
  shared_ptr<long> userType{};

  HotelOrderDetailInfoResponseBodyModuleOccupantInfoList() {}

  explicit HotelOrderDetailInfoResponseBodyModuleOccupantInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardNo) {
      res["card_no"] = boost::any(*cardNo);
    }
    if (cardType) {
      res["card_type"] = boost::any(*cardType);
    }
    if (costCenterInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*costCenterInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cost_center_info_list"] = boost::any(temp1);
    }
    if (customerType) {
      res["customer_type"] = boost::any(*customerType);
    }
    if (departmentId) {
      res["department_id"] = boost::any(*departmentId);
    }
    if (departmentName) {
      res["department_name"] = boost::any(*departmentName);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (employeeType) {
      res["employee_type"] = boost::any(*employeeType);
    }
    if (firstName) {
      res["first_name"] = boost::any(*firstName);
    }
    if (isBooker) {
      res["is_booker"] = boost::any(*isBooker);
    }
    if (lastName) {
      res["last_name"] = boost::any(*lastName);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (roomNo) {
      res["room_no"] = boost::any(*roomNo);
    }
    if (selected) {
      res["selected"] = boost::any(*selected);
    }
    if (staffNo) {
      res["staff_no"] = boost::any(*staffNo);
    }
    if (userType) {
      res["user_type"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("card_no") != m.end() && !m["card_no"].empty()) {
      cardNo = make_shared<string>(boost::any_cast<string>(m["card_no"]));
    }
    if (m.find("card_type") != m.end() && !m["card_type"].empty()) {
      cardType = make_shared<long>(boost::any_cast<long>(m["card_type"]));
    }
    if (m.find("cost_center_info_list") != m.end() && !m["cost_center_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["cost_center_info_list"].type()) {
        vector<HotelOrderDetailInfoResponseBodyModuleOccupantInfoListCostCenterInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cost_center_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderDetailInfoResponseBodyModuleOccupantInfoListCostCenterInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        costCenterInfoList = make_shared<vector<HotelOrderDetailInfoResponseBodyModuleOccupantInfoListCostCenterInfoList>>(expect1);
      }
    }
    if (m.find("customer_type") != m.end() && !m["customer_type"].empty()) {
      customerType = make_shared<long>(boost::any_cast<long>(m["customer_type"]));
    }
    if (m.find("department_id") != m.end() && !m["department_id"].empty()) {
      departmentId = make_shared<string>(boost::any_cast<string>(m["department_id"]));
    }
    if (m.find("department_name") != m.end() && !m["department_name"].empty()) {
      departmentName = make_shared<string>(boost::any_cast<string>(m["department_name"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("employee_type") != m.end() && !m["employee_type"].empty()) {
      employeeType = make_shared<long>(boost::any_cast<long>(m["employee_type"]));
    }
    if (m.find("first_name") != m.end() && !m["first_name"].empty()) {
      firstName = make_shared<string>(boost::any_cast<string>(m["first_name"]));
    }
    if (m.find("is_booker") != m.end() && !m["is_booker"].empty()) {
      isBooker = make_shared<bool>(boost::any_cast<bool>(m["is_booker"]));
    }
    if (m.find("last_name") != m.end() && !m["last_name"].empty()) {
      lastName = make_shared<string>(boost::any_cast<string>(m["last_name"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("room_no") != m.end() && !m["room_no"].empty()) {
      roomNo = make_shared<long>(boost::any_cast<long>(m["room_no"]));
    }
    if (m.find("selected") != m.end() && !m["selected"].empty()) {
      selected = make_shared<bool>(boost::any_cast<bool>(m["selected"]));
    }
    if (m.find("staff_no") != m.end() && !m["staff_no"].empty()) {
      staffNo = make_shared<string>(boost::any_cast<string>(m["staff_no"]));
    }
    if (m.find("user_type") != m.end() && !m["user_type"].empty()) {
      userType = make_shared<long>(boost::any_cast<long>(m["user_type"]));
    }
  }


  virtual ~HotelOrderDetailInfoResponseBodyModuleOccupantInfoList() = default;
};
class HotelOrderDetailInfoResponseBodyModuleRoomNightPriceInfoList : public Darabonba::Model {
public:
  shared_ptr<string> board{};
  shared_ptr<long> boardNum{};
  shared_ptr<string> checkIn{};
  shared_ptr<string> ratePlanId{};
  shared_ptr<string> ratePlanName{};
  shared_ptr<string> roomId{};
  shared_ptr<string> roomName{};
  shared_ptr<long> roomPrice{};

  HotelOrderDetailInfoResponseBodyModuleRoomNightPriceInfoList() {}

  explicit HotelOrderDetailInfoResponseBodyModuleRoomNightPriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (board) {
      res["board"] = boost::any(*board);
    }
    if (boardNum) {
      res["board_num"] = boost::any(*boardNum);
    }
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (ratePlanId) {
      res["rate_plan_id"] = boost::any(*ratePlanId);
    }
    if (ratePlanName) {
      res["rate_plan_name"] = boost::any(*ratePlanName);
    }
    if (roomId) {
      res["room_id"] = boost::any(*roomId);
    }
    if (roomName) {
      res["room_name"] = boost::any(*roomName);
    }
    if (roomPrice) {
      res["room_price"] = boost::any(*roomPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("board") != m.end() && !m["board"].empty()) {
      board = make_shared<string>(boost::any_cast<string>(m["board"]));
    }
    if (m.find("board_num") != m.end() && !m["board_num"].empty()) {
      boardNum = make_shared<long>(boost::any_cast<long>(m["board_num"]));
    }
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
    if (m.find("rate_plan_id") != m.end() && !m["rate_plan_id"].empty()) {
      ratePlanId = make_shared<string>(boost::any_cast<string>(m["rate_plan_id"]));
    }
    if (m.find("rate_plan_name") != m.end() && !m["rate_plan_name"].empty()) {
      ratePlanName = make_shared<string>(boost::any_cast<string>(m["rate_plan_name"]));
    }
    if (m.find("room_id") != m.end() && !m["room_id"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["room_id"]));
    }
    if (m.find("room_name") != m.end() && !m["room_name"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["room_name"]));
    }
    if (m.find("room_price") != m.end() && !m["room_price"].empty()) {
      roomPrice = make_shared<long>(boost::any_cast<long>(m["room_price"]));
    }
  }


  virtual ~HotelOrderDetailInfoResponseBodyModuleRoomNightPriceInfoList() = default;
};
class HotelOrderDetailInfoResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> actualCheckInTime{};
  shared_ptr<string> actualCheckOutTime{};
  shared_ptr<HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTO> btripHotelCancelPolicyDTO{};
  shared_ptr<string> btripOrderId{};
  shared_ptr<long> cancelFine{};
  shared_ptr<HotelOrderDetailInfoResponseBodyModuleCancelInfo> cancelInfo{};
  shared_ptr<string> checkIn{};
  shared_ptr<string> checkOut{};
  shared_ptr<string> confirmOrderTime{};
  shared_ptr<string> contractName{};
  shared_ptr<string> contractTel{};
  shared_ptr<string> createOrderTime{};
  shared_ptr<string> earlyArrivalTime{};
  shared_ptr<bool> earlyDeparture{};
  shared_ptr<long> guestCount{};
  shared_ptr<HotelOrderDetailInfoResponseBodyModuleHotelDetailInfo> hotelDetailInfo{};
  shared_ptr<HotelOrderDetailInfoResponseBodyModuleInvoiceInfo> invoiceInfo{};
  shared_ptr<string> itemId{};
  shared_ptr<string> lastArrivalTime{};
  shared_ptr<vector<HotelOrderDetailInfoResponseBodyModuleOccupantInfoList>> occupantInfoList{};
  shared_ptr<long> orderStatus{};
  shared_ptr<string> orderStatusDesc{};
  shared_ptr<string> payTime{};
  shared_ptr<long> productType{};
  shared_ptr<string> purchaseOrderId{};
  shared_ptr<long> refundPrice{};
  shared_ptr<string> refundReason{};
  shared_ptr<long> refundServiceFee{};
  shared_ptr<vector<HotelOrderDetailInfoResponseBodyModuleRoomNightPriceInfoList>> roomNightPriceInfoList{};
  shared_ptr<long> roomNumber{};
  shared_ptr<string> roomTypeName{};
  shared_ptr<string> sellerId{};
  shared_ptr<string> sellerName{};
  shared_ptr<long> serviceFee{};
  shared_ptr<string> settleType{};
  shared_ptr<string> supplierOrderId{};
  shared_ptr<long> totalPrice{};

  HotelOrderDetailInfoResponseBodyModule() {}

  explicit HotelOrderDetailInfoResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualCheckInTime) {
      res["actual_check_in_time"] = boost::any(*actualCheckInTime);
    }
    if (actualCheckOutTime) {
      res["actual_check_out_time"] = boost::any(*actualCheckOutTime);
    }
    if (btripHotelCancelPolicyDTO) {
      res["btrip_hotel_cancel_policy_d_t_o"] = btripHotelCancelPolicyDTO ? boost::any(btripHotelCancelPolicyDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (cancelFine) {
      res["cancel_fine"] = boost::any(*cancelFine);
    }
    if (cancelInfo) {
      res["cancel_info"] = cancelInfo ? boost::any(cancelInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (confirmOrderTime) {
      res["confirm_order_time"] = boost::any(*confirmOrderTime);
    }
    if (contractName) {
      res["contract_name"] = boost::any(*contractName);
    }
    if (contractTel) {
      res["contract_tel"] = boost::any(*contractTel);
    }
    if (createOrderTime) {
      res["create_order_time"] = boost::any(*createOrderTime);
    }
    if (earlyArrivalTime) {
      res["early_arrival_time"] = boost::any(*earlyArrivalTime);
    }
    if (earlyDeparture) {
      res["early_departure"] = boost::any(*earlyDeparture);
    }
    if (guestCount) {
      res["guest_count"] = boost::any(*guestCount);
    }
    if (hotelDetailInfo) {
      res["hotel_detail_info"] = hotelDetailInfo ? boost::any(hotelDetailInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invoiceInfo) {
      res["invoice_info"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (lastArrivalTime) {
      res["last_arrival_time"] = boost::any(*lastArrivalTime);
    }
    if (occupantInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*occupantInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["occupant_info_list"] = boost::any(temp1);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (orderStatusDesc) {
      res["order_status_desc"] = boost::any(*orderStatusDesc);
    }
    if (payTime) {
      res["pay_time"] = boost::any(*payTime);
    }
    if (productType) {
      res["product_type"] = boost::any(*productType);
    }
    if (purchaseOrderId) {
      res["purchase_order_id"] = boost::any(*purchaseOrderId);
    }
    if (refundPrice) {
      res["refund_price"] = boost::any(*refundPrice);
    }
    if (refundReason) {
      res["refund_reason"] = boost::any(*refundReason);
    }
    if (refundServiceFee) {
      res["refund_service_fee"] = boost::any(*refundServiceFee);
    }
    if (roomNightPriceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*roomNightPriceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["room_night_price_info_list"] = boost::any(temp1);
    }
    if (roomNumber) {
      res["room_number"] = boost::any(*roomNumber);
    }
    if (roomTypeName) {
      res["room_type_name"] = boost::any(*roomTypeName);
    }
    if (sellerId) {
      res["seller_id"] = boost::any(*sellerId);
    }
    if (sellerName) {
      res["seller_name"] = boost::any(*sellerName);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (settleType) {
      res["settle_type"] = boost::any(*settleType);
    }
    if (supplierOrderId) {
      res["supplier_order_id"] = boost::any(*supplierOrderId);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actual_check_in_time") != m.end() && !m["actual_check_in_time"].empty()) {
      actualCheckInTime = make_shared<string>(boost::any_cast<string>(m["actual_check_in_time"]));
    }
    if (m.find("actual_check_out_time") != m.end() && !m["actual_check_out_time"].empty()) {
      actualCheckOutTime = make_shared<string>(boost::any_cast<string>(m["actual_check_out_time"]));
    }
    if (m.find("btrip_hotel_cancel_policy_d_t_o") != m.end() && !m["btrip_hotel_cancel_policy_d_t_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["btrip_hotel_cancel_policy_d_t_o"].type()) {
        HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["btrip_hotel_cancel_policy_d_t_o"]));
        btripHotelCancelPolicyDTO = make_shared<HotelOrderDetailInfoResponseBodyModuleBtripHotelCancelPolicyDTO>(model1);
      }
    }
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<string>(boost::any_cast<string>(m["btrip_order_id"]));
    }
    if (m.find("cancel_fine") != m.end() && !m["cancel_fine"].empty()) {
      cancelFine = make_shared<long>(boost::any_cast<long>(m["cancel_fine"]));
    }
    if (m.find("cancel_info") != m.end() && !m["cancel_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["cancel_info"].type()) {
        HotelOrderDetailInfoResponseBodyModuleCancelInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cancel_info"]));
        cancelInfo = make_shared<HotelOrderDetailInfoResponseBodyModuleCancelInfo>(model1);
      }
    }
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<string>(boost::any_cast<string>(m["check_out"]));
    }
    if (m.find("confirm_order_time") != m.end() && !m["confirm_order_time"].empty()) {
      confirmOrderTime = make_shared<string>(boost::any_cast<string>(m["confirm_order_time"]));
    }
    if (m.find("contract_name") != m.end() && !m["contract_name"].empty()) {
      contractName = make_shared<string>(boost::any_cast<string>(m["contract_name"]));
    }
    if (m.find("contract_tel") != m.end() && !m["contract_tel"].empty()) {
      contractTel = make_shared<string>(boost::any_cast<string>(m["contract_tel"]));
    }
    if (m.find("create_order_time") != m.end() && !m["create_order_time"].empty()) {
      createOrderTime = make_shared<string>(boost::any_cast<string>(m["create_order_time"]));
    }
    if (m.find("early_arrival_time") != m.end() && !m["early_arrival_time"].empty()) {
      earlyArrivalTime = make_shared<string>(boost::any_cast<string>(m["early_arrival_time"]));
    }
    if (m.find("early_departure") != m.end() && !m["early_departure"].empty()) {
      earlyDeparture = make_shared<bool>(boost::any_cast<bool>(m["early_departure"]));
    }
    if (m.find("guest_count") != m.end() && !m["guest_count"].empty()) {
      guestCount = make_shared<long>(boost::any_cast<long>(m["guest_count"]));
    }
    if (m.find("hotel_detail_info") != m.end() && !m["hotel_detail_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["hotel_detail_info"].type()) {
        HotelOrderDetailInfoResponseBodyModuleHotelDetailInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["hotel_detail_info"]));
        hotelDetailInfo = make_shared<HotelOrderDetailInfoResponseBodyModuleHotelDetailInfo>(model1);
      }
    }
    if (m.find("invoice_info") != m.end() && !m["invoice_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice_info"].type()) {
        HotelOrderDetailInfoResponseBodyModuleInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice_info"]));
        invoiceInfo = make_shared<HotelOrderDetailInfoResponseBodyModuleInvoiceInfo>(model1);
      }
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["item_id"]));
    }
    if (m.find("last_arrival_time") != m.end() && !m["last_arrival_time"].empty()) {
      lastArrivalTime = make_shared<string>(boost::any_cast<string>(m["last_arrival_time"]));
    }
    if (m.find("occupant_info_list") != m.end() && !m["occupant_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["occupant_info_list"].type()) {
        vector<HotelOrderDetailInfoResponseBodyModuleOccupantInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["occupant_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderDetailInfoResponseBodyModuleOccupantInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        occupantInfoList = make_shared<vector<HotelOrderDetailInfoResponseBodyModuleOccupantInfoList>>(expect1);
      }
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("order_status_desc") != m.end() && !m["order_status_desc"].empty()) {
      orderStatusDesc = make_shared<string>(boost::any_cast<string>(m["order_status_desc"]));
    }
    if (m.find("pay_time") != m.end() && !m["pay_time"].empty()) {
      payTime = make_shared<string>(boost::any_cast<string>(m["pay_time"]));
    }
    if (m.find("product_type") != m.end() && !m["product_type"].empty()) {
      productType = make_shared<long>(boost::any_cast<long>(m["product_type"]));
    }
    if (m.find("purchase_order_id") != m.end() && !m["purchase_order_id"].empty()) {
      purchaseOrderId = make_shared<string>(boost::any_cast<string>(m["purchase_order_id"]));
    }
    if (m.find("refund_price") != m.end() && !m["refund_price"].empty()) {
      refundPrice = make_shared<long>(boost::any_cast<long>(m["refund_price"]));
    }
    if (m.find("refund_reason") != m.end() && !m["refund_reason"].empty()) {
      refundReason = make_shared<string>(boost::any_cast<string>(m["refund_reason"]));
    }
    if (m.find("refund_service_fee") != m.end() && !m["refund_service_fee"].empty()) {
      refundServiceFee = make_shared<long>(boost::any_cast<long>(m["refund_service_fee"]));
    }
    if (m.find("room_night_price_info_list") != m.end() && !m["room_night_price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["room_night_price_info_list"].type()) {
        vector<HotelOrderDetailInfoResponseBodyModuleRoomNightPriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["room_night_price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderDetailInfoResponseBodyModuleRoomNightPriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roomNightPriceInfoList = make_shared<vector<HotelOrderDetailInfoResponseBodyModuleRoomNightPriceInfoList>>(expect1);
      }
    }
    if (m.find("room_number") != m.end() && !m["room_number"].empty()) {
      roomNumber = make_shared<long>(boost::any_cast<long>(m["room_number"]));
    }
    if (m.find("room_type_name") != m.end() && !m["room_type_name"].empty()) {
      roomTypeName = make_shared<string>(boost::any_cast<string>(m["room_type_name"]));
    }
    if (m.find("seller_id") != m.end() && !m["seller_id"].empty()) {
      sellerId = make_shared<string>(boost::any_cast<string>(m["seller_id"]));
    }
    if (m.find("seller_name") != m.end() && !m["seller_name"].empty()) {
      sellerName = make_shared<string>(boost::any_cast<string>(m["seller_name"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<long>(boost::any_cast<long>(m["service_fee"]));
    }
    if (m.find("settle_type") != m.end() && !m["settle_type"].empty()) {
      settleType = make_shared<string>(boost::any_cast<string>(m["settle_type"]));
    }
    if (m.find("supplier_order_id") != m.end() && !m["supplier_order_id"].empty()) {
      supplierOrderId = make_shared<string>(boost::any_cast<string>(m["supplier_order_id"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<long>(boost::any_cast<long>(m["total_price"]));
    }
  }


  virtual ~HotelOrderDetailInfoResponseBodyModule() = default;
};
class HotelOrderDetailInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelOrderDetailInfoResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelOrderDetailInfoResponseBody() {}

  explicit HotelOrderDetailInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelOrderDetailInfoResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelOrderDetailInfoResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelOrderDetailInfoResponseBody() = default;
};
class HotelOrderDetailInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelOrderDetailInfoResponseBody> body{};

  HotelOrderDetailInfoResponse() {}

  explicit HotelOrderDetailInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelOrderDetailInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelOrderDetailInfoResponseBody>(model1);
      }
    }
  }


  virtual ~HotelOrderDetailInfoResponse() = default;
};
class HotelOrderListQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  HotelOrderListQueryHeaders() {}

  explicit HotelOrderListQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~HotelOrderListQueryHeaders() = default;
};
class HotelOrderListQueryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allApply{};
  shared_ptr<long> applyId{};
  shared_ptr<string> departId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> updateEndTime{};
  shared_ptr<string> updateStartTime{};
  shared_ptr<string> userId{};

  HotelOrderListQueryRequest() {}

  explicit HotelOrderListQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allApply) {
      res["all_apply"] = boost::any(*allApply);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (updateEndTime) {
      res["update_end_time"] = boost::any(*updateEndTime);
    }
    if (updateStartTime) {
      res["update_start_time"] = boost::any(*updateStartTime);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_apply") != m.end() && !m["all_apply"].empty()) {
      allApply = make_shared<bool>(boost::any_cast<bool>(m["all_apply"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("update_end_time") != m.end() && !m["update_end_time"].empty()) {
      updateEndTime = make_shared<string>(boost::any_cast<string>(m["update_end_time"]));
    }
    if (m.find("update_start_time") != m.end() && !m["update_start_time"].empty()) {
      updateStartTime = make_shared<string>(boost::any_cast<string>(m["update_start_time"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~HotelOrderListQueryRequest() = default;
};
class HotelOrderListQueryResponseBodyModuleCostCenter : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> number{};

  HotelOrderListQueryResponseBodyModuleCostCenter() {}

  explicit HotelOrderListQueryResponseBodyModuleCostCenter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (number) {
      res["number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("number") != m.end() && !m["number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["number"]));
    }
  }


  virtual ~HotelOrderListQueryResponseBodyModuleCostCenter() = default;
};
class HotelOrderListQueryResponseBodyModuleInvoice : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> invoiceType{};
  shared_ptr<string> title{};

  HotelOrderListQueryResponseBodyModuleInvoice() {}

  explicit HotelOrderListQueryResponseBodyModuleInvoice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~HotelOrderListQueryResponseBodyModuleInvoice() = default;
};
class HotelOrderListQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<long> categoryType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> payType{};
  shared_ptr<double> price{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  HotelOrderListQueryResponseBodyModulePriceInfoList() {}

  explicit HotelOrderListQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (categoryType) {
      res["category_type"] = boost::any(*categoryType);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("category_type") != m.end() && !m["category_type"].empty()) {
      categoryType = make_shared<long>(boost::any_cast<long>(m["category_type"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~HotelOrderListQueryResponseBodyModulePriceInfoList() = default;
};
class HotelOrderListQueryResponseBodyModuleUserAffiliateList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  HotelOrderListQueryResponseBodyModuleUserAffiliateList() {}

  explicit HotelOrderListQueryResponseBodyModuleUserAffiliateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~HotelOrderListQueryResponseBodyModuleUserAffiliateList() = default;
};
class HotelOrderListQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> checkIn{};
  shared_ptr<string> checkOut{};
  shared_ptr<string> city{};
  shared_ptr<string> cityAdCode{};
  shared_ptr<string> contactName{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<HotelOrderListQueryResponseBodyModuleCostCenter> costCenter{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> extendField{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> guest{};
  shared_ptr<string> hotelName{};
  shared_ptr<long> hotelSupportVatInvoiceType{};
  shared_ptr<long> id{};
  shared_ptr<HotelOrderListQueryResponseBodyModuleInvoice> invoice{};
  shared_ptr<long> night{};
  shared_ptr<long> orderStatus{};
  shared_ptr<string> orderStatusDesc{};
  shared_ptr<long> orderType{};
  shared_ptr<string> orderTypeDesc{};
  shared_ptr<vector<HotelOrderListQueryResponseBodyModulePriceInfoList>> priceInfoList{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<long> roomNum{};
  shared_ptr<string> roomType{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<string> thirdpartProjectId{};
  shared_ptr<vector<HotelOrderListQueryResponseBodyModuleUserAffiliateList>> userAffiliateList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  HotelOrderListQueryResponseBodyModule() {}

  explicit HotelOrderListQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (city) {
      res["city"] = boost::any(*city);
    }
    if (cityAdCode) {
      res["city_ad_code"] = boost::any(*cityAdCode);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (costCenter) {
      res["cost_center"] = costCenter ? boost::any(costCenter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (extendField) {
      res["extend_field"] = boost::any(*extendField);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (guest) {
      res["guest"] = boost::any(*guest);
    }
    if (hotelName) {
      res["hotel_name"] = boost::any(*hotelName);
    }
    if (hotelSupportVatInvoiceType) {
      res["hotel_support_vat_invoice_type"] = boost::any(*hotelSupportVatInvoiceType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (invoice) {
      res["invoice"] = invoice ? boost::any(invoice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (night) {
      res["night"] = boost::any(*night);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (orderStatusDesc) {
      res["order_status_desc"] = boost::any(*orderStatusDesc);
    }
    if (orderType) {
      res["order_type"] = boost::any(*orderType);
    }
    if (orderTypeDesc) {
      res["order_type_desc"] = boost::any(*orderTypeDesc);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (roomNum) {
      res["room_num"] = boost::any(*roomNum);
    }
    if (roomType) {
      res["room_type"] = boost::any(*roomType);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (thirdpartProjectId) {
      res["thirdpart_project_id"] = boost::any(*thirdpartProjectId);
    }
    if (userAffiliateList) {
      vector<boost::any> temp1;
      for(auto item1:*userAffiliateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["user_affiliate_list"] = boost::any(temp1);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<string>(boost::any_cast<string>(m["check_out"]));
    }
    if (m.find("city") != m.end() && !m["city"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["city"]));
    }
    if (m.find("city_ad_code") != m.end() && !m["city_ad_code"].empty()) {
      cityAdCode = make_shared<string>(boost::any_cast<string>(m["city_ad_code"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      if (typeid(map<string, boost::any>) == m["cost_center"].type()) {
        HotelOrderListQueryResponseBodyModuleCostCenter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cost_center"]));
        costCenter = make_shared<HotelOrderListQueryResponseBodyModuleCostCenter>(model1);
      }
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("extend_field") != m.end() && !m["extend_field"].empty()) {
      extendField = make_shared<string>(boost::any_cast<string>(m["extend_field"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("guest") != m.end() && !m["guest"].empty()) {
      guest = make_shared<string>(boost::any_cast<string>(m["guest"]));
    }
    if (m.find("hotel_name") != m.end() && !m["hotel_name"].empty()) {
      hotelName = make_shared<string>(boost::any_cast<string>(m["hotel_name"]));
    }
    if (m.find("hotel_support_vat_invoice_type") != m.end() && !m["hotel_support_vat_invoice_type"].empty()) {
      hotelSupportVatInvoiceType = make_shared<long>(boost::any_cast<long>(m["hotel_support_vat_invoice_type"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("invoice") != m.end() && !m["invoice"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice"].type()) {
        HotelOrderListQueryResponseBodyModuleInvoice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice"]));
        invoice = make_shared<HotelOrderListQueryResponseBodyModuleInvoice>(model1);
      }
    }
    if (m.find("night") != m.end() && !m["night"].empty()) {
      night = make_shared<long>(boost::any_cast<long>(m["night"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("order_status_desc") != m.end() && !m["order_status_desc"].empty()) {
      orderStatusDesc = make_shared<string>(boost::any_cast<string>(m["order_status_desc"]));
    }
    if (m.find("order_type") != m.end() && !m["order_type"].empty()) {
      orderType = make_shared<long>(boost::any_cast<long>(m["order_type"]));
    }
    if (m.find("order_type_desc") != m.end() && !m["order_type_desc"].empty()) {
      orderTypeDesc = make_shared<string>(boost::any_cast<string>(m["order_type_desc"]));
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<HotelOrderListQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderListQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<HotelOrderListQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("room_num") != m.end() && !m["room_num"].empty()) {
      roomNum = make_shared<long>(boost::any_cast<long>(m["room_num"]));
    }
    if (m.find("room_type") != m.end() && !m["room_type"].empty()) {
      roomType = make_shared<string>(boost::any_cast<string>(m["room_type"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("thirdpart_project_id") != m.end() && !m["thirdpart_project_id"].empty()) {
      thirdpartProjectId = make_shared<string>(boost::any_cast<string>(m["thirdpart_project_id"]));
    }
    if (m.find("user_affiliate_list") != m.end() && !m["user_affiliate_list"].empty()) {
      if (typeid(vector<boost::any>) == m["user_affiliate_list"].type()) {
        vector<HotelOrderListQueryResponseBodyModuleUserAffiliateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["user_affiliate_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderListQueryResponseBodyModuleUserAffiliateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userAffiliateList = make_shared<vector<HotelOrderListQueryResponseBodyModuleUserAffiliateList>>(expect1);
      }
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~HotelOrderListQueryResponseBodyModule() = default;
};
class HotelOrderListQueryResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalNumber{};

  HotelOrderListQueryResponseBodyPageInfo() {}

  explicit HotelOrderListQueryResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalNumber) {
      res["total_number"] = boost::any(*totalNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_number") != m.end() && !m["total_number"].empty()) {
      totalNumber = make_shared<long>(boost::any_cast<long>(m["total_number"]));
    }
  }


  virtual ~HotelOrderListQueryResponseBodyPageInfo() = default;
};
class HotelOrderListQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<HotelOrderListQueryResponseBodyModule>> module{};
  shared_ptr<HotelOrderListQueryResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelOrderListQueryResponseBody() {}

  explicit HotelOrderListQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<HotelOrderListQueryResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderListQueryResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<HotelOrderListQueryResponseBodyModule>>(expect1);
      }
    }
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        HotelOrderListQueryResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<HotelOrderListQueryResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelOrderListQueryResponseBody() = default;
};
class HotelOrderListQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelOrderListQueryResponseBody> body{};

  HotelOrderListQueryResponse() {}

  explicit HotelOrderListQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelOrderListQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelOrderListQueryResponseBody>(model1);
      }
    }
  }


  virtual ~HotelOrderListQueryResponse() = default;
};
class HotelOrderPayHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  HotelOrderPayHeaders() {}

  explicit HotelOrderPayHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~HotelOrderPayHeaders() = default;
};
class HotelOrderPayRequest : public Darabonba::Model {
public:
  shared_ptr<long> btripOrderId{};
  shared_ptr<string> btripUserId{};
  shared_ptr<long> companyPayFee{};
  shared_ptr<long> personPayFee{};
  shared_ptr<string> thirdPayAccount{};
  shared_ptr<string> thirdTradeNo{};
  shared_ptr<long> totalPrice{};

  HotelOrderPayRequest() {}

  explicit HotelOrderPayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (companyPayFee) {
      res["company_pay_fee"] = boost::any(*companyPayFee);
    }
    if (personPayFee) {
      res["person_pay_fee"] = boost::any(*personPayFee);
    }
    if (thirdPayAccount) {
      res["third_pay_account"] = boost::any(*thirdPayAccount);
    }
    if (thirdTradeNo) {
      res["third_trade_no"] = boost::any(*thirdTradeNo);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_order_id"]));
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("company_pay_fee") != m.end() && !m["company_pay_fee"].empty()) {
      companyPayFee = make_shared<long>(boost::any_cast<long>(m["company_pay_fee"]));
    }
    if (m.find("person_pay_fee") != m.end() && !m["person_pay_fee"].empty()) {
      personPayFee = make_shared<long>(boost::any_cast<long>(m["person_pay_fee"]));
    }
    if (m.find("third_pay_account") != m.end() && !m["third_pay_account"].empty()) {
      thirdPayAccount = make_shared<string>(boost::any_cast<string>(m["third_pay_account"]));
    }
    if (m.find("third_trade_no") != m.end() && !m["third_trade_no"].empty()) {
      thirdTradeNo = make_shared<string>(boost::any_cast<string>(m["third_trade_no"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<long>(boost::any_cast<long>(m["total_price"]));
    }
  }


  virtual ~HotelOrderPayRequest() = default;
};
class HotelOrderPayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelOrderPayResponseBody() {}

  explicit HotelOrderPayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<bool>(boost::any_cast<bool>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelOrderPayResponseBody() = default;
};
class HotelOrderPayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelOrderPayResponseBody> body{};

  HotelOrderPayResponse() {}

  explicit HotelOrderPayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelOrderPayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelOrderPayResponseBody>(model1);
      }
    }
  }


  virtual ~HotelOrderPayResponse() = default;
};
class HotelOrderPreValidateHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  HotelOrderPreValidateHeaders() {}

  explicit HotelOrderPreValidateHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~HotelOrderPreValidateHeaders() = default;
};
class HotelOrderPreValidateRequestDailyList : public Darabonba::Model {
public:
  shared_ptr<string> board{};
  shared_ptr<long> price{};
  shared_ptr<string> rateStartTime{};
  shared_ptr<long> roomCount{};

  HotelOrderPreValidateRequestDailyList() {}

  explicit HotelOrderPreValidateRequestDailyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (board) {
      res["board"] = boost::any(*board);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (rateStartTime) {
      res["rate_start_time"] = boost::any(*rateStartTime);
    }
    if (roomCount) {
      res["room_count"] = boost::any(*roomCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("board") != m.end() && !m["board"].empty()) {
      board = make_shared<string>(boost::any_cast<string>(m["board"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("rate_start_time") != m.end() && !m["rate_start_time"].empty()) {
      rateStartTime = make_shared<string>(boost::any_cast<string>(m["rate_start_time"]));
    }
    if (m.find("room_count") != m.end() && !m["room_count"].empty()) {
      roomCount = make_shared<long>(boost::any_cast<long>(m["room_count"]));
    }
  }


  virtual ~HotelOrderPreValidateRequestDailyList() = default;
};
class HotelOrderPreValidateRequestOccupantInfoList : public Darabonba::Model {
public:
  shared_ptr<string> cardNo{};
  shared_ptr<long> cardType{};
  shared_ptr<string> name{};
  shared_ptr<string> phone{};
  shared_ptr<string> staffNo{};
  shared_ptr<long> userType{};

  HotelOrderPreValidateRequestOccupantInfoList() {}

  explicit HotelOrderPreValidateRequestOccupantInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardNo) {
      res["card_no"] = boost::any(*cardNo);
    }
    if (cardType) {
      res["card_type"] = boost::any(*cardType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (staffNo) {
      res["staff_no"] = boost::any(*staffNo);
    }
    if (userType) {
      res["user_type"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("card_no") != m.end() && !m["card_no"].empty()) {
      cardNo = make_shared<string>(boost::any_cast<string>(m["card_no"]));
    }
    if (m.find("card_type") != m.end() && !m["card_type"].empty()) {
      cardType = make_shared<long>(boost::any_cast<long>(m["card_type"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("staff_no") != m.end() && !m["staff_no"].empty()) {
      staffNo = make_shared<string>(boost::any_cast<string>(m["staff_no"]));
    }
    if (m.find("user_type") != m.end() && !m["user_type"].empty()) {
      userType = make_shared<long>(boost::any_cast<long>(m["user_type"]));
    }
  }


  virtual ~HotelOrderPreValidateRequestOccupantInfoList() = default;
};
class HotelOrderPreValidateRequest : public Darabonba::Model {
public:
  shared_ptr<string> btripUserId{};
  shared_ptr<string> checkIn{};
  shared_ptr<string> checkOut{};
  shared_ptr<vector<HotelOrderPreValidateRequestDailyList>> dailyList{};
  shared_ptr<long> itemId{};
  shared_ptr<long> numberOfAdultsPerRoom{};
  shared_ptr<vector<HotelOrderPreValidateRequestOccupantInfoList>> occupantInfoList{};
  shared_ptr<long> ratePlanId{};
  shared_ptr<long> roomId{};
  shared_ptr<long> roomNum{};
  shared_ptr<long> searchRoomPrice{};
  shared_ptr<long> sellerId{};
  shared_ptr<long> shid{};

  HotelOrderPreValidateRequest() {}

  explicit HotelOrderPreValidateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (dailyList) {
      vector<boost::any> temp1;
      for(auto item1:*dailyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["daily_list"] = boost::any(temp1);
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (numberOfAdultsPerRoom) {
      res["number_of_adults_per_room"] = boost::any(*numberOfAdultsPerRoom);
    }
    if (occupantInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*occupantInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["occupant_info_list"] = boost::any(temp1);
    }
    if (ratePlanId) {
      res["rate_plan_id"] = boost::any(*ratePlanId);
    }
    if (roomId) {
      res["room_id"] = boost::any(*roomId);
    }
    if (roomNum) {
      res["room_num"] = boost::any(*roomNum);
    }
    if (searchRoomPrice) {
      res["search_room_price"] = boost::any(*searchRoomPrice);
    }
    if (sellerId) {
      res["seller_id"] = boost::any(*sellerId);
    }
    if (shid) {
      res["shid"] = boost::any(*shid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<string>(boost::any_cast<string>(m["check_out"]));
    }
    if (m.find("daily_list") != m.end() && !m["daily_list"].empty()) {
      if (typeid(vector<boost::any>) == m["daily_list"].type()) {
        vector<HotelOrderPreValidateRequestDailyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["daily_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderPreValidateRequestDailyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dailyList = make_shared<vector<HotelOrderPreValidateRequestDailyList>>(expect1);
      }
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["item_id"]));
    }
    if (m.find("number_of_adults_per_room") != m.end() && !m["number_of_adults_per_room"].empty()) {
      numberOfAdultsPerRoom = make_shared<long>(boost::any_cast<long>(m["number_of_adults_per_room"]));
    }
    if (m.find("occupant_info_list") != m.end() && !m["occupant_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["occupant_info_list"].type()) {
        vector<HotelOrderPreValidateRequestOccupantInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["occupant_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderPreValidateRequestOccupantInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        occupantInfoList = make_shared<vector<HotelOrderPreValidateRequestOccupantInfoList>>(expect1);
      }
    }
    if (m.find("rate_plan_id") != m.end() && !m["rate_plan_id"].empty()) {
      ratePlanId = make_shared<long>(boost::any_cast<long>(m["rate_plan_id"]));
    }
    if (m.find("room_id") != m.end() && !m["room_id"].empty()) {
      roomId = make_shared<long>(boost::any_cast<long>(m["room_id"]));
    }
    if (m.find("room_num") != m.end() && !m["room_num"].empty()) {
      roomNum = make_shared<long>(boost::any_cast<long>(m["room_num"]));
    }
    if (m.find("search_room_price") != m.end() && !m["search_room_price"].empty()) {
      searchRoomPrice = make_shared<long>(boost::any_cast<long>(m["search_room_price"]));
    }
    if (m.find("seller_id") != m.end() && !m["seller_id"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["seller_id"]));
    }
    if (m.find("shid") != m.end() && !m["shid"].empty()) {
      shid = make_shared<long>(boost::any_cast<long>(m["shid"]));
    }
  }


  virtual ~HotelOrderPreValidateRequest() = default;
};
class HotelOrderPreValidateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> btripUserId{};
  shared_ptr<string> checkIn{};
  shared_ptr<string> checkOut{};
  shared_ptr<string> dailyListShrink{};
  shared_ptr<long> itemId{};
  shared_ptr<long> numberOfAdultsPerRoom{};
  shared_ptr<string> occupantInfoListShrink{};
  shared_ptr<long> ratePlanId{};
  shared_ptr<long> roomId{};
  shared_ptr<long> roomNum{};
  shared_ptr<long> searchRoomPrice{};
  shared_ptr<long> sellerId{};
  shared_ptr<long> shid{};

  HotelOrderPreValidateShrinkRequest() {}

  explicit HotelOrderPreValidateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (dailyListShrink) {
      res["daily_list"] = boost::any(*dailyListShrink);
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (numberOfAdultsPerRoom) {
      res["number_of_adults_per_room"] = boost::any(*numberOfAdultsPerRoom);
    }
    if (occupantInfoListShrink) {
      res["occupant_info_list"] = boost::any(*occupantInfoListShrink);
    }
    if (ratePlanId) {
      res["rate_plan_id"] = boost::any(*ratePlanId);
    }
    if (roomId) {
      res["room_id"] = boost::any(*roomId);
    }
    if (roomNum) {
      res["room_num"] = boost::any(*roomNum);
    }
    if (searchRoomPrice) {
      res["search_room_price"] = boost::any(*searchRoomPrice);
    }
    if (sellerId) {
      res["seller_id"] = boost::any(*sellerId);
    }
    if (shid) {
      res["shid"] = boost::any(*shid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<string>(boost::any_cast<string>(m["check_out"]));
    }
    if (m.find("daily_list") != m.end() && !m["daily_list"].empty()) {
      dailyListShrink = make_shared<string>(boost::any_cast<string>(m["daily_list"]));
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["item_id"]));
    }
    if (m.find("number_of_adults_per_room") != m.end() && !m["number_of_adults_per_room"].empty()) {
      numberOfAdultsPerRoom = make_shared<long>(boost::any_cast<long>(m["number_of_adults_per_room"]));
    }
    if (m.find("occupant_info_list") != m.end() && !m["occupant_info_list"].empty()) {
      occupantInfoListShrink = make_shared<string>(boost::any_cast<string>(m["occupant_info_list"]));
    }
    if (m.find("rate_plan_id") != m.end() && !m["rate_plan_id"].empty()) {
      ratePlanId = make_shared<long>(boost::any_cast<long>(m["rate_plan_id"]));
    }
    if (m.find("room_id") != m.end() && !m["room_id"].empty()) {
      roomId = make_shared<long>(boost::any_cast<long>(m["room_id"]));
    }
    if (m.find("room_num") != m.end() && !m["room_num"].empty()) {
      roomNum = make_shared<long>(boost::any_cast<long>(m["room_num"]));
    }
    if (m.find("search_room_price") != m.end() && !m["search_room_price"].empty()) {
      searchRoomPrice = make_shared<long>(boost::any_cast<long>(m["search_room_price"]));
    }
    if (m.find("seller_id") != m.end() && !m["seller_id"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["seller_id"]));
    }
    if (m.find("shid") != m.end() && !m["shid"].empty()) {
      shid = make_shared<long>(boost::any_cast<long>(m["shid"]));
    }
  }


  virtual ~HotelOrderPreValidateShrinkRequest() = default;
};
class HotelOrderPreValidateResponseBodyModulePromotionInfoPromotionDetailInfoList : public Darabonba::Model {
public:
  shared_ptr<bool> checkStatus{};
  shared_ptr<bool> needCheck{};
  shared_ptr<string> promotionCode{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> promotionName{};
  shared_ptr<long> promotionPrice{};
  shared_ptr<string> promotionType{};

  HotelOrderPreValidateResponseBodyModulePromotionInfoPromotionDetailInfoList() {}

  explicit HotelOrderPreValidateResponseBodyModulePromotionInfoPromotionDetailInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkStatus) {
      res["check_status"] = boost::any(*checkStatus);
    }
    if (needCheck) {
      res["need_check"] = boost::any(*needCheck);
    }
    if (promotionCode) {
      res["promotion_code"] = boost::any(*promotionCode);
    }
    if (promotionId) {
      res["promotion_id"] = boost::any(*promotionId);
    }
    if (promotionName) {
      res["promotion_name"] = boost::any(*promotionName);
    }
    if (promotionPrice) {
      res["promotion_price"] = boost::any(*promotionPrice);
    }
    if (promotionType) {
      res["promotion_type"] = boost::any(*promotionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("check_status") != m.end() && !m["check_status"].empty()) {
      checkStatus = make_shared<bool>(boost::any_cast<bool>(m["check_status"]));
    }
    if (m.find("need_check") != m.end() && !m["need_check"].empty()) {
      needCheck = make_shared<bool>(boost::any_cast<bool>(m["need_check"]));
    }
    if (m.find("promotion_code") != m.end() && !m["promotion_code"].empty()) {
      promotionCode = make_shared<string>(boost::any_cast<string>(m["promotion_code"]));
    }
    if (m.find("promotion_id") != m.end() && !m["promotion_id"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["promotion_id"]));
    }
    if (m.find("promotion_name") != m.end() && !m["promotion_name"].empty()) {
      promotionName = make_shared<string>(boost::any_cast<string>(m["promotion_name"]));
    }
    if (m.find("promotion_price") != m.end() && !m["promotion_price"].empty()) {
      promotionPrice = make_shared<long>(boost::any_cast<long>(m["promotion_price"]));
    }
    if (m.find("promotion_type") != m.end() && !m["promotion_type"].empty()) {
      promotionType = make_shared<string>(boost::any_cast<string>(m["promotion_type"]));
    }
  }


  virtual ~HotelOrderPreValidateResponseBodyModulePromotionInfoPromotionDetailInfoList() = default;
};
class HotelOrderPreValidateResponseBodyModulePromotionInfo : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> extAttrMap{};
  shared_ptr<vector<HotelOrderPreValidateResponseBodyModulePromotionInfoPromotionDetailInfoList>> promotionDetailInfoList{};
  shared_ptr<long> promotionTotalPrice{};

  HotelOrderPreValidateResponseBodyModulePromotionInfo() {}

  explicit HotelOrderPreValidateResponseBodyModulePromotionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extAttrMap) {
      res["ext_attr_map"] = boost::any(*extAttrMap);
    }
    if (promotionDetailInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*promotionDetailInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["promotion_detail_info_list"] = boost::any(temp1);
    }
    if (promotionTotalPrice) {
      res["promotion_total_price"] = boost::any(*promotionTotalPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ext_attr_map") != m.end() && !m["ext_attr_map"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ext_attr_map"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extAttrMap = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("promotion_detail_info_list") != m.end() && !m["promotion_detail_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["promotion_detail_info_list"].type()) {
        vector<HotelOrderPreValidateResponseBodyModulePromotionInfoPromotionDetailInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["promotion_detail_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderPreValidateResponseBodyModulePromotionInfoPromotionDetailInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        promotionDetailInfoList = make_shared<vector<HotelOrderPreValidateResponseBodyModulePromotionInfoPromotionDetailInfoList>>(expect1);
      }
    }
    if (m.find("promotion_total_price") != m.end() && !m["promotion_total_price"].empty()) {
      promotionTotalPrice = make_shared<long>(boost::any_cast<long>(m["promotion_total_price"]));
    }
  }


  virtual ~HotelOrderPreValidateResponseBodyModulePromotionInfo() = default;
};
class HotelOrderPreValidateResponseBodyModuleRatePlanDaily : public Darabonba::Model {
public:
  shared_ptr<string> board{};
  shared_ptr<string> discountPrice{};
  shared_ptr<long> maxBookingNum{};
  shared_ptr<long> price{};
  shared_ptr<string> rateStartTime{};
  shared_ptr<long> roomCount{};
  shared_ptr<string> roundingDiscountPrice{};
  shared_ptr<string> roundingPrice{};
  shared_ptr<long> serviceFee{};

  HotelOrderPreValidateResponseBodyModuleRatePlanDaily() {}

  explicit HotelOrderPreValidateResponseBodyModuleRatePlanDaily(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (board) {
      res["board"] = boost::any(*board);
    }
    if (discountPrice) {
      res["discount_price"] = boost::any(*discountPrice);
    }
    if (maxBookingNum) {
      res["max_booking_num"] = boost::any(*maxBookingNum);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (rateStartTime) {
      res["rate_start_time"] = boost::any(*rateStartTime);
    }
    if (roomCount) {
      res["room_count"] = boost::any(*roomCount);
    }
    if (roundingDiscountPrice) {
      res["rounding_discount_price"] = boost::any(*roundingDiscountPrice);
    }
    if (roundingPrice) {
      res["rounding_price"] = boost::any(*roundingPrice);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("board") != m.end() && !m["board"].empty()) {
      board = make_shared<string>(boost::any_cast<string>(m["board"]));
    }
    if (m.find("discount_price") != m.end() && !m["discount_price"].empty()) {
      discountPrice = make_shared<string>(boost::any_cast<string>(m["discount_price"]));
    }
    if (m.find("max_booking_num") != m.end() && !m["max_booking_num"].empty()) {
      maxBookingNum = make_shared<long>(boost::any_cast<long>(m["max_booking_num"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("rate_start_time") != m.end() && !m["rate_start_time"].empty()) {
      rateStartTime = make_shared<string>(boost::any_cast<string>(m["rate_start_time"]));
    }
    if (m.find("room_count") != m.end() && !m["room_count"].empty()) {
      roomCount = make_shared<long>(boost::any_cast<long>(m["room_count"]));
    }
    if (m.find("rounding_discount_price") != m.end() && !m["rounding_discount_price"].empty()) {
      roundingDiscountPrice = make_shared<string>(boost::any_cast<string>(m["rounding_discount_price"]));
    }
    if (m.find("rounding_price") != m.end() && !m["rounding_price"].empty()) {
      roundingPrice = make_shared<string>(boost::any_cast<string>(m["rounding_price"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<long>(boost::any_cast<long>(m["service_fee"]));
    }
  }


  virtual ~HotelOrderPreValidateResponseBodyModuleRatePlanDaily() = default;
};
class HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList : public Darabonba::Model {
public:
  shared_ptr<long> hour{};
  shared_ptr<long> value{};

  HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList() {}

  explicit HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hour) {
      res["hour"] = boost::any(*hour);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hour") != m.end() && !m["hour"].empty()) {
      hour = make_shared<long>(boost::any_cast<long>(m["hour"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["value"]));
    }
  }


  virtual ~HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList() = default;
};
class HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTO : public Darabonba::Model {
public:
  shared_ptr<vector<HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList>> btripHotelCancelPolicyInfoDTOList{};
  shared_ptr<long> cancelPolicyType{};

  HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTO() {}

  explicit HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripHotelCancelPolicyInfoDTOList) {
      vector<boost::any> temp1;
      for(auto item1:*btripHotelCancelPolicyInfoDTOList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["btrip_hotel_cancel_policy_info_d_t_o_list"] = boost::any(temp1);
    }
    if (cancelPolicyType) {
      res["cancel_policy_type"] = boost::any(*cancelPolicyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_hotel_cancel_policy_info_d_t_o_list") != m.end() && !m["btrip_hotel_cancel_policy_info_d_t_o_list"].empty()) {
      if (typeid(vector<boost::any>) == m["btrip_hotel_cancel_policy_info_d_t_o_list"].type()) {
        vector<HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["btrip_hotel_cancel_policy_info_d_t_o_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        btripHotelCancelPolicyInfoDTOList = make_shared<vector<HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTOBtripHotelCancelPolicyInfoDTOList>>(expect1);
      }
    }
    if (m.find("cancel_policy_type") != m.end() && !m["cancel_policy_type"].empty()) {
      cancelPolicyType = make_shared<long>(boost::any_cast<long>(m["cancel_policy_type"]));
    }
  }


  virtual ~HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTO() = default;
};
class HotelOrderPreValidateResponseBodyModuleRatePlanInfo : public Darabonba::Model {
public:
  shared_ptr<string> bedDesc{};
  shared_ptr<HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTO> btripHotelCancelPolicyDTO{};
  shared_ptr<string> earliestCheckInTime{};
  shared_ptr<string> latestCheckOutTime{};
  shared_ptr<long> maxBookingNum{};
  shared_ptr<long> maxOccupancyNum{};
  shared_ptr<bool> needCertificate{};
  shared_ptr<bool> needEmail{};
  shared_ptr<bool> needEnglishName{};
  shared_ptr<long> totalOrderPrice{};
  shared_ptr<long> totalRoomPrice{};

  HotelOrderPreValidateResponseBodyModuleRatePlanInfo() {}

  explicit HotelOrderPreValidateResponseBodyModuleRatePlanInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bedDesc) {
      res["bed_desc"] = boost::any(*bedDesc);
    }
    if (btripHotelCancelPolicyDTO) {
      res["btrip_hotel_cancel_policy_d_t_o"] = btripHotelCancelPolicyDTO ? boost::any(btripHotelCancelPolicyDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (earliestCheckInTime) {
      res["earliest_check_in_time"] = boost::any(*earliestCheckInTime);
    }
    if (latestCheckOutTime) {
      res["latest_check_out_time"] = boost::any(*latestCheckOutTime);
    }
    if (maxBookingNum) {
      res["max_booking_num"] = boost::any(*maxBookingNum);
    }
    if (maxOccupancyNum) {
      res["max_occupancy_num"] = boost::any(*maxOccupancyNum);
    }
    if (needCertificate) {
      res["need_certificate"] = boost::any(*needCertificate);
    }
    if (needEmail) {
      res["need_email"] = boost::any(*needEmail);
    }
    if (needEnglishName) {
      res["need_english_name"] = boost::any(*needEnglishName);
    }
    if (totalOrderPrice) {
      res["total_order_price"] = boost::any(*totalOrderPrice);
    }
    if (totalRoomPrice) {
      res["total_room_price"] = boost::any(*totalRoomPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bed_desc") != m.end() && !m["bed_desc"].empty()) {
      bedDesc = make_shared<string>(boost::any_cast<string>(m["bed_desc"]));
    }
    if (m.find("btrip_hotel_cancel_policy_d_t_o") != m.end() && !m["btrip_hotel_cancel_policy_d_t_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["btrip_hotel_cancel_policy_d_t_o"].type()) {
        HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["btrip_hotel_cancel_policy_d_t_o"]));
        btripHotelCancelPolicyDTO = make_shared<HotelOrderPreValidateResponseBodyModuleRatePlanInfoBtripHotelCancelPolicyDTO>(model1);
      }
    }
    if (m.find("earliest_check_in_time") != m.end() && !m["earliest_check_in_time"].empty()) {
      earliestCheckInTime = make_shared<string>(boost::any_cast<string>(m["earliest_check_in_time"]));
    }
    if (m.find("latest_check_out_time") != m.end() && !m["latest_check_out_time"].empty()) {
      latestCheckOutTime = make_shared<string>(boost::any_cast<string>(m["latest_check_out_time"]));
    }
    if (m.find("max_booking_num") != m.end() && !m["max_booking_num"].empty()) {
      maxBookingNum = make_shared<long>(boost::any_cast<long>(m["max_booking_num"]));
    }
    if (m.find("max_occupancy_num") != m.end() && !m["max_occupancy_num"].empty()) {
      maxOccupancyNum = make_shared<long>(boost::any_cast<long>(m["max_occupancy_num"]));
    }
    if (m.find("need_certificate") != m.end() && !m["need_certificate"].empty()) {
      needCertificate = make_shared<bool>(boost::any_cast<bool>(m["need_certificate"]));
    }
    if (m.find("need_email") != m.end() && !m["need_email"].empty()) {
      needEmail = make_shared<bool>(boost::any_cast<bool>(m["need_email"]));
    }
    if (m.find("need_english_name") != m.end() && !m["need_english_name"].empty()) {
      needEnglishName = make_shared<bool>(boost::any_cast<bool>(m["need_english_name"]));
    }
    if (m.find("total_order_price") != m.end() && !m["total_order_price"].empty()) {
      totalOrderPrice = make_shared<long>(boost::any_cast<long>(m["total_order_price"]));
    }
    if (m.find("total_room_price") != m.end() && !m["total_room_price"].empty()) {
      totalRoomPrice = make_shared<long>(boost::any_cast<long>(m["total_room_price"]));
    }
  }


  virtual ~HotelOrderPreValidateResponseBodyModuleRatePlanInfo() = default;
};
class HotelOrderPreValidateResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> extendInfo{};
  shared_ptr<string> itineraryNo{};
  shared_ptr<HotelOrderPreValidateResponseBodyModulePromotionInfo> promotionInfo{};
  shared_ptr<vector<HotelOrderPreValidateResponseBodyModuleRatePlanDaily>> ratePlanDaily{};
  shared_ptr<long> ratePlanId{};
  shared_ptr<HotelOrderPreValidateResponseBodyModuleRatePlanInfo> ratePlanInfo{};
  shared_ptr<string> validateResKey{};

  HotelOrderPreValidateResponseBodyModule() {}

  explicit HotelOrderPreValidateResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extendInfo) {
      res["extend_info"] = boost::any(*extendInfo);
    }
    if (itineraryNo) {
      res["itinerary_no"] = boost::any(*itineraryNo);
    }
    if (promotionInfo) {
      res["promotion_info"] = promotionInfo ? boost::any(promotionInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ratePlanDaily) {
      vector<boost::any> temp1;
      for(auto item1:*ratePlanDaily){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["rate_plan_daily"] = boost::any(temp1);
    }
    if (ratePlanId) {
      res["rate_plan_id"] = boost::any(*ratePlanId);
    }
    if (ratePlanInfo) {
      res["rate_plan_info"] = ratePlanInfo ? boost::any(ratePlanInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (validateResKey) {
      res["validate_res_key"] = boost::any(*validateResKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extend_info") != m.end() && !m["extend_info"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["extend_info"]));
    }
    if (m.find("itinerary_no") != m.end() && !m["itinerary_no"].empty()) {
      itineraryNo = make_shared<string>(boost::any_cast<string>(m["itinerary_no"]));
    }
    if (m.find("promotion_info") != m.end() && !m["promotion_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["promotion_info"].type()) {
        HotelOrderPreValidateResponseBodyModulePromotionInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["promotion_info"]));
        promotionInfo = make_shared<HotelOrderPreValidateResponseBodyModulePromotionInfo>(model1);
      }
    }
    if (m.find("rate_plan_daily") != m.end() && !m["rate_plan_daily"].empty()) {
      if (typeid(vector<boost::any>) == m["rate_plan_daily"].type()) {
        vector<HotelOrderPreValidateResponseBodyModuleRatePlanDaily> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["rate_plan_daily"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderPreValidateResponseBodyModuleRatePlanDaily model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ratePlanDaily = make_shared<vector<HotelOrderPreValidateResponseBodyModuleRatePlanDaily>>(expect1);
      }
    }
    if (m.find("rate_plan_id") != m.end() && !m["rate_plan_id"].empty()) {
      ratePlanId = make_shared<long>(boost::any_cast<long>(m["rate_plan_id"]));
    }
    if (m.find("rate_plan_info") != m.end() && !m["rate_plan_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["rate_plan_info"].type()) {
        HotelOrderPreValidateResponseBodyModuleRatePlanInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["rate_plan_info"]));
        ratePlanInfo = make_shared<HotelOrderPreValidateResponseBodyModuleRatePlanInfo>(model1);
      }
    }
    if (m.find("validate_res_key") != m.end() && !m["validate_res_key"].empty()) {
      validateResKey = make_shared<string>(boost::any_cast<string>(m["validate_res_key"]));
    }
  }


  virtual ~HotelOrderPreValidateResponseBodyModule() = default;
};
class HotelOrderPreValidateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelOrderPreValidateResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelOrderPreValidateResponseBody() {}

  explicit HotelOrderPreValidateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelOrderPreValidateResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelOrderPreValidateResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelOrderPreValidateResponseBody() = default;
};
class HotelOrderPreValidateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelOrderPreValidateResponseBody> body{};

  HotelOrderPreValidateResponse() {}

  explicit HotelOrderPreValidateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelOrderPreValidateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelOrderPreValidateResponseBody>(model1);
      }
    }
  }


  virtual ~HotelOrderPreValidateResponse() = default;
};
class HotelOrderQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  HotelOrderQueryHeaders() {}

  explicit HotelOrderQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~HotelOrderQueryHeaders() = default;
};
class HotelOrderQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};

  HotelOrderQueryRequest() {}

  explicit HotelOrderQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
  }


  virtual ~HotelOrderQueryRequest() = default;
};
class HotelOrderQueryResponseBodyModuleHotelInfo : public Darabonba::Model {
public:
  shared_ptr<long> checkIn{};
  shared_ptr<long> checkOut{};
  shared_ptr<string> city{};
  shared_ptr<string> cityAdCode{};
  shared_ptr<string> hotelAddress{};
  shared_ptr<string> hotelName{};
  shared_ptr<string> hotelPhone{};
  shared_ptr<long> hotelSupportVatInvoiceType{};
  shared_ptr<long> night{};
  shared_ptr<long> roomNum{};
  shared_ptr<string> roomType{};

  HotelOrderQueryResponseBodyModuleHotelInfo() {}

  explicit HotelOrderQueryResponseBodyModuleHotelInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (city) {
      res["city"] = boost::any(*city);
    }
    if (cityAdCode) {
      res["city_ad_code"] = boost::any(*cityAdCode);
    }
    if (hotelAddress) {
      res["hotel_address"] = boost::any(*hotelAddress);
    }
    if (hotelName) {
      res["hotel_name"] = boost::any(*hotelName);
    }
    if (hotelPhone) {
      res["hotel_phone"] = boost::any(*hotelPhone);
    }
    if (hotelSupportVatInvoiceType) {
      res["hotel_support_vat_invoice_type"] = boost::any(*hotelSupportVatInvoiceType);
    }
    if (night) {
      res["night"] = boost::any(*night);
    }
    if (roomNum) {
      res["room_num"] = boost::any(*roomNum);
    }
    if (roomType) {
      res["room_type"] = boost::any(*roomType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<long>(boost::any_cast<long>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<long>(boost::any_cast<long>(m["check_out"]));
    }
    if (m.find("city") != m.end() && !m["city"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["city"]));
    }
    if (m.find("city_ad_code") != m.end() && !m["city_ad_code"].empty()) {
      cityAdCode = make_shared<string>(boost::any_cast<string>(m["city_ad_code"]));
    }
    if (m.find("hotel_address") != m.end() && !m["hotel_address"].empty()) {
      hotelAddress = make_shared<string>(boost::any_cast<string>(m["hotel_address"]));
    }
    if (m.find("hotel_name") != m.end() && !m["hotel_name"].empty()) {
      hotelName = make_shared<string>(boost::any_cast<string>(m["hotel_name"]));
    }
    if (m.find("hotel_phone") != m.end() && !m["hotel_phone"].empty()) {
      hotelPhone = make_shared<string>(boost::any_cast<string>(m["hotel_phone"]));
    }
    if (m.find("hotel_support_vat_invoice_type") != m.end() && !m["hotel_support_vat_invoice_type"].empty()) {
      hotelSupportVatInvoiceType = make_shared<long>(boost::any_cast<long>(m["hotel_support_vat_invoice_type"]));
    }
    if (m.find("night") != m.end() && !m["night"].empty()) {
      night = make_shared<long>(boost::any_cast<long>(m["night"]));
    }
    if (m.find("room_num") != m.end() && !m["room_num"].empty()) {
      roomNum = make_shared<long>(boost::any_cast<long>(m["room_num"]));
    }
    if (m.find("room_type") != m.end() && !m["room_type"].empty()) {
      roomType = make_shared<string>(boost::any_cast<string>(m["room_type"]));
    }
  }


  virtual ~HotelOrderQueryResponseBodyModuleHotelInfo() = default;
};
class HotelOrderQueryResponseBodyModuleInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  HotelOrderQueryResponseBodyModuleInvoiceInfo() {}

  explicit HotelOrderQueryResponseBodyModuleInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~HotelOrderQueryResponseBodyModuleInvoiceInfo() = default;
};
class HotelOrderQueryResponseBodyModuleOrderBaseInfo : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<vector<string>> exceedApplyNos{};
  shared_ptr<string> extendField{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> itineraryId{};
  shared_ptr<long> orderStatus{};
  shared_ptr<long> orderType{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartDepartId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  HotelOrderQueryResponseBodyModuleOrderBaseInfo() {}

  explicit HotelOrderQueryResponseBodyModuleOrderBaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (exceedApplyNos) {
      res["exceed_apply_nos"] = boost::any(*exceedApplyNos);
    }
    if (extendField) {
      res["extend_field"] = boost::any(*extendField);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (orderType) {
      res["order_type"] = boost::any(*orderType);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartDepartId) {
      res["thirdpart_depart_id"] = boost::any(*thirdpartDepartId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("exceed_apply_nos") != m.end() && !m["exceed_apply_nos"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["exceed_apply_nos"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["exceed_apply_nos"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      exceedApplyNos = make_shared<vector<string>>(toVec1);
    }
    if (m.find("extend_field") != m.end() && !m["extend_field"].empty()) {
      extendField = make_shared<string>(boost::any_cast<string>(m["extend_field"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["gmt_modified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("order_type") != m.end() && !m["order_type"].empty()) {
      orderType = make_shared<long>(boost::any_cast<long>(m["order_type"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_depart_id") != m.end() && !m["thirdpart_depart_id"].empty()) {
      thirdpartDepartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_depart_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~HotelOrderQueryResponseBodyModuleOrderBaseInfo() = default;
};
class HotelOrderQueryResponseBodyModulePassengerList : public Darabonba::Model {
public:
  shared_ptr<long> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdpartCostCenterId{};
  shared_ptr<string> thirdpartProjectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> userType{};

  HotelOrderQueryResponseBodyModulePassengerList() {}

  explicit HotelOrderQueryResponseBodyModulePassengerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdpartCostCenterId) {
      res["thirdpart_cost_center_id"] = boost::any(*thirdpartCostCenterId);
    }
    if (thirdpartProjectId) {
      res["thirdpart_project_id"] = boost::any(*thirdpartProjectId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (userType) {
      res["user_type"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("thirdpart_cost_center_id") != m.end() && !m["thirdpart_cost_center_id"].empty()) {
      thirdpartCostCenterId = make_shared<string>(boost::any_cast<string>(m["thirdpart_cost_center_id"]));
    }
    if (m.find("thirdpart_project_id") != m.end() && !m["thirdpart_project_id"].empty()) {
      thirdpartProjectId = make_shared<string>(boost::any_cast<string>(m["thirdpart_project_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("user_type") != m.end() && !m["user_type"].empty()) {
      userType = make_shared<long>(boost::any_cast<long>(m["user_type"]));
    }
  }


  virtual ~HotelOrderQueryResponseBodyModulePassengerList() = default;
};
class HotelOrderQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> payType{};
  shared_ptr<double> price{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  HotelOrderQueryResponseBodyModulePriceInfoList() {}

  explicit HotelOrderQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["gmt_create"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~HotelOrderQueryResponseBodyModulePriceInfoList() = default;
};
class HotelOrderQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<HotelOrderQueryResponseBodyModuleHotelInfo> hotelInfo{};
  shared_ptr<HotelOrderQueryResponseBodyModuleInvoiceInfo> invoiceInfo{};
  shared_ptr<HotelOrderQueryResponseBodyModuleOrderBaseInfo> orderBaseInfo{};
  shared_ptr<vector<HotelOrderQueryResponseBodyModulePassengerList>> passengerList{};
  shared_ptr<vector<HotelOrderQueryResponseBodyModulePriceInfoList>> priceInfoList{};

  HotelOrderQueryResponseBodyModule() {}

  explicit HotelOrderQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelInfo) {
      res["hotel_info"] = hotelInfo ? boost::any(hotelInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invoiceInfo) {
      res["invoice_info"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderBaseInfo) {
      res["order_base_info"] = orderBaseInfo ? boost::any(orderBaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passengerList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_list"] = boost::any(temp1);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_info") != m.end() && !m["hotel_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["hotel_info"].type()) {
        HotelOrderQueryResponseBodyModuleHotelInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["hotel_info"]));
        hotelInfo = make_shared<HotelOrderQueryResponseBodyModuleHotelInfo>(model1);
      }
    }
    if (m.find("invoice_info") != m.end() && !m["invoice_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice_info"].type()) {
        HotelOrderQueryResponseBodyModuleInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice_info"]));
        invoiceInfo = make_shared<HotelOrderQueryResponseBodyModuleInvoiceInfo>(model1);
      }
    }
    if (m.find("order_base_info") != m.end() && !m["order_base_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["order_base_info"].type()) {
        HotelOrderQueryResponseBodyModuleOrderBaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["order_base_info"]));
        orderBaseInfo = make_shared<HotelOrderQueryResponseBodyModuleOrderBaseInfo>(model1);
      }
    }
    if (m.find("passenger_list") != m.end() && !m["passenger_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_list"].type()) {
        vector<HotelOrderQueryResponseBodyModulePassengerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderQueryResponseBodyModulePassengerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerList = make_shared<vector<HotelOrderQueryResponseBodyModulePassengerList>>(expect1);
      }
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<HotelOrderQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelOrderQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<HotelOrderQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
  }


  virtual ~HotelOrderQueryResponseBodyModule() = default;
};
class HotelOrderQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelOrderQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelOrderQueryResponseBody() {}

  explicit HotelOrderQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelOrderQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelOrderQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelOrderQueryResponseBody() = default;
};
class HotelOrderQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelOrderQueryResponseBody> body{};

  HotelOrderQueryResponse() {}

  explicit HotelOrderQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelOrderQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelOrderQueryResponseBody>(model1);
      }
    }
  }


  virtual ~HotelOrderQueryResponse() = default;
};
class HotelPricePullHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  HotelPricePullHeaders() {}

  explicit HotelPricePullHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~HotelPricePullHeaders() = default;
};
class HotelPricePullRequest : public Darabonba::Model {
public:
  shared_ptr<string> btripUserId{};
  shared_ptr<string> checkIn{};
  shared_ptr<string> checkOut{};
  shared_ptr<long> cityCode{};
  shared_ptr<vector<string>> hotelIds{};
  shared_ptr<long> paymentType{};

  HotelPricePullRequest() {}

  explicit HotelPricePullRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (hotelIds) {
      res["hotel_ids"] = boost::any(*hotelIds);
    }
    if (paymentType) {
      res["payment_type"] = boost::any(*paymentType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<string>(boost::any_cast<string>(m["check_out"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<long>(boost::any_cast<long>(m["city_code"]));
    }
    if (m.find("hotel_ids") != m.end() && !m["hotel_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["hotel_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["hotel_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hotelIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("payment_type") != m.end() && !m["payment_type"].empty()) {
      paymentType = make_shared<long>(boost::any_cast<long>(m["payment_type"]));
    }
  }


  virtual ~HotelPricePullRequest() = default;
};
class HotelPricePullShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> btripUserId{};
  shared_ptr<string> checkIn{};
  shared_ptr<string> checkOut{};
  shared_ptr<long> cityCode{};
  shared_ptr<string> hotelIdsShrink{};
  shared_ptr<long> paymentType{};

  HotelPricePullShrinkRequest() {}

  explicit HotelPricePullShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (hotelIdsShrink) {
      res["hotel_ids"] = boost::any(*hotelIdsShrink);
    }
    if (paymentType) {
      res["payment_type"] = boost::any(*paymentType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<string>(boost::any_cast<string>(m["check_out"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<long>(boost::any_cast<long>(m["city_code"]));
    }
    if (m.find("hotel_ids") != m.end() && !m["hotel_ids"].empty()) {
      hotelIdsShrink = make_shared<string>(boost::any_cast<string>(m["hotel_ids"]));
    }
    if (m.find("payment_type") != m.end() && !m["payment_type"].empty()) {
      paymentType = make_shared<long>(boost::any_cast<long>(m["payment_type"]));
    }
  }


  virtual ~HotelPricePullShrinkRequest() = default;
};
class HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicyBtripHotelCancelPolicyInfoDTOList : public Darabonba::Model {
public:
  shared_ptr<long> hour{};
  shared_ptr<long> value{};

  HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicyBtripHotelCancelPolicyInfoDTOList() {}

  explicit HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicyBtripHotelCancelPolicyInfoDTOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hour) {
      res["hour"] = boost::any(*hour);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hour") != m.end() && !m["hour"].empty()) {
      hour = make_shared<long>(boost::any_cast<long>(m["hour"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["value"]));
    }
  }


  virtual ~HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicyBtripHotelCancelPolicyInfoDTOList() = default;
};
class HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicy : public Darabonba::Model {
public:
  shared_ptr<vector<HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicyBtripHotelCancelPolicyInfoDTOList>> btripHotelCancelPolicyInfoDTOList{};
  shared_ptr<long> cancelPolicyType{};

  HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicy() {}

  explicit HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripHotelCancelPolicyInfoDTOList) {
      vector<boost::any> temp1;
      for(auto item1:*btripHotelCancelPolicyInfoDTOList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["btrip_hotel_cancel_policy_info_d_t_o_list"] = boost::any(temp1);
    }
    if (cancelPolicyType) {
      res["cancel_policy_type"] = boost::any(*cancelPolicyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_hotel_cancel_policy_info_d_t_o_list") != m.end() && !m["btrip_hotel_cancel_policy_info_d_t_o_list"].empty()) {
      if (typeid(vector<boost::any>) == m["btrip_hotel_cancel_policy_info_d_t_o_list"].type()) {
        vector<HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicyBtripHotelCancelPolicyInfoDTOList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["btrip_hotel_cancel_policy_info_d_t_o_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicyBtripHotelCancelPolicyInfoDTOList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        btripHotelCancelPolicyInfoDTOList = make_shared<vector<HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicyBtripHotelCancelPolicyInfoDTOList>>(expect1);
      }
    }
    if (m.find("cancel_policy_type") != m.end() && !m["cancel_policy_type"].empty()) {
      cancelPolicyType = make_shared<long>(boost::any_cast<long>(m["cancel_policy_type"]));
    }
  }


  virtual ~HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicy() = default;
};
class HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesRateDailys : public Darabonba::Model {
public:
  shared_ptr<long> discountPrice{};
  shared_ptr<long> lastDiscountsPrice{};
  shared_ptr<long> price{};
  shared_ptr<string> startDate{};

  HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesRateDailys() {}

  explicit HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesRateDailys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountPrice) {
      res["discount_price"] = boost::any(*discountPrice);
    }
    if (lastDiscountsPrice) {
      res["last_discounts_price"] = boost::any(*lastDiscountsPrice);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (startDate) {
      res["start_date"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("discount_price") != m.end() && !m["discount_price"].empty()) {
      discountPrice = make_shared<long>(boost::any_cast<long>(m["discount_price"]));
    }
    if (m.find("last_discounts_price") != m.end() && !m["last_discounts_price"].empty()) {
      lastDiscountsPrice = make_shared<long>(boost::any_cast<long>(m["last_discounts_price"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("start_date") != m.end() && !m["start_date"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["start_date"]));
    }
  }


  virtual ~HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesRateDailys() = default;
};
class HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRates : public Darabonba::Model {
public:
  shared_ptr<string> breakfast{};
  shared_ptr<long> breakfastCount{};
  shared_ptr<HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicy> btripHotelCancelPolicy{};
  shared_ptr<string> cancelPolicyDesc{};
  shared_ptr<string> companyAassist{};
  shared_ptr<string> currencyCode{};
  shared_ptr<bool> instantConfirm{};
  shared_ptr<string> itemId{};
  shared_ptr<long> maxAdvHours{};
  shared_ptr<long> maxDays{};
  shared_ptr<long> minAdvHours{};
  shared_ptr<long> minDays{};
  shared_ptr<long> nod{};
  shared_ptr<long> nop{};
  shared_ptr<long> paymentType{};
  shared_ptr<long> price{};
  shared_ptr<string> promotionInfo{};
  shared_ptr<long> quota{};
  shared_ptr<vector<HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesRateDailys>> rateDailys{};
  shared_ptr<string> rateId{};
  shared_ptr<string> ratePlanName{};
  shared_ptr<string> rpId{};
  shared_ptr<string> sellerId{};
  shared_ptr<bool> supportSpecialInvoice{};

  HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRates() {}

  explicit HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakfast) {
      res["breakfast"] = boost::any(*breakfast);
    }
    if (breakfastCount) {
      res["breakfast_count"] = boost::any(*breakfastCount);
    }
    if (btripHotelCancelPolicy) {
      res["btrip_hotel_cancel_policy"] = btripHotelCancelPolicy ? boost::any(btripHotelCancelPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cancelPolicyDesc) {
      res["cancel_policy_desc"] = boost::any(*cancelPolicyDesc);
    }
    if (companyAassist) {
      res["company_aassist"] = boost::any(*companyAassist);
    }
    if (currencyCode) {
      res["currency_code"] = boost::any(*currencyCode);
    }
    if (instantConfirm) {
      res["instant_confirm"] = boost::any(*instantConfirm);
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (maxAdvHours) {
      res["max_adv_hours"] = boost::any(*maxAdvHours);
    }
    if (maxDays) {
      res["max_days"] = boost::any(*maxDays);
    }
    if (minAdvHours) {
      res["min_adv_hours"] = boost::any(*minAdvHours);
    }
    if (minDays) {
      res["min_days"] = boost::any(*minDays);
    }
    if (nod) {
      res["nod"] = boost::any(*nod);
    }
    if (nop) {
      res["nop"] = boost::any(*nop);
    }
    if (paymentType) {
      res["payment_type"] = boost::any(*paymentType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (promotionInfo) {
      res["promotion_info"] = boost::any(*promotionInfo);
    }
    if (quota) {
      res["quota"] = boost::any(*quota);
    }
    if (rateDailys) {
      vector<boost::any> temp1;
      for(auto item1:*rateDailys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["rate_dailys"] = boost::any(temp1);
    }
    if (rateId) {
      res["rate_id"] = boost::any(*rateId);
    }
    if (ratePlanName) {
      res["rate_plan_name"] = boost::any(*ratePlanName);
    }
    if (rpId) {
      res["rp_id"] = boost::any(*rpId);
    }
    if (sellerId) {
      res["seller_id"] = boost::any(*sellerId);
    }
    if (supportSpecialInvoice) {
      res["support_special_invoice"] = boost::any(*supportSpecialInvoice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("breakfast") != m.end() && !m["breakfast"].empty()) {
      breakfast = make_shared<string>(boost::any_cast<string>(m["breakfast"]));
    }
    if (m.find("breakfast_count") != m.end() && !m["breakfast_count"].empty()) {
      breakfastCount = make_shared<long>(boost::any_cast<long>(m["breakfast_count"]));
    }
    if (m.find("btrip_hotel_cancel_policy") != m.end() && !m["btrip_hotel_cancel_policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["btrip_hotel_cancel_policy"].type()) {
        HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["btrip_hotel_cancel_policy"]));
        btripHotelCancelPolicy = make_shared<HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesBtripHotelCancelPolicy>(model1);
      }
    }
    if (m.find("cancel_policy_desc") != m.end() && !m["cancel_policy_desc"].empty()) {
      cancelPolicyDesc = make_shared<string>(boost::any_cast<string>(m["cancel_policy_desc"]));
    }
    if (m.find("company_aassist") != m.end() && !m["company_aassist"].empty()) {
      companyAassist = make_shared<string>(boost::any_cast<string>(m["company_aassist"]));
    }
    if (m.find("currency_code") != m.end() && !m["currency_code"].empty()) {
      currencyCode = make_shared<string>(boost::any_cast<string>(m["currency_code"]));
    }
    if (m.find("instant_confirm") != m.end() && !m["instant_confirm"].empty()) {
      instantConfirm = make_shared<bool>(boost::any_cast<bool>(m["instant_confirm"]));
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["item_id"]));
    }
    if (m.find("max_adv_hours") != m.end() && !m["max_adv_hours"].empty()) {
      maxAdvHours = make_shared<long>(boost::any_cast<long>(m["max_adv_hours"]));
    }
    if (m.find("max_days") != m.end() && !m["max_days"].empty()) {
      maxDays = make_shared<long>(boost::any_cast<long>(m["max_days"]));
    }
    if (m.find("min_adv_hours") != m.end() && !m["min_adv_hours"].empty()) {
      minAdvHours = make_shared<long>(boost::any_cast<long>(m["min_adv_hours"]));
    }
    if (m.find("min_days") != m.end() && !m["min_days"].empty()) {
      minDays = make_shared<long>(boost::any_cast<long>(m["min_days"]));
    }
    if (m.find("nod") != m.end() && !m["nod"].empty()) {
      nod = make_shared<long>(boost::any_cast<long>(m["nod"]));
    }
    if (m.find("nop") != m.end() && !m["nop"].empty()) {
      nop = make_shared<long>(boost::any_cast<long>(m["nop"]));
    }
    if (m.find("payment_type") != m.end() && !m["payment_type"].empty()) {
      paymentType = make_shared<long>(boost::any_cast<long>(m["payment_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("promotion_info") != m.end() && !m["promotion_info"].empty()) {
      promotionInfo = make_shared<string>(boost::any_cast<string>(m["promotion_info"]));
    }
    if (m.find("quota") != m.end() && !m["quota"].empty()) {
      quota = make_shared<long>(boost::any_cast<long>(m["quota"]));
    }
    if (m.find("rate_dailys") != m.end() && !m["rate_dailys"].empty()) {
      if (typeid(vector<boost::any>) == m["rate_dailys"].type()) {
        vector<HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesRateDailys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["rate_dailys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesRateDailys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rateDailys = make_shared<vector<HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRatesRateDailys>>(expect1);
      }
    }
    if (m.find("rate_id") != m.end() && !m["rate_id"].empty()) {
      rateId = make_shared<string>(boost::any_cast<string>(m["rate_id"]));
    }
    if (m.find("rate_plan_name") != m.end() && !m["rate_plan_name"].empty()) {
      ratePlanName = make_shared<string>(boost::any_cast<string>(m["rate_plan_name"]));
    }
    if (m.find("rp_id") != m.end() && !m["rp_id"].empty()) {
      rpId = make_shared<string>(boost::any_cast<string>(m["rp_id"]));
    }
    if (m.find("seller_id") != m.end() && !m["seller_id"].empty()) {
      sellerId = make_shared<string>(boost::any_cast<string>(m["seller_id"]));
    }
    if (m.find("support_special_invoice") != m.end() && !m["support_special_invoice"].empty()) {
      supportSpecialInvoice = make_shared<bool>(boost::any_cast<bool>(m["support_special_invoice"]));
    }
  }


  virtual ~HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRates() = default;
};
class HotelPricePullResponseBodyModuleHotelPriceInfosRooms : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> bed{};
  shared_ptr<string> bedTypeString{};
  shared_ptr<string> facility{};
  shared_ptr<string> floor{};
  shared_ptr<long> maxOccupancy{};
  shared_ptr<string> networkService{};
  shared_ptr<vector<string>> pics{};
  shared_ptr<vector<HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRates>> rates{};
  shared_ptr<string> roomId{};
  shared_ptr<string> roomName{};
  shared_ptr<long> status{};
  shared_ptr<string> windowType{};

  HotelPricePullResponseBodyModuleHotelPriceInfosRooms() {}

  explicit HotelPricePullResponseBodyModuleHotelPriceInfosRooms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["area"] = boost::any(*area);
    }
    if (bed) {
      res["bed"] = boost::any(*bed);
    }
    if (bedTypeString) {
      res["bed_type_string"] = boost::any(*bedTypeString);
    }
    if (facility) {
      res["facility"] = boost::any(*facility);
    }
    if (floor) {
      res["floor"] = boost::any(*floor);
    }
    if (maxOccupancy) {
      res["max_occupancy"] = boost::any(*maxOccupancy);
    }
    if (networkService) {
      res["network_service"] = boost::any(*networkService);
    }
    if (pics) {
      res["pics"] = boost::any(*pics);
    }
    if (rates) {
      vector<boost::any> temp1;
      for(auto item1:*rates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["rates"] = boost::any(temp1);
    }
    if (roomId) {
      res["room_id"] = boost::any(*roomId);
    }
    if (roomName) {
      res["room_name"] = boost::any(*roomName);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (windowType) {
      res["window_type"] = boost::any(*windowType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("area") != m.end() && !m["area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["area"]));
    }
    if (m.find("bed") != m.end() && !m["bed"].empty()) {
      bed = make_shared<string>(boost::any_cast<string>(m["bed"]));
    }
    if (m.find("bed_type_string") != m.end() && !m["bed_type_string"].empty()) {
      bedTypeString = make_shared<string>(boost::any_cast<string>(m["bed_type_string"]));
    }
    if (m.find("facility") != m.end() && !m["facility"].empty()) {
      facility = make_shared<string>(boost::any_cast<string>(m["facility"]));
    }
    if (m.find("floor") != m.end() && !m["floor"].empty()) {
      floor = make_shared<string>(boost::any_cast<string>(m["floor"]));
    }
    if (m.find("max_occupancy") != m.end() && !m["max_occupancy"].empty()) {
      maxOccupancy = make_shared<long>(boost::any_cast<long>(m["max_occupancy"]));
    }
    if (m.find("network_service") != m.end() && !m["network_service"].empty()) {
      networkService = make_shared<string>(boost::any_cast<string>(m["network_service"]));
    }
    if (m.find("pics") != m.end() && !m["pics"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["pics"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["pics"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pics = make_shared<vector<string>>(toVec1);
    }
    if (m.find("rates") != m.end() && !m["rates"].empty()) {
      if (typeid(vector<boost::any>) == m["rates"].type()) {
        vector<HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["rates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rates = make_shared<vector<HotelPricePullResponseBodyModuleHotelPriceInfosRoomsRates>>(expect1);
      }
    }
    if (m.find("room_id") != m.end() && !m["room_id"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["room_id"]));
    }
    if (m.find("room_name") != m.end() && !m["room_name"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["room_name"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("window_type") != m.end() && !m["window_type"].empty()) {
      windowType = make_shared<string>(boost::any_cast<string>(m["window_type"]));
    }
  }


  virtual ~HotelPricePullResponseBodyModuleHotelPriceInfosRooms() = default;
};
class HotelPricePullResponseBodyModuleHotelPriceInfos : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> hotelId{};
  shared_ptr<string> hotelName{};
  shared_ptr<vector<HotelPricePullResponseBodyModuleHotelPriceInfosRooms>> rooms{};
  shared_ptr<string> searchId{};

  HotelPricePullResponseBodyModuleHotelPriceInfos() {}

  explicit HotelPricePullResponseBodyModuleHotelPriceInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["address"] = boost::any(*address);
    }
    if (hotelId) {
      res["hotel_id"] = boost::any(*hotelId);
    }
    if (hotelName) {
      res["hotel_name"] = boost::any(*hotelName);
    }
    if (rooms) {
      vector<boost::any> temp1;
      for(auto item1:*rooms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["rooms"] = boost::any(temp1);
    }
    if (searchId) {
      res["search_id"] = boost::any(*searchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("address") != m.end() && !m["address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["address"]));
    }
    if (m.find("hotel_id") != m.end() && !m["hotel_id"].empty()) {
      hotelId = make_shared<string>(boost::any_cast<string>(m["hotel_id"]));
    }
    if (m.find("hotel_name") != m.end() && !m["hotel_name"].empty()) {
      hotelName = make_shared<string>(boost::any_cast<string>(m["hotel_name"]));
    }
    if (m.find("rooms") != m.end() && !m["rooms"].empty()) {
      if (typeid(vector<boost::any>) == m["rooms"].type()) {
        vector<HotelPricePullResponseBodyModuleHotelPriceInfosRooms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["rooms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelPricePullResponseBodyModuleHotelPriceInfosRooms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rooms = make_shared<vector<HotelPricePullResponseBodyModuleHotelPriceInfosRooms>>(expect1);
      }
    }
    if (m.find("search_id") != m.end() && !m["search_id"].empty()) {
      searchId = make_shared<string>(boost::any_cast<string>(m["search_id"]));
    }
  }


  virtual ~HotelPricePullResponseBodyModuleHotelPriceInfos() = default;
};
class HotelPricePullResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<HotelPricePullResponseBodyModuleHotelPriceInfos>> hotelPriceInfos{};

  HotelPricePullResponseBodyModule() {}

  explicit HotelPricePullResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelPriceInfos) {
      vector<boost::any> temp1;
      for(auto item1:*hotelPriceInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_price_infos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_price_infos") != m.end() && !m["hotel_price_infos"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_price_infos"].type()) {
        vector<HotelPricePullResponseBodyModuleHotelPriceInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_price_infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelPricePullResponseBodyModuleHotelPriceInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelPriceInfos = make_shared<vector<HotelPricePullResponseBodyModuleHotelPriceInfos>>(expect1);
      }
    }
  }


  virtual ~HotelPricePullResponseBodyModule() = default;
};
class HotelPricePullResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelPricePullResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelPricePullResponseBody() {}

  explicit HotelPricePullResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["request_id"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelPricePullResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelPricePullResponseBodyModule>(model1);
      }
    }
    if (m.find("request_id") != m.end() && !m["request_id"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["request_id"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelPricePullResponseBody() = default;
};
class HotelPricePullResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelPricePullResponseBody> body{};

  HotelPricePullResponse() {}

  explicit HotelPricePullResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelPricePullResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelPricePullResponseBody>(model1);
      }
    }
  }


  virtual ~HotelPricePullResponse() = default;
};
class HotelRoomInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  HotelRoomInfoHeaders() {}

  explicit HotelRoomInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~HotelRoomInfoHeaders() = default;
};
class HotelRoomInfoRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> roomIds{};

  HotelRoomInfoRequest() {}

  explicit HotelRoomInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roomIds) {
      res["room_ids"] = boost::any(*roomIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("room_ids") != m.end() && !m["room_ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["room_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["room_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      roomIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~HotelRoomInfoRequest() = default;
};
class HotelRoomInfoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> roomIdsShrink{};

  HotelRoomInfoShrinkRequest() {}

  explicit HotelRoomInfoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roomIdsShrink) {
      res["room_ids"] = boost::any(*roomIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("room_ids") != m.end() && !m["room_ids"].empty()) {
      roomIdsShrink = make_shared<string>(boost::any_cast<string>(m["room_ids"]));
    }
  }


  virtual ~HotelRoomInfoShrinkRequest() = default;
};
class HotelRoomInfoResponseBodyModuleBedInfos : public Darabonba::Model {
public:
  shared_ptr<string> bedDesc{};
  shared_ptr<long> bedNum{};
  shared_ptr<string> bedSize{};
  shared_ptr<string> bedType{};

  HotelRoomInfoResponseBodyModuleBedInfos() {}

  explicit HotelRoomInfoResponseBodyModuleBedInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bedDesc) {
      res["bed_desc"] = boost::any(*bedDesc);
    }
    if (bedNum) {
      res["bed_num"] = boost::any(*bedNum);
    }
    if (bedSize) {
      res["bed_size"] = boost::any(*bedSize);
    }
    if (bedType) {
      res["bed_type"] = boost::any(*bedType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bed_desc") != m.end() && !m["bed_desc"].empty()) {
      bedDesc = make_shared<string>(boost::any_cast<string>(m["bed_desc"]));
    }
    if (m.find("bed_num") != m.end() && !m["bed_num"].empty()) {
      bedNum = make_shared<long>(boost::any_cast<long>(m["bed_num"]));
    }
    if (m.find("bed_size") != m.end() && !m["bed_size"].empty()) {
      bedSize = make_shared<string>(boost::any_cast<string>(m["bed_size"]));
    }
    if (m.find("bed_type") != m.end() && !m["bed_type"].empty()) {
      bedType = make_shared<string>(boost::any_cast<string>(m["bed_type"]));
    }
  }


  virtual ~HotelRoomInfoResponseBodyModuleBedInfos() = default;
};
class HotelRoomInfoResponseBodyModuleRoomImages : public Darabonba::Model {
public:
  shared_ptr<string> bedInfos2{};
  shared_ptr<long> tag{};
  shared_ptr<string> url{};

  HotelRoomInfoResponseBodyModuleRoomImages() {}

  explicit HotelRoomInfoResponseBodyModuleRoomImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bedInfos2) {
      res["bed_infos2"] = boost::any(*bedInfos2);
    }
    if (tag) {
      res["tag"] = boost::any(*tag);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bed_infos2") != m.end() && !m["bed_infos2"].empty()) {
      bedInfos2 = make_shared<string>(boost::any_cast<string>(m["bed_infos2"]));
    }
    if (m.find("tag") != m.end() && !m["tag"].empty()) {
      tag = make_shared<long>(boost::any_cast<long>(m["tag"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~HotelRoomInfoResponseBodyModuleRoomImages() = default;
};
class HotelRoomInfoResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<HotelRoomInfoResponseBodyModuleBedInfos>> bedInfos{};
  shared_ptr<long> extraBed{};
  shared_ptr<string> extraBedDesc{};
  shared_ptr<string> floor{};
  shared_ptr<string> internetWay{};
  shared_ptr<long> maxOccupancy{};
  shared_ptr<string> roomDesc{};
  shared_ptr<string> roomFacilities{};
  shared_ptr<vector<string>> roomFacilityList{};
  shared_ptr<string> roomId{};
  shared_ptr<string> roomImage{};
  shared_ptr<vector<HotelRoomInfoResponseBodyModuleRoomImages>> roomImages{};
  shared_ptr<string> roomName{};
  shared_ptr<long> roomType{};
  shared_ptr<string> roomarea{};
  shared_ptr<long> rooms{};
  shared_ptr<string> window{};
  shared_ptr<string> windowBad{};
  shared_ptr<string> windowView{};

  HotelRoomInfoResponseBodyModule() {}

  explicit HotelRoomInfoResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bedInfos) {
      vector<boost::any> temp1;
      for(auto item1:*bedInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["bed_infos"] = boost::any(temp1);
    }
    if (extraBed) {
      res["extra_bed"] = boost::any(*extraBed);
    }
    if (extraBedDesc) {
      res["extra_bed_desc"] = boost::any(*extraBedDesc);
    }
    if (floor) {
      res["floor"] = boost::any(*floor);
    }
    if (internetWay) {
      res["internet_way"] = boost::any(*internetWay);
    }
    if (maxOccupancy) {
      res["max_occupancy"] = boost::any(*maxOccupancy);
    }
    if (roomDesc) {
      res["room_desc"] = boost::any(*roomDesc);
    }
    if (roomFacilities) {
      res["room_facilities"] = boost::any(*roomFacilities);
    }
    if (roomFacilityList) {
      res["room_facility_list"] = boost::any(*roomFacilityList);
    }
    if (roomId) {
      res["room_id"] = boost::any(*roomId);
    }
    if (roomImage) {
      res["room_image"] = boost::any(*roomImage);
    }
    if (roomImages) {
      vector<boost::any> temp1;
      for(auto item1:*roomImages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["room_images"] = boost::any(temp1);
    }
    if (roomName) {
      res["room_name"] = boost::any(*roomName);
    }
    if (roomType) {
      res["room_type"] = boost::any(*roomType);
    }
    if (roomarea) {
      res["roomarea"] = boost::any(*roomarea);
    }
    if (rooms) {
      res["rooms"] = boost::any(*rooms);
    }
    if (window) {
      res["window"] = boost::any(*window);
    }
    if (windowBad) {
      res["window_bad"] = boost::any(*windowBad);
    }
    if (windowView) {
      res["window_view"] = boost::any(*windowView);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bed_infos") != m.end() && !m["bed_infos"].empty()) {
      if (typeid(vector<boost::any>) == m["bed_infos"].type()) {
        vector<HotelRoomInfoResponseBodyModuleBedInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["bed_infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelRoomInfoResponseBodyModuleBedInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bedInfos = make_shared<vector<HotelRoomInfoResponseBodyModuleBedInfos>>(expect1);
      }
    }
    if (m.find("extra_bed") != m.end() && !m["extra_bed"].empty()) {
      extraBed = make_shared<long>(boost::any_cast<long>(m["extra_bed"]));
    }
    if (m.find("extra_bed_desc") != m.end() && !m["extra_bed_desc"].empty()) {
      extraBedDesc = make_shared<string>(boost::any_cast<string>(m["extra_bed_desc"]));
    }
    if (m.find("floor") != m.end() && !m["floor"].empty()) {
      floor = make_shared<string>(boost::any_cast<string>(m["floor"]));
    }
    if (m.find("internet_way") != m.end() && !m["internet_way"].empty()) {
      internetWay = make_shared<string>(boost::any_cast<string>(m["internet_way"]));
    }
    if (m.find("max_occupancy") != m.end() && !m["max_occupancy"].empty()) {
      maxOccupancy = make_shared<long>(boost::any_cast<long>(m["max_occupancy"]));
    }
    if (m.find("room_desc") != m.end() && !m["room_desc"].empty()) {
      roomDesc = make_shared<string>(boost::any_cast<string>(m["room_desc"]));
    }
    if (m.find("room_facilities") != m.end() && !m["room_facilities"].empty()) {
      roomFacilities = make_shared<string>(boost::any_cast<string>(m["room_facilities"]));
    }
    if (m.find("room_facility_list") != m.end() && !m["room_facility_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["room_facility_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["room_facility_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roomFacilityList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("room_id") != m.end() && !m["room_id"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["room_id"]));
    }
    if (m.find("room_image") != m.end() && !m["room_image"].empty()) {
      roomImage = make_shared<string>(boost::any_cast<string>(m["room_image"]));
    }
    if (m.find("room_images") != m.end() && !m["room_images"].empty()) {
      if (typeid(vector<boost::any>) == m["room_images"].type()) {
        vector<HotelRoomInfoResponseBodyModuleRoomImages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["room_images"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelRoomInfoResponseBodyModuleRoomImages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roomImages = make_shared<vector<HotelRoomInfoResponseBodyModuleRoomImages>>(expect1);
      }
    }
    if (m.find("room_name") != m.end() && !m["room_name"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["room_name"]));
    }
    if (m.find("room_type") != m.end() && !m["room_type"].empty()) {
      roomType = make_shared<long>(boost::any_cast<long>(m["room_type"]));
    }
    if (m.find("roomarea") != m.end() && !m["roomarea"].empty()) {
      roomarea = make_shared<string>(boost::any_cast<string>(m["roomarea"]));
    }
    if (m.find("rooms") != m.end() && !m["rooms"].empty()) {
      rooms = make_shared<long>(boost::any_cast<long>(m["rooms"]));
    }
    if (m.find("window") != m.end() && !m["window"].empty()) {
      window = make_shared<string>(boost::any_cast<string>(m["window"]));
    }
    if (m.find("window_bad") != m.end() && !m["window_bad"].empty()) {
      windowBad = make_shared<string>(boost::any_cast<string>(m["window_bad"]));
    }
    if (m.find("window_view") != m.end() && !m["window_view"].empty()) {
      windowView = make_shared<string>(boost::any_cast<string>(m["window_view"]));
    }
  }


  virtual ~HotelRoomInfoResponseBodyModule() = default;
};
class HotelRoomInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<HotelRoomInfoResponseBodyModule>> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelRoomInfoResponseBody() {}

  explicit HotelRoomInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<HotelRoomInfoResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelRoomInfoResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<HotelRoomInfoResponseBodyModule>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelRoomInfoResponseBody() = default;
};
class HotelRoomInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelRoomInfoResponseBody> body{};

  HotelRoomInfoResponse() {}

  explicit HotelRoomInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelRoomInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelRoomInfoResponseBody>(model1);
      }
    }
  }


  virtual ~HotelRoomInfoResponse() = default;
};
class HotelSearchHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  HotelSearchHeaders() {}

  explicit HotelSearchHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~HotelSearchHeaders() = default;
};
class HotelSearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> adultNum{};
  shared_ptr<vector<string>> brandCode{};
  shared_ptr<string> btripUserId{};
  shared_ptr<string> checkInDate{};
  shared_ptr<string> checkOutDate{};
  shared_ptr<string> cityCode{};
  shared_ptr<long> dir{};
  shared_ptr<long> distance{};
  shared_ptr<string> districtCode{};
  shared_ptr<string> hotelStar{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<string> keyWords{};
  shared_ptr<string> location{};
  shared_ptr<double> maxPrice{};
  shared_ptr<double> minPrice{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> payOverType{};
  shared_ptr<long> paymentType{};
  shared_ptr<vector<long>> shids{};
  shared_ptr<long> sortCode{};
  shared_ptr<long> superMan{};

  HotelSearchRequest() {}

  explicit HotelSearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adultNum) {
      res["adult_num"] = boost::any(*adultNum);
    }
    if (brandCode) {
      res["brand_code"] = boost::any(*brandCode);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (checkInDate) {
      res["check_in_date"] = boost::any(*checkInDate);
    }
    if (checkOutDate) {
      res["check_out_date"] = boost::any(*checkOutDate);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (dir) {
      res["dir"] = boost::any(*dir);
    }
    if (distance) {
      res["distance"] = boost::any(*distance);
    }
    if (districtCode) {
      res["district_code"] = boost::any(*districtCode);
    }
    if (hotelStar) {
      res["hotel_star"] = boost::any(*hotelStar);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (keyWords) {
      res["key_words"] = boost::any(*keyWords);
    }
    if (location) {
      res["location"] = boost::any(*location);
    }
    if (maxPrice) {
      res["max_price"] = boost::any(*maxPrice);
    }
    if (minPrice) {
      res["min_price"] = boost::any(*minPrice);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (payOverType) {
      res["pay_over_type"] = boost::any(*payOverType);
    }
    if (paymentType) {
      res["payment_type"] = boost::any(*paymentType);
    }
    if (shids) {
      res["shids"] = boost::any(*shids);
    }
    if (sortCode) {
      res["sort_code"] = boost::any(*sortCode);
    }
    if (superMan) {
      res["super_man"] = boost::any(*superMan);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("adult_num") != m.end() && !m["adult_num"].empty()) {
      adultNum = make_shared<string>(boost::any_cast<string>(m["adult_num"]));
    }
    if (m.find("brand_code") != m.end() && !m["brand_code"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["brand_code"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["brand_code"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      brandCode = make_shared<vector<string>>(toVec1);
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("check_in_date") != m.end() && !m["check_in_date"].empty()) {
      checkInDate = make_shared<string>(boost::any_cast<string>(m["check_in_date"]));
    }
    if (m.find("check_out_date") != m.end() && !m["check_out_date"].empty()) {
      checkOutDate = make_shared<string>(boost::any_cast<string>(m["check_out_date"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("dir") != m.end() && !m["dir"].empty()) {
      dir = make_shared<long>(boost::any_cast<long>(m["dir"]));
    }
    if (m.find("distance") != m.end() && !m["distance"].empty()) {
      distance = make_shared<long>(boost::any_cast<long>(m["distance"]));
    }
    if (m.find("district_code") != m.end() && !m["district_code"].empty()) {
      districtCode = make_shared<string>(boost::any_cast<string>(m["district_code"]));
    }
    if (m.find("hotel_star") != m.end() && !m["hotel_star"].empty()) {
      hotelStar = make_shared<string>(boost::any_cast<string>(m["hotel_star"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("key_words") != m.end() && !m["key_words"].empty()) {
      keyWords = make_shared<string>(boost::any_cast<string>(m["key_words"]));
    }
    if (m.find("location") != m.end() && !m["location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["location"]));
    }
    if (m.find("max_price") != m.end() && !m["max_price"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["max_price"]));
    }
    if (m.find("min_price") != m.end() && !m["min_price"].empty()) {
      minPrice = make_shared<double>(boost::any_cast<double>(m["min_price"]));
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("pay_over_type") != m.end() && !m["pay_over_type"].empty()) {
      payOverType = make_shared<long>(boost::any_cast<long>(m["pay_over_type"]));
    }
    if (m.find("payment_type") != m.end() && !m["payment_type"].empty()) {
      paymentType = make_shared<long>(boost::any_cast<long>(m["payment_type"]));
    }
    if (m.find("shids") != m.end() && !m["shids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["shids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["shids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      shids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("sort_code") != m.end() && !m["sort_code"].empty()) {
      sortCode = make_shared<long>(boost::any_cast<long>(m["sort_code"]));
    }
    if (m.find("super_man") != m.end() && !m["super_man"].empty()) {
      superMan = make_shared<long>(boost::any_cast<long>(m["super_man"]));
    }
  }


  virtual ~HotelSearchRequest() = default;
};
class HotelSearchShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> adultNum{};
  shared_ptr<string> brandCodeShrink{};
  shared_ptr<string> btripUserId{};
  shared_ptr<string> checkInDate{};
  shared_ptr<string> checkOutDate{};
  shared_ptr<string> cityCode{};
  shared_ptr<long> dir{};
  shared_ptr<long> distance{};
  shared_ptr<string> districtCode{};
  shared_ptr<string> hotelStar{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<string> keyWords{};
  shared_ptr<string> location{};
  shared_ptr<double> maxPrice{};
  shared_ptr<double> minPrice{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> payOverType{};
  shared_ptr<long> paymentType{};
  shared_ptr<string> shidsShrink{};
  shared_ptr<long> sortCode{};
  shared_ptr<long> superMan{};

  HotelSearchShrinkRequest() {}

  explicit HotelSearchShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adultNum) {
      res["adult_num"] = boost::any(*adultNum);
    }
    if (brandCodeShrink) {
      res["brand_code"] = boost::any(*brandCodeShrink);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (checkInDate) {
      res["check_in_date"] = boost::any(*checkInDate);
    }
    if (checkOutDate) {
      res["check_out_date"] = boost::any(*checkOutDate);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (dir) {
      res["dir"] = boost::any(*dir);
    }
    if (distance) {
      res["distance"] = boost::any(*distance);
    }
    if (districtCode) {
      res["district_code"] = boost::any(*districtCode);
    }
    if (hotelStar) {
      res["hotel_star"] = boost::any(*hotelStar);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (keyWords) {
      res["key_words"] = boost::any(*keyWords);
    }
    if (location) {
      res["location"] = boost::any(*location);
    }
    if (maxPrice) {
      res["max_price"] = boost::any(*maxPrice);
    }
    if (minPrice) {
      res["min_price"] = boost::any(*minPrice);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (payOverType) {
      res["pay_over_type"] = boost::any(*payOverType);
    }
    if (paymentType) {
      res["payment_type"] = boost::any(*paymentType);
    }
    if (shidsShrink) {
      res["shids"] = boost::any(*shidsShrink);
    }
    if (sortCode) {
      res["sort_code"] = boost::any(*sortCode);
    }
    if (superMan) {
      res["super_man"] = boost::any(*superMan);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("adult_num") != m.end() && !m["adult_num"].empty()) {
      adultNum = make_shared<string>(boost::any_cast<string>(m["adult_num"]));
    }
    if (m.find("brand_code") != m.end() && !m["brand_code"].empty()) {
      brandCodeShrink = make_shared<string>(boost::any_cast<string>(m["brand_code"]));
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("check_in_date") != m.end() && !m["check_in_date"].empty()) {
      checkInDate = make_shared<string>(boost::any_cast<string>(m["check_in_date"]));
    }
    if (m.find("check_out_date") != m.end() && !m["check_out_date"].empty()) {
      checkOutDate = make_shared<string>(boost::any_cast<string>(m["check_out_date"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("dir") != m.end() && !m["dir"].empty()) {
      dir = make_shared<long>(boost::any_cast<long>(m["dir"]));
    }
    if (m.find("distance") != m.end() && !m["distance"].empty()) {
      distance = make_shared<long>(boost::any_cast<long>(m["distance"]));
    }
    if (m.find("district_code") != m.end() && !m["district_code"].empty()) {
      districtCode = make_shared<string>(boost::any_cast<string>(m["district_code"]));
    }
    if (m.find("hotel_star") != m.end() && !m["hotel_star"].empty()) {
      hotelStar = make_shared<string>(boost::any_cast<string>(m["hotel_star"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("key_words") != m.end() && !m["key_words"].empty()) {
      keyWords = make_shared<string>(boost::any_cast<string>(m["key_words"]));
    }
    if (m.find("location") != m.end() && !m["location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["location"]));
    }
    if (m.find("max_price") != m.end() && !m["max_price"].empty()) {
      maxPrice = make_shared<double>(boost::any_cast<double>(m["max_price"]));
    }
    if (m.find("min_price") != m.end() && !m["min_price"].empty()) {
      minPrice = make_shared<double>(boost::any_cast<double>(m["min_price"]));
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("pay_over_type") != m.end() && !m["pay_over_type"].empty()) {
      payOverType = make_shared<long>(boost::any_cast<long>(m["pay_over_type"]));
    }
    if (m.find("payment_type") != m.end() && !m["payment_type"].empty()) {
      paymentType = make_shared<long>(boost::any_cast<long>(m["payment_type"]));
    }
    if (m.find("shids") != m.end() && !m["shids"].empty()) {
      shidsShrink = make_shared<string>(boost::any_cast<string>(m["shids"]));
    }
    if (m.find("sort_code") != m.end() && !m["sort_code"].empty()) {
      sortCode = make_shared<long>(boost::any_cast<long>(m["sort_code"]));
    }
    if (m.find("super_man") != m.end() && !m["super_man"].empty()) {
      superMan = make_shared<long>(boost::any_cast<long>(m["super_man"]));
    }
  }


  virtual ~HotelSearchShrinkRequest() = default;
};
class HotelSearchResponseBodyModuleItemsDiscountDescDiscountDetail : public Darabonba::Model {
public:
  shared_ptr<vector<string>> labelName{};
  shared_ptr<string> moneyDesc{};

  HotelSearchResponseBodyModuleItemsDiscountDescDiscountDetail() {}

  explicit HotelSearchResponseBodyModuleItemsDiscountDescDiscountDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labelName) {
      res["label_name"] = boost::any(*labelName);
    }
    if (moneyDesc) {
      res["money_desc"] = boost::any(*moneyDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("label_name") != m.end() && !m["label_name"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["label_name"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["label_name"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labelName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("money_desc") != m.end() && !m["money_desc"].empty()) {
      moneyDesc = make_shared<string>(boost::any_cast<string>(m["money_desc"]));
    }
  }


  virtual ~HotelSearchResponseBodyModuleItemsDiscountDescDiscountDetail() = default;
};
class HotelSearchResponseBodyModuleItemsDiscountDesc : public Darabonba::Model {
public:
  shared_ptr<string> cashReduceTotal{};
  shared_ptr<string> dinamicLabel{};
  shared_ptr<vector<HotelSearchResponseBodyModuleItemsDiscountDescDiscountDetail>> discountDetail{};
  shared_ptr<string> subTitle{};
  shared_ptr<string> title{};

  HotelSearchResponseBodyModuleItemsDiscountDesc() {}

  explicit HotelSearchResponseBodyModuleItemsDiscountDesc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cashReduceTotal) {
      res["cash_reduce_total"] = boost::any(*cashReduceTotal);
    }
    if (dinamicLabel) {
      res["dinamic_label"] = boost::any(*dinamicLabel);
    }
    if (discountDetail) {
      vector<boost::any> temp1;
      for(auto item1:*discountDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["discount_detail"] = boost::any(temp1);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cash_reduce_total") != m.end() && !m["cash_reduce_total"].empty()) {
      cashReduceTotal = make_shared<string>(boost::any_cast<string>(m["cash_reduce_total"]));
    }
    if (m.find("dinamic_label") != m.end() && !m["dinamic_label"].empty()) {
      dinamicLabel = make_shared<string>(boost::any_cast<string>(m["dinamic_label"]));
    }
    if (m.find("discount_detail") != m.end() && !m["discount_detail"].empty()) {
      if (typeid(vector<boost::any>) == m["discount_detail"].type()) {
        vector<HotelSearchResponseBodyModuleItemsDiscountDescDiscountDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["discount_detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelSearchResponseBodyModuleItemsDiscountDescDiscountDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        discountDetail = make_shared<vector<HotelSearchResponseBodyModuleItemsDiscountDescDiscountDetail>>(expect1);
      }
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~HotelSearchResponseBodyModuleItemsDiscountDesc() = default;
};
class HotelSearchResponseBodyModuleItems : public Darabonba::Model {
public:
  shared_ptr<string> brandName{};
  shared_ptr<string> btandCode{};
  shared_ptr<string> cityCode{};
  shared_ptr<HotelSearchResponseBodyModuleItemsDiscountDesc> discountDesc{};
  shared_ptr<long> distance{};
  shared_ptr<string> districtCode{};
  shared_ptr<string> hotelAddress{};
  shared_ptr<string> hotelCode{};
  shared_ptr<string> hotelEnName{};
  shared_ptr<string> hotelName{};
  shared_ptr<string> hotelStar{};
  shared_ptr<string> imageUrl{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<string> location{};
  shared_ptr<double> minPrice{};
  shared_ptr<double> originalMinPrice{};
  shared_ptr<string> score{};
  shared_ptr<long> status{};
  shared_ptr<string> tel{};

  HotelSearchResponseBodyModuleItems() {}

  explicit HotelSearchResponseBodyModuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (brandName) {
      res["brand_name"] = boost::any(*brandName);
    }
    if (btandCode) {
      res["btand_code"] = boost::any(*btandCode);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (discountDesc) {
      res["discount_desc"] = discountDesc ? boost::any(discountDesc->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (distance) {
      res["distance"] = boost::any(*distance);
    }
    if (districtCode) {
      res["district_code"] = boost::any(*districtCode);
    }
    if (hotelAddress) {
      res["hotel_address"] = boost::any(*hotelAddress);
    }
    if (hotelCode) {
      res["hotel_code"] = boost::any(*hotelCode);
    }
    if (hotelEnName) {
      res["hotel_en_name"] = boost::any(*hotelEnName);
    }
    if (hotelName) {
      res["hotel_name"] = boost::any(*hotelName);
    }
    if (hotelStar) {
      res["hotel_star"] = boost::any(*hotelStar);
    }
    if (imageUrl) {
      res["image_url"] = boost::any(*imageUrl);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (location) {
      res["location"] = boost::any(*location);
    }
    if (minPrice) {
      res["min_price"] = boost::any(*minPrice);
    }
    if (originalMinPrice) {
      res["original_min_price"] = boost::any(*originalMinPrice);
    }
    if (score) {
      res["score"] = boost::any(*score);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (tel) {
      res["tel"] = boost::any(*tel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("brand_name") != m.end() && !m["brand_name"].empty()) {
      brandName = make_shared<string>(boost::any_cast<string>(m["brand_name"]));
    }
    if (m.find("btand_code") != m.end() && !m["btand_code"].empty()) {
      btandCode = make_shared<string>(boost::any_cast<string>(m["btand_code"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("discount_desc") != m.end() && !m["discount_desc"].empty()) {
      if (typeid(map<string, boost::any>) == m["discount_desc"].type()) {
        HotelSearchResponseBodyModuleItemsDiscountDesc model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["discount_desc"]));
        discountDesc = make_shared<HotelSearchResponseBodyModuleItemsDiscountDesc>(model1);
      }
    }
    if (m.find("distance") != m.end() && !m["distance"].empty()) {
      distance = make_shared<long>(boost::any_cast<long>(m["distance"]));
    }
    if (m.find("district_code") != m.end() && !m["district_code"].empty()) {
      districtCode = make_shared<string>(boost::any_cast<string>(m["district_code"]));
    }
    if (m.find("hotel_address") != m.end() && !m["hotel_address"].empty()) {
      hotelAddress = make_shared<string>(boost::any_cast<string>(m["hotel_address"]));
    }
    if (m.find("hotel_code") != m.end() && !m["hotel_code"].empty()) {
      hotelCode = make_shared<string>(boost::any_cast<string>(m["hotel_code"]));
    }
    if (m.find("hotel_en_name") != m.end() && !m["hotel_en_name"].empty()) {
      hotelEnName = make_shared<string>(boost::any_cast<string>(m["hotel_en_name"]));
    }
    if (m.find("hotel_name") != m.end() && !m["hotel_name"].empty()) {
      hotelName = make_shared<string>(boost::any_cast<string>(m["hotel_name"]));
    }
    if (m.find("hotel_star") != m.end() && !m["hotel_star"].empty()) {
      hotelStar = make_shared<string>(boost::any_cast<string>(m["hotel_star"]));
    }
    if (m.find("image_url") != m.end() && !m["image_url"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["image_url"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("location") != m.end() && !m["location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["location"]));
    }
    if (m.find("min_price") != m.end() && !m["min_price"].empty()) {
      minPrice = make_shared<double>(boost::any_cast<double>(m["min_price"]));
    }
    if (m.find("original_min_price") != m.end() && !m["original_min_price"].empty()) {
      originalMinPrice = make_shared<double>(boost::any_cast<double>(m["original_min_price"]));
    }
    if (m.find("score") != m.end() && !m["score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["score"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("tel") != m.end() && !m["tel"].empty()) {
      tel = make_shared<string>(boost::any_cast<string>(m["tel"]));
    }
  }


  virtual ~HotelSearchResponseBodyModuleItems() = default;
};
class HotelSearchResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<HotelSearchResponseBodyModuleItems>> items{};

  HotelSearchResponseBodyModule() {}

  explicit HotelSearchResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<HotelSearchResponseBodyModuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelSearchResponseBodyModuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<HotelSearchResponseBodyModuleItems>>(expect1);
      }
    }
  }


  virtual ~HotelSearchResponseBodyModule() = default;
};
class HotelSearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelSearchResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelSearchResponseBody() {}

  explicit HotelSearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelSearchResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelSearchResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelSearchResponseBody() = default;
};
class HotelSearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelSearchResponseBody> body{};

  HotelSearchResponse() {}

  explicit HotelSearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelSearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelSearchResponseBody>(model1);
      }
    }
  }


  virtual ~HotelSearchResponse() = default;
};
class HotelStaticInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  HotelStaticInfoHeaders() {}

  explicit HotelStaticInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~HotelStaticInfoHeaders() = default;
};
class HotelStaticInfoRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hotelIds{};

  HotelStaticInfoRequest() {}

  explicit HotelStaticInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelIds) {
      res["hotel_ids"] = boost::any(*hotelIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_ids") != m.end() && !m["hotel_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["hotel_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["hotel_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hotelIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~HotelStaticInfoRequest() = default;
};
class HotelStaticInfoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> hotelIdsShrink{};

  HotelStaticInfoShrinkRequest() {}

  explicit HotelStaticInfoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelIdsShrink) {
      res["hotel_ids"] = boost::any(*hotelIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_ids") != m.end() && !m["hotel_ids"].empty()) {
      hotelIdsShrink = make_shared<string>(boost::any_cast<string>(m["hotel_ids"]));
    }
  }


  virtual ~HotelStaticInfoShrinkRequest() = default;
};
class HotelStaticInfoResponseBodyModuleHotelStaticInfosExpandInfo : public Darabonba::Model {
public:
  shared_ptr<string> checkIn{};
  shared_ptr<string> checkOut{};
  shared_ptr<string> decorateTime{};
  shared_ptr<string> floors{};
  shared_ptr<vector<string>> hotelFacilities{};
  shared_ptr<long> hotelType{};
  shared_ptr<string> openingTime{};
  shared_ptr<vector<string>> roomFacilities{};
  shared_ptr<long> rooms{};
  shared_ptr<vector<string>> service{};
  shared_ptr<string> themeTag{};

  HotelStaticInfoResponseBodyModuleHotelStaticInfosExpandInfo() {}

  explicit HotelStaticInfoResponseBodyModuleHotelStaticInfosExpandInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkIn) {
      res["check_in"] = boost::any(*checkIn);
    }
    if (checkOut) {
      res["check_out"] = boost::any(*checkOut);
    }
    if (decorateTime) {
      res["decorate_time"] = boost::any(*decorateTime);
    }
    if (floors) {
      res["floors"] = boost::any(*floors);
    }
    if (hotelFacilities) {
      res["hotel_facilities"] = boost::any(*hotelFacilities);
    }
    if (hotelType) {
      res["hotel_type"] = boost::any(*hotelType);
    }
    if (openingTime) {
      res["opening_time"] = boost::any(*openingTime);
    }
    if (roomFacilities) {
      res["room_facilities"] = boost::any(*roomFacilities);
    }
    if (rooms) {
      res["rooms"] = boost::any(*rooms);
    }
    if (service) {
      res["service"] = boost::any(*service);
    }
    if (themeTag) {
      res["theme_tag"] = boost::any(*themeTag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("check_in") != m.end() && !m["check_in"].empty()) {
      checkIn = make_shared<string>(boost::any_cast<string>(m["check_in"]));
    }
    if (m.find("check_out") != m.end() && !m["check_out"].empty()) {
      checkOut = make_shared<string>(boost::any_cast<string>(m["check_out"]));
    }
    if (m.find("decorate_time") != m.end() && !m["decorate_time"].empty()) {
      decorateTime = make_shared<string>(boost::any_cast<string>(m["decorate_time"]));
    }
    if (m.find("floors") != m.end() && !m["floors"].empty()) {
      floors = make_shared<string>(boost::any_cast<string>(m["floors"]));
    }
    if (m.find("hotel_facilities") != m.end() && !m["hotel_facilities"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["hotel_facilities"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["hotel_facilities"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hotelFacilities = make_shared<vector<string>>(toVec1);
    }
    if (m.find("hotel_type") != m.end() && !m["hotel_type"].empty()) {
      hotelType = make_shared<long>(boost::any_cast<long>(m["hotel_type"]));
    }
    if (m.find("opening_time") != m.end() && !m["opening_time"].empty()) {
      openingTime = make_shared<string>(boost::any_cast<string>(m["opening_time"]));
    }
    if (m.find("room_facilities") != m.end() && !m["room_facilities"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["room_facilities"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["room_facilities"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roomFacilities = make_shared<vector<string>>(toVec1);
    }
    if (m.find("rooms") != m.end() && !m["rooms"].empty()) {
      rooms = make_shared<long>(boost::any_cast<long>(m["rooms"]));
    }
    if (m.find("service") != m.end() && !m["service"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["service"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["service"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      service = make_shared<vector<string>>(toVec1);
    }
    if (m.find("theme_tag") != m.end() && !m["theme_tag"].empty()) {
      themeTag = make_shared<string>(boost::any_cast<string>(m["theme_tag"]));
    }
  }


  virtual ~HotelStaticInfoResponseBodyModuleHotelStaticInfosExpandInfo() = default;
};
class HotelStaticInfoResponseBodyModuleHotelStaticInfosImageinfos : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<long> tag{};
  shared_ptr<string> url{};

  HotelStaticInfoResponseBodyModuleHotelStaticInfosImageinfos() {}

  explicit HotelStaticInfoResponseBodyModuleHotelStaticInfosImageinfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (tag) {
      res["tag"] = boost::any(*tag);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("tag") != m.end() && !m["tag"].empty()) {
      tag = make_shared<long>(boost::any_cast<long>(m["tag"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~HotelStaticInfoResponseBodyModuleHotelStaticInfosImageinfos() = default;
};
class HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfosBedInfos : public Darabonba::Model {
public:
  shared_ptr<string> bedDesc{};
  shared_ptr<long> bedNum{};
  shared_ptr<string> bedSize{};
  shared_ptr<string> bedType{};

  HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfosBedInfos() {}

  explicit HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfosBedInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bedDesc) {
      res["bed_desc"] = boost::any(*bedDesc);
    }
    if (bedNum) {
      res["bed_num"] = boost::any(*bedNum);
    }
    if (bedSize) {
      res["bed_size"] = boost::any(*bedSize);
    }
    if (bedType) {
      res["bed_type"] = boost::any(*bedType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bed_desc") != m.end() && !m["bed_desc"].empty()) {
      bedDesc = make_shared<string>(boost::any_cast<string>(m["bed_desc"]));
    }
    if (m.find("bed_num") != m.end() && !m["bed_num"].empty()) {
      bedNum = make_shared<long>(boost::any_cast<long>(m["bed_num"]));
    }
    if (m.find("bed_size") != m.end() && !m["bed_size"].empty()) {
      bedSize = make_shared<string>(boost::any_cast<string>(m["bed_size"]));
    }
    if (m.find("bed_type") != m.end() && !m["bed_type"].empty()) {
      bedType = make_shared<string>(boost::any_cast<string>(m["bed_type"]));
    }
  }


  virtual ~HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfosBedInfos() = default;
};
class HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfos : public Darabonba::Model {
public:
  shared_ptr<vector<HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfosBedInfos>> bedInfos{};
  shared_ptr<long> extraBed{};
  shared_ptr<string> extraBedDesc{};
  shared_ptr<string> floor{};
  shared_ptr<string> internetWay{};
  shared_ptr<long> maxOccupancy{};
  shared_ptr<string> roomFacilities{};
  shared_ptr<vector<string>> roomFacilityList{};
  shared_ptr<string> roomId{};
  shared_ptr<string> roomImage{};
  shared_ptr<vector<string>> roomImages{};
  shared_ptr<string> roomName{};
  shared_ptr<long> roomType{};
  shared_ptr<string> roomarea{};
  shared_ptr<long> rooms{};
  shared_ptr<string> window{};
  shared_ptr<string> windowBad{};
  shared_ptr<string> windowView{};

  HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfos() {}

  explicit HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bedInfos) {
      vector<boost::any> temp1;
      for(auto item1:*bedInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["bed_infos"] = boost::any(temp1);
    }
    if (extraBed) {
      res["extra_bed"] = boost::any(*extraBed);
    }
    if (extraBedDesc) {
      res["extra_bed_desc"] = boost::any(*extraBedDesc);
    }
    if (floor) {
      res["floor"] = boost::any(*floor);
    }
    if (internetWay) {
      res["internet_way"] = boost::any(*internetWay);
    }
    if (maxOccupancy) {
      res["max_occupancy"] = boost::any(*maxOccupancy);
    }
    if (roomFacilities) {
      res["room_facilities"] = boost::any(*roomFacilities);
    }
    if (roomFacilityList) {
      res["room_facility_list"] = boost::any(*roomFacilityList);
    }
    if (roomId) {
      res["room_id"] = boost::any(*roomId);
    }
    if (roomImage) {
      res["room_image"] = boost::any(*roomImage);
    }
    if (roomImages) {
      res["room_images"] = boost::any(*roomImages);
    }
    if (roomName) {
      res["room_name"] = boost::any(*roomName);
    }
    if (roomType) {
      res["room_type"] = boost::any(*roomType);
    }
    if (roomarea) {
      res["roomarea"] = boost::any(*roomarea);
    }
    if (rooms) {
      res["rooms"] = boost::any(*rooms);
    }
    if (window) {
      res["window"] = boost::any(*window);
    }
    if (windowBad) {
      res["window_bad"] = boost::any(*windowBad);
    }
    if (windowView) {
      res["window_view"] = boost::any(*windowView);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bed_infos") != m.end() && !m["bed_infos"].empty()) {
      if (typeid(vector<boost::any>) == m["bed_infos"].type()) {
        vector<HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfosBedInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["bed_infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfosBedInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bedInfos = make_shared<vector<HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfosBedInfos>>(expect1);
      }
    }
    if (m.find("extra_bed") != m.end() && !m["extra_bed"].empty()) {
      extraBed = make_shared<long>(boost::any_cast<long>(m["extra_bed"]));
    }
    if (m.find("extra_bed_desc") != m.end() && !m["extra_bed_desc"].empty()) {
      extraBedDesc = make_shared<string>(boost::any_cast<string>(m["extra_bed_desc"]));
    }
    if (m.find("floor") != m.end() && !m["floor"].empty()) {
      floor = make_shared<string>(boost::any_cast<string>(m["floor"]));
    }
    if (m.find("internet_way") != m.end() && !m["internet_way"].empty()) {
      internetWay = make_shared<string>(boost::any_cast<string>(m["internet_way"]));
    }
    if (m.find("max_occupancy") != m.end() && !m["max_occupancy"].empty()) {
      maxOccupancy = make_shared<long>(boost::any_cast<long>(m["max_occupancy"]));
    }
    if (m.find("room_facilities") != m.end() && !m["room_facilities"].empty()) {
      roomFacilities = make_shared<string>(boost::any_cast<string>(m["room_facilities"]));
    }
    if (m.find("room_facility_list") != m.end() && !m["room_facility_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["room_facility_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["room_facility_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roomFacilityList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("room_id") != m.end() && !m["room_id"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["room_id"]));
    }
    if (m.find("room_image") != m.end() && !m["room_image"].empty()) {
      roomImage = make_shared<string>(boost::any_cast<string>(m["room_image"]));
    }
    if (m.find("room_images") != m.end() && !m["room_images"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["room_images"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["room_images"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roomImages = make_shared<vector<string>>(toVec1);
    }
    if (m.find("room_name") != m.end() && !m["room_name"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["room_name"]));
    }
    if (m.find("room_type") != m.end() && !m["room_type"].empty()) {
      roomType = make_shared<long>(boost::any_cast<long>(m["room_type"]));
    }
    if (m.find("roomarea") != m.end() && !m["roomarea"].empty()) {
      roomarea = make_shared<string>(boost::any_cast<string>(m["roomarea"]));
    }
    if (m.find("rooms") != m.end() && !m["rooms"].empty()) {
      rooms = make_shared<long>(boost::any_cast<long>(m["rooms"]));
    }
    if (m.find("window") != m.end() && !m["window"].empty()) {
      window = make_shared<string>(boost::any_cast<string>(m["window"]));
    }
    if (m.find("window_bad") != m.end() && !m["window_bad"].empty()) {
      windowBad = make_shared<string>(boost::any_cast<string>(m["window_bad"]));
    }
    if (m.find("window_view") != m.end() && !m["window_view"].empty()) {
      windowView = make_shared<string>(boost::any_cast<string>(m["window_view"]));
    }
  }


  virtual ~HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfos() = default;
};
class HotelStaticInfoResponseBodyModuleHotelStaticInfos : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> blockRoomTypeInformation{};
  shared_ptr<string> brand{};
  shared_ptr<string> brandName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> country{};
  shared_ptr<string> countryCode{};
  shared_ptr<string> description{};
  shared_ptr<string> district{};
  shared_ptr<string> districtName{};
  shared_ptr<HotelStaticInfoResponseBodyModuleHotelStaticInfosExpandInfo> expandInfo{};
  shared_ptr<string> hotelAddress{};
  shared_ptr<string> hotelEnAddress{};
  shared_ptr<string> hotelEnName{};
  shared_ptr<string> hotelId{};
  shared_ptr<string> hotelName{};
  shared_ptr<string> hotelOpenTime{};
  shared_ptr<string> hotelPhones{};
  shared_ptr<string> hotelPolicies{};
  shared_ptr<string> hotelfax{};
  shared_ptr<string> hotelpics{};
  shared_ptr<vector<HotelStaticInfoResponseBodyModuleHotelStaticInfosImageinfos>> imageinfos{};
  shared_ptr<string> invoiceProviderMethod{};
  shared_ptr<vector<long>> invoiceTypes{};
  shared_ptr<string> location{};
  shared_ptr<string> province{};
  shared_ptr<string> provinceName{};
  shared_ptr<string> ratingAverage{};
  shared_ptr<vector<HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfos>> roomInfos{};
  shared_ptr<string> star{};
  shared_ptr<string> starRate{};
  shared_ptr<string> status{};
  shared_ptr<string> themes{};
  shared_ptr<bool> visaReminding{};

  HotelStaticInfoResponseBodyModuleHotelStaticInfos() {}

  explicit HotelStaticInfoResponseBodyModuleHotelStaticInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockRoomTypeInformation) {
      res["block_room_type_information"] = boost::any(*blockRoomTypeInformation);
    }
    if (brand) {
      res["brand"] = boost::any(*brand);
    }
    if (brandName) {
      res["brand_name"] = boost::any(*brandName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (country) {
      res["country"] = boost::any(*country);
    }
    if (countryCode) {
      res["country_code"] = boost::any(*countryCode);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (district) {
      res["district"] = boost::any(*district);
    }
    if (districtName) {
      res["district_name"] = boost::any(*districtName);
    }
    if (expandInfo) {
      res["expand_info"] = expandInfo ? boost::any(expandInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotelAddress) {
      res["hotel_address"] = boost::any(*hotelAddress);
    }
    if (hotelEnAddress) {
      res["hotel_en_address"] = boost::any(*hotelEnAddress);
    }
    if (hotelEnName) {
      res["hotel_en_name"] = boost::any(*hotelEnName);
    }
    if (hotelId) {
      res["hotel_id"] = boost::any(*hotelId);
    }
    if (hotelName) {
      res["hotel_name"] = boost::any(*hotelName);
    }
    if (hotelOpenTime) {
      res["hotel_open_time"] = boost::any(*hotelOpenTime);
    }
    if (hotelPhones) {
      res["hotel_phones"] = boost::any(*hotelPhones);
    }
    if (hotelPolicies) {
      res["hotel_policies"] = boost::any(*hotelPolicies);
    }
    if (hotelfax) {
      res["hotelfax"] = boost::any(*hotelfax);
    }
    if (hotelpics) {
      res["hotelpics"] = boost::any(*hotelpics);
    }
    if (imageinfos) {
      vector<boost::any> temp1;
      for(auto item1:*imageinfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["imageinfos"] = boost::any(temp1);
    }
    if (invoiceProviderMethod) {
      res["invoice_provider_method"] = boost::any(*invoiceProviderMethod);
    }
    if (invoiceTypes) {
      res["invoice_types"] = boost::any(*invoiceTypes);
    }
    if (location) {
      res["location"] = boost::any(*location);
    }
    if (province) {
      res["province"] = boost::any(*province);
    }
    if (provinceName) {
      res["province_name"] = boost::any(*provinceName);
    }
    if (ratingAverage) {
      res["rating_average"] = boost::any(*ratingAverage);
    }
    if (roomInfos) {
      vector<boost::any> temp1;
      for(auto item1:*roomInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["room_infos"] = boost::any(temp1);
    }
    if (star) {
      res["star"] = boost::any(*star);
    }
    if (starRate) {
      res["star_rate"] = boost::any(*starRate);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (themes) {
      res["themes"] = boost::any(*themes);
    }
    if (visaReminding) {
      res["visa_reminding"] = boost::any(*visaReminding);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("block_room_type_information") != m.end() && !m["block_room_type_information"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["block_room_type_information"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      blockRoomTypeInformation = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("brand") != m.end() && !m["brand"].empty()) {
      brand = make_shared<string>(boost::any_cast<string>(m["brand"]));
    }
    if (m.find("brand_name") != m.end() && !m["brand_name"].empty()) {
      brandName = make_shared<string>(boost::any_cast<string>(m["brand_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("country") != m.end() && !m["country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["country"]));
    }
    if (m.find("country_code") != m.end() && !m["country_code"].empty()) {
      countryCode = make_shared<string>(boost::any_cast<string>(m["country_code"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("district") != m.end() && !m["district"].empty()) {
      district = make_shared<string>(boost::any_cast<string>(m["district"]));
    }
    if (m.find("district_name") != m.end() && !m["district_name"].empty()) {
      districtName = make_shared<string>(boost::any_cast<string>(m["district_name"]));
    }
    if (m.find("expand_info") != m.end() && !m["expand_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["expand_info"].type()) {
        HotelStaticInfoResponseBodyModuleHotelStaticInfosExpandInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["expand_info"]));
        expandInfo = make_shared<HotelStaticInfoResponseBodyModuleHotelStaticInfosExpandInfo>(model1);
      }
    }
    if (m.find("hotel_address") != m.end() && !m["hotel_address"].empty()) {
      hotelAddress = make_shared<string>(boost::any_cast<string>(m["hotel_address"]));
    }
    if (m.find("hotel_en_address") != m.end() && !m["hotel_en_address"].empty()) {
      hotelEnAddress = make_shared<string>(boost::any_cast<string>(m["hotel_en_address"]));
    }
    if (m.find("hotel_en_name") != m.end() && !m["hotel_en_name"].empty()) {
      hotelEnName = make_shared<string>(boost::any_cast<string>(m["hotel_en_name"]));
    }
    if (m.find("hotel_id") != m.end() && !m["hotel_id"].empty()) {
      hotelId = make_shared<string>(boost::any_cast<string>(m["hotel_id"]));
    }
    if (m.find("hotel_name") != m.end() && !m["hotel_name"].empty()) {
      hotelName = make_shared<string>(boost::any_cast<string>(m["hotel_name"]));
    }
    if (m.find("hotel_open_time") != m.end() && !m["hotel_open_time"].empty()) {
      hotelOpenTime = make_shared<string>(boost::any_cast<string>(m["hotel_open_time"]));
    }
    if (m.find("hotel_phones") != m.end() && !m["hotel_phones"].empty()) {
      hotelPhones = make_shared<string>(boost::any_cast<string>(m["hotel_phones"]));
    }
    if (m.find("hotel_policies") != m.end() && !m["hotel_policies"].empty()) {
      hotelPolicies = make_shared<string>(boost::any_cast<string>(m["hotel_policies"]));
    }
    if (m.find("hotelfax") != m.end() && !m["hotelfax"].empty()) {
      hotelfax = make_shared<string>(boost::any_cast<string>(m["hotelfax"]));
    }
    if (m.find("hotelpics") != m.end() && !m["hotelpics"].empty()) {
      hotelpics = make_shared<string>(boost::any_cast<string>(m["hotelpics"]));
    }
    if (m.find("imageinfos") != m.end() && !m["imageinfos"].empty()) {
      if (typeid(vector<boost::any>) == m["imageinfos"].type()) {
        vector<HotelStaticInfoResponseBodyModuleHotelStaticInfosImageinfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["imageinfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelStaticInfoResponseBodyModuleHotelStaticInfosImageinfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageinfos = make_shared<vector<HotelStaticInfoResponseBodyModuleHotelStaticInfosImageinfos>>(expect1);
      }
    }
    if (m.find("invoice_provider_method") != m.end() && !m["invoice_provider_method"].empty()) {
      invoiceProviderMethod = make_shared<string>(boost::any_cast<string>(m["invoice_provider_method"]));
    }
    if (m.find("invoice_types") != m.end() && !m["invoice_types"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["invoice_types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["invoice_types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      invoiceTypes = make_shared<vector<long>>(toVec1);
    }
    if (m.find("location") != m.end() && !m["location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["location"]));
    }
    if (m.find("province") != m.end() && !m["province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["province"]));
    }
    if (m.find("province_name") != m.end() && !m["province_name"].empty()) {
      provinceName = make_shared<string>(boost::any_cast<string>(m["province_name"]));
    }
    if (m.find("rating_average") != m.end() && !m["rating_average"].empty()) {
      ratingAverage = make_shared<string>(boost::any_cast<string>(m["rating_average"]));
    }
    if (m.find("room_infos") != m.end() && !m["room_infos"].empty()) {
      if (typeid(vector<boost::any>) == m["room_infos"].type()) {
        vector<HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["room_infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roomInfos = make_shared<vector<HotelStaticInfoResponseBodyModuleHotelStaticInfosRoomInfos>>(expect1);
      }
    }
    if (m.find("star") != m.end() && !m["star"].empty()) {
      star = make_shared<string>(boost::any_cast<string>(m["star"]));
    }
    if (m.find("star_rate") != m.end() && !m["star_rate"].empty()) {
      starRate = make_shared<string>(boost::any_cast<string>(m["star_rate"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("themes") != m.end() && !m["themes"].empty()) {
      themes = make_shared<string>(boost::any_cast<string>(m["themes"]));
    }
    if (m.find("visa_reminding") != m.end() && !m["visa_reminding"].empty()) {
      visaReminding = make_shared<bool>(boost::any_cast<bool>(m["visa_reminding"]));
    }
  }


  virtual ~HotelStaticInfoResponseBodyModuleHotelStaticInfos() = default;
};
class HotelStaticInfoResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<HotelStaticInfoResponseBodyModuleHotelStaticInfos>> hotelStaticInfos{};

  HotelStaticInfoResponseBodyModule() {}

  explicit HotelStaticInfoResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotelStaticInfos) {
      vector<boost::any> temp1;
      for(auto item1:*hotelStaticInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["hotel_static_infos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hotel_static_infos") != m.end() && !m["hotel_static_infos"].empty()) {
      if (typeid(vector<boost::any>) == m["hotel_static_infos"].type()) {
        vector<HotelStaticInfoResponseBodyModuleHotelStaticInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hotel_static_infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HotelStaticInfoResponseBodyModuleHotelStaticInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotelStaticInfos = make_shared<vector<HotelStaticInfoResponseBodyModuleHotelStaticInfos>>(expect1);
      }
    }
  }


  virtual ~HotelStaticInfoResponseBodyModule() = default;
};
class HotelStaticInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<HotelStaticInfoResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  HotelStaticInfoResponseBody() {}

  explicit HotelStaticInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        HotelStaticInfoResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<HotelStaticInfoResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~HotelStaticInfoResponseBody() = default;
};
class HotelStaticInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HotelStaticInfoResponseBody> body{};

  HotelStaticInfoResponse() {}

  explicit HotelStaticInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HotelStaticInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HotelStaticInfoResponseBody>(model1);
      }
    }
  }


  virtual ~HotelStaticInfoResponse() = default;
};
class IeFlightBillSettlementQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  IeFlightBillSettlementQueryHeaders() {}

  explicit IeFlightBillSettlementQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~IeFlightBillSettlementQueryHeaders() = default;
};
class IeFlightBillSettlementQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};

  IeFlightBillSettlementQueryRequest() {}

  explicit IeFlightBillSettlementQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
  }


  virtual ~IeFlightBillSettlementQueryRequest() = default;
};
class IeFlightBillSettlementQueryResponseBodyModuleDataList : public Darabonba::Model {
public:
  shared_ptr<long> advanceDay{};
  shared_ptr<string> airlineCorpCode{};
  shared_ptr<string> airlineCorpName{};
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<string> applyArrCityCode{};
  shared_ptr<string> applyArrCityName{};
  shared_ptr<string> applyDepCityCode{};
  shared_ptr<string> applyDepCityName{};
  shared_ptr<string> applyExtendField{};
  shared_ptr<string> applyId{};
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> arrStation{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> billRecordTime{};
  shared_ptr<string> bookMode{};
  shared_ptr<string> bookTime{};
  shared_ptr<string> bookerId{};
  shared_ptr<string> bookerJobNo{};
  shared_ptr<string> bookerName{};
  shared_ptr<double> btripCouponFee{};
  shared_ptr<string> businessTripResult{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> capitalDirection{};
  shared_ptr<string> cascadeDepartment{};
  shared_ptr<double> changeFee{};
  shared_ptr<string> changeResult{};
  shared_ptr<double> corpPayOrderFee{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<double> coupon{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> department{};
  shared_ptr<string> departmentId{};
  shared_ptr<string> deptCity{};
  shared_ptr<string> deptDate{};
  shared_ptr<string> deptStation{};
  shared_ptr<string> deptTime{};
  shared_ptr<string> discount{};
  shared_ptr<string> exceedReason{};
  shared_ptr<string> feeType{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> index{};
  shared_ptr<double> insuranceFee{};
  shared_ptr<string> insuranceNumber{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> mostDifferenceDeptTime{};
  shared_ptr<string> mostDifferenceDiscount{};
  shared_ptr<string> mostDifferenceFlightNo{};
  shared_ptr<double> mostDifferencePrice{};
  shared_ptr<string> mostDifferenceReason{};
  shared_ptr<double> mostPrice{};
  shared_ptr<double> negotiationCouponFee{};
  shared_ptr<string> orderId{};
  shared_ptr<string> orderStatusDesc{};
  shared_ptr<string> overApplyId{};
  shared_ptr<long> primaryId{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectName{};
  shared_ptr<double> refundFee{};
  shared_ptr<string> refundResult{};
  shared_ptr<string> remark{};
  shared_ptr<string> repeatRefund{};
  shared_ptr<double> sealPrice{};
  shared_ptr<string> segmentType{};
  shared_ptr<double> serviceFee{};
  shared_ptr<double> settlementFee{};
  shared_ptr<double> settlementGrantFee{};
  shared_ptr<string> settlementTime{};
  shared_ptr<string> settlementType{};
  shared_ptr<long> status{};
  shared_ptr<string> subOrderId{};
  shared_ptr<double> taxFee{};
  shared_ptr<string> taxRate{};
  shared_ptr<string> thirdItineraryId{};
  shared_ptr<string> ticketId{};
  shared_ptr<string> trade{};
  shared_ptr<string> travelerId{};
  shared_ptr<string> travelerJobNo{};
  shared_ptr<string> travelerName{};
  shared_ptr<long> voucherType{};

  IeFlightBillSettlementQueryResponseBodyModuleDataList() {}

  explicit IeFlightBillSettlementQueryResponseBodyModuleDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advanceDay) {
      res["advance_day"] = boost::any(*advanceDay);
    }
    if (airlineCorpCode) {
      res["airline_corp_code"] = boost::any(*airlineCorpCode);
    }
    if (airlineCorpName) {
      res["airline_corp_name"] = boost::any(*airlineCorpName);
    }
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (applyArrCityCode) {
      res["apply_arr_city_code"] = boost::any(*applyArrCityCode);
    }
    if (applyArrCityName) {
      res["apply_arr_city_name"] = boost::any(*applyArrCityName);
    }
    if (applyDepCityCode) {
      res["apply_dep_city_code"] = boost::any(*applyDepCityCode);
    }
    if (applyDepCityName) {
      res["apply_dep_city_name"] = boost::any(*applyDepCityName);
    }
    if (applyExtendField) {
      res["apply_extend_field"] = boost::any(*applyExtendField);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (arrStation) {
      res["arr_station"] = boost::any(*arrStation);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (billRecordTime) {
      res["bill_record_time"] = boost::any(*billRecordTime);
    }
    if (bookMode) {
      res["book_mode"] = boost::any(*bookMode);
    }
    if (bookTime) {
      res["book_time"] = boost::any(*bookTime);
    }
    if (bookerId) {
      res["booker_id"] = boost::any(*bookerId);
    }
    if (bookerJobNo) {
      res["booker_job_no"] = boost::any(*bookerJobNo);
    }
    if (bookerName) {
      res["booker_name"] = boost::any(*bookerName);
    }
    if (btripCouponFee) {
      res["btrip_coupon_fee"] = boost::any(*btripCouponFee);
    }
    if (businessTripResult) {
      res["business_trip_result"] = boost::any(*businessTripResult);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (capitalDirection) {
      res["capital_direction"] = boost::any(*capitalDirection);
    }
    if (cascadeDepartment) {
      res["cascade_department"] = boost::any(*cascadeDepartment);
    }
    if (changeFee) {
      res["change_fee"] = boost::any(*changeFee);
    }
    if (changeResult) {
      res["change_result"] = boost::any(*changeResult);
    }
    if (corpPayOrderFee) {
      res["corp_pay_order_fee"] = boost::any(*corpPayOrderFee);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (coupon) {
      res["coupon"] = boost::any(*coupon);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (departmentId) {
      res["department_id"] = boost::any(*departmentId);
    }
    if (deptCity) {
      res["dept_city"] = boost::any(*deptCity);
    }
    if (deptDate) {
      res["dept_date"] = boost::any(*deptDate);
    }
    if (deptStation) {
      res["dept_station"] = boost::any(*deptStation);
    }
    if (deptTime) {
      res["dept_time"] = boost::any(*deptTime);
    }
    if (discount) {
      res["discount"] = boost::any(*discount);
    }
    if (exceedReason) {
      res["exceed_reason"] = boost::any(*exceedReason);
    }
    if (feeType) {
      res["fee_type"] = boost::any(*feeType);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (insuranceFee) {
      res["insurance_fee"] = boost::any(*insuranceFee);
    }
    if (insuranceNumber) {
      res["insurance_number"] = boost::any(*insuranceNumber);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (mostDifferenceDeptTime) {
      res["most_difference_dept_time"] = boost::any(*mostDifferenceDeptTime);
    }
    if (mostDifferenceDiscount) {
      res["most_difference_discount"] = boost::any(*mostDifferenceDiscount);
    }
    if (mostDifferenceFlightNo) {
      res["most_difference_flight_no"] = boost::any(*mostDifferenceFlightNo);
    }
    if (mostDifferencePrice) {
      res["most_difference_price"] = boost::any(*mostDifferencePrice);
    }
    if (mostDifferenceReason) {
      res["most_difference_reason"] = boost::any(*mostDifferenceReason);
    }
    if (mostPrice) {
      res["most_price"] = boost::any(*mostPrice);
    }
    if (negotiationCouponFee) {
      res["negotiation_coupon_fee"] = boost::any(*negotiationCouponFee);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderStatusDesc) {
      res["order_status_desc"] = boost::any(*orderStatusDesc);
    }
    if (overApplyId) {
      res["over_apply_id"] = boost::any(*overApplyId);
    }
    if (primaryId) {
      res["primary_id"] = boost::any(*primaryId);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (refundResult) {
      res["refund_result"] = boost::any(*refundResult);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (repeatRefund) {
      res["repeat_refund"] = boost::any(*repeatRefund);
    }
    if (sealPrice) {
      res["seal_price"] = boost::any(*sealPrice);
    }
    if (segmentType) {
      res["segment_type"] = boost::any(*segmentType);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (settlementFee) {
      res["settlement_fee"] = boost::any(*settlementFee);
    }
    if (settlementGrantFee) {
      res["settlement_grant_fee"] = boost::any(*settlementGrantFee);
    }
    if (settlementTime) {
      res["settlement_time"] = boost::any(*settlementTime);
    }
    if (settlementType) {
      res["settlement_type"] = boost::any(*settlementType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subOrderId) {
      res["sub_order_id"] = boost::any(*subOrderId);
    }
    if (taxFee) {
      res["tax_fee"] = boost::any(*taxFee);
    }
    if (taxRate) {
      res["tax_rate"] = boost::any(*taxRate);
    }
    if (thirdItineraryId) {
      res["third_itinerary_id"] = boost::any(*thirdItineraryId);
    }
    if (ticketId) {
      res["ticket_id"] = boost::any(*ticketId);
    }
    if (trade) {
      res["trade"] = boost::any(*trade);
    }
    if (travelerId) {
      res["traveler_id"] = boost::any(*travelerId);
    }
    if (travelerJobNo) {
      res["traveler_job_no"] = boost::any(*travelerJobNo);
    }
    if (travelerName) {
      res["traveler_name"] = boost::any(*travelerName);
    }
    if (voucherType) {
      res["voucher_type"] = boost::any(*voucherType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("advance_day") != m.end() && !m["advance_day"].empty()) {
      advanceDay = make_shared<long>(boost::any_cast<long>(m["advance_day"]));
    }
    if (m.find("airline_corp_code") != m.end() && !m["airline_corp_code"].empty()) {
      airlineCorpCode = make_shared<string>(boost::any_cast<string>(m["airline_corp_code"]));
    }
    if (m.find("airline_corp_name") != m.end() && !m["airline_corp_name"].empty()) {
      airlineCorpName = make_shared<string>(boost::any_cast<string>(m["airline_corp_name"]));
    }
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("apply_arr_city_code") != m.end() && !m["apply_arr_city_code"].empty()) {
      applyArrCityCode = make_shared<string>(boost::any_cast<string>(m["apply_arr_city_code"]));
    }
    if (m.find("apply_arr_city_name") != m.end() && !m["apply_arr_city_name"].empty()) {
      applyArrCityName = make_shared<string>(boost::any_cast<string>(m["apply_arr_city_name"]));
    }
    if (m.find("apply_dep_city_code") != m.end() && !m["apply_dep_city_code"].empty()) {
      applyDepCityCode = make_shared<string>(boost::any_cast<string>(m["apply_dep_city_code"]));
    }
    if (m.find("apply_dep_city_name") != m.end() && !m["apply_dep_city_name"].empty()) {
      applyDepCityName = make_shared<string>(boost::any_cast<string>(m["apply_dep_city_name"]));
    }
    if (m.find("apply_extend_field") != m.end() && !m["apply_extend_field"].empty()) {
      applyExtendField = make_shared<string>(boost::any_cast<string>(m["apply_extend_field"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("arr_station") != m.end() && !m["arr_station"].empty()) {
      arrStation = make_shared<string>(boost::any_cast<string>(m["arr_station"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("bill_record_time") != m.end() && !m["bill_record_time"].empty()) {
      billRecordTime = make_shared<string>(boost::any_cast<string>(m["bill_record_time"]));
    }
    if (m.find("book_mode") != m.end() && !m["book_mode"].empty()) {
      bookMode = make_shared<string>(boost::any_cast<string>(m["book_mode"]));
    }
    if (m.find("book_time") != m.end() && !m["book_time"].empty()) {
      bookTime = make_shared<string>(boost::any_cast<string>(m["book_time"]));
    }
    if (m.find("booker_id") != m.end() && !m["booker_id"].empty()) {
      bookerId = make_shared<string>(boost::any_cast<string>(m["booker_id"]));
    }
    if (m.find("booker_job_no") != m.end() && !m["booker_job_no"].empty()) {
      bookerJobNo = make_shared<string>(boost::any_cast<string>(m["booker_job_no"]));
    }
    if (m.find("booker_name") != m.end() && !m["booker_name"].empty()) {
      bookerName = make_shared<string>(boost::any_cast<string>(m["booker_name"]));
    }
    if (m.find("btrip_coupon_fee") != m.end() && !m["btrip_coupon_fee"].empty()) {
      btripCouponFee = make_shared<double>(boost::any_cast<double>(m["btrip_coupon_fee"]));
    }
    if (m.find("business_trip_result") != m.end() && !m["business_trip_result"].empty()) {
      businessTripResult = make_shared<string>(boost::any_cast<string>(m["business_trip_result"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("capital_direction") != m.end() && !m["capital_direction"].empty()) {
      capitalDirection = make_shared<string>(boost::any_cast<string>(m["capital_direction"]));
    }
    if (m.find("cascade_department") != m.end() && !m["cascade_department"].empty()) {
      cascadeDepartment = make_shared<string>(boost::any_cast<string>(m["cascade_department"]));
    }
    if (m.find("change_fee") != m.end() && !m["change_fee"].empty()) {
      changeFee = make_shared<double>(boost::any_cast<double>(m["change_fee"]));
    }
    if (m.find("change_result") != m.end() && !m["change_result"].empty()) {
      changeResult = make_shared<string>(boost::any_cast<string>(m["change_result"]));
    }
    if (m.find("corp_pay_order_fee") != m.end() && !m["corp_pay_order_fee"].empty()) {
      corpPayOrderFee = make_shared<double>(boost::any_cast<double>(m["corp_pay_order_fee"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("coupon") != m.end() && !m["coupon"].empty()) {
      coupon = make_shared<double>(boost::any_cast<double>(m["coupon"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("department_id") != m.end() && !m["department_id"].empty()) {
      departmentId = make_shared<string>(boost::any_cast<string>(m["department_id"]));
    }
    if (m.find("dept_city") != m.end() && !m["dept_city"].empty()) {
      deptCity = make_shared<string>(boost::any_cast<string>(m["dept_city"]));
    }
    if (m.find("dept_date") != m.end() && !m["dept_date"].empty()) {
      deptDate = make_shared<string>(boost::any_cast<string>(m["dept_date"]));
    }
    if (m.find("dept_station") != m.end() && !m["dept_station"].empty()) {
      deptStation = make_shared<string>(boost::any_cast<string>(m["dept_station"]));
    }
    if (m.find("dept_time") != m.end() && !m["dept_time"].empty()) {
      deptTime = make_shared<string>(boost::any_cast<string>(m["dept_time"]));
    }
    if (m.find("discount") != m.end() && !m["discount"].empty()) {
      discount = make_shared<string>(boost::any_cast<string>(m["discount"]));
    }
    if (m.find("exceed_reason") != m.end() && !m["exceed_reason"].empty()) {
      exceedReason = make_shared<string>(boost::any_cast<string>(m["exceed_reason"]));
    }
    if (m.find("fee_type") != m.end() && !m["fee_type"].empty()) {
      feeType = make_shared<string>(boost::any_cast<string>(m["fee_type"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("insurance_fee") != m.end() && !m["insurance_fee"].empty()) {
      insuranceFee = make_shared<double>(boost::any_cast<double>(m["insurance_fee"]));
    }
    if (m.find("insurance_number") != m.end() && !m["insurance_number"].empty()) {
      insuranceNumber = make_shared<string>(boost::any_cast<string>(m["insurance_number"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("most_difference_dept_time") != m.end() && !m["most_difference_dept_time"].empty()) {
      mostDifferenceDeptTime = make_shared<string>(boost::any_cast<string>(m["most_difference_dept_time"]));
    }
    if (m.find("most_difference_discount") != m.end() && !m["most_difference_discount"].empty()) {
      mostDifferenceDiscount = make_shared<string>(boost::any_cast<string>(m["most_difference_discount"]));
    }
    if (m.find("most_difference_flight_no") != m.end() && !m["most_difference_flight_no"].empty()) {
      mostDifferenceFlightNo = make_shared<string>(boost::any_cast<string>(m["most_difference_flight_no"]));
    }
    if (m.find("most_difference_price") != m.end() && !m["most_difference_price"].empty()) {
      mostDifferencePrice = make_shared<double>(boost::any_cast<double>(m["most_difference_price"]));
    }
    if (m.find("most_difference_reason") != m.end() && !m["most_difference_reason"].empty()) {
      mostDifferenceReason = make_shared<string>(boost::any_cast<string>(m["most_difference_reason"]));
    }
    if (m.find("most_price") != m.end() && !m["most_price"].empty()) {
      mostPrice = make_shared<double>(boost::any_cast<double>(m["most_price"]));
    }
    if (m.find("negotiation_coupon_fee") != m.end() && !m["negotiation_coupon_fee"].empty()) {
      negotiationCouponFee = make_shared<double>(boost::any_cast<double>(m["negotiation_coupon_fee"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("order_status_desc") != m.end() && !m["order_status_desc"].empty()) {
      orderStatusDesc = make_shared<string>(boost::any_cast<string>(m["order_status_desc"]));
    }
    if (m.find("over_apply_id") != m.end() && !m["over_apply_id"].empty()) {
      overApplyId = make_shared<string>(boost::any_cast<string>(m["over_apply_id"]));
    }
    if (m.find("primary_id") != m.end() && !m["primary_id"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["primary_id"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<double>(boost::any_cast<double>(m["refund_fee"]));
    }
    if (m.find("refund_result") != m.end() && !m["refund_result"].empty()) {
      refundResult = make_shared<string>(boost::any_cast<string>(m["refund_result"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("repeat_refund") != m.end() && !m["repeat_refund"].empty()) {
      repeatRefund = make_shared<string>(boost::any_cast<string>(m["repeat_refund"]));
    }
    if (m.find("seal_price") != m.end() && !m["seal_price"].empty()) {
      sealPrice = make_shared<double>(boost::any_cast<double>(m["seal_price"]));
    }
    if (m.find("segment_type") != m.end() && !m["segment_type"].empty()) {
      segmentType = make_shared<string>(boost::any_cast<string>(m["segment_type"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<double>(boost::any_cast<double>(m["service_fee"]));
    }
    if (m.find("settlement_fee") != m.end() && !m["settlement_fee"].empty()) {
      settlementFee = make_shared<double>(boost::any_cast<double>(m["settlement_fee"]));
    }
    if (m.find("settlement_grant_fee") != m.end() && !m["settlement_grant_fee"].empty()) {
      settlementGrantFee = make_shared<double>(boost::any_cast<double>(m["settlement_grant_fee"]));
    }
    if (m.find("settlement_time") != m.end() && !m["settlement_time"].empty()) {
      settlementTime = make_shared<string>(boost::any_cast<string>(m["settlement_time"]));
    }
    if (m.find("settlement_type") != m.end() && !m["settlement_type"].empty()) {
      settlementType = make_shared<string>(boost::any_cast<string>(m["settlement_type"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("sub_order_id") != m.end() && !m["sub_order_id"].empty()) {
      subOrderId = make_shared<string>(boost::any_cast<string>(m["sub_order_id"]));
    }
    if (m.find("tax_fee") != m.end() && !m["tax_fee"].empty()) {
      taxFee = make_shared<double>(boost::any_cast<double>(m["tax_fee"]));
    }
    if (m.find("tax_rate") != m.end() && !m["tax_rate"].empty()) {
      taxRate = make_shared<string>(boost::any_cast<string>(m["tax_rate"]));
    }
    if (m.find("third_itinerary_id") != m.end() && !m["third_itinerary_id"].empty()) {
      thirdItineraryId = make_shared<string>(boost::any_cast<string>(m["third_itinerary_id"]));
    }
    if (m.find("ticket_id") != m.end() && !m["ticket_id"].empty()) {
      ticketId = make_shared<string>(boost::any_cast<string>(m["ticket_id"]));
    }
    if (m.find("trade") != m.end() && !m["trade"].empty()) {
      trade = make_shared<string>(boost::any_cast<string>(m["trade"]));
    }
    if (m.find("traveler_id") != m.end() && !m["traveler_id"].empty()) {
      travelerId = make_shared<string>(boost::any_cast<string>(m["traveler_id"]));
    }
    if (m.find("traveler_job_no") != m.end() && !m["traveler_job_no"].empty()) {
      travelerJobNo = make_shared<string>(boost::any_cast<string>(m["traveler_job_no"]));
    }
    if (m.find("traveler_name") != m.end() && !m["traveler_name"].empty()) {
      travelerName = make_shared<string>(boost::any_cast<string>(m["traveler_name"]));
    }
    if (m.find("voucher_type") != m.end() && !m["voucher_type"].empty()) {
      voucherType = make_shared<long>(boost::any_cast<long>(m["voucher_type"]));
    }
  }


  virtual ~IeFlightBillSettlementQueryResponseBodyModuleDataList() = default;
};
class IeFlightBillSettlementQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> category{};
  shared_ptr<string> corpId{};
  shared_ptr<vector<IeFlightBillSettlementQueryResponseBodyModuleDataList>> dataList{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};
  shared_ptr<long> totalNum{};

  IeFlightBillSettlementQueryResponseBodyModule() {}

  explicit IeFlightBillSettlementQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_list"] = boost::any(temp1);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    if (totalNum) {
      res["total_num"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["category"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("data_list") != m.end() && !m["data_list"].empty()) {
      if (typeid(vector<boost::any>) == m["data_list"].type()) {
        vector<IeFlightBillSettlementQueryResponseBodyModuleDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IeFlightBillSettlementQueryResponseBodyModuleDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<IeFlightBillSettlementQueryResponseBodyModuleDataList>>(expect1);
      }
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
    if (m.find("total_num") != m.end() && !m["total_num"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["total_num"]));
    }
  }


  virtual ~IeFlightBillSettlementQueryResponseBodyModule() = default;
};
class IeFlightBillSettlementQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<IeFlightBillSettlementQueryResponseBodyModule> module{};
  shared_ptr<bool> morePage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  IeFlightBillSettlementQueryResponseBody() {}

  explicit IeFlightBillSettlementQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (morePage) {
      res["more_page"] = boost::any(*morePage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        IeFlightBillSettlementQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<IeFlightBillSettlementQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("more_page") != m.end() && !m["more_page"].empty()) {
      morePage = make_shared<bool>(boost::any_cast<bool>(m["more_page"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~IeFlightBillSettlementQueryResponseBody() = default;
};
class IeFlightBillSettlementQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<IeFlightBillSettlementQueryResponseBody> body{};

  IeFlightBillSettlementQueryResponse() {}

  explicit IeFlightBillSettlementQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        IeFlightBillSettlementQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<IeFlightBillSettlementQueryResponseBody>(model1);
      }
    }
  }


  virtual ~IeFlightBillSettlementQueryResponse() = default;
};
class InsInvoiceScanQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  InsInvoiceScanQueryHeaders() {}

  explicit InsInvoiceScanQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~InsInvoiceScanQueryHeaders() = default;
};
class InsInvoiceScanQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> billDate{};
  shared_ptr<long> billId{};
  shared_ptr<long> invoiceSubTaskId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  InsInvoiceScanQueryRequest() {}

  explicit InsInvoiceScanQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (billId) {
      res["bill_id"] = boost::any(*billId);
    }
    if (invoiceSubTaskId) {
      res["invoice_sub_task_id"] = boost::any(*invoiceSubTaskId);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("bill_id") != m.end() && !m["bill_id"].empty()) {
      billId = make_shared<long>(boost::any_cast<long>(m["bill_id"]));
    }
    if (m.find("invoice_sub_task_id") != m.end() && !m["invoice_sub_task_id"].empty()) {
      invoiceSubTaskId = make_shared<long>(boost::any_cast<long>(m["invoice_sub_task_id"]));
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
  }


  virtual ~InsInvoiceScanQueryRequest() = default;
};
class InsInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails : public Darabonba::Model {
public:
  shared_ptr<string> amount{};
  shared_ptr<string> index{};
  shared_ptr<string> itemName{};
  shared_ptr<string> quantity{};
  shared_ptr<string> specification{};
  shared_ptr<string> tax{};
  shared_ptr<string> taxRate{};
  shared_ptr<string> unit{};
  shared_ptr<string> unitPrice{};

  InsInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails() {}

  explicit InsInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (itemName) {
      res["item_name"] = boost::any(*itemName);
    }
    if (quantity) {
      res["quantity"] = boost::any(*quantity);
    }
    if (specification) {
      res["specification"] = boost::any(*specification);
    }
    if (tax) {
      res["tax"] = boost::any(*tax);
    }
    if (taxRate) {
      res["tax_rate"] = boost::any(*taxRate);
    }
    if (unit) {
      res["unit"] = boost::any(*unit);
    }
    if (unitPrice) {
      res["unit_price"] = boost::any(*unitPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<string>(boost::any_cast<string>(m["amount"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("item_name") != m.end() && !m["item_name"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["item_name"]));
    }
    if (m.find("quantity") != m.end() && !m["quantity"].empty()) {
      quantity = make_shared<string>(boost::any_cast<string>(m["quantity"]));
    }
    if (m.find("specification") != m.end() && !m["specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["specification"]));
    }
    if (m.find("tax") != m.end() && !m["tax"].empty()) {
      tax = make_shared<string>(boost::any_cast<string>(m["tax"]));
    }
    if (m.find("tax_rate") != m.end() && !m["tax_rate"].empty()) {
      taxRate = make_shared<string>(boost::any_cast<string>(m["tax_rate"]));
    }
    if (m.find("unit") != m.end() && !m["unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["unit"]));
    }
    if (m.find("unit_price") != m.end() && !m["unit_price"].empty()) {
      unitPrice = make_shared<string>(boost::any_cast<string>(m["unit_price"]));
    }
  }


  virtual ~InsInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails() = default;
};
class InsInvoiceScanQueryResponseBodyModuleItems : public Darabonba::Model {
public:
  shared_ptr<string> amountWithTax{};
  shared_ptr<string> amountWithoutTax{};
  shared_ptr<string> billDate{};
  shared_ptr<string> checkCode{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> department{};
  shared_ptr<string> drawer{};
  shared_ptr<string> id{};
  shared_ptr<string> insuranceCompany{};
  shared_ptr<string> insuranceOrderId{};
  shared_ptr<string> insuranceType{};
  shared_ptr<string> invoiceCode{};
  shared_ptr<string> invoiceDay{};
  shared_ptr<vector<InsInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails>> invoiceDetails{};
  shared_ptr<string> invoiceLocation{};
  shared_ptr<string> invoiceNo{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> machineCode{};
  shared_ptr<long> orderId{};
  shared_ptr<string> ossUrl{};
  shared_ptr<string> passenger{};
  shared_ptr<string> passwordArea{};
  shared_ptr<string> project{};
  shared_ptr<string> purchaserBankAccountInfo{};
  shared_ptr<string> purchaserContactInfo{};
  shared_ptr<string> purchaserName{};
  shared_ptr<string> purchaserTaxNo{};
  shared_ptr<string> recipient{};
  shared_ptr<string> remarks{};
  shared_ptr<string> reviewer{};
  shared_ptr<string> sellerBankAccountInfo{};
  shared_ptr<string> sellerContactInfo{};
  shared_ptr<string> sellerName{};
  shared_ptr<string> sellerTaxNo{};
  shared_ptr<string> smartCheckCode{};
  shared_ptr<string> taxAmount{};
  shared_ptr<string> taxRate{};
  shared_ptr<string> totalAmountInWords{};

  InsInvoiceScanQueryResponseBodyModuleItems() {}

  explicit InsInvoiceScanQueryResponseBodyModuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amountWithTax) {
      res["amount_with_tax"] = boost::any(*amountWithTax);
    }
    if (amountWithoutTax) {
      res["amount_without_tax"] = boost::any(*amountWithoutTax);
    }
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (checkCode) {
      res["check_code"] = boost::any(*checkCode);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (drawer) {
      res["drawer"] = boost::any(*drawer);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (insuranceCompany) {
      res["insurance_company"] = boost::any(*insuranceCompany);
    }
    if (insuranceOrderId) {
      res["insurance_order_id"] = boost::any(*insuranceOrderId);
    }
    if (insuranceType) {
      res["insurance_type"] = boost::any(*insuranceType);
    }
    if (invoiceCode) {
      res["invoice_code"] = boost::any(*invoiceCode);
    }
    if (invoiceDay) {
      res["invoice_day"] = boost::any(*invoiceDay);
    }
    if (invoiceDetails) {
      vector<boost::any> temp1;
      for(auto item1:*invoiceDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["invoice_details"] = boost::any(temp1);
    }
    if (invoiceLocation) {
      res["invoice_location"] = boost::any(*invoiceLocation);
    }
    if (invoiceNo) {
      res["invoice_no"] = boost::any(*invoiceNo);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (machineCode) {
      res["machine_code"] = boost::any(*machineCode);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (ossUrl) {
      res["oss_url"] = boost::any(*ossUrl);
    }
    if (passenger) {
      res["passenger"] = boost::any(*passenger);
    }
    if (passwordArea) {
      res["password_area"] = boost::any(*passwordArea);
    }
    if (project) {
      res["project"] = boost::any(*project);
    }
    if (purchaserBankAccountInfo) {
      res["purchaser_bank_account_info"] = boost::any(*purchaserBankAccountInfo);
    }
    if (purchaserContactInfo) {
      res["purchaser_contact_info"] = boost::any(*purchaserContactInfo);
    }
    if (purchaserName) {
      res["purchaser_name"] = boost::any(*purchaserName);
    }
    if (purchaserTaxNo) {
      res["purchaser_tax_no"] = boost::any(*purchaserTaxNo);
    }
    if (recipient) {
      res["recipient"] = boost::any(*recipient);
    }
    if (remarks) {
      res["remarks"] = boost::any(*remarks);
    }
    if (reviewer) {
      res["reviewer"] = boost::any(*reviewer);
    }
    if (sellerBankAccountInfo) {
      res["seller_bank_account_info"] = boost::any(*sellerBankAccountInfo);
    }
    if (sellerContactInfo) {
      res["seller_contact_info"] = boost::any(*sellerContactInfo);
    }
    if (sellerName) {
      res["seller_name"] = boost::any(*sellerName);
    }
    if (sellerTaxNo) {
      res["seller_tax_no"] = boost::any(*sellerTaxNo);
    }
    if (smartCheckCode) {
      res["smart_check_code"] = boost::any(*smartCheckCode);
    }
    if (taxAmount) {
      res["tax_amount"] = boost::any(*taxAmount);
    }
    if (taxRate) {
      res["tax_rate"] = boost::any(*taxRate);
    }
    if (totalAmountInWords) {
      res["total_amount_in_words"] = boost::any(*totalAmountInWords);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount_with_tax") != m.end() && !m["amount_with_tax"].empty()) {
      amountWithTax = make_shared<string>(boost::any_cast<string>(m["amount_with_tax"]));
    }
    if (m.find("amount_without_tax") != m.end() && !m["amount_without_tax"].empty()) {
      amountWithoutTax = make_shared<string>(boost::any_cast<string>(m["amount_without_tax"]));
    }
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("check_code") != m.end() && !m["check_code"].empty()) {
      checkCode = make_shared<string>(boost::any_cast<string>(m["check_code"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("drawer") != m.end() && !m["drawer"].empty()) {
      drawer = make_shared<string>(boost::any_cast<string>(m["drawer"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("insurance_company") != m.end() && !m["insurance_company"].empty()) {
      insuranceCompany = make_shared<string>(boost::any_cast<string>(m["insurance_company"]));
    }
    if (m.find("insurance_order_id") != m.end() && !m["insurance_order_id"].empty()) {
      insuranceOrderId = make_shared<string>(boost::any_cast<string>(m["insurance_order_id"]));
    }
    if (m.find("insurance_type") != m.end() && !m["insurance_type"].empty()) {
      insuranceType = make_shared<string>(boost::any_cast<string>(m["insurance_type"]));
    }
    if (m.find("invoice_code") != m.end() && !m["invoice_code"].empty()) {
      invoiceCode = make_shared<string>(boost::any_cast<string>(m["invoice_code"]));
    }
    if (m.find("invoice_day") != m.end() && !m["invoice_day"].empty()) {
      invoiceDay = make_shared<string>(boost::any_cast<string>(m["invoice_day"]));
    }
    if (m.find("invoice_details") != m.end() && !m["invoice_details"].empty()) {
      if (typeid(vector<boost::any>) == m["invoice_details"].type()) {
        vector<InsInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["invoice_details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invoiceDetails = make_shared<vector<InsInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails>>(expect1);
      }
    }
    if (m.find("invoice_location") != m.end() && !m["invoice_location"].empty()) {
      invoiceLocation = make_shared<string>(boost::any_cast<string>(m["invoice_location"]));
    }
    if (m.find("invoice_no") != m.end() && !m["invoice_no"].empty()) {
      invoiceNo = make_shared<string>(boost::any_cast<string>(m["invoice_no"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("machine_code") != m.end() && !m["machine_code"].empty()) {
      machineCode = make_shared<string>(boost::any_cast<string>(m["machine_code"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("oss_url") != m.end() && !m["oss_url"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["oss_url"]));
    }
    if (m.find("passenger") != m.end() && !m["passenger"].empty()) {
      passenger = make_shared<string>(boost::any_cast<string>(m["passenger"]));
    }
    if (m.find("password_area") != m.end() && !m["password_area"].empty()) {
      passwordArea = make_shared<string>(boost::any_cast<string>(m["password_area"]));
    }
    if (m.find("project") != m.end() && !m["project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["project"]));
    }
    if (m.find("purchaser_bank_account_info") != m.end() && !m["purchaser_bank_account_info"].empty()) {
      purchaserBankAccountInfo = make_shared<string>(boost::any_cast<string>(m["purchaser_bank_account_info"]));
    }
    if (m.find("purchaser_contact_info") != m.end() && !m["purchaser_contact_info"].empty()) {
      purchaserContactInfo = make_shared<string>(boost::any_cast<string>(m["purchaser_contact_info"]));
    }
    if (m.find("purchaser_name") != m.end() && !m["purchaser_name"].empty()) {
      purchaserName = make_shared<string>(boost::any_cast<string>(m["purchaser_name"]));
    }
    if (m.find("purchaser_tax_no") != m.end() && !m["purchaser_tax_no"].empty()) {
      purchaserTaxNo = make_shared<string>(boost::any_cast<string>(m["purchaser_tax_no"]));
    }
    if (m.find("recipient") != m.end() && !m["recipient"].empty()) {
      recipient = make_shared<string>(boost::any_cast<string>(m["recipient"]));
    }
    if (m.find("remarks") != m.end() && !m["remarks"].empty()) {
      remarks = make_shared<string>(boost::any_cast<string>(m["remarks"]));
    }
    if (m.find("reviewer") != m.end() && !m["reviewer"].empty()) {
      reviewer = make_shared<string>(boost::any_cast<string>(m["reviewer"]));
    }
    if (m.find("seller_bank_account_info") != m.end() && !m["seller_bank_account_info"].empty()) {
      sellerBankAccountInfo = make_shared<string>(boost::any_cast<string>(m["seller_bank_account_info"]));
    }
    if (m.find("seller_contact_info") != m.end() && !m["seller_contact_info"].empty()) {
      sellerContactInfo = make_shared<string>(boost::any_cast<string>(m["seller_contact_info"]));
    }
    if (m.find("seller_name") != m.end() && !m["seller_name"].empty()) {
      sellerName = make_shared<string>(boost::any_cast<string>(m["seller_name"]));
    }
    if (m.find("seller_tax_no") != m.end() && !m["seller_tax_no"].empty()) {
      sellerTaxNo = make_shared<string>(boost::any_cast<string>(m["seller_tax_no"]));
    }
    if (m.find("smart_check_code") != m.end() && !m["smart_check_code"].empty()) {
      smartCheckCode = make_shared<string>(boost::any_cast<string>(m["smart_check_code"]));
    }
    if (m.find("tax_amount") != m.end() && !m["tax_amount"].empty()) {
      taxAmount = make_shared<string>(boost::any_cast<string>(m["tax_amount"]));
    }
    if (m.find("tax_rate") != m.end() && !m["tax_rate"].empty()) {
      taxRate = make_shared<string>(boost::any_cast<string>(m["tax_rate"]));
    }
    if (m.find("total_amount_in_words") != m.end() && !m["total_amount_in_words"].empty()) {
      totalAmountInWords = make_shared<string>(boost::any_cast<string>(m["total_amount_in_words"]));
    }
  }


  virtual ~InsInvoiceScanQueryResponseBodyModuleItems() = default;
};
class InsInvoiceScanQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<InsInvoiceScanQueryResponseBodyModuleItems>> items{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalPage{};
  shared_ptr<long> totalSize{};

  InsInvoiceScanQueryResponseBodyModule() {}

  explicit InsInvoiceScanQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalPage) {
      res["total_page"] = boost::any(*totalPage);
    }
    if (totalSize) {
      res["total_size"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<InsInvoiceScanQueryResponseBodyModuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsInvoiceScanQueryResponseBodyModuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<InsInvoiceScanQueryResponseBodyModuleItems>>(expect1);
      }
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_page") != m.end() && !m["total_page"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["total_page"]));
    }
    if (m.find("total_size") != m.end() && !m["total_size"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["total_size"]));
    }
  }


  virtual ~InsInvoiceScanQueryResponseBodyModule() = default;
};
class InsInvoiceScanQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<InsInvoiceScanQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InsInvoiceScanQueryResponseBody() {}

  explicit InsInvoiceScanQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        InsInvoiceScanQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<InsInvoiceScanQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InsInvoiceScanQueryResponseBody() = default;
};
class InsInvoiceScanQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsInvoiceScanQueryResponseBody> body{};

  InsInvoiceScanQueryResponse() {}

  explicit InsInvoiceScanQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsInvoiceScanQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsInvoiceScanQueryResponseBody>(model1);
      }
    }
  }


  virtual ~InsInvoiceScanQueryResponse() = default;
};
class InsureOrderApplyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  InsureOrderApplyHeaders() {}

  explicit InsureOrderApplyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~InsureOrderApplyHeaders() = default;
};
class InsureOrderApplyRequest : public Darabonba::Model {
public:
  shared_ptr<string> btripUserId{};
  shared_ptr<string> buyerName{};
  shared_ptr<string> insOrderId{};
  shared_ptr<string> isvName{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<string> supplierCode{};

  InsureOrderApplyRequest() {}

  explicit InsureOrderApplyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (insOrderId) {
      res["ins_order_id"] = boost::any(*insOrderId);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (supplierCode) {
      res["supplier_code"] = boost::any(*supplierCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("ins_order_id") != m.end() && !m["ins_order_id"].empty()) {
      insOrderId = make_shared<string>(boost::any_cast<string>(m["ins_order_id"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("supplier_code") != m.end() && !m["supplier_code"].empty()) {
      supplierCode = make_shared<string>(boost::any_cast<string>(m["supplier_code"]));
    }
  }


  virtual ~InsureOrderApplyRequest() = default;
};
class InsureOrderApplyResponseBodyModuleInsOrderPolicyList : public Darabonba::Model {
public:
  shared_ptr<string> outSubInsOrderId{};
  shared_ptr<string> policyNo{};
  shared_ptr<string> status{};
  shared_ptr<string> subInsOrderId{};

  InsureOrderApplyResponseBodyModuleInsOrderPolicyList() {}

  explicit InsureOrderApplyResponseBodyModuleInsOrderPolicyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outSubInsOrderId) {
      res["out_sub_ins_order_id"] = boost::any(*outSubInsOrderId);
    }
    if (policyNo) {
      res["policy_no"] = boost::any(*policyNo);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subInsOrderId) {
      res["sub_ins_order_id"] = boost::any(*subInsOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("out_sub_ins_order_id") != m.end() && !m["out_sub_ins_order_id"].empty()) {
      outSubInsOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_ins_order_id"]));
    }
    if (m.find("policy_no") != m.end() && !m["policy_no"].empty()) {
      policyNo = make_shared<string>(boost::any_cast<string>(m["policy_no"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("sub_ins_order_id") != m.end() && !m["sub_ins_order_id"].empty()) {
      subInsOrderId = make_shared<string>(boost::any_cast<string>(m["sub_ins_order_id"]));
    }
  }


  virtual ~InsureOrderApplyResponseBodyModuleInsOrderPolicyList() = default;
};
class InsureOrderApplyResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> insOrderId{};
  shared_ptr<vector<InsureOrderApplyResponseBodyModuleInsOrderPolicyList>> insOrderPolicyList{};

  InsureOrderApplyResponseBodyModule() {}

  explicit InsureOrderApplyResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (insOrderId) {
      res["ins_order_id"] = boost::any(*insOrderId);
    }
    if (insOrderPolicyList) {
      vector<boost::any> temp1;
      for(auto item1:*insOrderPolicyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ins_order_policy_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ins_order_id") != m.end() && !m["ins_order_id"].empty()) {
      insOrderId = make_shared<string>(boost::any_cast<string>(m["ins_order_id"]));
    }
    if (m.find("ins_order_policy_list") != m.end() && !m["ins_order_policy_list"].empty()) {
      if (typeid(vector<boost::any>) == m["ins_order_policy_list"].type()) {
        vector<InsureOrderApplyResponseBodyModuleInsOrderPolicyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ins_order_policy_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsureOrderApplyResponseBodyModuleInsOrderPolicyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        insOrderPolicyList = make_shared<vector<InsureOrderApplyResponseBodyModuleInsOrderPolicyList>>(expect1);
      }
    }
  }


  virtual ~InsureOrderApplyResponseBodyModule() = default;
};
class InsureOrderApplyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<InsureOrderApplyResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InsureOrderApplyResponseBody() {}

  explicit InsureOrderApplyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        InsureOrderApplyResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<InsureOrderApplyResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InsureOrderApplyResponseBody() = default;
};
class InsureOrderApplyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsureOrderApplyResponseBody> body{};

  InsureOrderApplyResponse() {}

  explicit InsureOrderApplyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsureOrderApplyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsureOrderApplyResponseBody>(model1);
      }
    }
  }


  virtual ~InsureOrderApplyResponse() = default;
};
class InsureOrderCancelHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  InsureOrderCancelHeaders() {}

  explicit InsureOrderCancelHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~InsureOrderCancelHeaders() = default;
};
class InsureOrderCancelRequest : public Darabonba::Model {
public:
  shared_ptr<string> btripUserId{};
  shared_ptr<string> buyerName{};
  shared_ptr<string> isvName{};
  shared_ptr<string> supplierCode{};

  InsureOrderCancelRequest() {}

  explicit InsureOrderCancelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (supplierCode) {
      res["supplier_code"] = boost::any(*supplierCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("supplier_code") != m.end() && !m["supplier_code"].empty()) {
      supplierCode = make_shared<string>(boost::any_cast<string>(m["supplier_code"]));
    }
  }


  virtual ~InsureOrderCancelRequest() = default;
};
class InsureOrderCancelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InsureOrderCancelResponseBody() {}

  explicit InsureOrderCancelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InsureOrderCancelResponseBody() = default;
};
class InsureOrderCancelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsureOrderCancelResponseBody> body{};

  InsureOrderCancelResponse() {}

  explicit InsureOrderCancelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsureOrderCancelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsureOrderCancelResponseBody>(model1);
      }
    }
  }


  virtual ~InsureOrderCancelResponse() = default;
};
class InsureOrderCreateHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  InsureOrderCreateHeaders() {}

  explicit InsureOrderCreateHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~InsureOrderCreateHeaders() = default;
};
class InsureOrderCreateRequestApplicant : public Darabonba::Model {
public:
  shared_ptr<string> birthday{};
  shared_ptr<string> btripUserId{};
  shared_ptr<string> certName{};
  shared_ptr<string> certNo{};
  shared_ptr<string> certType{};
  shared_ptr<string> gender{};
  shared_ptr<string> phone{};

  InsureOrderCreateRequestApplicant() {}

  explicit InsureOrderCreateRequestApplicant(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthday) {
      res["birthday"] = boost::any(*birthday);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (certName) {
      res["cert_name"] = boost::any(*certName);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (gender) {
      res["gender"] = boost::any(*gender);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birthday") != m.end() && !m["birthday"].empty()) {
      birthday = make_shared<string>(boost::any_cast<string>(m["birthday"]));
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("cert_name") != m.end() && !m["cert_name"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["cert_name"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["cert_type"]));
    }
    if (m.find("gender") != m.end() && !m["gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["gender"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
  }


  virtual ~InsureOrderCreateRequestApplicant() = default;
};
class InsureOrderCreateRequestInsPersonAndSegmentListInsureSegment : public Darabonba::Model {
public:
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depTime{};
  shared_ptr<string> flightNo{};

  InsureOrderCreateRequestInsPersonAndSegmentListInsureSegment() {}

  explicit InsureOrderCreateRequestInsPersonAndSegmentListInsureSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
  }


  virtual ~InsureOrderCreateRequestInsPersonAndSegmentListInsureSegment() = default;
};
class InsureOrderCreateRequestInsPersonAndSegmentListInsured : public Darabonba::Model {
public:
  shared_ptr<string> birthday{};
  shared_ptr<string> btripUserId{};
  shared_ptr<string> certName{};
  shared_ptr<string> certNo{};
  shared_ptr<string> certType{};
  shared_ptr<string> gender{};
  shared_ptr<string> phone{};

  InsureOrderCreateRequestInsPersonAndSegmentListInsured() {}

  explicit InsureOrderCreateRequestInsPersonAndSegmentListInsured(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthday) {
      res["birthday"] = boost::any(*birthday);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (certName) {
      res["cert_name"] = boost::any(*certName);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (gender) {
      res["gender"] = boost::any(*gender);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birthday") != m.end() && !m["birthday"].empty()) {
      birthday = make_shared<string>(boost::any_cast<string>(m["birthday"]));
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("cert_name") != m.end() && !m["cert_name"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["cert_name"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["cert_type"]));
    }
    if (m.find("gender") != m.end() && !m["gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["gender"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
  }


  virtual ~InsureOrderCreateRequestInsPersonAndSegmentListInsured() = default;
};
class InsureOrderCreateRequestInsPersonAndSegmentList : public Darabonba::Model {
public:
  shared_ptr<InsureOrderCreateRequestInsPersonAndSegmentListInsureSegment> insureSegment{};
  shared_ptr<InsureOrderCreateRequestInsPersonAndSegmentListInsured> insured{};
  shared_ptr<string> outSubInsOrderId{};

  InsureOrderCreateRequestInsPersonAndSegmentList() {}

  explicit InsureOrderCreateRequestInsPersonAndSegmentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (insureSegment) {
      res["insure_segment"] = insureSegment ? boost::any(insureSegment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (insured) {
      res["insured"] = insured ? boost::any(insured->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outSubInsOrderId) {
      res["out_sub_ins_order_id"] = boost::any(*outSubInsOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("insure_segment") != m.end() && !m["insure_segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["insure_segment"].type()) {
        InsureOrderCreateRequestInsPersonAndSegmentListInsureSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["insure_segment"]));
        insureSegment = make_shared<InsureOrderCreateRequestInsPersonAndSegmentListInsureSegment>(model1);
      }
    }
    if (m.find("insured") != m.end() && !m["insured"].empty()) {
      if (typeid(map<string, boost::any>) == m["insured"].type()) {
        InsureOrderCreateRequestInsPersonAndSegmentListInsured model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["insured"]));
        insured = make_shared<InsureOrderCreateRequestInsPersonAndSegmentListInsured>(model1);
      }
    }
    if (m.find("out_sub_ins_order_id") != m.end() && !m["out_sub_ins_order_id"].empty()) {
      outSubInsOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_ins_order_id"]));
    }
  }


  virtual ~InsureOrderCreateRequestInsPersonAndSegmentList() = default;
};
class InsureOrderCreateRequest : public Darabonba::Model {
public:
  shared_ptr<InsureOrderCreateRequestApplicant> applicant{};
  shared_ptr<string> btripUserId{};
  shared_ptr<string> buyerName{};
  shared_ptr<vector<InsureOrderCreateRequestInsPersonAndSegmentList>> insPersonAndSegmentList{};
  shared_ptr<string> isvName{};
  shared_ptr<string> outInsOrderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<string> supplierCode{};

  InsureOrderCreateRequest() {}

  explicit InsureOrderCreateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicant) {
      res["applicant"] = applicant ? boost::any(applicant->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (insPersonAndSegmentList) {
      vector<boost::any> temp1;
      for(auto item1:*insPersonAndSegmentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ins_person_and_segment_list"] = boost::any(temp1);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (outInsOrderId) {
      res["out_ins_order_id"] = boost::any(*outInsOrderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (supplierCode) {
      res["supplier_code"] = boost::any(*supplierCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("applicant") != m.end() && !m["applicant"].empty()) {
      if (typeid(map<string, boost::any>) == m["applicant"].type()) {
        InsureOrderCreateRequestApplicant model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["applicant"]));
        applicant = make_shared<InsureOrderCreateRequestApplicant>(model1);
      }
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("ins_person_and_segment_list") != m.end() && !m["ins_person_and_segment_list"].empty()) {
      if (typeid(vector<boost::any>) == m["ins_person_and_segment_list"].type()) {
        vector<InsureOrderCreateRequestInsPersonAndSegmentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ins_person_and_segment_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsureOrderCreateRequestInsPersonAndSegmentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        insPersonAndSegmentList = make_shared<vector<InsureOrderCreateRequestInsPersonAndSegmentList>>(expect1);
      }
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("out_ins_order_id") != m.end() && !m["out_ins_order_id"].empty()) {
      outInsOrderId = make_shared<string>(boost::any_cast<string>(m["out_ins_order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("supplier_code") != m.end() && !m["supplier_code"].empty()) {
      supplierCode = make_shared<string>(boost::any_cast<string>(m["supplier_code"]));
    }
  }


  virtual ~InsureOrderCreateRequest() = default;
};
class InsureOrderCreateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicantShrink{};
  shared_ptr<string> btripUserId{};
  shared_ptr<string> buyerName{};
  shared_ptr<string> insPersonAndSegmentListShrink{};
  shared_ptr<string> isvName{};
  shared_ptr<string> outInsOrderId{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<string> supplierCode{};

  InsureOrderCreateShrinkRequest() {}

  explicit InsureOrderCreateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicantShrink) {
      res["applicant"] = boost::any(*applicantShrink);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (insPersonAndSegmentListShrink) {
      res["ins_person_and_segment_list"] = boost::any(*insPersonAndSegmentListShrink);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (outInsOrderId) {
      res["out_ins_order_id"] = boost::any(*outInsOrderId);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (supplierCode) {
      res["supplier_code"] = boost::any(*supplierCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("applicant") != m.end() && !m["applicant"].empty()) {
      applicantShrink = make_shared<string>(boost::any_cast<string>(m["applicant"]));
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("ins_person_and_segment_list") != m.end() && !m["ins_person_and_segment_list"].empty()) {
      insPersonAndSegmentListShrink = make_shared<string>(boost::any_cast<string>(m["ins_person_and_segment_list"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("out_ins_order_id") != m.end() && !m["out_ins_order_id"].empty()) {
      outInsOrderId = make_shared<string>(boost::any_cast<string>(m["out_ins_order_id"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("supplier_code") != m.end() && !m["supplier_code"].empty()) {
      supplierCode = make_shared<string>(boost::any_cast<string>(m["supplier_code"]));
    }
  }


  virtual ~InsureOrderCreateShrinkRequest() = default;
};
class InsureOrderCreateResponseBodyModuleInsureOrderDetailList : public Darabonba::Model {
public:
  shared_ptr<string> outSubInsOrderId{};
  shared_ptr<string> policyNo{};
  shared_ptr<string> status{};
  shared_ptr<string> subInsOrderId{};

  InsureOrderCreateResponseBodyModuleInsureOrderDetailList() {}

  explicit InsureOrderCreateResponseBodyModuleInsureOrderDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outSubInsOrderId) {
      res["out_sub_ins_order_id"] = boost::any(*outSubInsOrderId);
    }
    if (policyNo) {
      res["policy_no"] = boost::any(*policyNo);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subInsOrderId) {
      res["sub_ins_order_id"] = boost::any(*subInsOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("out_sub_ins_order_id") != m.end() && !m["out_sub_ins_order_id"].empty()) {
      outSubInsOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_ins_order_id"]));
    }
    if (m.find("policy_no") != m.end() && !m["policy_no"].empty()) {
      policyNo = make_shared<string>(boost::any_cast<string>(m["policy_no"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("sub_ins_order_id") != m.end() && !m["sub_ins_order_id"].empty()) {
      subInsOrderId = make_shared<string>(boost::any_cast<string>(m["sub_ins_order_id"]));
    }
  }


  virtual ~InsureOrderCreateResponseBodyModuleInsureOrderDetailList() = default;
};
class InsureOrderCreateResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> copies{};
  shared_ptr<vector<InsureOrderCreateResponseBodyModuleInsureOrderDetailList>> insureOrderDetailList{};
  shared_ptr<string> insureOrderId{};
  shared_ptr<long> premium{};

  InsureOrderCreateResponseBodyModule() {}

  explicit InsureOrderCreateResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (copies) {
      res["copies"] = boost::any(*copies);
    }
    if (insureOrderDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*insureOrderDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["insure_order_detail_list"] = boost::any(temp1);
    }
    if (insureOrderId) {
      res["insure_order_id"] = boost::any(*insureOrderId);
    }
    if (premium) {
      res["premium"] = boost::any(*premium);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("copies") != m.end() && !m["copies"].empty()) {
      copies = make_shared<long>(boost::any_cast<long>(m["copies"]));
    }
    if (m.find("insure_order_detail_list") != m.end() && !m["insure_order_detail_list"].empty()) {
      if (typeid(vector<boost::any>) == m["insure_order_detail_list"].type()) {
        vector<InsureOrderCreateResponseBodyModuleInsureOrderDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["insure_order_detail_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsureOrderCreateResponseBodyModuleInsureOrderDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        insureOrderDetailList = make_shared<vector<InsureOrderCreateResponseBodyModuleInsureOrderDetailList>>(expect1);
      }
    }
    if (m.find("insure_order_id") != m.end() && !m["insure_order_id"].empty()) {
      insureOrderId = make_shared<string>(boost::any_cast<string>(m["insure_order_id"]));
    }
    if (m.find("premium") != m.end() && !m["premium"].empty()) {
      premium = make_shared<long>(boost::any_cast<long>(m["premium"]));
    }
  }


  virtual ~InsureOrderCreateResponseBodyModule() = default;
};
class InsureOrderCreateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<InsureOrderCreateResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InsureOrderCreateResponseBody() {}

  explicit InsureOrderCreateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        InsureOrderCreateResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<InsureOrderCreateResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InsureOrderCreateResponseBody() = default;
};
class InsureOrderCreateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsureOrderCreateResponseBody> body{};

  InsureOrderCreateResponse() {}

  explicit InsureOrderCreateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsureOrderCreateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsureOrderCreateResponseBody>(model1);
      }
    }
  }


  virtual ~InsureOrderCreateResponse() = default;
};
class InsureOrderDetailHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  InsureOrderDetailHeaders() {}

  explicit InsureOrderDetailHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~InsureOrderDetailHeaders() = default;
};
class InsureOrderDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> btripUserId{};
  shared_ptr<string> buyerName{};
  shared_ptr<string> insOrderId{};
  shared_ptr<string> isvName{};
  shared_ptr<string> supplierCode{};

  InsureOrderDetailRequest() {}

  explicit InsureOrderDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (insOrderId) {
      res["ins_order_id"] = boost::any(*insOrderId);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (supplierCode) {
      res["supplier_code"] = boost::any(*supplierCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("ins_order_id") != m.end() && !m["ins_order_id"].empty()) {
      insOrderId = make_shared<string>(boost::any_cast<string>(m["ins_order_id"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("supplier_code") != m.end() && !m["supplier_code"].empty()) {
      supplierCode = make_shared<string>(boost::any_cast<string>(m["supplier_code"]));
    }
  }


  virtual ~InsureOrderDetailRequest() = default;
};
class InsureOrderDetailResponseBodyModuleApplicant : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> certNo{};
  shared_ptr<string> certType{};
  shared_ptr<string> phone{};

  InsureOrderDetailResponseBodyModuleApplicant() {}

  explicit InsureOrderDetailResponseBodyModuleApplicant(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["cert_name"] = boost::any(*certName);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cert_name") != m.end() && !m["cert_name"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["cert_name"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["cert_type"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
  }


  virtual ~InsureOrderDetailResponseBodyModuleApplicant() = default;
};
class InsureOrderDetailResponseBodyModuleInsureOrderDetailListInsureSegment : public Darabonba::Model {
public:
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depTime{};
  shared_ptr<string> flightNo{};

  InsureOrderDetailResponseBodyModuleInsureOrderDetailListInsureSegment() {}

  explicit InsureOrderDetailResponseBodyModuleInsureOrderDetailListInsureSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
  }


  virtual ~InsureOrderDetailResponseBodyModuleInsureOrderDetailListInsureSegment() = default;
};
class InsureOrderDetailResponseBodyModuleInsureOrderDetailListInsured : public Darabonba::Model {
public:
  shared_ptr<string> birthday{};
  shared_ptr<string> btripUserId{};
  shared_ptr<string> certName{};
  shared_ptr<string> certNo{};
  shared_ptr<string> certType{};
  shared_ptr<string> gender{};
  shared_ptr<string> phone{};

  InsureOrderDetailResponseBodyModuleInsureOrderDetailListInsured() {}

  explicit InsureOrderDetailResponseBodyModuleInsureOrderDetailListInsured(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthday) {
      res["birthday"] = boost::any(*birthday);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (certName) {
      res["cert_name"] = boost::any(*certName);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (gender) {
      res["gender"] = boost::any(*gender);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birthday") != m.end() && !m["birthday"].empty()) {
      birthday = make_shared<string>(boost::any_cast<string>(m["birthday"]));
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("cert_name") != m.end() && !m["cert_name"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["cert_name"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["cert_type"]));
    }
    if (m.find("gender") != m.end() && !m["gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["gender"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
  }


  virtual ~InsureOrderDetailResponseBodyModuleInsureOrderDetailListInsured() = default;
};
class InsureOrderDetailResponseBodyModuleInsureOrderDetailList : public Darabonba::Model {
public:
  shared_ptr<string> effectiveEndTime{};
  shared_ptr<string> effectiveStartTime{};
  shared_ptr<InsureOrderDetailResponseBodyModuleInsureOrderDetailListInsureSegment> insureSegment{};
  shared_ptr<string> insureTime{};
  shared_ptr<InsureOrderDetailResponseBodyModuleInsureOrderDetailListInsured> insured{};
  shared_ptr<string> outSubInsOrderId{};
  shared_ptr<string> policyNo{};
  shared_ptr<long> price{};
  shared_ptr<string> productName{};
  shared_ptr<string> productNo{};
  shared_ptr<string> status{};
  shared_ptr<string> subInsOrderId{};

  InsureOrderDetailResponseBodyModuleInsureOrderDetailList() {}

  explicit InsureOrderDetailResponseBodyModuleInsureOrderDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectiveEndTime) {
      res["effective_end_time"] = boost::any(*effectiveEndTime);
    }
    if (effectiveStartTime) {
      res["effective_start_time"] = boost::any(*effectiveStartTime);
    }
    if (insureSegment) {
      res["insure_segment"] = insureSegment ? boost::any(insureSegment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (insureTime) {
      res["insure_time"] = boost::any(*insureTime);
    }
    if (insured) {
      res["insured"] = insured ? boost::any(insured->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outSubInsOrderId) {
      res["out_sub_ins_order_id"] = boost::any(*outSubInsOrderId);
    }
    if (policyNo) {
      res["policy_no"] = boost::any(*policyNo);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (productName) {
      res["product_name"] = boost::any(*productName);
    }
    if (productNo) {
      res["product_no"] = boost::any(*productNo);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subInsOrderId) {
      res["sub_ins_order_id"] = boost::any(*subInsOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("effective_end_time") != m.end() && !m["effective_end_time"].empty()) {
      effectiveEndTime = make_shared<string>(boost::any_cast<string>(m["effective_end_time"]));
    }
    if (m.find("effective_start_time") != m.end() && !m["effective_start_time"].empty()) {
      effectiveStartTime = make_shared<string>(boost::any_cast<string>(m["effective_start_time"]));
    }
    if (m.find("insure_segment") != m.end() && !m["insure_segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["insure_segment"].type()) {
        InsureOrderDetailResponseBodyModuleInsureOrderDetailListInsureSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["insure_segment"]));
        insureSegment = make_shared<InsureOrderDetailResponseBodyModuleInsureOrderDetailListInsureSegment>(model1);
      }
    }
    if (m.find("insure_time") != m.end() && !m["insure_time"].empty()) {
      insureTime = make_shared<string>(boost::any_cast<string>(m["insure_time"]));
    }
    if (m.find("insured") != m.end() && !m["insured"].empty()) {
      if (typeid(map<string, boost::any>) == m["insured"].type()) {
        InsureOrderDetailResponseBodyModuleInsureOrderDetailListInsured model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["insured"]));
        insured = make_shared<InsureOrderDetailResponseBodyModuleInsureOrderDetailListInsured>(model1);
      }
    }
    if (m.find("out_sub_ins_order_id") != m.end() && !m["out_sub_ins_order_id"].empty()) {
      outSubInsOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_ins_order_id"]));
    }
    if (m.find("policy_no") != m.end() && !m["policy_no"].empty()) {
      policyNo = make_shared<string>(boost::any_cast<string>(m["policy_no"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("product_name") != m.end() && !m["product_name"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["product_name"]));
    }
    if (m.find("product_no") != m.end() && !m["product_no"].empty()) {
      productNo = make_shared<string>(boost::any_cast<string>(m["product_no"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("sub_ins_order_id") != m.end() && !m["sub_ins_order_id"].empty()) {
      subInsOrderId = make_shared<string>(boost::any_cast<string>(m["sub_ins_order_id"]));
    }
  }


  virtual ~InsureOrderDetailResponseBodyModuleInsureOrderDetailList() = default;
};
class InsureOrderDetailResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<InsureOrderDetailResponseBodyModuleApplicant> applicant{};
  shared_ptr<string> insOrderId{};
  shared_ptr<vector<InsureOrderDetailResponseBodyModuleInsureOrderDetailList>> insureOrderDetailList{};
  shared_ptr<string> status{};

  InsureOrderDetailResponseBodyModule() {}

  explicit InsureOrderDetailResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicant) {
      res["applicant"] = applicant ? boost::any(applicant->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (insOrderId) {
      res["ins_order_id"] = boost::any(*insOrderId);
    }
    if (insureOrderDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*insureOrderDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["insure_order_detail_list"] = boost::any(temp1);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("applicant") != m.end() && !m["applicant"].empty()) {
      if (typeid(map<string, boost::any>) == m["applicant"].type()) {
        InsureOrderDetailResponseBodyModuleApplicant model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["applicant"]));
        applicant = make_shared<InsureOrderDetailResponseBodyModuleApplicant>(model1);
      }
    }
    if (m.find("ins_order_id") != m.end() && !m["ins_order_id"].empty()) {
      insOrderId = make_shared<string>(boost::any_cast<string>(m["ins_order_id"]));
    }
    if (m.find("insure_order_detail_list") != m.end() && !m["insure_order_detail_list"].empty()) {
      if (typeid(vector<boost::any>) == m["insure_order_detail_list"].type()) {
        vector<InsureOrderDetailResponseBodyModuleInsureOrderDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["insure_order_detail_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsureOrderDetailResponseBodyModuleInsureOrderDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        insureOrderDetailList = make_shared<vector<InsureOrderDetailResponseBodyModuleInsureOrderDetailList>>(expect1);
      }
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~InsureOrderDetailResponseBodyModule() = default;
};
class InsureOrderDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<InsureOrderDetailResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InsureOrderDetailResponseBody() {}

  explicit InsureOrderDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        InsureOrderDetailResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<InsureOrderDetailResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InsureOrderDetailResponseBody() = default;
};
class InsureOrderDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsureOrderDetailResponseBody> body{};

  InsureOrderDetailResponse() {}

  explicit InsureOrderDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsureOrderDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsureOrderDetailResponseBody>(model1);
      }
    }
  }


  virtual ~InsureOrderDetailResponse() = default;
};
class InsureOrderPayHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  InsureOrderPayHeaders() {}

  explicit InsureOrderPayHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~InsureOrderPayHeaders() = default;
};
class InsureOrderPayRequest : public Darabonba::Model {
public:
  shared_ptr<string> btripUserId{};
  shared_ptr<string> buyerName{};
  shared_ptr<string> isvName{};
  shared_ptr<string> outOrderId{};
  shared_ptr<string> outSubOrderId{};
  shared_ptr<long> paymentAmount{};
  shared_ptr<string> supplierCode{};

  InsureOrderPayRequest() {}

  explicit InsureOrderPayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (outOrderId) {
      res["out_order_id"] = boost::any(*outOrderId);
    }
    if (outSubOrderId) {
      res["out_sub_order_id"] = boost::any(*outSubOrderId);
    }
    if (paymentAmount) {
      res["payment_amount"] = boost::any(*paymentAmount);
    }
    if (supplierCode) {
      res["supplier_code"] = boost::any(*supplierCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("out_order_id") != m.end() && !m["out_order_id"].empty()) {
      outOrderId = make_shared<string>(boost::any_cast<string>(m["out_order_id"]));
    }
    if (m.find("out_sub_order_id") != m.end() && !m["out_sub_order_id"].empty()) {
      outSubOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_order_id"]));
    }
    if (m.find("payment_amount") != m.end() && !m["payment_amount"].empty()) {
      paymentAmount = make_shared<long>(boost::any_cast<long>(m["payment_amount"]));
    }
    if (m.find("supplier_code") != m.end() && !m["supplier_code"].empty()) {
      supplierCode = make_shared<string>(boost::any_cast<string>(m["supplier_code"]));
    }
  }


  virtual ~InsureOrderPayRequest() = default;
};
class InsureOrderPayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InsureOrderPayResponseBody() {}

  explicit InsureOrderPayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InsureOrderPayResponseBody() = default;
};
class InsureOrderPayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsureOrderPayResponseBody> body{};

  InsureOrderPayResponse() {}

  explicit InsureOrderPayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsureOrderPayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsureOrderPayResponseBody>(model1);
      }
    }
  }


  virtual ~InsureOrderPayResponse() = default;
};
class InsureOrderRefundHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  InsureOrderRefundHeaders() {}

  explicit InsureOrderRefundHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~InsureOrderRefundHeaders() = default;
};
class InsureOrderRefundRequest : public Darabonba::Model {
public:
  shared_ptr<string> btripUserId{};
  shared_ptr<string> buyerName{};
  shared_ptr<string> isvName{};
  shared_ptr<string> outApplyId{};
  shared_ptr<vector<string>> policyNoList{};
  shared_ptr<vector<string>> subInsOrderIds{};
  shared_ptr<string> supplierCode{};

  InsureOrderRefundRequest() {}

  explicit InsureOrderRefundRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (outApplyId) {
      res["out_apply_id"] = boost::any(*outApplyId);
    }
    if (policyNoList) {
      res["policy_no_list"] = boost::any(*policyNoList);
    }
    if (subInsOrderIds) {
      res["sub_ins_order_ids"] = boost::any(*subInsOrderIds);
    }
    if (supplierCode) {
      res["supplier_code"] = boost::any(*supplierCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("out_apply_id") != m.end() && !m["out_apply_id"].empty()) {
      outApplyId = make_shared<string>(boost::any_cast<string>(m["out_apply_id"]));
    }
    if (m.find("policy_no_list") != m.end() && !m["policy_no_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["policy_no_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["policy_no_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyNoList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("sub_ins_order_ids") != m.end() && !m["sub_ins_order_ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["sub_ins_order_ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["sub_ins_order_ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subInsOrderIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("supplier_code") != m.end() && !m["supplier_code"].empty()) {
      supplierCode = make_shared<string>(boost::any_cast<string>(m["supplier_code"]));
    }
  }


  virtual ~InsureOrderRefundRequest() = default;
};
class InsureOrderRefundShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> btripUserId{};
  shared_ptr<string> buyerName{};
  shared_ptr<string> isvName{};
  shared_ptr<string> outApplyId{};
  shared_ptr<string> policyNoListShrink{};
  shared_ptr<string> subInsOrderIdsShrink{};
  shared_ptr<string> supplierCode{};

  InsureOrderRefundShrinkRequest() {}

  explicit InsureOrderRefundShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (outApplyId) {
      res["out_apply_id"] = boost::any(*outApplyId);
    }
    if (policyNoListShrink) {
      res["policy_no_list"] = boost::any(*policyNoListShrink);
    }
    if (subInsOrderIdsShrink) {
      res["sub_ins_order_ids"] = boost::any(*subInsOrderIdsShrink);
    }
    if (supplierCode) {
      res["supplier_code"] = boost::any(*supplierCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("out_apply_id") != m.end() && !m["out_apply_id"].empty()) {
      outApplyId = make_shared<string>(boost::any_cast<string>(m["out_apply_id"]));
    }
    if (m.find("policy_no_list") != m.end() && !m["policy_no_list"].empty()) {
      policyNoListShrink = make_shared<string>(boost::any_cast<string>(m["policy_no_list"]));
    }
    if (m.find("sub_ins_order_ids") != m.end() && !m["sub_ins_order_ids"].empty()) {
      subInsOrderIdsShrink = make_shared<string>(boost::any_cast<string>(m["sub_ins_order_ids"]));
    }
    if (m.find("supplier_code") != m.end() && !m["supplier_code"].empty()) {
      supplierCode = make_shared<string>(boost::any_cast<string>(m["supplier_code"]));
    }
  }


  virtual ~InsureOrderRefundShrinkRequest() = default;
};
class InsureOrderRefundResponseBodyModuleInsRefundList : public Darabonba::Model {
public:
  shared_ptr<string> policyRefundNo{};
  shared_ptr<string> refundStatus{};
  shared_ptr<string> subInsOrderId{};

  InsureOrderRefundResponseBodyModuleInsRefundList() {}

  explicit InsureOrderRefundResponseBodyModuleInsRefundList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyRefundNo) {
      res["policy_refund_no"] = boost::any(*policyRefundNo);
    }
    if (refundStatus) {
      res["refund_status"] = boost::any(*refundStatus);
    }
    if (subInsOrderId) {
      res["sub_ins_order_id"] = boost::any(*subInsOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("policy_refund_no") != m.end() && !m["policy_refund_no"].empty()) {
      policyRefundNo = make_shared<string>(boost::any_cast<string>(m["policy_refund_no"]));
    }
    if (m.find("refund_status") != m.end() && !m["refund_status"].empty()) {
      refundStatus = make_shared<string>(boost::any_cast<string>(m["refund_status"]));
    }
    if (m.find("sub_ins_order_id") != m.end() && !m["sub_ins_order_id"].empty()) {
      subInsOrderId = make_shared<string>(boost::any_cast<string>(m["sub_ins_order_id"]));
    }
  }


  virtual ~InsureOrderRefundResponseBodyModuleInsRefundList() = default;
};
class InsureOrderRefundResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> insOrderId{};
  shared_ptr<vector<InsureOrderRefundResponseBodyModuleInsRefundList>> insRefundList{};
  shared_ptr<string> outApplyId{};

  InsureOrderRefundResponseBodyModule() {}

  explicit InsureOrderRefundResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (insOrderId) {
      res["ins_order_id"] = boost::any(*insOrderId);
    }
    if (insRefundList) {
      vector<boost::any> temp1;
      for(auto item1:*insRefundList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ins_refund_list"] = boost::any(temp1);
    }
    if (outApplyId) {
      res["out_apply_id"] = boost::any(*outApplyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("ins_order_id") != m.end() && !m["ins_order_id"].empty()) {
      insOrderId = make_shared<string>(boost::any_cast<string>(m["ins_order_id"]));
    }
    if (m.find("ins_refund_list") != m.end() && !m["ins_refund_list"].empty()) {
      if (typeid(vector<boost::any>) == m["ins_refund_list"].type()) {
        vector<InsureOrderRefundResponseBodyModuleInsRefundList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ins_refund_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsureOrderRefundResponseBodyModuleInsRefundList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        insRefundList = make_shared<vector<InsureOrderRefundResponseBodyModuleInsRefundList>>(expect1);
      }
    }
    if (m.find("out_apply_id") != m.end() && !m["out_apply_id"].empty()) {
      outApplyId = make_shared<string>(boost::any_cast<string>(m["out_apply_id"]));
    }
  }


  virtual ~InsureOrderRefundResponseBodyModule() = default;
};
class InsureOrderRefundResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<InsureOrderRefundResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InsureOrderRefundResponseBody() {}

  explicit InsureOrderRefundResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        InsureOrderRefundResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<InsureOrderRefundResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InsureOrderRefundResponseBody() = default;
};
class InsureOrderRefundResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsureOrderRefundResponseBody> body{};

  InsureOrderRefundResponse() {}

  explicit InsureOrderRefundResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsureOrderRefundResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsureOrderRefundResponseBody>(model1);
      }
    }
  }


  virtual ~InsureOrderRefundResponse() = default;
};
class InsureOrderUrlDetailHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  InsureOrderUrlDetailHeaders() {}

  explicit InsureOrderUrlDetailHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~InsureOrderUrlDetailHeaders() = default;
};
class InsureOrderUrlDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InsureOrderUrlDetailResponseBody() {}

  explicit InsureOrderUrlDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InsureOrderUrlDetailResponseBody() = default;
};
class InsureOrderUrlDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsureOrderUrlDetailResponseBody> body{};

  InsureOrderUrlDetailResponse() {}

  explicit InsureOrderUrlDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsureOrderUrlDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsureOrderUrlDetailResponseBody>(model1);
      }
    }
  }


  virtual ~InsureOrderUrlDetailResponse() = default;
};
class InsureRefundDetailHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  InsureRefundDetailHeaders() {}

  explicit InsureRefundDetailHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~InsureRefundDetailHeaders() = default;
};
class InsureRefundDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> btripUserId{};
  shared_ptr<string> buyerName{};
  shared_ptr<string> insOrderId{};
  shared_ptr<string> isvName{};
  shared_ptr<string> outApplyId{};
  shared_ptr<string> supplierCode{};

  InsureRefundDetailRequest() {}

  explicit InsureRefundDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (buyerName) {
      res["buyer_name"] = boost::any(*buyerName);
    }
    if (insOrderId) {
      res["ins_order_id"] = boost::any(*insOrderId);
    }
    if (isvName) {
      res["isv_name"] = boost::any(*isvName);
    }
    if (outApplyId) {
      res["out_apply_id"] = boost::any(*outApplyId);
    }
    if (supplierCode) {
      res["supplier_code"] = boost::any(*supplierCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("buyer_name") != m.end() && !m["buyer_name"].empty()) {
      buyerName = make_shared<string>(boost::any_cast<string>(m["buyer_name"]));
    }
    if (m.find("ins_order_id") != m.end() && !m["ins_order_id"].empty()) {
      insOrderId = make_shared<string>(boost::any_cast<string>(m["ins_order_id"]));
    }
    if (m.find("isv_name") != m.end() && !m["isv_name"].empty()) {
      isvName = make_shared<string>(boost::any_cast<string>(m["isv_name"]));
    }
    if (m.find("out_apply_id") != m.end() && !m["out_apply_id"].empty()) {
      outApplyId = make_shared<string>(boost::any_cast<string>(m["out_apply_id"]));
    }
    if (m.find("supplier_code") != m.end() && !m["supplier_code"].empty()) {
      supplierCode = make_shared<string>(boost::any_cast<string>(m["supplier_code"]));
    }
  }


  virtual ~InsureRefundDetailRequest() = default;
};
class InsureRefundDetailResponseBodyModuleInsureOrderApplicant : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> certNo{};
  shared_ptr<string> certType{};
  shared_ptr<string> phone{};

  InsureRefundDetailResponseBodyModuleInsureOrderApplicant() {}

  explicit InsureRefundDetailResponseBodyModuleInsureOrderApplicant(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["cert_name"] = boost::any(*certName);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cert_name") != m.end() && !m["cert_name"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["cert_name"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["cert_type"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
  }


  virtual ~InsureRefundDetailResponseBodyModuleInsureOrderApplicant() = default;
};
class InsureRefundDetailResponseBodyModuleInsureOrder : public Darabonba::Model {
public:
  shared_ptr<InsureRefundDetailResponseBodyModuleInsureOrderApplicant> applicant{};
  shared_ptr<string> bizOrderId{};
  shared_ptr<long> bizType{};
  shared_ptr<string> closeTime{};
  shared_ptr<string> insOrderId{};
  shared_ptr<string> outInsOrderId{};
  shared_ptr<string> payTime{};
  shared_ptr<long> price{};
  shared_ptr<long> settleType{};
  shared_ptr<string> status{};

  InsureRefundDetailResponseBodyModuleInsureOrder() {}

  explicit InsureRefundDetailResponseBodyModuleInsureOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicant) {
      res["applicant"] = applicant ? boost::any(applicant->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizOrderId) {
      res["biz_order_id"] = boost::any(*bizOrderId);
    }
    if (bizType) {
      res["biz_type"] = boost::any(*bizType);
    }
    if (closeTime) {
      res["close_time"] = boost::any(*closeTime);
    }
    if (insOrderId) {
      res["ins_order_id"] = boost::any(*insOrderId);
    }
    if (outInsOrderId) {
      res["out_ins_order_id"] = boost::any(*outInsOrderId);
    }
    if (payTime) {
      res["pay_time"] = boost::any(*payTime);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (settleType) {
      res["settle_type"] = boost::any(*settleType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("applicant") != m.end() && !m["applicant"].empty()) {
      if (typeid(map<string, boost::any>) == m["applicant"].type()) {
        InsureRefundDetailResponseBodyModuleInsureOrderApplicant model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["applicant"]));
        applicant = make_shared<InsureRefundDetailResponseBodyModuleInsureOrderApplicant>(model1);
      }
    }
    if (m.find("biz_order_id") != m.end() && !m["biz_order_id"].empty()) {
      bizOrderId = make_shared<string>(boost::any_cast<string>(m["biz_order_id"]));
    }
    if (m.find("biz_type") != m.end() && !m["biz_type"].empty()) {
      bizType = make_shared<long>(boost::any_cast<long>(m["biz_type"]));
    }
    if (m.find("close_time") != m.end() && !m["close_time"].empty()) {
      closeTime = make_shared<string>(boost::any_cast<string>(m["close_time"]));
    }
    if (m.find("ins_order_id") != m.end() && !m["ins_order_id"].empty()) {
      insOrderId = make_shared<string>(boost::any_cast<string>(m["ins_order_id"]));
    }
    if (m.find("out_ins_order_id") != m.end() && !m["out_ins_order_id"].empty()) {
      outInsOrderId = make_shared<string>(boost::any_cast<string>(m["out_ins_order_id"]));
    }
    if (m.find("pay_time") != m.end() && !m["pay_time"].empty()) {
      payTime = make_shared<string>(boost::any_cast<string>(m["pay_time"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("settle_type") != m.end() && !m["settle_type"].empty()) {
      settleType = make_shared<long>(boost::any_cast<long>(m["settle_type"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~InsureRefundDetailResponseBodyModuleInsureOrder() = default;
};
class InsureRefundDetailResponseBodyModuleSubOrderRefundListInsureSegment : public Darabonba::Model {
public:
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depTime{};
  shared_ptr<string> flightNo{};

  InsureRefundDetailResponseBodyModuleSubOrderRefundListInsureSegment() {}

  explicit InsureRefundDetailResponseBodyModuleSubOrderRefundListInsureSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
  }


  virtual ~InsureRefundDetailResponseBodyModuleSubOrderRefundListInsureSegment() = default;
};
class InsureRefundDetailResponseBodyModuleSubOrderRefundListInsured : public Darabonba::Model {
public:
  shared_ptr<string> birthday{};
  shared_ptr<string> btripUserId{};
  shared_ptr<string> certName{};
  shared_ptr<string> certNo{};
  shared_ptr<string> certType{};
  shared_ptr<string> gender{};
  shared_ptr<string> phone{};

  InsureRefundDetailResponseBodyModuleSubOrderRefundListInsured() {}

  explicit InsureRefundDetailResponseBodyModuleSubOrderRefundListInsured(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthday) {
      res["birthday"] = boost::any(*birthday);
    }
    if (btripUserId) {
      res["btrip_user_id"] = boost::any(*btripUserId);
    }
    if (certName) {
      res["cert_name"] = boost::any(*certName);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (gender) {
      res["gender"] = boost::any(*gender);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birthday") != m.end() && !m["birthday"].empty()) {
      birthday = make_shared<string>(boost::any_cast<string>(m["birthday"]));
    }
    if (m.find("btrip_user_id") != m.end() && !m["btrip_user_id"].empty()) {
      btripUserId = make_shared<string>(boost::any_cast<string>(m["btrip_user_id"]));
    }
    if (m.find("cert_name") != m.end() && !m["cert_name"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["cert_name"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["cert_type"]));
    }
    if (m.find("gender") != m.end() && !m["gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["gender"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
  }


  virtual ~InsureRefundDetailResponseBodyModuleSubOrderRefundListInsured() = default;
};
class InsureRefundDetailResponseBodyModuleSubOrderRefundList : public Darabonba::Model {
public:
  shared_ptr<string> effectiveEndTime{};
  shared_ptr<string> effectiveStartTime{};
  shared_ptr<InsureRefundDetailResponseBodyModuleSubOrderRefundListInsureSegment> insureSegment{};
  shared_ptr<string> insureTime{};
  shared_ptr<InsureRefundDetailResponseBodyModuleSubOrderRefundListInsured> insured{};
  shared_ptr<string> outSubInsOrderId{};
  shared_ptr<string> policyNo{};
  shared_ptr<string> policyRefundNo{};
  shared_ptr<long> price{};
  shared_ptr<string> productName{};
  shared_ptr<string> productNo{};
  shared_ptr<string> refundStatus{};
  shared_ptr<string> refundTime{};
  shared_ptr<string> status{};
  shared_ptr<string> subInsOrderId{};

  InsureRefundDetailResponseBodyModuleSubOrderRefundList() {}

  explicit InsureRefundDetailResponseBodyModuleSubOrderRefundList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectiveEndTime) {
      res["effective_end_time"] = boost::any(*effectiveEndTime);
    }
    if (effectiveStartTime) {
      res["effective_start_time"] = boost::any(*effectiveStartTime);
    }
    if (insureSegment) {
      res["insure_segment"] = insureSegment ? boost::any(insureSegment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (insureTime) {
      res["insure_time"] = boost::any(*insureTime);
    }
    if (insured) {
      res["insured"] = insured ? boost::any(insured->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outSubInsOrderId) {
      res["out_sub_ins_order_id"] = boost::any(*outSubInsOrderId);
    }
    if (policyNo) {
      res["policy_no"] = boost::any(*policyNo);
    }
    if (policyRefundNo) {
      res["policy_refund_no"] = boost::any(*policyRefundNo);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (productName) {
      res["product_name"] = boost::any(*productName);
    }
    if (productNo) {
      res["product_no"] = boost::any(*productNo);
    }
    if (refundStatus) {
      res["refund_status"] = boost::any(*refundStatus);
    }
    if (refundTime) {
      res["refund_time"] = boost::any(*refundTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subInsOrderId) {
      res["sub_ins_order_id"] = boost::any(*subInsOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("effective_end_time") != m.end() && !m["effective_end_time"].empty()) {
      effectiveEndTime = make_shared<string>(boost::any_cast<string>(m["effective_end_time"]));
    }
    if (m.find("effective_start_time") != m.end() && !m["effective_start_time"].empty()) {
      effectiveStartTime = make_shared<string>(boost::any_cast<string>(m["effective_start_time"]));
    }
    if (m.find("insure_segment") != m.end() && !m["insure_segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["insure_segment"].type()) {
        InsureRefundDetailResponseBodyModuleSubOrderRefundListInsureSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["insure_segment"]));
        insureSegment = make_shared<InsureRefundDetailResponseBodyModuleSubOrderRefundListInsureSegment>(model1);
      }
    }
    if (m.find("insure_time") != m.end() && !m["insure_time"].empty()) {
      insureTime = make_shared<string>(boost::any_cast<string>(m["insure_time"]));
    }
    if (m.find("insured") != m.end() && !m["insured"].empty()) {
      if (typeid(map<string, boost::any>) == m["insured"].type()) {
        InsureRefundDetailResponseBodyModuleSubOrderRefundListInsured model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["insured"]));
        insured = make_shared<InsureRefundDetailResponseBodyModuleSubOrderRefundListInsured>(model1);
      }
    }
    if (m.find("out_sub_ins_order_id") != m.end() && !m["out_sub_ins_order_id"].empty()) {
      outSubInsOrderId = make_shared<string>(boost::any_cast<string>(m["out_sub_ins_order_id"]));
    }
    if (m.find("policy_no") != m.end() && !m["policy_no"].empty()) {
      policyNo = make_shared<string>(boost::any_cast<string>(m["policy_no"]));
    }
    if (m.find("policy_refund_no") != m.end() && !m["policy_refund_no"].empty()) {
      policyRefundNo = make_shared<string>(boost::any_cast<string>(m["policy_refund_no"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("product_name") != m.end() && !m["product_name"].empty()) {
      productName = make_shared<string>(boost::any_cast<string>(m["product_name"]));
    }
    if (m.find("product_no") != m.end() && !m["product_no"].empty()) {
      productNo = make_shared<string>(boost::any_cast<string>(m["product_no"]));
    }
    if (m.find("refund_status") != m.end() && !m["refund_status"].empty()) {
      refundStatus = make_shared<string>(boost::any_cast<string>(m["refund_status"]));
    }
    if (m.find("refund_time") != m.end() && !m["refund_time"].empty()) {
      refundTime = make_shared<string>(boost::any_cast<string>(m["refund_time"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("sub_ins_order_id") != m.end() && !m["sub_ins_order_id"].empty()) {
      subInsOrderId = make_shared<string>(boost::any_cast<string>(m["sub_ins_order_id"]));
    }
  }


  virtual ~InsureRefundDetailResponseBodyModuleSubOrderRefundList() = default;
};
class InsureRefundDetailResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> insOrderId{};
  shared_ptr<InsureRefundDetailResponseBodyModuleInsureOrder> insureOrder{};
  shared_ptr<string> outApplyId{};
  shared_ptr<vector<InsureRefundDetailResponseBodyModuleSubOrderRefundList>> subOrderRefundList{};

  InsureRefundDetailResponseBodyModule() {}

  explicit InsureRefundDetailResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (insOrderId) {
      res["ins_order_id"] = boost::any(*insOrderId);
    }
    if (insureOrder) {
      res["insure_order"] = insureOrder ? boost::any(insureOrder->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outApplyId) {
      res["out_apply_id"] = boost::any(*outApplyId);
    }
    if (subOrderRefundList) {
      vector<boost::any> temp1;
      for(auto item1:*subOrderRefundList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["sub_order_refund_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("ins_order_id") != m.end() && !m["ins_order_id"].empty()) {
      insOrderId = make_shared<string>(boost::any_cast<string>(m["ins_order_id"]));
    }
    if (m.find("insure_order") != m.end() && !m["insure_order"].empty()) {
      if (typeid(map<string, boost::any>) == m["insure_order"].type()) {
        InsureRefundDetailResponseBodyModuleInsureOrder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["insure_order"]));
        insureOrder = make_shared<InsureRefundDetailResponseBodyModuleInsureOrder>(model1);
      }
    }
    if (m.find("out_apply_id") != m.end() && !m["out_apply_id"].empty()) {
      outApplyId = make_shared<string>(boost::any_cast<string>(m["out_apply_id"]));
    }
    if (m.find("sub_order_refund_list") != m.end() && !m["sub_order_refund_list"].empty()) {
      if (typeid(vector<boost::any>) == m["sub_order_refund_list"].type()) {
        vector<InsureRefundDetailResponseBodyModuleSubOrderRefundList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["sub_order_refund_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsureRefundDetailResponseBodyModuleSubOrderRefundList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subOrderRefundList = make_shared<vector<InsureRefundDetailResponseBodyModuleSubOrderRefundList>>(expect1);
      }
    }
  }


  virtual ~InsureRefundDetailResponseBodyModule() = default;
};
class InsureRefundDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<InsureRefundDetailResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InsureRefundDetailResponseBody() {}

  explicit InsureRefundDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        InsureRefundDetailResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<InsureRefundDetailResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InsureRefundDetailResponseBody() = default;
};
class InsureRefundDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsureRefundDetailResponseBody> body{};

  InsureRefundDetailResponse() {}

  explicit InsureRefundDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsureRefundDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsureRefundDetailResponseBody>(model1);
      }
    }
  }


  virtual ~InsureRefundDetailResponse() = default;
};
class InvoiceAddHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  InvoiceAddHeaders() {}

  explicit InvoiceAddHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~InvoiceAddHeaders() = default;
};
class InvoiceAddRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> bankName{};
  shared_ptr<string> bankNo{};
  shared_ptr<string> taxNo{};
  shared_ptr<string> tel{};
  shared_ptr<string> thirdPartId{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};
  shared_ptr<long> unitType{};

  InvoiceAddRequest() {}

  explicit InvoiceAddRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["address"] = boost::any(*address);
    }
    if (bankName) {
      res["bank_name"] = boost::any(*bankName);
    }
    if (bankNo) {
      res["bank_no"] = boost::any(*bankNo);
    }
    if (taxNo) {
      res["tax_no"] = boost::any(*taxNo);
    }
    if (tel) {
      res["tel"] = boost::any(*tel);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (unitType) {
      res["unit_type"] = boost::any(*unitType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("address") != m.end() && !m["address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["address"]));
    }
    if (m.find("bank_name") != m.end() && !m["bank_name"].empty()) {
      bankName = make_shared<string>(boost::any_cast<string>(m["bank_name"]));
    }
    if (m.find("bank_no") != m.end() && !m["bank_no"].empty()) {
      bankNo = make_shared<string>(boost::any_cast<string>(m["bank_no"]));
    }
    if (m.find("tax_no") != m.end() && !m["tax_no"].empty()) {
      taxNo = make_shared<string>(boost::any_cast<string>(m["tax_no"]));
    }
    if (m.find("tel") != m.end() && !m["tel"].empty()) {
      tel = make_shared<string>(boost::any_cast<string>(m["tel"]));
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("unit_type") != m.end() && !m["unit_type"].empty()) {
      unitType = make_shared<long>(boost::any_cast<long>(m["unit_type"]));
    }
  }


  virtual ~InvoiceAddRequest() = default;
};
class InvoiceAddResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InvoiceAddResponseBody() {}

  explicit InvoiceAddResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InvoiceAddResponseBody() = default;
};
class InvoiceAddResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvoiceAddResponseBody> body{};

  InvoiceAddResponse() {}

  explicit InvoiceAddResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvoiceAddResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvoiceAddResponseBody>(model1);
      }
    }
  }


  virtual ~InvoiceAddResponse() = default;
};
class InvoiceDeleteHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  InvoiceDeleteHeaders() {}

  explicit InvoiceDeleteHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~InvoiceDeleteHeaders() = default;
};
class InvoiceDeleteRequest : public Darabonba::Model {
public:
  shared_ptr<string> thirdPartId{};

  InvoiceDeleteRequest() {}

  explicit InvoiceDeleteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~InvoiceDeleteRequest() = default;
};
class InvoiceDeleteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InvoiceDeleteResponseBody() {}

  explicit InvoiceDeleteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InvoiceDeleteResponseBody() = default;
};
class InvoiceDeleteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvoiceDeleteResponseBody> body{};

  InvoiceDeleteResponse() {}

  explicit InvoiceDeleteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvoiceDeleteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvoiceDeleteResponseBody>(model1);
      }
    }
  }


  virtual ~InvoiceDeleteResponse() = default;
};
class InvoiceModifyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  InvoiceModifyHeaders() {}

  explicit InvoiceModifyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~InvoiceModifyHeaders() = default;
};
class InvoiceModifyRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> bankName{};
  shared_ptr<string> bankNo{};
  shared_ptr<string> taxNo{};
  shared_ptr<string> tel{};
  shared_ptr<string> thirdPartId{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};
  shared_ptr<long> unitType{};

  InvoiceModifyRequest() {}

  explicit InvoiceModifyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["address"] = boost::any(*address);
    }
    if (bankName) {
      res["bank_name"] = boost::any(*bankName);
    }
    if (bankNo) {
      res["bank_no"] = boost::any(*bankNo);
    }
    if (taxNo) {
      res["tax_no"] = boost::any(*taxNo);
    }
    if (tel) {
      res["tel"] = boost::any(*tel);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (unitType) {
      res["unit_type"] = boost::any(*unitType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("address") != m.end() && !m["address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["address"]));
    }
    if (m.find("bank_name") != m.end() && !m["bank_name"].empty()) {
      bankName = make_shared<string>(boost::any_cast<string>(m["bank_name"]));
    }
    if (m.find("bank_no") != m.end() && !m["bank_no"].empty()) {
      bankNo = make_shared<string>(boost::any_cast<string>(m["bank_no"]));
    }
    if (m.find("tax_no") != m.end() && !m["tax_no"].empty()) {
      taxNo = make_shared<string>(boost::any_cast<string>(m["tax_no"]));
    }
    if (m.find("tel") != m.end() && !m["tel"].empty()) {
      tel = make_shared<string>(boost::any_cast<string>(m["tel"]));
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
    if (m.find("unit_type") != m.end() && !m["unit_type"].empty()) {
      unitType = make_shared<long>(boost::any_cast<long>(m["unit_type"]));
    }
  }


  virtual ~InvoiceModifyRequest() = default;
};
class InvoiceModifyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InvoiceModifyResponseBody() {}

  explicit InvoiceModifyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InvoiceModifyResponseBody() = default;
};
class InvoiceModifyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvoiceModifyResponseBody> body{};

  InvoiceModifyResponse() {}

  explicit InvoiceModifyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvoiceModifyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvoiceModifyResponseBody>(model1);
      }
    }
  }


  virtual ~InvoiceModifyResponse() = default;
};
class InvoiceRuleAddHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  InvoiceRuleAddHeaders() {}

  explicit InvoiceRuleAddHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~InvoiceRuleAddHeaders() = default;
};
class InvoiceRuleAddRequestEntities : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> entityName{};
  shared_ptr<string> entityType{};

  InvoiceRuleAddRequestEntities() {}

  explicit InvoiceRuleAddRequestEntities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["entity_id"] = boost::any(*entityId);
    }
    if (entityName) {
      res["entity_name"] = boost::any(*entityName);
    }
    if (entityType) {
      res["entity_type"] = boost::any(*entityType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_id") != m.end() && !m["entity_id"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["entity_id"]));
    }
    if (m.find("entity_name") != m.end() && !m["entity_name"].empty()) {
      entityName = make_shared<string>(boost::any_cast<string>(m["entity_name"]));
    }
    if (m.find("entity_type") != m.end() && !m["entity_type"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["entity_type"]));
    }
  }


  virtual ~InvoiceRuleAddRequestEntities() = default;
};
class InvoiceRuleAddRequest : public Darabonba::Model {
public:
  shared_ptr<vector<InvoiceRuleAddRequestEntities>> entities{};
  shared_ptr<string> thirdPartId{};

  InvoiceRuleAddRequest() {}

  explicit InvoiceRuleAddRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entities) {
      vector<boost::any> temp1;
      for(auto item1:*entities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entities"] = boost::any(temp1);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entities") != m.end() && !m["entities"].empty()) {
      if (typeid(vector<boost::any>) == m["entities"].type()) {
        vector<InvoiceRuleAddRequestEntities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvoiceRuleAddRequestEntities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entities = make_shared<vector<InvoiceRuleAddRequestEntities>>(expect1);
      }
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~InvoiceRuleAddRequest() = default;
};
class InvoiceRuleAddShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> entitiesShrink{};
  shared_ptr<string> thirdPartId{};

  InvoiceRuleAddShrinkRequest() {}

  explicit InvoiceRuleAddShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entitiesShrink) {
      res["entities"] = boost::any(*entitiesShrink);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entities") != m.end() && !m["entities"].empty()) {
      entitiesShrink = make_shared<string>(boost::any_cast<string>(m["entities"]));
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~InvoiceRuleAddShrinkRequest() = default;
};
class InvoiceRuleAddResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> addNum{};
  shared_ptr<long> selectedUserNum{};

  InvoiceRuleAddResponseBodyModule() {}

  explicit InvoiceRuleAddResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addNum) {
      res["add_num"] = boost::any(*addNum);
    }
    if (selectedUserNum) {
      res["selected_user_num"] = boost::any(*selectedUserNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("add_num") != m.end() && !m["add_num"].empty()) {
      addNum = make_shared<long>(boost::any_cast<long>(m["add_num"]));
    }
    if (m.find("selected_user_num") != m.end() && !m["selected_user_num"].empty()) {
      selectedUserNum = make_shared<long>(boost::any_cast<long>(m["selected_user_num"]));
    }
  }


  virtual ~InvoiceRuleAddResponseBodyModule() = default;
};
class InvoiceRuleAddResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<InvoiceRuleAddResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InvoiceRuleAddResponseBody() {}

  explicit InvoiceRuleAddResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        InvoiceRuleAddResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<InvoiceRuleAddResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InvoiceRuleAddResponseBody() = default;
};
class InvoiceRuleAddResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvoiceRuleAddResponseBody> body{};

  InvoiceRuleAddResponse() {}

  explicit InvoiceRuleAddResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvoiceRuleAddResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvoiceRuleAddResponseBody>(model1);
      }
    }
  }


  virtual ~InvoiceRuleAddResponse() = default;
};
class InvoiceRuleDeleteHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  InvoiceRuleDeleteHeaders() {}

  explicit InvoiceRuleDeleteHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~InvoiceRuleDeleteHeaders() = default;
};
class InvoiceRuleDeleteRequestEntities : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> entityType{};

  InvoiceRuleDeleteRequestEntities() {}

  explicit InvoiceRuleDeleteRequestEntities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["entity_id"] = boost::any(*entityId);
    }
    if (entityType) {
      res["entity_type"] = boost::any(*entityType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_id") != m.end() && !m["entity_id"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["entity_id"]));
    }
    if (m.find("entity_type") != m.end() && !m["entity_type"].empty()) {
      entityType = make_shared<string>(boost::any_cast<string>(m["entity_type"]));
    }
  }


  virtual ~InvoiceRuleDeleteRequestEntities() = default;
};
class InvoiceRuleDeleteRequest : public Darabonba::Model {
public:
  shared_ptr<bool> delAll{};
  shared_ptr<vector<InvoiceRuleDeleteRequestEntities>> entities{};
  shared_ptr<string> thirdPartId{};

  InvoiceRuleDeleteRequest() {}

  explicit InvoiceRuleDeleteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delAll) {
      res["del_all"] = boost::any(*delAll);
    }
    if (entities) {
      vector<boost::any> temp1;
      for(auto item1:*entities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entities"] = boost::any(temp1);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("del_all") != m.end() && !m["del_all"].empty()) {
      delAll = make_shared<bool>(boost::any_cast<bool>(m["del_all"]));
    }
    if (m.find("entities") != m.end() && !m["entities"].empty()) {
      if (typeid(vector<boost::any>) == m["entities"].type()) {
        vector<InvoiceRuleDeleteRequestEntities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvoiceRuleDeleteRequestEntities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entities = make_shared<vector<InvoiceRuleDeleteRequestEntities>>(expect1);
      }
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~InvoiceRuleDeleteRequest() = default;
};
class InvoiceRuleDeleteShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> delAll{};
  shared_ptr<string> entitiesShrink{};
  shared_ptr<string> thirdPartId{};

  InvoiceRuleDeleteShrinkRequest() {}

  explicit InvoiceRuleDeleteShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delAll) {
      res["del_all"] = boost::any(*delAll);
    }
    if (entitiesShrink) {
      res["entities"] = boost::any(*entitiesShrink);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("del_all") != m.end() && !m["del_all"].empty()) {
      delAll = make_shared<bool>(boost::any_cast<bool>(m["del_all"]));
    }
    if (m.find("entities") != m.end() && !m["entities"].empty()) {
      entitiesShrink = make_shared<string>(boost::any_cast<string>(m["entities"]));
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~InvoiceRuleDeleteShrinkRequest() = default;
};
class InvoiceRuleDeleteResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> removeNum{};
  shared_ptr<long> selectedUserNum{};

  InvoiceRuleDeleteResponseBodyModule() {}

  explicit InvoiceRuleDeleteResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (removeNum) {
      res["remove_num"] = boost::any(*removeNum);
    }
    if (selectedUserNum) {
      res["selected_user_num"] = boost::any(*selectedUserNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("remove_num") != m.end() && !m["remove_num"].empty()) {
      removeNum = make_shared<long>(boost::any_cast<long>(m["remove_num"]));
    }
    if (m.find("selected_user_num") != m.end() && !m["selected_user_num"].empty()) {
      selectedUserNum = make_shared<long>(boost::any_cast<long>(m["selected_user_num"]));
    }
  }


  virtual ~InvoiceRuleDeleteResponseBodyModule() = default;
};
class InvoiceRuleDeleteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<InvoiceRuleDeleteResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InvoiceRuleDeleteResponseBody() {}

  explicit InvoiceRuleDeleteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        InvoiceRuleDeleteResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<InvoiceRuleDeleteResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InvoiceRuleDeleteResponseBody() = default;
};
class InvoiceRuleDeleteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvoiceRuleDeleteResponseBody> body{};

  InvoiceRuleDeleteResponse() {}

  explicit InvoiceRuleDeleteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvoiceRuleDeleteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvoiceRuleDeleteResponseBody>(model1);
      }
    }
  }


  virtual ~InvoiceRuleDeleteResponse() = default;
};
class InvoiceRuleSaveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  InvoiceRuleSaveHeaders() {}

  explicit InvoiceRuleSaveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~InvoiceRuleSaveHeaders() = default;
};
class InvoiceRuleSaveRequestEntities : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> type{};

  InvoiceRuleSaveRequestEntities() {}

  explicit InvoiceRuleSaveRequestEntities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~InvoiceRuleSaveRequestEntities() = default;
};
class InvoiceRuleSaveRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allEmploye{};
  shared_ptr<vector<InvoiceRuleSaveRequestEntities>> entities{};
  shared_ptr<string> thirdPartId{};

  InvoiceRuleSaveRequest() {}

  explicit InvoiceRuleSaveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allEmploye) {
      res["all_employe"] = boost::any(*allEmploye);
    }
    if (entities) {
      vector<boost::any> temp1;
      for(auto item1:*entities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entities"] = boost::any(temp1);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_employe") != m.end() && !m["all_employe"].empty()) {
      allEmploye = make_shared<bool>(boost::any_cast<bool>(m["all_employe"]));
    }
    if (m.find("entities") != m.end() && !m["entities"].empty()) {
      if (typeid(vector<boost::any>) == m["entities"].type()) {
        vector<InvoiceRuleSaveRequestEntities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvoiceRuleSaveRequestEntities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entities = make_shared<vector<InvoiceRuleSaveRequestEntities>>(expect1);
      }
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~InvoiceRuleSaveRequest() = default;
};
class InvoiceRuleSaveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allEmploye{};
  shared_ptr<string> entitiesShrink{};
  shared_ptr<string> thirdPartId{};

  InvoiceRuleSaveShrinkRequest() {}

  explicit InvoiceRuleSaveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allEmploye) {
      res["all_employe"] = boost::any(*allEmploye);
    }
    if (entitiesShrink) {
      res["entities"] = boost::any(*entitiesShrink);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_employe") != m.end() && !m["all_employe"].empty()) {
      allEmploye = make_shared<bool>(boost::any_cast<bool>(m["all_employe"]));
    }
    if (m.find("entities") != m.end() && !m["entities"].empty()) {
      entitiesShrink = make_shared<string>(boost::any_cast<string>(m["entities"]));
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~InvoiceRuleSaveShrinkRequest() = default;
};
class InvoiceRuleSaveResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> addNum{};
  shared_ptr<long> removeNum{};

  InvoiceRuleSaveResponseBodyModule() {}

  explicit InvoiceRuleSaveResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addNum) {
      res["add_num"] = boost::any(*addNum);
    }
    if (removeNum) {
      res["remove_num"] = boost::any(*removeNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("add_num") != m.end() && !m["add_num"].empty()) {
      addNum = make_shared<long>(boost::any_cast<long>(m["add_num"]));
    }
    if (m.find("remove_num") != m.end() && !m["remove_num"].empty()) {
      removeNum = make_shared<long>(boost::any_cast<long>(m["remove_num"]));
    }
  }


  virtual ~InvoiceRuleSaveResponseBodyModule() = default;
};
class InvoiceRuleSaveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<InvoiceRuleSaveResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InvoiceRuleSaveResponseBody() {}

  explicit InvoiceRuleSaveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        InvoiceRuleSaveResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<InvoiceRuleSaveResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InvoiceRuleSaveResponseBody() = default;
};
class InvoiceRuleSaveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvoiceRuleSaveResponseBody> body{};

  InvoiceRuleSaveResponse() {}

  explicit InvoiceRuleSaveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvoiceRuleSaveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvoiceRuleSaveResponseBody>(model1);
      }
    }
  }


  virtual ~InvoiceRuleSaveResponse() = default;
};
class InvoiceSearchHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  InvoiceSearchHeaders() {}

  explicit InvoiceSearchHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~InvoiceSearchHeaders() = default;
};
class InvoiceSearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> title{};
  shared_ptr<string> userId{};

  InvoiceSearchRequest() {}

  explicit InvoiceSearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~InvoiceSearchRequest() = default;
};
class InvoiceSearchResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> thirdPartInvoiceId{};
  shared_ptr<string> title{};

  InvoiceSearchResponseBodyModule() {}

  explicit InvoiceSearchResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~InvoiceSearchResponseBodyModule() = default;
};
class InvoiceSearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<InvoiceSearchResponseBodyModule>> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  InvoiceSearchResponseBody() {}

  explicit InvoiceSearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<InvoiceSearchResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvoiceSearchResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<InvoiceSearchResponseBodyModule>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~InvoiceSearchResponseBody() = default;
};
class InvoiceSearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvoiceSearchResponseBody> body{};

  InvoiceSearchResponse() {}

  explicit InvoiceSearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvoiceSearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvoiceSearchResponseBody>(model1);
      }
    }
  }


  virtual ~InvoiceSearchResponse() = default;
};
class IsvRuleSaveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  IsvRuleSaveHeaders() {}

  explicit IsvRuleSaveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~IsvRuleSaveHeaders() = default;
};
class IsvRuleSaveRequestBookuserList : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<long> entityType{};

  IsvRuleSaveRequestBookuserList() {}

  explicit IsvRuleSaveRequestBookuserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["entity_id"] = boost::any(*entityId);
    }
    if (entityType) {
      res["entity_type"] = boost::any(*entityType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("entity_id") != m.end() && !m["entity_id"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["entity_id"]));
    }
    if (m.find("entity_type") != m.end() && !m["entity_type"].empty()) {
      entityType = make_shared<long>(boost::any_cast<long>(m["entity_type"]));
    }
  }


  virtual ~IsvRuleSaveRequestBookuserList() = default;
};
class IsvRuleSaveRequest : public Darabonba::Model {
public:
  shared_ptr<bool> applyNeed{};
  shared_ptr<string> bookType{};
  shared_ptr<vector<IsvRuleSaveRequestBookuserList>> bookuserList{};
  shared_ptr<bool> ruleNeed{};
  shared_ptr<long> status{};
  shared_ptr<string> userId{};

  IsvRuleSaveRequest() {}

  explicit IsvRuleSaveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyNeed) {
      res["apply_need"] = boost::any(*applyNeed);
    }
    if (bookType) {
      res["book_type"] = boost::any(*bookType);
    }
    if (bookuserList) {
      vector<boost::any> temp1;
      for(auto item1:*bookuserList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["bookuser_list"] = boost::any(temp1);
    }
    if (ruleNeed) {
      res["rule_need"] = boost::any(*ruleNeed);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_need") != m.end() && !m["apply_need"].empty()) {
      applyNeed = make_shared<bool>(boost::any_cast<bool>(m["apply_need"]));
    }
    if (m.find("book_type") != m.end() && !m["book_type"].empty()) {
      bookType = make_shared<string>(boost::any_cast<string>(m["book_type"]));
    }
    if (m.find("bookuser_list") != m.end() && !m["bookuser_list"].empty()) {
      if (typeid(vector<boost::any>) == m["bookuser_list"].type()) {
        vector<IsvRuleSaveRequestBookuserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["bookuser_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IsvRuleSaveRequestBookuserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bookuserList = make_shared<vector<IsvRuleSaveRequestBookuserList>>(expect1);
      }
    }
    if (m.find("rule_need") != m.end() && !m["rule_need"].empty()) {
      ruleNeed = make_shared<bool>(boost::any_cast<bool>(m["rule_need"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~IsvRuleSaveRequest() = default;
};
class IsvRuleSaveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> applyNeed{};
  shared_ptr<string> bookType{};
  shared_ptr<string> bookuserListShrink{};
  shared_ptr<bool> ruleNeed{};
  shared_ptr<long> status{};
  shared_ptr<string> userId{};

  IsvRuleSaveShrinkRequest() {}

  explicit IsvRuleSaveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyNeed) {
      res["apply_need"] = boost::any(*applyNeed);
    }
    if (bookType) {
      res["book_type"] = boost::any(*bookType);
    }
    if (bookuserListShrink) {
      res["bookuser_list"] = boost::any(*bookuserListShrink);
    }
    if (ruleNeed) {
      res["rule_need"] = boost::any(*ruleNeed);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_need") != m.end() && !m["apply_need"].empty()) {
      applyNeed = make_shared<bool>(boost::any_cast<bool>(m["apply_need"]));
    }
    if (m.find("book_type") != m.end() && !m["book_type"].empty()) {
      bookType = make_shared<string>(boost::any_cast<string>(m["book_type"]));
    }
    if (m.find("bookuser_list") != m.end() && !m["bookuser_list"].empty()) {
      bookuserListShrink = make_shared<string>(boost::any_cast<string>(m["bookuser_list"]));
    }
    if (m.find("rule_need") != m.end() && !m["rule_need"].empty()) {
      ruleNeed = make_shared<bool>(boost::any_cast<bool>(m["rule_need"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~IsvRuleSaveShrinkRequest() = default;
};
class IsvRuleSaveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  IsvRuleSaveResponseBody() {}

  explicit IsvRuleSaveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~IsvRuleSaveResponseBody() = default;
};
class IsvRuleSaveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<IsvRuleSaveResponseBody> body{};

  IsvRuleSaveResponse() {}

  explicit IsvRuleSaveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        IsvRuleSaveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<IsvRuleSaveResponseBody>(model1);
      }
    }
  }


  virtual ~IsvRuleSaveResponse() = default;
};
class IsvUserSaveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  IsvUserSaveHeaders() {}

  explicit IsvUserSaveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~IsvUserSaveHeaders() = default;
};
class IsvUserSaveRequestUserListCertList : public Darabonba::Model {
public:
  shared_ptr<string> certExpiredTime{};
  shared_ptr<string> certNation{};
  shared_ptr<string> certNo{};
  shared_ptr<long> certType{};
  shared_ptr<string> nationality{};

  IsvUserSaveRequestUserListCertList() {}

  explicit IsvUserSaveRequestUserListCertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certExpiredTime) {
      res["cert_expired_time"] = boost::any(*certExpiredTime);
    }
    if (certNation) {
      res["cert_nation"] = boost::any(*certNation);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (nationality) {
      res["nationality"] = boost::any(*nationality);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cert_expired_time") != m.end() && !m["cert_expired_time"].empty()) {
      certExpiredTime = make_shared<string>(boost::any_cast<string>(m["cert_expired_time"]));
    }
    if (m.find("cert_nation") != m.end() && !m["cert_nation"].empty()) {
      certNation = make_shared<string>(boost::any_cast<string>(m["cert_nation"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<long>(boost::any_cast<long>(m["cert_type"]));
    }
    if (m.find("nationality") != m.end() && !m["nationality"].empty()) {
      nationality = make_shared<string>(boost::any_cast<string>(m["nationality"]));
    }
  }


  virtual ~IsvUserSaveRequestUserListCertList() = default;
};
class IsvUserSaveRequestUserList : public Darabonba::Model {
public:
  shared_ptr<string> baseCityCode{};
  shared_ptr<string> birthday{};
  shared_ptr<vector<IsvUserSaveRequestUserListCertList>> certList{};
  shared_ptr<long> departId{};
  shared_ptr<string> email{};
  shared_ptr<string> gender{};
  shared_ptr<bool> isAdmin{};
  shared_ptr<string> jobNo{};
  shared_ptr<long> leaveStatus{};
  shared_ptr<string> managerUserId{};
  shared_ptr<string> phone{};
  shared_ptr<string> position{};
  shared_ptr<string> positionLevel{};
  shared_ptr<string> realNameEn{};
  shared_ptr<string> thirdDepartId{};
  shared_ptr<vector<string>> thirdDepartIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  IsvUserSaveRequestUserList() {}

  explicit IsvUserSaveRequestUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseCityCode) {
      res["base_city_code"] = boost::any(*baseCityCode);
    }
    if (birthday) {
      res["birthday"] = boost::any(*birthday);
    }
    if (certList) {
      vector<boost::any> temp1;
      for(auto item1:*certList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cert_list"] = boost::any(temp1);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (gender) {
      res["gender"] = boost::any(*gender);
    }
    if (isAdmin) {
      res["is_admin"] = boost::any(*isAdmin);
    }
    if (jobNo) {
      res["job_no"] = boost::any(*jobNo);
    }
    if (leaveStatus) {
      res["leave_status"] = boost::any(*leaveStatus);
    }
    if (managerUserId) {
      res["manager_user_id"] = boost::any(*managerUserId);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (position) {
      res["position"] = boost::any(*position);
    }
    if (positionLevel) {
      res["position_level"] = boost::any(*positionLevel);
    }
    if (realNameEn) {
      res["real_name_en"] = boost::any(*realNameEn);
    }
    if (thirdDepartId) {
      res["third_depart_id"] = boost::any(*thirdDepartId);
    }
    if (thirdDepartIdList) {
      res["third_depart_id_list"] = boost::any(*thirdDepartIdList);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("base_city_code") != m.end() && !m["base_city_code"].empty()) {
      baseCityCode = make_shared<string>(boost::any_cast<string>(m["base_city_code"]));
    }
    if (m.find("birthday") != m.end() && !m["birthday"].empty()) {
      birthday = make_shared<string>(boost::any_cast<string>(m["birthday"]));
    }
    if (m.find("cert_list") != m.end() && !m["cert_list"].empty()) {
      if (typeid(vector<boost::any>) == m["cert_list"].type()) {
        vector<IsvUserSaveRequestUserListCertList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cert_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IsvUserSaveRequestUserListCertList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certList = make_shared<vector<IsvUserSaveRequestUserListCertList>>(expect1);
      }
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<long>(boost::any_cast<long>(m["depart_id"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("gender") != m.end() && !m["gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["gender"]));
    }
    if (m.find("is_admin") != m.end() && !m["is_admin"].empty()) {
      isAdmin = make_shared<bool>(boost::any_cast<bool>(m["is_admin"]));
    }
    if (m.find("job_no") != m.end() && !m["job_no"].empty()) {
      jobNo = make_shared<string>(boost::any_cast<string>(m["job_no"]));
    }
    if (m.find("leave_status") != m.end() && !m["leave_status"].empty()) {
      leaveStatus = make_shared<long>(boost::any_cast<long>(m["leave_status"]));
    }
    if (m.find("manager_user_id") != m.end() && !m["manager_user_id"].empty()) {
      managerUserId = make_shared<string>(boost::any_cast<string>(m["manager_user_id"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("position") != m.end() && !m["position"].empty()) {
      position = make_shared<string>(boost::any_cast<string>(m["position"]));
    }
    if (m.find("position_level") != m.end() && !m["position_level"].empty()) {
      positionLevel = make_shared<string>(boost::any_cast<string>(m["position_level"]));
    }
    if (m.find("real_name_en") != m.end() && !m["real_name_en"].empty()) {
      realNameEn = make_shared<string>(boost::any_cast<string>(m["real_name_en"]));
    }
    if (m.find("third_depart_id") != m.end() && !m["third_depart_id"].empty()) {
      thirdDepartId = make_shared<string>(boost::any_cast<string>(m["third_depart_id"]));
    }
    if (m.find("third_depart_id_list") != m.end() && !m["third_depart_id_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["third_depart_id_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["third_depart_id_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      thirdDepartIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~IsvUserSaveRequestUserList() = default;
};
class IsvUserSaveRequest : public Darabonba::Model {
public:
  shared_ptr<vector<IsvUserSaveRequestUserList>> userList{};

  IsvUserSaveRequest() {}

  explicit IsvUserSaveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["user_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_list") != m.end() && !m["user_list"].empty()) {
      if (typeid(vector<boost::any>) == m["user_list"].type()) {
        vector<IsvUserSaveRequestUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["user_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IsvUserSaveRequestUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<IsvUserSaveRequestUserList>>(expect1);
      }
    }
  }


  virtual ~IsvUserSaveRequest() = default;
};
class IsvUserSaveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> userListShrink{};

  IsvUserSaveShrinkRequest() {}

  explicit IsvUserSaveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userListShrink) {
      res["user_list"] = boost::any(*userListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_list") != m.end() && !m["user_list"].empty()) {
      userListShrink = make_shared<string>(boost::any_cast<string>(m["user_list"]));
    }
  }


  virtual ~IsvUserSaveShrinkRequest() = default;
};
class IsvUserSaveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  IsvUserSaveResponseBody() {}

  explicit IsvUserSaveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~IsvUserSaveResponseBody() = default;
};
class IsvUserSaveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<IsvUserSaveResponseBody> body{};

  IsvUserSaveResponse() {}

  explicit IsvUserSaveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        IsvUserSaveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<IsvUserSaveResponseBody>(model1);
      }
    }
  }


  virtual ~IsvUserSaveResponse() = default;
};
class MonthBillConfirmHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  MonthBillConfirmHeaders() {}

  explicit MonthBillConfirmHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~MonthBillConfirmHeaders() = default;
};
class MonthBillConfirmRequest : public Darabonba::Model {
public:
  shared_ptr<long> mailBillDate{};
  shared_ptr<string> userId{};

  MonthBillConfirmRequest() {}

  explicit MonthBillConfirmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mailBillDate) {
      res["mail_bill_date"] = boost::any(*mailBillDate);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("mail_bill_date") != m.end() && !m["mail_bill_date"].empty()) {
      mailBillDate = make_shared<long>(boost::any_cast<long>(m["mail_bill_date"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~MonthBillConfirmRequest() = default;
};
class MonthBillConfirmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  MonthBillConfirmResponseBody() {}

  explicit MonthBillConfirmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~MonthBillConfirmResponseBody() = default;
};
class MonthBillConfirmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MonthBillConfirmResponseBody> body{};

  MonthBillConfirmResponse() {}

  explicit MonthBillConfirmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MonthBillConfirmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MonthBillConfirmResponseBody>(model1);
      }
    }
  }


  virtual ~MonthBillConfirmResponse() = default;
};
class MonthBillGetHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  MonthBillGetHeaders() {}

  explicit MonthBillGetHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~MonthBillGetHeaders() = default;
};
class MonthBillGetRequest : public Darabonba::Model {
public:
  shared_ptr<string> billMonth{};

  MonthBillGetRequest() {}

  explicit MonthBillGetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billMonth) {
      res["bill_month"] = boost::any(*billMonth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_month") != m.end() && !m["bill_month"].empty()) {
      billMonth = make_shared<string>(boost::any_cast<string>(m["bill_month"]));
    }
  }


  virtual ~MonthBillGetRequest() = default;
};
class MonthBillGetResponseBodyModuleMonthAccountBillDetail : public Darabonba::Model {
public:
  shared_ptr<long> billConfirmed{};
  shared_ptr<double> carAmount{};
  shared_ptr<double> damageAmount{};
  shared_ptr<double> flightAmount{};
  shared_ptr<double> fuPoint{};
  shared_ptr<double> hotelAmount{};
  shared_ptr<double> ieFlightAmount{};
  shared_ptr<double> ieHotelAmount{};
  shared_ptr<long> mailBillDate{};
  shared_ptr<double> serviceAmount{};
  shared_ptr<double> trainAmount{};

  MonthBillGetResponseBodyModuleMonthAccountBillDetail() {}

  explicit MonthBillGetResponseBodyModuleMonthAccountBillDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billConfirmed) {
      res["billConfirmed"] = boost::any(*billConfirmed);
    }
    if (carAmount) {
      res["carAmount"] = boost::any(*carAmount);
    }
    if (damageAmount) {
      res["damageAmount"] = boost::any(*damageAmount);
    }
    if (flightAmount) {
      res["flightAmount"] = boost::any(*flightAmount);
    }
    if (fuPoint) {
      res["fuPoint"] = boost::any(*fuPoint);
    }
    if (hotelAmount) {
      res["hotelAmount"] = boost::any(*hotelAmount);
    }
    if (ieFlightAmount) {
      res["ieFlightAmount"] = boost::any(*ieFlightAmount);
    }
    if (ieHotelAmount) {
      res["ieHotelAmount"] = boost::any(*ieHotelAmount);
    }
    if (mailBillDate) {
      res["mailBillDate"] = boost::any(*mailBillDate);
    }
    if (serviceAmount) {
      res["serviceAmount"] = boost::any(*serviceAmount);
    }
    if (trainAmount) {
      res["trainAmount"] = boost::any(*trainAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("billConfirmed") != m.end() && !m["billConfirmed"].empty()) {
      billConfirmed = make_shared<long>(boost::any_cast<long>(m["billConfirmed"]));
    }
    if (m.find("carAmount") != m.end() && !m["carAmount"].empty()) {
      carAmount = make_shared<double>(boost::any_cast<double>(m["carAmount"]));
    }
    if (m.find("damageAmount") != m.end() && !m["damageAmount"].empty()) {
      damageAmount = make_shared<double>(boost::any_cast<double>(m["damageAmount"]));
    }
    if (m.find("flightAmount") != m.end() && !m["flightAmount"].empty()) {
      flightAmount = make_shared<double>(boost::any_cast<double>(m["flightAmount"]));
    }
    if (m.find("fuPoint") != m.end() && !m["fuPoint"].empty()) {
      fuPoint = make_shared<double>(boost::any_cast<double>(m["fuPoint"]));
    }
    if (m.find("hotelAmount") != m.end() && !m["hotelAmount"].empty()) {
      hotelAmount = make_shared<double>(boost::any_cast<double>(m["hotelAmount"]));
    }
    if (m.find("ieFlightAmount") != m.end() && !m["ieFlightAmount"].empty()) {
      ieFlightAmount = make_shared<double>(boost::any_cast<double>(m["ieFlightAmount"]));
    }
    if (m.find("ieHotelAmount") != m.end() && !m["ieHotelAmount"].empty()) {
      ieHotelAmount = make_shared<double>(boost::any_cast<double>(m["ieHotelAmount"]));
    }
    if (m.find("mailBillDate") != m.end() && !m["mailBillDate"].empty()) {
      mailBillDate = make_shared<long>(boost::any_cast<long>(m["mailBillDate"]));
    }
    if (m.find("serviceAmount") != m.end() && !m["serviceAmount"].empty()) {
      serviceAmount = make_shared<double>(boost::any_cast<double>(m["serviceAmount"]));
    }
    if (m.find("trainAmount") != m.end() && !m["trainAmount"].empty()) {
      trainAmount = make_shared<double>(boost::any_cast<double>(m["trainAmount"]));
    }
  }


  virtual ~MonthBillGetResponseBodyModuleMonthAccountBillDetail() = default;
};
class MonthBillGetResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<MonthBillGetResponseBodyModuleMonthAccountBillDetail> monthAccountBillDetail{};
  shared_ptr<string> startDate{};
  shared_ptr<string> url{};

  MonthBillGetResponseBodyModule() {}

  explicit MonthBillGetResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["end_date"] = boost::any(*endDate);
    }
    if (monthAccountBillDetail) {
      res["monthAccountBillDetail"] = monthAccountBillDetail ? boost::any(monthAccountBillDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startDate) {
      res["start_date"] = boost::any(*startDate);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("end_date") != m.end() && !m["end_date"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["end_date"]));
    }
    if (m.find("monthAccountBillDetail") != m.end() && !m["monthAccountBillDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["monthAccountBillDetail"].type()) {
        MonthBillGetResponseBodyModuleMonthAccountBillDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["monthAccountBillDetail"]));
        monthAccountBillDetail = make_shared<MonthBillGetResponseBodyModuleMonthAccountBillDetail>(model1);
      }
    }
    if (m.find("start_date") != m.end() && !m["start_date"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["start_date"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~MonthBillGetResponseBodyModule() = default;
};
class MonthBillGetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<MonthBillGetResponseBodyModule>> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  MonthBillGetResponseBody() {}

  explicit MonthBillGetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<MonthBillGetResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MonthBillGetResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<MonthBillGetResponseBodyModule>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~MonthBillGetResponseBody() = default;
};
class MonthBillGetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MonthBillGetResponseBody> body{};

  MonthBillGetResponse() {}

  explicit MonthBillGetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MonthBillGetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MonthBillGetResponseBody>(model1);
      }
    }
  }


  virtual ~MonthBillGetResponse() = default;
};
class ProjectAddHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ProjectAddHeaders() {}

  explicit ProjectAddHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ProjectAddHeaders() = default;
};
class ProjectAddRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> projectName{};
  shared_ptr<string> thirdPartCostCenterId{};
  shared_ptr<string> thirdPartId{};
  shared_ptr<string> thirdPartInvoiceId{};

  ProjectAddRequest() {}

  explicit ProjectAddRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (thirdPartCostCenterId) {
      res["third_part_cost_center_id"] = boost::any(*thirdPartCostCenterId);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("third_part_cost_center_id") != m.end() && !m["third_part_cost_center_id"].empty()) {
      thirdPartCostCenterId = make_shared<string>(boost::any_cast<string>(m["third_part_cost_center_id"]));
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
  }


  virtual ~ProjectAddRequest() = default;
};
class ProjectAddResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<long> module{};
  shared_ptr<bool> morePage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ProjectAddResponseBody() {}

  explicit ProjectAddResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (morePage) {
      res["more_page"] = boost::any(*morePage);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<long>(boost::any_cast<long>(m["module"]));
    }
    if (m.find("more_page") != m.end() && !m["more_page"].empty()) {
      morePage = make_shared<bool>(boost::any_cast<bool>(m["more_page"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ProjectAddResponseBody() = default;
};
class ProjectAddResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ProjectAddResponseBody> body{};

  ProjectAddResponse() {}

  explicit ProjectAddResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ProjectAddResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ProjectAddResponseBody>(model1);
      }
    }
  }


  virtual ~ProjectAddResponse() = default;
};
class ProjectDeleteHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ProjectDeleteHeaders() {}

  explicit ProjectDeleteHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ProjectDeleteHeaders() = default;
};
class ProjectDeleteRequest : public Darabonba::Model {
public:
  shared_ptr<string> thirdPartId{};

  ProjectDeleteRequest() {}

  explicit ProjectDeleteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
  }


  virtual ~ProjectDeleteRequest() = default;
};
class ProjectDeleteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ProjectDeleteResponseBody() {}

  explicit ProjectDeleteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<bool>(boost::any_cast<bool>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ProjectDeleteResponseBody() = default;
};
class ProjectDeleteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ProjectDeleteResponseBody> body{};

  ProjectDeleteResponse() {}

  explicit ProjectDeleteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ProjectDeleteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ProjectDeleteResponseBody>(model1);
      }
    }
  }


  virtual ~ProjectDeleteResponse() = default;
};
class ProjectModifyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  ProjectModifyHeaders() {}

  explicit ProjectModifyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~ProjectModifyHeaders() = default;
};
class ProjectModifyRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> projectName{};
  shared_ptr<string> thirdPartCostCenterId{};
  shared_ptr<string> thirdPartId{};
  shared_ptr<string> thirdPartInvoiceId{};

  ProjectModifyRequest() {}

  explicit ProjectModifyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (thirdPartCostCenterId) {
      res["third_part_cost_center_id"] = boost::any(*thirdPartCostCenterId);
    }
    if (thirdPartId) {
      res["third_part_id"] = boost::any(*thirdPartId);
    }
    if (thirdPartInvoiceId) {
      res["third_part_invoice_id"] = boost::any(*thirdPartInvoiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("third_part_cost_center_id") != m.end() && !m["third_part_cost_center_id"].empty()) {
      thirdPartCostCenterId = make_shared<string>(boost::any_cast<string>(m["third_part_cost_center_id"]));
    }
    if (m.find("third_part_id") != m.end() && !m["third_part_id"].empty()) {
      thirdPartId = make_shared<string>(boost::any_cast<string>(m["third_part_id"]));
    }
    if (m.find("third_part_invoice_id") != m.end() && !m["third_part_invoice_id"].empty()) {
      thirdPartInvoiceId = make_shared<string>(boost::any_cast<string>(m["third_part_invoice_id"]));
    }
  }


  virtual ~ProjectModifyRequest() = default;
};
class ProjectModifyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  ProjectModifyResponseBody() {}

  explicit ProjectModifyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<bool>(boost::any_cast<bool>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~ProjectModifyResponseBody() = default;
};
class ProjectModifyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ProjectModifyResponseBody> body{};

  ProjectModifyResponse() {}

  explicit ProjectModifyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ProjectModifyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ProjectModifyResponseBody>(model1);
      }
    }
  }


  virtual ~ProjectModifyResponse() = default;
};
class QueryReimbursementOrderHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  QueryReimbursementOrderHeaders() {}

  explicit QueryReimbursementOrderHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~QueryReimbursementOrderHeaders() = default;
};
class QueryReimbursementOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> reimbOrderNo{};
  shared_ptr<string> subCorpId{};

  QueryReimbursementOrderRequest() {}

  explicit QueryReimbursementOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reimbOrderNo) {
      res["reimb_order_no"] = boost::any(*reimbOrderNo);
    }
    if (subCorpId) {
      res["sub_corp_id"] = boost::any(*subCorpId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("reimb_order_no") != m.end() && !m["reimb_order_no"].empty()) {
      reimbOrderNo = make_shared<string>(boost::any_cast<string>(m["reimb_order_no"]));
    }
    if (m.find("sub_corp_id") != m.end() && !m["sub_corp_id"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["sub_corp_id"]));
    }
  }


  virtual ~QueryReimbursementOrderRequest() = default;
};
class QueryReimbursementOrderResponseBodyModuleExpensesExpenseCompositions : public Darabonba::Model {
public:
  shared_ptr<long> billSettlementId{};
  shared_ptr<string> capitalDirection{};
  shared_ptr<string> feeType{};
  shared_ptr<string> orderId{};
  shared_ptr<string> remark{};
  shared_ptr<vector<string>> remindTagList{};
  shared_ptr<string> settlementAmount{};
  shared_ptr<string> settlementTime{};
  shared_ptr<long> voucherType{};

  QueryReimbursementOrderResponseBodyModuleExpensesExpenseCompositions() {}

  explicit QueryReimbursementOrderResponseBodyModuleExpensesExpenseCompositions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billSettlementId) {
      res["bill_settlement_id"] = boost::any(*billSettlementId);
    }
    if (capitalDirection) {
      res["capital_direction"] = boost::any(*capitalDirection);
    }
    if (feeType) {
      res["fee_type"] = boost::any(*feeType);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (remindTagList) {
      res["remind_tag_list"] = boost::any(*remindTagList);
    }
    if (settlementAmount) {
      res["settlement_amount"] = boost::any(*settlementAmount);
    }
    if (settlementTime) {
      res["settlement_time"] = boost::any(*settlementTime);
    }
    if (voucherType) {
      res["voucher_type"] = boost::any(*voucherType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_settlement_id") != m.end() && !m["bill_settlement_id"].empty()) {
      billSettlementId = make_shared<long>(boost::any_cast<long>(m["bill_settlement_id"]));
    }
    if (m.find("capital_direction") != m.end() && !m["capital_direction"].empty()) {
      capitalDirection = make_shared<string>(boost::any_cast<string>(m["capital_direction"]));
    }
    if (m.find("fee_type") != m.end() && !m["fee_type"].empty()) {
      feeType = make_shared<string>(boost::any_cast<string>(m["fee_type"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("remind_tag_list") != m.end() && !m["remind_tag_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["remind_tag_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["remind_tag_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      remindTagList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("settlement_amount") != m.end() && !m["settlement_amount"].empty()) {
      settlementAmount = make_shared<string>(boost::any_cast<string>(m["settlement_amount"]));
    }
    if (m.find("settlement_time") != m.end() && !m["settlement_time"].empty()) {
      settlementTime = make_shared<string>(boost::any_cast<string>(m["settlement_time"]));
    }
    if (m.find("voucher_type") != m.end() && !m["voucher_type"].empty()) {
      voucherType = make_shared<long>(boost::any_cast<long>(m["voucher_type"]));
    }
  }


  virtual ~QueryReimbursementOrderResponseBodyModuleExpensesExpenseCompositions() = default;
};
class QueryReimbursementOrderResponseBodyModuleExpenses : public Darabonba::Model {
public:
  shared_ptr<string> amount{};
  shared_ptr<string> currency{};
  shared_ptr<string> expenseCity{};
  shared_ptr<vector<QueryReimbursementOrderResponseBodyModuleExpensesExpenseCompositions>> expenseCompositions{};
  shared_ptr<string> expenseTime{};
  shared_ptr<string> expenseType{};
  shared_ptr<string> expenseTypeCode{};
  shared_ptr<long> reimbExpenseId{};
  shared_ptr<string> remark{};
  shared_ptr<string> settlementType{};

  QueryReimbursementOrderResponseBodyModuleExpenses() {}

  explicit QueryReimbursementOrderResponseBodyModuleExpenses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (currency) {
      res["currency"] = boost::any(*currency);
    }
    if (expenseCity) {
      res["expense_city"] = boost::any(*expenseCity);
    }
    if (expenseCompositions) {
      vector<boost::any> temp1;
      for(auto item1:*expenseCompositions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["expense_compositions"] = boost::any(temp1);
    }
    if (expenseTime) {
      res["expense_time"] = boost::any(*expenseTime);
    }
    if (expenseType) {
      res["expense_type"] = boost::any(*expenseType);
    }
    if (expenseTypeCode) {
      res["expense_type_code"] = boost::any(*expenseTypeCode);
    }
    if (reimbExpenseId) {
      res["reimb_expense_id"] = boost::any(*reimbExpenseId);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (settlementType) {
      res["settlement_type"] = boost::any(*settlementType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<string>(boost::any_cast<string>(m["amount"]));
    }
    if (m.find("currency") != m.end() && !m["currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["currency"]));
    }
    if (m.find("expense_city") != m.end() && !m["expense_city"].empty()) {
      expenseCity = make_shared<string>(boost::any_cast<string>(m["expense_city"]));
    }
    if (m.find("expense_compositions") != m.end() && !m["expense_compositions"].empty()) {
      if (typeid(vector<boost::any>) == m["expense_compositions"].type()) {
        vector<QueryReimbursementOrderResponseBodyModuleExpensesExpenseCompositions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["expense_compositions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryReimbursementOrderResponseBodyModuleExpensesExpenseCompositions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expenseCompositions = make_shared<vector<QueryReimbursementOrderResponseBodyModuleExpensesExpenseCompositions>>(expect1);
      }
    }
    if (m.find("expense_time") != m.end() && !m["expense_time"].empty()) {
      expenseTime = make_shared<string>(boost::any_cast<string>(m["expense_time"]));
    }
    if (m.find("expense_type") != m.end() && !m["expense_type"].empty()) {
      expenseType = make_shared<string>(boost::any_cast<string>(m["expense_type"]));
    }
    if (m.find("expense_type_code") != m.end() && !m["expense_type_code"].empty()) {
      expenseTypeCode = make_shared<string>(boost::any_cast<string>(m["expense_type_code"]));
    }
    if (m.find("reimb_expense_id") != m.end() && !m["reimb_expense_id"].empty()) {
      reimbExpenseId = make_shared<long>(boost::any_cast<long>(m["reimb_expense_id"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("settlement_type") != m.end() && !m["settlement_type"].empty()) {
      settlementType = make_shared<string>(boost::any_cast<string>(m["settlement_type"]));
    }
  }


  virtual ~QueryReimbursementOrderResponseBodyModuleExpenses() = default;
};
class QueryReimbursementOrderResponseBodyModuleItineraries : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depDate{};
  shared_ptr<string> trafficWay{};
  shared_ptr<string> tripWay{};

  QueryReimbursementOrderResponseBodyModuleItineraries() {}

  explicit QueryReimbursementOrderResponseBodyModuleItineraries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (trafficWay) {
      res["traffic_way"] = boost::any(*trafficWay);
    }
    if (tripWay) {
      res["trip_way"] = boost::any(*tripWay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("traffic_way") != m.end() && !m["traffic_way"].empty()) {
      trafficWay = make_shared<string>(boost::any_cast<string>(m["traffic_way"]));
    }
    if (m.find("trip_way") != m.end() && !m["trip_way"].empty()) {
      tripWay = make_shared<string>(boost::any_cast<string>(m["trip_way"]));
    }
  }


  virtual ~QueryReimbursementOrderResponseBodyModuleItineraries() = default;
};
class QueryReimbursementOrderResponseBodyModulePaymentInfos : public Darabonba::Model {
public:
  shared_ptr<string> amount{};
  shared_ptr<string> payeeUserId{};

  QueryReimbursementOrderResponseBodyModulePaymentInfos() {}

  explicit QueryReimbursementOrderResponseBodyModulePaymentInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (payeeUserId) {
      res["payee_user_id"] = boost::any(*payeeUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<string>(boost::any_cast<string>(m["amount"]));
    }
    if (m.find("payee_user_id") != m.end() && !m["payee_user_id"].empty()) {
      payeeUserId = make_shared<string>(boost::any_cast<string>(m["payee_user_id"]));
    }
  }


  virtual ~QueryReimbursementOrderResponseBodyModulePaymentInfos() = default;
};
class QueryReimbursementOrderResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> companyAmount{};
  shared_ptr<string> companyPayAmount{};
  shared_ptr<string> corpId{};
  shared_ptr<string> costCenterCode{};
  shared_ptr<string> costCenterName{};
  shared_ptr<vector<QueryReimbursementOrderResponseBodyModuleExpenses>> expenses{};
  shared_ptr<string> expensesCoverDeptId{};
  shared_ptr<string> expensesCoverDeptName{};
  shared_ptr<string> expensesCoverInvoiceTitle{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> isDeleted{};
  shared_ptr<vector<QueryReimbursementOrderResponseBodyModuleItineraries>> itineraries{};
  shared_ptr<vector<QueryReimbursementOrderResponseBodyModulePaymentInfos>> paymentInfos{};
  shared_ptr<string> personalAmount{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectName{};
  shared_ptr<string> reason{};
  shared_ptr<string> reimbursementNo{};
  shared_ptr<string> remark{};
  shared_ptr<string> status{};
  shared_ptr<string> travelThirdApplyId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  QueryReimbursementOrderResponseBodyModule() {}

  explicit QueryReimbursementOrderResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (companyAmount) {
      res["company_amount"] = boost::any(*companyAmount);
    }
    if (companyPayAmount) {
      res["company_pay_amount"] = boost::any(*companyPayAmount);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (costCenterCode) {
      res["cost_center_code"] = boost::any(*costCenterCode);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (expenses) {
      vector<boost::any> temp1;
      for(auto item1:*expenses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["expenses"] = boost::any(temp1);
    }
    if (expensesCoverDeptId) {
      res["expenses_cover_dept_id"] = boost::any(*expensesCoverDeptId);
    }
    if (expensesCoverDeptName) {
      res["expenses_cover_dept_name"] = boost::any(*expensesCoverDeptName);
    }
    if (expensesCoverInvoiceTitle) {
      res["expenses_cover_invoice_title"] = boost::any(*expensesCoverInvoiceTitle);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (isDeleted) {
      res["is_deleted"] = boost::any(*isDeleted);
    }
    if (itineraries) {
      vector<boost::any> temp1;
      for(auto item1:*itineraries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["itineraries"] = boost::any(temp1);
    }
    if (paymentInfos) {
      vector<boost::any> temp1;
      for(auto item1:*paymentInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["payment_infos"] = boost::any(temp1);
    }
    if (personalAmount) {
      res["personal_amount"] = boost::any(*personalAmount);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (reimbursementNo) {
      res["reimbursement_no"] = boost::any(*reimbursementNo);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (travelThirdApplyId) {
      res["travel_third_apply_id"] = boost::any(*travelThirdApplyId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("company_amount") != m.end() && !m["company_amount"].empty()) {
      companyAmount = make_shared<string>(boost::any_cast<string>(m["company_amount"]));
    }
    if (m.find("company_pay_amount") != m.end() && !m["company_pay_amount"].empty()) {
      companyPayAmount = make_shared<string>(boost::any_cast<string>(m["company_pay_amount"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("cost_center_code") != m.end() && !m["cost_center_code"].empty()) {
      costCenterCode = make_shared<string>(boost::any_cast<string>(m["cost_center_code"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("expenses") != m.end() && !m["expenses"].empty()) {
      if (typeid(vector<boost::any>) == m["expenses"].type()) {
        vector<QueryReimbursementOrderResponseBodyModuleExpenses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["expenses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryReimbursementOrderResponseBodyModuleExpenses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expenses = make_shared<vector<QueryReimbursementOrderResponseBodyModuleExpenses>>(expect1);
      }
    }
    if (m.find("expenses_cover_dept_id") != m.end() && !m["expenses_cover_dept_id"].empty()) {
      expensesCoverDeptId = make_shared<string>(boost::any_cast<string>(m["expenses_cover_dept_id"]));
    }
    if (m.find("expenses_cover_dept_name") != m.end() && !m["expenses_cover_dept_name"].empty()) {
      expensesCoverDeptName = make_shared<string>(boost::any_cast<string>(m["expenses_cover_dept_name"]));
    }
    if (m.find("expenses_cover_invoice_title") != m.end() && !m["expenses_cover_invoice_title"].empty()) {
      expensesCoverInvoiceTitle = make_shared<string>(boost::any_cast<string>(m["expenses_cover_invoice_title"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("is_deleted") != m.end() && !m["is_deleted"].empty()) {
      isDeleted = make_shared<string>(boost::any_cast<string>(m["is_deleted"]));
    }
    if (m.find("itineraries") != m.end() && !m["itineraries"].empty()) {
      if (typeid(vector<boost::any>) == m["itineraries"].type()) {
        vector<QueryReimbursementOrderResponseBodyModuleItineraries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["itineraries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryReimbursementOrderResponseBodyModuleItineraries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itineraries = make_shared<vector<QueryReimbursementOrderResponseBodyModuleItineraries>>(expect1);
      }
    }
    if (m.find("payment_infos") != m.end() && !m["payment_infos"].empty()) {
      if (typeid(vector<boost::any>) == m["payment_infos"].type()) {
        vector<QueryReimbursementOrderResponseBodyModulePaymentInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["payment_infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryReimbursementOrderResponseBodyModulePaymentInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paymentInfos = make_shared<vector<QueryReimbursementOrderResponseBodyModulePaymentInfos>>(expect1);
      }
    }
    if (m.find("personal_amount") != m.end() && !m["personal_amount"].empty()) {
      personalAmount = make_shared<string>(boost::any_cast<string>(m["personal_amount"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("reimbursement_no") != m.end() && !m["reimbursement_no"].empty()) {
      reimbursementNo = make_shared<string>(boost::any_cast<string>(m["reimbursement_no"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("travel_third_apply_id") != m.end() && !m["travel_third_apply_id"].empty()) {
      travelThirdApplyId = make_shared<string>(boost::any_cast<string>(m["travel_third_apply_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~QueryReimbursementOrderResponseBodyModule() = default;
};
class QueryReimbursementOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryReimbursementOrderResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  QueryReimbursementOrderResponseBody() {}

  explicit QueryReimbursementOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        QueryReimbursementOrderResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<QueryReimbursementOrderResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~QueryReimbursementOrderResponseBody() = default;
};
class QueryReimbursementOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryReimbursementOrderResponseBody> body{};

  QueryReimbursementOrderResponse() {}

  explicit QueryReimbursementOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryReimbursementOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryReimbursementOrderResponseBody>(model1);
      }
    }
  }


  virtual ~QueryReimbursementOrderResponse() = default;
};
class SyncSingleUserHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  SyncSingleUserHeaders() {}

  explicit SyncSingleUserHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~SyncSingleUserHeaders() = default;
};
class SyncSingleUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> email{};
  shared_ptr<string> jobNo{};
  shared_ptr<long> leaveStatus{};
  shared_ptr<string> managerUserId{};
  shared_ptr<string> phone{};
  shared_ptr<string> position{};
  shared_ptr<string> positionLevel{};
  shared_ptr<string> realNameEn{};
  shared_ptr<vector<string>> thirdDepartIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  SyncSingleUserRequest() {}

  explicit SyncSingleUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (jobNo) {
      res["job_no"] = boost::any(*jobNo);
    }
    if (leaveStatus) {
      res["leave_status"] = boost::any(*leaveStatus);
    }
    if (managerUserId) {
      res["manager_user_id"] = boost::any(*managerUserId);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (position) {
      res["position"] = boost::any(*position);
    }
    if (positionLevel) {
      res["position_level"] = boost::any(*positionLevel);
    }
    if (realNameEn) {
      res["real_name_en"] = boost::any(*realNameEn);
    }
    if (thirdDepartIdList) {
      res["third_depart_id_list"] = boost::any(*thirdDepartIdList);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("job_no") != m.end() && !m["job_no"].empty()) {
      jobNo = make_shared<string>(boost::any_cast<string>(m["job_no"]));
    }
    if (m.find("leave_status") != m.end() && !m["leave_status"].empty()) {
      leaveStatus = make_shared<long>(boost::any_cast<long>(m["leave_status"]));
    }
    if (m.find("manager_user_id") != m.end() && !m["manager_user_id"].empty()) {
      managerUserId = make_shared<string>(boost::any_cast<string>(m["manager_user_id"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("position") != m.end() && !m["position"].empty()) {
      position = make_shared<string>(boost::any_cast<string>(m["position"]));
    }
    if (m.find("position_level") != m.end() && !m["position_level"].empty()) {
      positionLevel = make_shared<string>(boost::any_cast<string>(m["position_level"]));
    }
    if (m.find("real_name_en") != m.end() && !m["real_name_en"].empty()) {
      realNameEn = make_shared<string>(boost::any_cast<string>(m["real_name_en"]));
    }
    if (m.find("third_depart_id_list") != m.end() && !m["third_depart_id_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["third_depart_id_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["third_depart_id_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      thirdDepartIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~SyncSingleUserRequest() = default;
};
class SyncSingleUserShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> email{};
  shared_ptr<string> jobNo{};
  shared_ptr<long> leaveStatus{};
  shared_ptr<string> managerUserId{};
  shared_ptr<string> phone{};
  shared_ptr<string> position{};
  shared_ptr<string> positionLevel{};
  shared_ptr<string> realNameEn{};
  shared_ptr<string> thirdDepartIdListShrink{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  SyncSingleUserShrinkRequest() {}

  explicit SyncSingleUserShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (jobNo) {
      res["job_no"] = boost::any(*jobNo);
    }
    if (leaveStatus) {
      res["leave_status"] = boost::any(*leaveStatus);
    }
    if (managerUserId) {
      res["manager_user_id"] = boost::any(*managerUserId);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (position) {
      res["position"] = boost::any(*position);
    }
    if (positionLevel) {
      res["position_level"] = boost::any(*positionLevel);
    }
    if (realNameEn) {
      res["real_name_en"] = boost::any(*realNameEn);
    }
    if (thirdDepartIdListShrink) {
      res["third_depart_id_list"] = boost::any(*thirdDepartIdListShrink);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("job_no") != m.end() && !m["job_no"].empty()) {
      jobNo = make_shared<string>(boost::any_cast<string>(m["job_no"]));
    }
    if (m.find("leave_status") != m.end() && !m["leave_status"].empty()) {
      leaveStatus = make_shared<long>(boost::any_cast<long>(m["leave_status"]));
    }
    if (m.find("manager_user_id") != m.end() && !m["manager_user_id"].empty()) {
      managerUserId = make_shared<string>(boost::any_cast<string>(m["manager_user_id"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("position") != m.end() && !m["position"].empty()) {
      position = make_shared<string>(boost::any_cast<string>(m["position"]));
    }
    if (m.find("position_level") != m.end() && !m["position_level"].empty()) {
      positionLevel = make_shared<string>(boost::any_cast<string>(m["position_level"]));
    }
    if (m.find("real_name_en") != m.end() && !m["real_name_en"].empty()) {
      realNameEn = make_shared<string>(boost::any_cast<string>(m["real_name_en"]));
    }
    if (m.find("third_depart_id_list") != m.end() && !m["third_depart_id_list"].empty()) {
      thirdDepartIdListShrink = make_shared<string>(boost::any_cast<string>(m["third_depart_id_list"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~SyncSingleUserShrinkRequest() = default;
};
class SyncSingleUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  SyncSingleUserResponseBody() {}

  explicit SyncSingleUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~SyncSingleUserResponseBody() = default;
};
class SyncSingleUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncSingleUserResponseBody> body{};

  SyncSingleUserResponse() {}

  explicit SyncSingleUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncSingleUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncSingleUserResponseBody>(model1);
      }
    }
  }


  virtual ~SyncSingleUserResponse() = default;
};
class SyncThirdUserMappingHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  SyncThirdUserMappingHeaders() {}

  explicit SyncThirdUserMappingHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~SyncThirdUserMappingHeaders() = default;
};
class SyncThirdUserMappingRequest : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> thirdChannelType{};
  shared_ptr<string> thirdUserId{};
  shared_ptr<string> userId{};

  SyncThirdUserMappingRequest() {}

  explicit SyncThirdUserMappingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdChannelType) {
      res["third_channel_type"] = boost::any(*thirdChannelType);
    }
    if (thirdUserId) {
      res["third_user_id"] = boost::any(*thirdUserId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("third_channel_type") != m.end() && !m["third_channel_type"].empty()) {
      thirdChannelType = make_shared<string>(boost::any_cast<string>(m["third_channel_type"]));
    }
    if (m.find("third_user_id") != m.end() && !m["third_user_id"].empty()) {
      thirdUserId = make_shared<string>(boost::any_cast<string>(m["third_user_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~SyncThirdUserMappingRequest() = default;
};
class SyncThirdUserMappingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  SyncThirdUserMappingResponseBody() {}

  explicit SyncThirdUserMappingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~SyncThirdUserMappingResponseBody() = default;
};
class SyncThirdUserMappingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncThirdUserMappingResponseBody> body{};

  SyncThirdUserMappingResponse() {}

  explicit SyncThirdUserMappingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncThirdUserMappingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncThirdUserMappingResponseBody>(model1);
      }
    }
  }


  virtual ~SyncThirdUserMappingResponse() = default;
};
class TBAccountInfoQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TBAccountInfoQueryHeaders() {}

  explicit TBAccountInfoQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TBAccountInfoQueryHeaders() = default;
};
class TBAccountInfoQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> tbAccount{};
  shared_ptr<bool> tbBond{};

  TBAccountInfoQueryResponseBodyModule() {}

  explicit TBAccountInfoQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tbAccount) {
      res["tb_account"] = boost::any(*tbAccount);
    }
    if (tbBond) {
      res["tb_bond"] = boost::any(*tbBond);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tb_account") != m.end() && !m["tb_account"].empty()) {
      tbAccount = make_shared<string>(boost::any_cast<string>(m["tb_account"]));
    }
    if (m.find("tb_bond") != m.end() && !m["tb_bond"].empty()) {
      tbBond = make_shared<bool>(boost::any_cast<bool>(m["tb_bond"]));
    }
  }


  virtual ~TBAccountInfoQueryResponseBodyModule() = default;
};
class TBAccountInfoQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TBAccountInfoQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TBAccountInfoQueryResponseBody() {}

  explicit TBAccountInfoQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TBAccountInfoQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TBAccountInfoQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TBAccountInfoQueryResponseBody() = default;
};
class TBAccountInfoQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TBAccountInfoQueryResponseBody> body{};

  TBAccountInfoQueryResponse() {}

  explicit TBAccountInfoQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TBAccountInfoQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TBAccountInfoQueryResponseBody>(model1);
      }
    }
  }


  virtual ~TBAccountInfoQueryResponse() = default;
};
class TBAccountUnbindHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TBAccountUnbindHeaders() {}

  explicit TBAccountUnbindHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TBAccountUnbindHeaders() = default;
};
class TBAccountUnbindResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TBAccountUnbindResponseBody() {}

  explicit TBAccountUnbindResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = boost::any(*module);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      module = make_shared<bool>(boost::any_cast<bool>(m["module"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TBAccountUnbindResponseBody() = default;
};
class TBAccountUnbindResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TBAccountUnbindResponseBody> body{};

  TBAccountUnbindResponse() {}

  explicit TBAccountUnbindResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TBAccountUnbindResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TBAccountUnbindResponseBody>(model1);
      }
    }
  }


  virtual ~TBAccountUnbindResponse() = default;
};
class TicketChangingApplyHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TicketChangingApplyHeaders() {}

  explicit TicketChangingApplyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TicketChangingApplyHeaders() = default;
};
class TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList : public Darabonba::Model {
public:
  shared_ptr<string> originFlightNo{};
  shared_ptr<string> outUserId{};
  shared_ptr<string> passengerName{};

  TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList() {}

  explicit TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originFlightNo) {
      res["origin_flight_no"] = boost::any(*originFlightNo);
    }
    if (outUserId) {
      res["out_user_id"] = boost::any(*outUserId);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("origin_flight_no") != m.end() && !m["origin_flight_no"].empty()) {
      originFlightNo = make_shared<string>(boost::any_cast<string>(m["origin_flight_no"]));
    }
    if (m.find("out_user_id") != m.end() && !m["out_user_id"].empty()) {
      outUserId = make_shared<string>(boost::any_cast<string>(m["out_user_id"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
  }


  virtual ~TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList() = default;
};
class TicketChangingApplyRequestModifyFlightInfoList : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> cabin{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depDate{};
  shared_ptr<string> flightNo{};
  shared_ptr<vector<TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList>> passengerInfoList{};

  TicketChangingApplyRequestModifyFlightInfoList() {}

  explicit TicketChangingApplyRequestModifyFlightInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (passengerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("passenger_info_list") != m.end() && !m["passenger_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_info_list"].type()) {
        vector<TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerInfoList = make_shared<vector<TicketChangingApplyRequestModifyFlightInfoListPassengerInfoList>>(expect1);
      }
    }
  }


  virtual ~TicketChangingApplyRequestModifyFlightInfoList() = default;
};
class TicketChangingApplyRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<vector<TicketChangingApplyRequestModifyFlightInfoList>> modifyFlightInfoList{};
  shared_ptr<string> otaItemId{};
  shared_ptr<string> reason{};
  shared_ptr<string> sessionId{};
  shared_ptr<bool> whetherRetry{};

  TicketChangingApplyRequest() {}

  explicit TicketChangingApplyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (modifyFlightInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*modifyFlightInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["modify_flight_info_list"] = boost::any(temp1);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (whetherRetry) {
      res["whether_retry"] = boost::any(*whetherRetry);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("modify_flight_info_list") != m.end() && !m["modify_flight_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["modify_flight_info_list"].type()) {
        vector<TicketChangingApplyRequestModifyFlightInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["modify_flight_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingApplyRequestModifyFlightInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modifyFlightInfoList = make_shared<vector<TicketChangingApplyRequestModifyFlightInfoList>>(expect1);
      }
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("whether_retry") != m.end() && !m["whether_retry"].empty()) {
      whetherRetry = make_shared<bool>(boost::any_cast<bool>(m["whether_retry"]));
    }
  }


  virtual ~TicketChangingApplyRequest() = default;
};
class TicketChangingApplyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<string> modifyFlightInfoListShrink{};
  shared_ptr<string> otaItemId{};
  shared_ptr<string> reason{};
  shared_ptr<string> sessionId{};
  shared_ptr<bool> whetherRetry{};

  TicketChangingApplyShrinkRequest() {}

  explicit TicketChangingApplyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (modifyFlightInfoListShrink) {
      res["modify_flight_info_list"] = boost::any(*modifyFlightInfoListShrink);
    }
    if (otaItemId) {
      res["ota_item_id"] = boost::any(*otaItemId);
    }
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (whetherRetry) {
      res["whether_retry"] = boost::any(*whetherRetry);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("modify_flight_info_list") != m.end() && !m["modify_flight_info_list"].empty()) {
      modifyFlightInfoListShrink = make_shared<string>(boost::any_cast<string>(m["modify_flight_info_list"]));
    }
    if (m.find("ota_item_id") != m.end() && !m["ota_item_id"].empty()) {
      otaItemId = make_shared<string>(boost::any_cast<string>(m["ota_item_id"]));
    }
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("whether_retry") != m.end() && !m["whether_retry"].empty()) {
      whetherRetry = make_shared<bool>(boost::any_cast<bool>(m["whether_retry"]));
    }
  }


  virtual ~TicketChangingApplyShrinkRequest() = default;
};
class TicketChangingApplyResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> bookingChangedTotalFee{};
  shared_ptr<long> bookingOriginTotalFee{};
  shared_ptr<bool> bookingPriceChanged{};
  shared_ptr<long> btripOrderId{};
  shared_ptr<long> btripSubOrderId{};
  shared_ptr<bool> canPay{};
  shared_ptr<long> changeFee{};
  shared_ptr<string> deadlineTime{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<long> maxRetryTimes{};
  shared_ptr<long> nextRetryInterval{};
  shared_ptr<bool> retry{};
  shared_ptr<string> retryClientTips{};
  shared_ptr<long> status{};
  shared_ptr<long> upgradeFee{};

  TicketChangingApplyResponseBodyModule() {}

  explicit TicketChangingApplyResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bookingChangedTotalFee) {
      res["booking_changed_total_fee"] = boost::any(*bookingChangedTotalFee);
    }
    if (bookingOriginTotalFee) {
      res["booking_origin_total_fee"] = boost::any(*bookingOriginTotalFee);
    }
    if (bookingPriceChanged) {
      res["booking_price_changed"] = boost::any(*bookingPriceChanged);
    }
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (btripSubOrderId) {
      res["btrip_sub_order_id"] = boost::any(*btripSubOrderId);
    }
    if (canPay) {
      res["can_pay"] = boost::any(*canPay);
    }
    if (changeFee) {
      res["change_fee"] = boost::any(*changeFee);
    }
    if (deadlineTime) {
      res["deadline_time"] = boost::any(*deadlineTime);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (maxRetryTimes) {
      res["max_retry_times"] = boost::any(*maxRetryTimes);
    }
    if (nextRetryInterval) {
      res["next_retry_interval"] = boost::any(*nextRetryInterval);
    }
    if (retry) {
      res["retry"] = boost::any(*retry);
    }
    if (retryClientTips) {
      res["retry_client_tips"] = boost::any(*retryClientTips);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (upgradeFee) {
      res["upgrade_fee"] = boost::any(*upgradeFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("booking_changed_total_fee") != m.end() && !m["booking_changed_total_fee"].empty()) {
      bookingChangedTotalFee = make_shared<long>(boost::any_cast<long>(m["booking_changed_total_fee"]));
    }
    if (m.find("booking_origin_total_fee") != m.end() && !m["booking_origin_total_fee"].empty()) {
      bookingOriginTotalFee = make_shared<long>(boost::any_cast<long>(m["booking_origin_total_fee"]));
    }
    if (m.find("booking_price_changed") != m.end() && !m["booking_price_changed"].empty()) {
      bookingPriceChanged = make_shared<bool>(boost::any_cast<bool>(m["booking_price_changed"]));
    }
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_order_id"]));
    }
    if (m.find("btrip_sub_order_id") != m.end() && !m["btrip_sub_order_id"].empty()) {
      btripSubOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_sub_order_id"]));
    }
    if (m.find("can_pay") != m.end() && !m["can_pay"].empty()) {
      canPay = make_shared<bool>(boost::any_cast<bool>(m["can_pay"]));
    }
    if (m.find("change_fee") != m.end() && !m["change_fee"].empty()) {
      changeFee = make_shared<long>(boost::any_cast<long>(m["change_fee"]));
    }
    if (m.find("deadline_time") != m.end() && !m["deadline_time"].empty()) {
      deadlineTime = make_shared<string>(boost::any_cast<string>(m["deadline_time"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("max_retry_times") != m.end() && !m["max_retry_times"].empty()) {
      maxRetryTimes = make_shared<long>(boost::any_cast<long>(m["max_retry_times"]));
    }
    if (m.find("next_retry_interval") != m.end() && !m["next_retry_interval"].empty()) {
      nextRetryInterval = make_shared<long>(boost::any_cast<long>(m["next_retry_interval"]));
    }
    if (m.find("retry") != m.end() && !m["retry"].empty()) {
      retry = make_shared<bool>(boost::any_cast<bool>(m["retry"]));
    }
    if (m.find("retry_client_tips") != m.end() && !m["retry_client_tips"].empty()) {
      retryClientTips = make_shared<string>(boost::any_cast<string>(m["retry_client_tips"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("upgrade_fee") != m.end() && !m["upgrade_fee"].empty()) {
      upgradeFee = make_shared<long>(boost::any_cast<long>(m["upgrade_fee"]));
    }
  }


  virtual ~TicketChangingApplyResponseBodyModule() = default;
};
class TicketChangingApplyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TicketChangingApplyResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TicketChangingApplyResponseBody() {}

  explicit TicketChangingApplyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TicketChangingApplyResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TicketChangingApplyResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TicketChangingApplyResponseBody() = default;
};
class TicketChangingApplyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TicketChangingApplyResponseBody> body{};

  TicketChangingApplyResponse() {}

  explicit TicketChangingApplyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TicketChangingApplyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TicketChangingApplyResponseBody>(model1);
      }
    }
  }


  virtual ~TicketChangingApplyResponse() = default;
};
class TicketChangingCancelHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TicketChangingCancelHeaders() {}

  explicit TicketChangingCancelHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TicketChangingCancelHeaders() = default;
};
class TicketChangingCancelRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};

  TicketChangingCancelRequest() {}

  explicit TicketChangingCancelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
  }


  virtual ~TicketChangingCancelRequest() = default;
};
class TicketChangingCancelResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> cancelTime{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<string> status{};

  TicketChangingCancelResponseBodyModule() {}

  explicit TicketChangingCancelResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelTime) {
      res["cancel_time"] = boost::any(*cancelTime);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cancel_time") != m.end() && !m["cancel_time"].empty()) {
      cancelTime = make_shared<string>(boost::any_cast<string>(m["cancel_time"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~TicketChangingCancelResponseBodyModule() = default;
};
class TicketChangingCancelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TicketChangingCancelResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TicketChangingCancelResponseBody() {}

  explicit TicketChangingCancelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TicketChangingCancelResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TicketChangingCancelResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TicketChangingCancelResponseBody() = default;
};
class TicketChangingCancelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TicketChangingCancelResponseBody> body{};

  TicketChangingCancelResponse() {}

  explicit TicketChangingCancelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TicketChangingCancelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TicketChangingCancelResponseBody>(model1);
      }
    }
  }


  virtual ~TicketChangingCancelResponse() = default;
};
class TicketChangingDetailHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TicketChangingDetailHeaders() {}

  explicit TicketChangingDetailHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TicketChangingDetailHeaders() = default;
};
class TicketChangingDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};

  TicketChangingDetailRequest() {}

  explicit TicketChangingDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
  }


  virtual ~TicketChangingDetailRequest() = default;
};
class TicketChangingDetailResponseBodyModuleFlightInfoList : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};
  shared_ptr<string> arrAirport{};
  shared_ptr<string> arrAirportCode{};
  shared_ptr<string> arrAirportCodeName{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrTerminal{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> baggage{};
  shared_ptr<long> buildPrice{};
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> carrier{};
  shared_ptr<string> depAirport{};
  shared_ptr<string> depAirportCode{};
  shared_ptr<string> depAirportCodeName{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depTerminal{};
  shared_ptr<string> depTime{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> lastCabin{};
  shared_ptr<string> lastFlightNo{};
  shared_ptr<string> meal{};
  shared_ptr<long> oilPrice{};
  shared_ptr<long> segmentType{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopDepTime{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<string> tuigaiqianInfo{};

  TicketChangingDetailResponseBodyModuleFlightInfoList() {}

  explicit TicketChangingDetailResponseBodyModuleFlightInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    if (arrAirport) {
      res["arr_airport"] = boost::any(*arrAirport);
    }
    if (arrAirportCode) {
      res["arr_airport_code"] = boost::any(*arrAirportCode);
    }
    if (arrAirportCodeName) {
      res["arr_airport_code_name"] = boost::any(*arrAirportCodeName);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrTerminal) {
      res["arr_terminal"] = boost::any(*arrTerminal);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (baggage) {
      res["baggage"] = boost::any(*baggage);
    }
    if (buildPrice) {
      res["build_price"] = boost::any(*buildPrice);
    }
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (carrier) {
      res["carrier"] = boost::any(*carrier);
    }
    if (depAirport) {
      res["dep_airport"] = boost::any(*depAirport);
    }
    if (depAirportCode) {
      res["dep_airport_code"] = boost::any(*depAirportCode);
    }
    if (depAirportCodeName) {
      res["dep_airport_code_name"] = boost::any(*depAirportCodeName);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depTerminal) {
      res["dep_terminal"] = boost::any(*depTerminal);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (lastCabin) {
      res["last_cabin"] = boost::any(*lastCabin);
    }
    if (lastFlightNo) {
      res["last_flight_no"] = boost::any(*lastFlightNo);
    }
    if (meal) {
      res["meal"] = boost::any(*meal);
    }
    if (oilPrice) {
      res["oil_price"] = boost::any(*oilPrice);
    }
    if (segmentType) {
      res["segment_type"] = boost::any(*segmentType);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (tuigaiqianInfo) {
      res["tuigaiqian_info"] = boost::any(*tuigaiqianInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
    if (m.find("arr_airport") != m.end() && !m["arr_airport"].empty()) {
      arrAirport = make_shared<string>(boost::any_cast<string>(m["arr_airport"]));
    }
    if (m.find("arr_airport_code") != m.end() && !m["arr_airport_code"].empty()) {
      arrAirportCode = make_shared<string>(boost::any_cast<string>(m["arr_airport_code"]));
    }
    if (m.find("arr_airport_code_name") != m.end() && !m["arr_airport_code_name"].empty()) {
      arrAirportCodeName = make_shared<string>(boost::any_cast<string>(m["arr_airport_code_name"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_terminal") != m.end() && !m["arr_terminal"].empty()) {
      arrTerminal = make_shared<string>(boost::any_cast<string>(m["arr_terminal"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("baggage") != m.end() && !m["baggage"].empty()) {
      baggage = make_shared<string>(boost::any_cast<string>(m["baggage"]));
    }
    if (m.find("build_price") != m.end() && !m["build_price"].empty()) {
      buildPrice = make_shared<long>(boost::any_cast<long>(m["build_price"]));
    }
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("carrier") != m.end() && !m["carrier"].empty()) {
      carrier = make_shared<string>(boost::any_cast<string>(m["carrier"]));
    }
    if (m.find("dep_airport") != m.end() && !m["dep_airport"].empty()) {
      depAirport = make_shared<string>(boost::any_cast<string>(m["dep_airport"]));
    }
    if (m.find("dep_airport_code") != m.end() && !m["dep_airport_code"].empty()) {
      depAirportCode = make_shared<string>(boost::any_cast<string>(m["dep_airport_code"]));
    }
    if (m.find("dep_airport_code_name") != m.end() && !m["dep_airport_code_name"].empty()) {
      depAirportCodeName = make_shared<string>(boost::any_cast<string>(m["dep_airport_code_name"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_terminal") != m.end() && !m["dep_terminal"].empty()) {
      depTerminal = make_shared<string>(boost::any_cast<string>(m["dep_terminal"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("last_cabin") != m.end() && !m["last_cabin"].empty()) {
      lastCabin = make_shared<string>(boost::any_cast<string>(m["last_cabin"]));
    }
    if (m.find("last_flight_no") != m.end() && !m["last_flight_no"].empty()) {
      lastFlightNo = make_shared<string>(boost::any_cast<string>(m["last_flight_no"]));
    }
    if (m.find("meal") != m.end() && !m["meal"].empty()) {
      meal = make_shared<string>(boost::any_cast<string>(m["meal"]));
    }
    if (m.find("oil_price") != m.end() && !m["oil_price"].empty()) {
      oilPrice = make_shared<long>(boost::any_cast<long>(m["oil_price"]));
    }
    if (m.find("segment_type") != m.end() && !m["segment_type"].empty()) {
      segmentType = make_shared<long>(boost::any_cast<long>(m["segment_type"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("tuigaiqian_info") != m.end() && !m["tuigaiqian_info"].empty()) {
      tuigaiqianInfo = make_shared<string>(boost::any_cast<string>(m["tuigaiqian_info"]));
    }
  }


  virtual ~TicketChangingDetailResponseBodyModuleFlightInfoList() = default;
};
class TicketChangingDetailResponseBodyModuleTravelerInfoList : public Darabonba::Model {
public:
  shared_ptr<string> birthDate{};
  shared_ptr<string> certNo{};
  shared_ptr<string> certType{};
  shared_ptr<long> openTicketStatus{};
  shared_ptr<string> passengerName{};
  shared_ptr<string> passengerType{};
  shared_ptr<string> phone{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> userId{};

  TicketChangingDetailResponseBodyModuleTravelerInfoList() {}

  explicit TicketChangingDetailResponseBodyModuleTravelerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (birthDate) {
      res["birth_date"] = boost::any(*birthDate);
    }
    if (certNo) {
      res["cert_no"] = boost::any(*certNo);
    }
    if (certType) {
      res["cert_type"] = boost::any(*certType);
    }
    if (openTicketStatus) {
      res["open_ticket_status"] = boost::any(*openTicketStatus);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("birth_date") != m.end() && !m["birth_date"].empty()) {
      birthDate = make_shared<string>(boost::any_cast<string>(m["birth_date"]));
    }
    if (m.find("cert_no") != m.end() && !m["cert_no"].empty()) {
      certNo = make_shared<string>(boost::any_cast<string>(m["cert_no"]));
    }
    if (m.find("cert_type") != m.end() && !m["cert_type"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["cert_type"]));
    }
    if (m.find("open_ticket_status") != m.end() && !m["open_ticket_status"].empty()) {
      openTicketStatus = make_shared<long>(boost::any_cast<long>(m["open_ticket_status"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<string>(boost::any_cast<string>(m["passenger_type"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TicketChangingDetailResponseBodyModuleTravelerInfoList() = default;
};
class TicketChangingDetailResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<long> btripOrderId{};
  shared_ptr<long> btripSubOrderId{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<string> extra{};
  shared_ptr<vector<TicketChangingDetailResponseBodyModuleFlightInfoList>> flightInfoList{};
  shared_ptr<string> lastPayTime{};
  shared_ptr<long> payStatus{};
  shared_ptr<string> payTime{};
  shared_ptr<long> settlePrice{};
  shared_ptr<long> settleType{};
  shared_ptr<long> status{};
  shared_ptr<long> totalChangePrice{};
  shared_ptr<long> totalPrice{};
  shared_ptr<long> totalUpgradePrice{};
  shared_ptr<vector<TicketChangingDetailResponseBodyModuleTravelerInfoList>> travelerInfoList{};

  TicketChangingDetailResponseBodyModule() {}

  explicit TicketChangingDetailResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (btripOrderId) {
      res["btrip_order_id"] = boost::any(*btripOrderId);
    }
    if (btripSubOrderId) {
      res["btrip_sub_order_id"] = boost::any(*btripSubOrderId);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (flightInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_info_list"] = boost::any(temp1);
    }
    if (lastPayTime) {
      res["last_pay_time"] = boost::any(*lastPayTime);
    }
    if (payStatus) {
      res["pay_status"] = boost::any(*payStatus);
    }
    if (payTime) {
      res["pay_time"] = boost::any(*payTime);
    }
    if (settlePrice) {
      res["settle_price"] = boost::any(*settlePrice);
    }
    if (settleType) {
      res["settle_type"] = boost::any(*settleType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (totalChangePrice) {
      res["total_change_price"] = boost::any(*totalChangePrice);
    }
    if (totalPrice) {
      res["total_price"] = boost::any(*totalPrice);
    }
    if (totalUpgradePrice) {
      res["total_upgrade_price"] = boost::any(*totalUpgradePrice);
    }
    if (travelerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("btrip_order_id") != m.end() && !m["btrip_order_id"].empty()) {
      btripOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_order_id"]));
    }
    if (m.find("btrip_sub_order_id") != m.end() && !m["btrip_sub_order_id"].empty()) {
      btripSubOrderId = make_shared<long>(boost::any_cast<long>(m["btrip_sub_order_id"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("flight_info_list") != m.end() && !m["flight_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_info_list"].type()) {
        vector<TicketChangingDetailResponseBodyModuleFlightInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingDetailResponseBodyModuleFlightInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightInfoList = make_shared<vector<TicketChangingDetailResponseBodyModuleFlightInfoList>>(expect1);
      }
    }
    if (m.find("last_pay_time") != m.end() && !m["last_pay_time"].empty()) {
      lastPayTime = make_shared<string>(boost::any_cast<string>(m["last_pay_time"]));
    }
    if (m.find("pay_status") != m.end() && !m["pay_status"].empty()) {
      payStatus = make_shared<long>(boost::any_cast<long>(m["pay_status"]));
    }
    if (m.find("pay_time") != m.end() && !m["pay_time"].empty()) {
      payTime = make_shared<string>(boost::any_cast<string>(m["pay_time"]));
    }
    if (m.find("settle_price") != m.end() && !m["settle_price"].empty()) {
      settlePrice = make_shared<long>(boost::any_cast<long>(m["settle_price"]));
    }
    if (m.find("settle_type") != m.end() && !m["settle_type"].empty()) {
      settleType = make_shared<long>(boost::any_cast<long>(m["settle_type"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("total_change_price") != m.end() && !m["total_change_price"].empty()) {
      totalChangePrice = make_shared<long>(boost::any_cast<long>(m["total_change_price"]));
    }
    if (m.find("total_price") != m.end() && !m["total_price"].empty()) {
      totalPrice = make_shared<long>(boost::any_cast<long>(m["total_price"]));
    }
    if (m.find("total_upgrade_price") != m.end() && !m["total_upgrade_price"].empty()) {
      totalUpgradePrice = make_shared<long>(boost::any_cast<long>(m["total_upgrade_price"]));
    }
    if (m.find("traveler_info_list") != m.end() && !m["traveler_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_info_list"].type()) {
        vector<TicketChangingDetailResponseBodyModuleTravelerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingDetailResponseBodyModuleTravelerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerInfoList = make_shared<vector<TicketChangingDetailResponseBodyModuleTravelerInfoList>>(expect1);
      }
    }
  }


  virtual ~TicketChangingDetailResponseBodyModule() = default;
};
class TicketChangingDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TicketChangingDetailResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TicketChangingDetailResponseBody() {}

  explicit TicketChangingDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TicketChangingDetailResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TicketChangingDetailResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TicketChangingDetailResponseBody() = default;
};
class TicketChangingDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TicketChangingDetailResponseBody> body{};

  TicketChangingDetailResponse() {}

  explicit TicketChangingDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TicketChangingDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TicketChangingDetailResponseBody>(model1);
      }
    }
  }


  virtual ~TicketChangingDetailResponse() = default;
};
class TicketChangingEnquiryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TicketChangingEnquiryHeaders() {}

  explicit TicketChangingEnquiryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TicketChangingEnquiryHeaders() = default;
};
class TicketChangingEnquiryRequest : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> depCity{};
  shared_ptr<string> disOrderId{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<string> modifyDepartDate{};
  shared_ptr<string> modifyFlightNo{};
  shared_ptr<string> sessionId{};

  TicketChangingEnquiryRequest() {}

  explicit TicketChangingEnquiryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (modifyDepartDate) {
      res["modify_depart_date"] = boost::any(*modifyDepartDate);
    }
    if (modifyFlightNo) {
      res["modify_flight_no"] = boost::any(*modifyFlightNo);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("modify_depart_date") != m.end() && !m["modify_depart_date"].empty()) {
      modifyDepartDate = make_shared<string>(boost::any_cast<string>(m["modify_depart_date"]));
    }
    if (m.find("modify_flight_no") != m.end() && !m["modify_flight_no"].empty()) {
      modifyFlightNo = make_shared<string>(boost::any_cast<string>(m["modify_flight_no"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
  }


  virtual ~TicketChangingEnquiryRequest() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListAirlineInfo() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListAirlineInfo() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListArrAirportInfo() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListArrAirportInfo() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesDescription : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> icon{};
  shared_ptr<string> image{};
  shared_ptr<string> title{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesDescription() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesDescription() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesImageDO : public Darabonba::Model {
public:
  shared_ptr<string> image{};
  shared_ptr<string> largest{};
  shared_ptr<string> middle{};
  shared_ptr<string> smallest{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesImageDO() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesImageDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (image) {
      res["image"] = boost::any(*image);
    }
    if (largest) {
      res["largest"] = boost::any(*largest);
    }
    if (middle) {
      res["middle"] = boost::any(*middle);
    }
    if (smallest) {
      res["smallest"] = boost::any(*smallest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("image") != m.end() && !m["image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["image"]));
    }
    if (m.find("largest") != m.end() && !m["largest"].empty()) {
      largest = make_shared<string>(boost::any_cast<string>(m["largest"]));
    }
    if (m.find("middle") != m.end() && !m["middle"].empty()) {
      middle = make_shared<string>(boost::any_cast<string>(m["middle"]));
    }
    if (m.find("smallest") != m.end() && !m["smallest"].empty()) {
      smallest = make_shared<string>(boost::any_cast<string>(m["smallest"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesImageDO() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> baggageDesc{};
  shared_ptr<long> baggageSubContentType{};
  shared_ptr<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesDescription> description{};
  shared_ptr<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesImageDO> imageDO{};
  shared_ptr<bool> isHighlight{};
  shared_ptr<string> subTitle{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (baggageSubContentType) {
      res["baggage_sub_content_type"] = boost::any(*baggageSubContentType);
    }
    if (description) {
      res["description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageDO) {
      res["imageDO"] = imageDO ? boost::any(imageDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isHighlight) {
      res["is_highlight"] = boost::any(*isHighlight);
    }
    if (subTitle) {
      res["subTitle"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["baggage_desc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["baggage_desc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      baggageDesc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("baggage_sub_content_type") != m.end() && !m["baggage_sub_content_type"].empty()) {
      baggageSubContentType = make_shared<long>(boost::any_cast<long>(m["baggage_sub_content_type"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      if (typeid(map<string, boost::any>) == m["description"].type()) {
        TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["description"]));
        description = make_shared<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesDescription>(model1);
      }
    }
    if (m.find("imageDO") != m.end() && !m["imageDO"].empty()) {
      if (typeid(map<string, boost::any>) == m["imageDO"].type()) {
        TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesImageDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["imageDO"]));
        imageDO = make_shared<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizesImageDO>(model1);
      }
    }
    if (m.find("is_highlight") != m.end() && !m["is_highlight"].empty()) {
      isHighlight = make_shared<bool>(boost::any_cast<bool>(m["is_highlight"]));
    }
    if (m.find("subTitle") != m.end() && !m["subTitle"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["subTitle"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents : public Darabonba::Model {
public:
  shared_ptr<string> baggageDesc{};
  shared_ptr<string> icon{};
  shared_ptr<long> style{};
  shared_ptr<string> subTitle{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDesc) {
      res["baggage_desc"] = boost::any(*baggageDesc);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    if (subTitle) {
      res["sub_title"] = boost::any(*subTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_desc") != m.end() && !m["baggage_desc"].empty()) {
      baggageDesc = make_shared<string>(boost::any_cast<string>(m["baggage_desc"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<long>(boost::any_cast<long>(m["style"]));
    }
    if (m.find("sub_title") != m.end() && !m["sub_title"].empty()) {
      subTitle = make_shared<string>(boost::any_cast<string>(m["sub_title"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> attributes{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes>> baggageSubContentVisualizes{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents>> baggageSubContents{};
  shared_ptr<string> content{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<string> title{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributes) {
      res["attributes"] = boost::any(*attributes);
    }
    if (baggageSubContentVisualizes) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContentVisualizes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_content_visualizes"] = boost::any(temp1);
    }
    if (baggageSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_contents"] = boost::any(temp1);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("attributes") != m.end() && !m["attributes"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["attributes"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      attributes = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("baggage_sub_content_visualizes") != m.end() && !m["baggage_sub_content_visualizes"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_content_visualizes"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_content_visualizes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContentVisualizes = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContentVisualizes>>(expect1);
      }
    }
    if (m.find("baggage_sub_contents") != m.end() && !m["baggage_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_contents"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubContents = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItemsBaggageSubContents>>(expect1);
      }
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsTips : public Darabonba::Model {
public:
  shared_ptr<string> logo{};
  shared_ptr<string> tipsDesc{};
  shared_ptr<string> tipsImage{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsTips() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsTips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logo) {
      res["logo"] = boost::any(*logo);
    }
    if (tipsDesc) {
      res["tips_desc"] = boost::any(*tipsDesc);
    }
    if (tipsImage) {
      res["tips_image"] = boost::any(*tipsImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("logo") != m.end() && !m["logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["logo"]));
    }
    if (m.find("tips_desc") != m.end() && !m["tips_desc"].empty()) {
      tipsDesc = make_shared<string>(boost::any_cast<string>(m["tips_desc"]));
    }
    if (m.find("tips_image") != m.end() && !m["tips_image"].empty()) {
      tipsImage = make_shared<string>(boost::any_cast<string>(m["tips_image"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsTips() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails : public Darabonba::Model {
public:
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems>> baggageSubItems{};
  shared_ptr<long> index{};
  shared_ptr<string> tableHead{};
  shared_ptr<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsTips> tips{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*baggageSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_sub_items"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (tips) {
      res["tips"] = tips ? boost::any(tips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_sub_items") != m.end() && !m["baggage_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_sub_items"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageSubItems = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsBaggageSubItems>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("tips") != m.end() && !m["tips"].empty()) {
      if (typeid(map<string, boost::any>) == m["tips"].type()) {
        TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsTips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["tips"]));
        tips = make_shared<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetailsTips>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> icon{};
  shared_ptr<string> title{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<string> style{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<string>(boost::any_cast<string>(m["style"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails : public Darabonba::Model {
public:
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems>> refundSubItems{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetailsRefundSubItems>>(expect1);
      }
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> icon{};
  shared_ptr<string> title{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (icon) {
      res["icon"] = boost::any(*icon);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("icon") != m.end() && !m["icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["icon"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents : public Darabonba::Model {
public:
  shared_ptr<string> feeDesc{};
  shared_ptr<string> feeRange{};
  shared_ptr<string> style{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feeDesc) {
      res["fee_desc"] = boost::any(*feeDesc);
    }
    if (feeRange) {
      res["fee_range"] = boost::any(*feeRange);
    }
    if (style) {
      res["style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fee_desc") != m.end() && !m["fee_desc"].empty()) {
      feeDesc = make_shared<string>(boost::any_cast<string>(m["fee_desc"]));
    }
    if (m.find("fee_range") != m.end() && !m["fee_range"].empty()) {
      feeRange = make_shared<string>(boost::any_cast<string>(m["fee_range"]));
    }
    if (m.find("style") != m.end() && !m["style"].empty()) {
      style = make_shared<string>(boost::any_cast<string>(m["style"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<bool> isStruct{};
  shared_ptr<string> ptc{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents>> refundSubContents{};
  shared_ptr<string> title{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (isStruct) {
      res["is_struct"] = boost::any(*isStruct);
    }
    if (ptc) {
      res["ptc"] = boost::any(*ptc);
    }
    if (refundSubContents) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_contents"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("is_struct") != m.end() && !m["is_struct"].empty()) {
      isStruct = make_shared<bool>(boost::any_cast<bool>(m["is_struct"]));
    }
    if (m.find("ptc") != m.end() && !m["ptc"].empty()) {
      ptc = make_shared<string>(boost::any_cast<string>(m["ptc"]));
    }
    if (m.find("refund_sub_contents") != m.end() && !m["refund_sub_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_contents"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubContents = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItemsRefundSubContents>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails : public Darabonba::Model {
public:
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents>> extraContents{};
  shared_ptr<long> index{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems>> refundSubItems{};
  shared_ptr<string> tableHead{};
  shared_ptr<string> title{};
  shared_ptr<long> type{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraContents) {
      vector<boost::any> temp1;
      for(auto item1:*extraContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extra_contents"] = boost::any(temp1);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (refundSubItems) {
      vector<boost::any> temp1;
      for(auto item1:*refundSubItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_sub_items"] = boost::any(temp1);
    }
    if (tableHead) {
      res["table_head"] = boost::any(*tableHead);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extra_contents") != m.end() && !m["extra_contents"].empty()) {
      if (typeid(vector<boost::any>) == m["extra_contents"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extra_contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extraContents = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsExtraContents>>(expect1);
      }
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("refund_sub_items") != m.end() && !m["refund_sub_items"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_sub_items"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_sub_items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundSubItems = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetailsRefundSubItems>>(expect1);
      }
    }
    if (m.find("table_head") != m.end() && !m["table_head"].empty()) {
      tableHead = make_shared<string>(boost::any_cast<string>(m["table_head"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRq : public Darabonba::Model {
public:
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails>> baggageDetails{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails>> changeDetails{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails>> refundDetails{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRq() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRq(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baggageDetails) {
      vector<boost::any> temp1;
      for(auto item1:*baggageDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["baggage_details"] = boost::any(temp1);
    }
    if (changeDetails) {
      vector<boost::any> temp1;
      for(auto item1:*changeDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["change_details"] = boost::any(temp1);
    }
    if (refundDetails) {
      vector<boost::any> temp1;
      for(auto item1:*refundDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_details"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("baggage_details") != m.end() && !m["baggage_details"].empty()) {
      if (typeid(vector<boost::any>) == m["baggage_details"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["baggage_details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baggageDetails = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqBaggageDetails>>(expect1);
      }
    }
    if (m.find("change_details") != m.end() && !m["change_details"].empty()) {
      if (typeid(vector<boost::any>) == m["change_details"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["change_details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeDetails = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqChangeDetails>>(expect1);
      }
    }
    if (m.find("refund_details") != m.end() && !m["refund_details"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_details"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundDetails = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRqRefundDetails>>(expect1);
      }
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRq() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList : public Darabonba::Model {
public:
  shared_ptr<long> passengerType{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> upgradeFee{};
  shared_ptr<long> upgradePrice{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (upgradeFee) {
      res["upgrade_fee"] = boost::any(*upgradeFee);
    }
    if (upgradePrice) {
      res["upgrade_price"] = boost::any(*upgradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<long>(boost::any_cast<long>(m["passenger_type"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("upgrade_fee") != m.end() && !m["upgrade_fee"].empty()) {
      upgradeFee = make_shared<long>(boost::any_cast<long>(m["upgrade_fee"]));
    }
    if (m.find("upgrade_price") != m.end() && !m["upgrade_price"].empty()) {
      upgradePrice = make_shared<long>(boost::any_cast<long>(m["upgrade_price"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList : public Darabonba::Model {
public:
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinDesc{};
  shared_ptr<long> cabinDiscount{};
  shared_ptr<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRq> changeOtaItemRuleRq{};
  shared_ptr<string> childCabin{};
  shared_ptr<string> leftNum{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList>> modifyPriceList{};
  shared_ptr<string> otaItemid{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinDesc) {
      res["cabin_desc"] = boost::any(*cabinDesc);
    }
    if (cabinDiscount) {
      res["cabin_discount"] = boost::any(*cabinDiscount);
    }
    if (changeOtaItemRuleRq) {
      res["change_ota_item_rule_rq"] = changeOtaItemRuleRq ? boost::any(changeOtaItemRuleRq->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (childCabin) {
      res["child_cabin"] = boost::any(*childCabin);
    }
    if (leftNum) {
      res["left_num"] = boost::any(*leftNum);
    }
    if (modifyPriceList) {
      vector<boost::any> temp1;
      for(auto item1:*modifyPriceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["modify_price_list"] = boost::any(temp1);
    }
    if (otaItemid) {
      res["ota_itemid"] = boost::any(*otaItemid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_desc") != m.end() && !m["cabin_desc"].empty()) {
      cabinDesc = make_shared<string>(boost::any_cast<string>(m["cabin_desc"]));
    }
    if (m.find("cabin_discount") != m.end() && !m["cabin_discount"].empty()) {
      cabinDiscount = make_shared<long>(boost::any_cast<long>(m["cabin_discount"]));
    }
    if (m.find("change_ota_item_rule_rq") != m.end() && !m["change_ota_item_rule_rq"].empty()) {
      if (typeid(map<string, boost::any>) == m["change_ota_item_rule_rq"].type()) {
        TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRq model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["change_ota_item_rule_rq"]));
        changeOtaItemRuleRq = make_shared<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListChangeOtaItemRuleRq>(model1);
      }
    }
    if (m.find("child_cabin") != m.end() && !m["child_cabin"].empty()) {
      childCabin = make_shared<string>(boost::any_cast<string>(m["child_cabin"]));
    }
    if (m.find("left_num") != m.end() && !m["left_num"].empty()) {
      leftNum = make_shared<string>(boost::any_cast<string>(m["left_num"]));
    }
    if (m.find("modify_price_list") != m.end() && !m["modify_price_list"].empty()) {
      if (typeid(vector<boost::any>) == m["modify_price_list"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["modify_price_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modifyPriceList = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinListModifyPriceList>>(expect1);
      }
    }
    if (m.find("ota_itemid") != m.end() && !m["ota_itemid"].empty()) {
      otaItemid = make_shared<string>(boost::any_cast<string>(m["ota_itemid"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListDepAirportInfo() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListDepAirportInfo() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice : public Darabonba::Model {
public:
  shared_ptr<long> passengerType{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> upgradeFee{};
  shared_ptr<long> upgradePrice{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (upgradeFee) {
      res["upgrade_fee"] = boost::any(*upgradeFee);
    }
    if (upgradePrice) {
      res["upgrade_price"] = boost::any(*upgradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<long>(boost::any_cast<long>(m["passenger_type"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("upgrade_fee") != m.end() && !m["upgrade_fee"].empty()) {
      upgradeFee = make_shared<long>(boost::any_cast<long>(m["upgrade_fee"]));
    }
    if (m.find("upgrade_price") != m.end() && !m["upgrade_price"].empty()) {
      upgradePrice = make_shared<long>(boost::any_cast<long>(m["upgrade_price"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice() = default;
};
class TicketChangingEnquiryResponseBodyModuleFlightInfoList : public Darabonba::Model {
public:
  shared_ptr<TicketChangingEnquiryResponseBodyModuleFlightInfoListAirlineInfo> airlineInfo{};
  shared_ptr<TicketChangingEnquiryResponseBodyModuleFlightInfoListArrAirportInfo> arrAirportInfo{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList>> cabinList{};
  shared_ptr<string> carrierAirline{};
  shared_ptr<string> carrierNo{};
  shared_ptr<TicketChangingEnquiryResponseBodyModuleFlightInfoListDepAirportInfo> depAirportInfo{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> flightNo{};
  shared_ptr<bool> isShare{};
  shared_ptr<string> lowestCabin{};
  shared_ptr<string> lowestCabinClass{};
  shared_ptr<string> lowestCabinDesc{};
  shared_ptr<string> lowestCabinNum{};
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice>> lowestCabinPrice{};
  shared_ptr<string> modifyFlightArrTime{};
  shared_ptr<string> modifyFlightDepDate{};
  shared_ptr<string> modifyFlightDepTime{};
  shared_ptr<string> sessionId{};

  TicketChangingEnquiryResponseBodyModuleFlightInfoList() {}

  explicit TicketChangingEnquiryResponseBodyModuleFlightInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cabinList) {
      vector<boost::any> temp1;
      for(auto item1:*cabinList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cabin_list"] = boost::any(temp1);
    }
    if (carrierAirline) {
      res["carrier_airline"] = boost::any(*carrierAirline);
    }
    if (carrierNo) {
      res["carrier_no"] = boost::any(*carrierNo);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (isShare) {
      res["is_share"] = boost::any(*isShare);
    }
    if (lowestCabin) {
      res["lowest_cabin"] = boost::any(*lowestCabin);
    }
    if (lowestCabinClass) {
      res["lowest_cabin_class"] = boost::any(*lowestCabinClass);
    }
    if (lowestCabinDesc) {
      res["lowest_cabin_desc"] = boost::any(*lowestCabinDesc);
    }
    if (lowestCabinNum) {
      res["lowest_cabin_num"] = boost::any(*lowestCabinNum);
    }
    if (lowestCabinPrice) {
      vector<boost::any> temp1;
      for(auto item1:*lowestCabinPrice){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["lowest_cabin_price"] = boost::any(temp1);
    }
    if (modifyFlightArrTime) {
      res["modify_flight_arr_time"] = boost::any(*modifyFlightArrTime);
    }
    if (modifyFlightDepDate) {
      res["modify_flight_dep_date"] = boost::any(*modifyFlightDepDate);
    }
    if (modifyFlightDepTime) {
      res["modify_flight_dep_time"] = boost::any(*modifyFlightDepTime);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        TicketChangingEnquiryResponseBodyModuleFlightInfoListAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<TicketChangingEnquiryResponseBodyModuleFlightInfoListAirlineInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        TicketChangingEnquiryResponseBodyModuleFlightInfoListArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<TicketChangingEnquiryResponseBodyModuleFlightInfoListArrAirportInfo>(model1);
      }
    }
    if (m.find("cabin_list") != m.end() && !m["cabin_list"].empty()) {
      if (typeid(vector<boost::any>) == m["cabin_list"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cabin_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cabinList = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListCabinList>>(expect1);
      }
    }
    if (m.find("carrier_airline") != m.end() && !m["carrier_airline"].empty()) {
      carrierAirline = make_shared<string>(boost::any_cast<string>(m["carrier_airline"]));
    }
    if (m.find("carrier_no") != m.end() && !m["carrier_no"].empty()) {
      carrierNo = make_shared<string>(boost::any_cast<string>(m["carrier_no"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        TicketChangingEnquiryResponseBodyModuleFlightInfoListDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<TicketChangingEnquiryResponseBodyModuleFlightInfoListDepAirportInfo>(model1);
      }
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("is_share") != m.end() && !m["is_share"].empty()) {
      isShare = make_shared<bool>(boost::any_cast<bool>(m["is_share"]));
    }
    if (m.find("lowest_cabin") != m.end() && !m["lowest_cabin"].empty()) {
      lowestCabin = make_shared<string>(boost::any_cast<string>(m["lowest_cabin"]));
    }
    if (m.find("lowest_cabin_class") != m.end() && !m["lowest_cabin_class"].empty()) {
      lowestCabinClass = make_shared<string>(boost::any_cast<string>(m["lowest_cabin_class"]));
    }
    if (m.find("lowest_cabin_desc") != m.end() && !m["lowest_cabin_desc"].empty()) {
      lowestCabinDesc = make_shared<string>(boost::any_cast<string>(m["lowest_cabin_desc"]));
    }
    if (m.find("lowest_cabin_num") != m.end() && !m["lowest_cabin_num"].empty()) {
      lowestCabinNum = make_shared<string>(boost::any_cast<string>(m["lowest_cabin_num"]));
    }
    if (m.find("lowest_cabin_price") != m.end() && !m["lowest_cabin_price"].empty()) {
      if (typeid(vector<boost::any>) == m["lowest_cabin_price"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["lowest_cabin_price"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lowestCabinPrice = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoListLowestCabinPrice>>(expect1);
      }
    }
    if (m.find("modify_flight_arr_time") != m.end() && !m["modify_flight_arr_time"].empty()) {
      modifyFlightArrTime = make_shared<string>(boost::any_cast<string>(m["modify_flight_arr_time"]));
    }
    if (m.find("modify_flight_dep_date") != m.end() && !m["modify_flight_dep_date"].empty()) {
      modifyFlightDepDate = make_shared<string>(boost::any_cast<string>(m["modify_flight_dep_date"]));
    }
    if (m.find("modify_flight_dep_time") != m.end() && !m["modify_flight_dep_time"].empty()) {
      modifyFlightDepTime = make_shared<string>(boost::any_cast<string>(m["modify_flight_dep_time"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModuleFlightInfoList() = default;
};
class TicketChangingEnquiryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoList>> flightInfoList{};

  TicketChangingEnquiryResponseBodyModule() {}

  explicit TicketChangingEnquiryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_info_list") != m.end() && !m["flight_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_info_list"].type()) {
        vector<TicketChangingEnquiryResponseBodyModuleFlightInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingEnquiryResponseBodyModuleFlightInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightInfoList = make_shared<vector<TicketChangingEnquiryResponseBodyModuleFlightInfoList>>(expect1);
      }
    }
  }


  virtual ~TicketChangingEnquiryResponseBodyModule() = default;
};
class TicketChangingEnquiryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TicketChangingEnquiryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TicketChangingEnquiryResponseBody() {}

  explicit TicketChangingEnquiryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TicketChangingEnquiryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TicketChangingEnquiryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TicketChangingEnquiryResponseBody() = default;
};
class TicketChangingEnquiryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TicketChangingEnquiryResponseBody> body{};

  TicketChangingEnquiryResponse() {}

  explicit TicketChangingEnquiryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TicketChangingEnquiryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TicketChangingEnquiryResponseBody>(model1);
      }
    }
  }


  virtual ~TicketChangingEnquiryResponse() = default;
};
class TicketChangingFlightListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TicketChangingFlightListHeaders() {}

  explicit TicketChangingFlightListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TicketChangingFlightListHeaders() = default;
};
class TicketChangingFlightListRequestTravelerInfoList : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> depCity{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> userId{};

  TicketChangingFlightListRequestTravelerInfoList() {}

  explicit TicketChangingFlightListRequestTravelerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TicketChangingFlightListRequestTravelerInfoList() = default;
};
class TicketChangingFlightListRequest : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depDate{};
  shared_ptr<string> disOrderId{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<vector<TicketChangingFlightListRequestTravelerInfoList>> travelerInfoList{};

  TicketChangingFlightListRequest() {}

  explicit TicketChangingFlightListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (travelerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*travelerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["traveler_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("traveler_info_list") != m.end() && !m["traveler_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["traveler_info_list"].type()) {
        vector<TicketChangingFlightListRequestTravelerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["traveler_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingFlightListRequestTravelerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        travelerInfoList = make_shared<vector<TicketChangingFlightListRequestTravelerInfoList>>(expect1);
      }
    }
  }


  virtual ~TicketChangingFlightListRequest() = default;
};
class TicketChangingFlightListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depDate{};
  shared_ptr<string> disOrderId{};
  shared_ptr<long> isVoluntary{};
  shared_ptr<string> travelerInfoListShrink{};

  TicketChangingFlightListShrinkRequest() {}

  explicit TicketChangingFlightListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depDate) {
      res["dep_date"] = boost::any(*depDate);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (isVoluntary) {
      res["is_voluntary"] = boost::any(*isVoluntary);
    }
    if (travelerInfoListShrink) {
      res["traveler_info_list"] = boost::any(*travelerInfoListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_date") != m.end() && !m["dep_date"].empty()) {
      depDate = make_shared<string>(boost::any_cast<string>(m["dep_date"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("is_voluntary") != m.end() && !m["is_voluntary"].empty()) {
      isVoluntary = make_shared<long>(boost::any_cast<long>(m["is_voluntary"]));
    }
    if (m.find("traveler_info_list") != m.end() && !m["traveler_info_list"].empty()) {
      travelerInfoListShrink = make_shared<string>(boost::any_cast<string>(m["traveler_info_list"]));
    }
  }


  virtual ~TicketChangingFlightListShrinkRequest() = default;
};
class TicketChangingFlightListResponseBodyModuleFlightInfoListAirlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> airlineCode{};
  shared_ptr<string> airlineName{};
  shared_ptr<string> airlineSimpleName{};

  TicketChangingFlightListResponseBodyModuleFlightInfoListAirlineInfo() {}

  explicit TicketChangingFlightListResponseBodyModuleFlightInfoListAirlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineCode) {
      res["airline_code"] = boost::any(*airlineCode);
    }
    if (airlineName) {
      res["airline_name"] = boost::any(*airlineName);
    }
    if (airlineSimpleName) {
      res["airline_simple_name"] = boost::any(*airlineSimpleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_code") != m.end() && !m["airline_code"].empty()) {
      airlineCode = make_shared<string>(boost::any_cast<string>(m["airline_code"]));
    }
    if (m.find("airline_name") != m.end() && !m["airline_name"].empty()) {
      airlineName = make_shared<string>(boost::any_cast<string>(m["airline_name"]));
    }
    if (m.find("airline_simple_name") != m.end() && !m["airline_simple_name"].empty()) {
      airlineSimpleName = make_shared<string>(boost::any_cast<string>(m["airline_simple_name"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModuleFlightInfoListAirlineInfo() = default;
};
class TicketChangingFlightListResponseBodyModuleFlightInfoListArrAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  TicketChangingFlightListResponseBodyModuleFlightInfoListArrAirportInfo() {}

  explicit TicketChangingFlightListResponseBodyModuleFlightInfoListArrAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModuleFlightInfoListArrAirportInfo() = default;
};
class TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList : public Darabonba::Model {
public:
  shared_ptr<long> passengerType{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> upgradeFee{};
  shared_ptr<long> upgradePrice{};

  TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList() {}

  explicit TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (upgradeFee) {
      res["upgrade_fee"] = boost::any(*upgradeFee);
    }
    if (upgradePrice) {
      res["upgrade_price"] = boost::any(*upgradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<long>(boost::any_cast<long>(m["passenger_type"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("upgrade_fee") != m.end() && !m["upgrade_fee"].empty()) {
      upgradeFee = make_shared<long>(boost::any_cast<long>(m["upgrade_fee"]));
    }
    if (m.find("upgrade_price") != m.end() && !m["upgrade_price"].empty()) {
      upgradePrice = make_shared<long>(boost::any_cast<long>(m["upgrade_price"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList() = default;
};
class TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList : public Darabonba::Model {
public:
  shared_ptr<string> cabin{};
  shared_ptr<string> cabinClass{};
  shared_ptr<string> cabinDesc{};
  shared_ptr<long> cabinDiscount{};
  shared_ptr<string> childCabin{};
  shared_ptr<string> leftNum{};
  shared_ptr<vector<TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList>> modifyPriceList{};
  shared_ptr<string> otaItemid{};

  TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList() {}

  explicit TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cabin) {
      res["cabin"] = boost::any(*cabin);
    }
    if (cabinClass) {
      res["cabin_class"] = boost::any(*cabinClass);
    }
    if (cabinDesc) {
      res["cabin_desc"] = boost::any(*cabinDesc);
    }
    if (cabinDiscount) {
      res["cabin_discount"] = boost::any(*cabinDiscount);
    }
    if (childCabin) {
      res["child_cabin"] = boost::any(*childCabin);
    }
    if (leftNum) {
      res["left_num"] = boost::any(*leftNum);
    }
    if (modifyPriceList) {
      vector<boost::any> temp1;
      for(auto item1:*modifyPriceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["modify_price_list"] = boost::any(temp1);
    }
    if (otaItemid) {
      res["ota_itemid"] = boost::any(*otaItemid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cabin") != m.end() && !m["cabin"].empty()) {
      cabin = make_shared<string>(boost::any_cast<string>(m["cabin"]));
    }
    if (m.find("cabin_class") != m.end() && !m["cabin_class"].empty()) {
      cabinClass = make_shared<string>(boost::any_cast<string>(m["cabin_class"]));
    }
    if (m.find("cabin_desc") != m.end() && !m["cabin_desc"].empty()) {
      cabinDesc = make_shared<string>(boost::any_cast<string>(m["cabin_desc"]));
    }
    if (m.find("cabin_discount") != m.end() && !m["cabin_discount"].empty()) {
      cabinDiscount = make_shared<long>(boost::any_cast<long>(m["cabin_discount"]));
    }
    if (m.find("child_cabin") != m.end() && !m["child_cabin"].empty()) {
      childCabin = make_shared<string>(boost::any_cast<string>(m["child_cabin"]));
    }
    if (m.find("left_num") != m.end() && !m["left_num"].empty()) {
      leftNum = make_shared<string>(boost::any_cast<string>(m["left_num"]));
    }
    if (m.find("modify_price_list") != m.end() && !m["modify_price_list"].empty()) {
      if (typeid(vector<boost::any>) == m["modify_price_list"].type()) {
        vector<TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["modify_price_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modifyPriceList = make_shared<vector<TicketChangingFlightListResponseBodyModuleFlightInfoListCabinListModifyPriceList>>(expect1);
      }
    }
    if (m.find("ota_itemid") != m.end() && !m["ota_itemid"].empty()) {
      otaItemid = make_shared<string>(boost::any_cast<string>(m["ota_itemid"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList() = default;
};
class TicketChangingFlightListResponseBodyModuleFlightInfoListDepAirportInfo : public Darabonba::Model {
public:
  shared_ptr<string> airportCode{};
  shared_ptr<string> airportName{};
  shared_ptr<string> cityCode{};
  shared_ptr<string> cityName{};
  shared_ptr<string> terminal{};

  TicketChangingFlightListResponseBodyModuleFlightInfoListDepAirportInfo() {}

  explicit TicketChangingFlightListResponseBodyModuleFlightInfoListDepAirportInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airportCode) {
      res["airport_code"] = boost::any(*airportCode);
    }
    if (airportName) {
      res["airport_name"] = boost::any(*airportName);
    }
    if (cityCode) {
      res["city_code"] = boost::any(*cityCode);
    }
    if (cityName) {
      res["city_name"] = boost::any(*cityName);
    }
    if (terminal) {
      res["terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airport_code") != m.end() && !m["airport_code"].empty()) {
      airportCode = make_shared<string>(boost::any_cast<string>(m["airport_code"]));
    }
    if (m.find("airport_name") != m.end() && !m["airport_name"].empty()) {
      airportName = make_shared<string>(boost::any_cast<string>(m["airport_name"]));
    }
    if (m.find("city_code") != m.end() && !m["city_code"].empty()) {
      cityCode = make_shared<string>(boost::any_cast<string>(m["city_code"]));
    }
    if (m.find("city_name") != m.end() && !m["city_name"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["city_name"]));
    }
    if (m.find("terminal") != m.end() && !m["terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["terminal"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModuleFlightInfoListDepAirportInfo() = default;
};
class TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice : public Darabonba::Model {
public:
  shared_ptr<long> passengerType{};
  shared_ptr<long> ticketPrice{};
  shared_ptr<long> upgradeFee{};
  shared_ptr<long> upgradePrice{};

  TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice() {}

  explicit TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passengerType) {
      res["passenger_type"] = boost::any(*passengerType);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (upgradeFee) {
      res["upgrade_fee"] = boost::any(*upgradeFee);
    }
    if (upgradePrice) {
      res["upgrade_price"] = boost::any(*upgradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("passenger_type") != m.end() && !m["passenger_type"].empty()) {
      passengerType = make_shared<long>(boost::any_cast<long>(m["passenger_type"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<long>(boost::any_cast<long>(m["ticket_price"]));
    }
    if (m.find("upgrade_fee") != m.end() && !m["upgrade_fee"].empty()) {
      upgradeFee = make_shared<long>(boost::any_cast<long>(m["upgrade_fee"]));
    }
    if (m.find("upgrade_price") != m.end() && !m["upgrade_price"].empty()) {
      upgradePrice = make_shared<long>(boost::any_cast<long>(m["upgrade_price"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice() = default;
};
class TicketChangingFlightListResponseBodyModuleFlightInfoList : public Darabonba::Model {
public:
  shared_ptr<TicketChangingFlightListResponseBodyModuleFlightInfoListAirlineInfo> airlineInfo{};
  shared_ptr<TicketChangingFlightListResponseBodyModuleFlightInfoListArrAirportInfo> arrAirportInfo{};
  shared_ptr<vector<TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList>> cabinList{};
  shared_ptr<string> carrierAirline{};
  shared_ptr<string> carrierNo{};
  shared_ptr<TicketChangingFlightListResponseBodyModuleFlightInfoListDepAirportInfo> depAirportInfo{};
  shared_ptr<string> flightNo{};
  shared_ptr<string> flightSize{};
  shared_ptr<string> flightType{};
  shared_ptr<bool> isProtocol{};
  shared_ptr<bool> isShare{};
  shared_ptr<bool> isStop{};
  shared_ptr<string> lowestCabin{};
  shared_ptr<string> lowestCabinClass{};
  shared_ptr<string> lowestCabinDesc{};
  shared_ptr<string> lowestCabinNum{};
  shared_ptr<vector<TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice>> lowestCabinPrice{};
  shared_ptr<string> mealDesc{};
  shared_ptr<string> modifyFlightArrTime{};
  shared_ptr<string> modifyFlightDepDate{};
  shared_ptr<string> modifyFlightDepTime{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> stopArrTime{};
  shared_ptr<string> stopCity{};
  shared_ptr<string> stopDepTime{};

  TicketChangingFlightListResponseBodyModuleFlightInfoList() {}

  explicit TicketChangingFlightListResponseBodyModuleFlightInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (airlineInfo) {
      res["airline_info"] = airlineInfo ? boost::any(airlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (arrAirportInfo) {
      res["arr_airport_info"] = arrAirportInfo ? boost::any(arrAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cabinList) {
      vector<boost::any> temp1;
      for(auto item1:*cabinList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cabin_list"] = boost::any(temp1);
    }
    if (carrierAirline) {
      res["carrier_airline"] = boost::any(*carrierAirline);
    }
    if (carrierNo) {
      res["carrier_no"] = boost::any(*carrierNo);
    }
    if (depAirportInfo) {
      res["dep_airport_info"] = depAirportInfo ? boost::any(depAirportInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flightNo) {
      res["flight_no"] = boost::any(*flightNo);
    }
    if (flightSize) {
      res["flight_size"] = boost::any(*flightSize);
    }
    if (flightType) {
      res["flight_type"] = boost::any(*flightType);
    }
    if (isProtocol) {
      res["is_protocol"] = boost::any(*isProtocol);
    }
    if (isShare) {
      res["is_share"] = boost::any(*isShare);
    }
    if (isStop) {
      res["is_stop"] = boost::any(*isStop);
    }
    if (lowestCabin) {
      res["lowest_cabin"] = boost::any(*lowestCabin);
    }
    if (lowestCabinClass) {
      res["lowest_cabin_class"] = boost::any(*lowestCabinClass);
    }
    if (lowestCabinDesc) {
      res["lowest_cabin_desc"] = boost::any(*lowestCabinDesc);
    }
    if (lowestCabinNum) {
      res["lowest_cabin_num"] = boost::any(*lowestCabinNum);
    }
    if (lowestCabinPrice) {
      vector<boost::any> temp1;
      for(auto item1:*lowestCabinPrice){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["lowest_cabin_price"] = boost::any(temp1);
    }
    if (mealDesc) {
      res["meal_desc"] = boost::any(*mealDesc);
    }
    if (modifyFlightArrTime) {
      res["modify_flight_arr_time"] = boost::any(*modifyFlightArrTime);
    }
    if (modifyFlightDepDate) {
      res["modify_flight_dep_date"] = boost::any(*modifyFlightDepDate);
    }
    if (modifyFlightDepTime) {
      res["modify_flight_dep_time"] = boost::any(*modifyFlightDepTime);
    }
    if (sessionId) {
      res["session_id"] = boost::any(*sessionId);
    }
    if (stopArrTime) {
      res["stop_arr_time"] = boost::any(*stopArrTime);
    }
    if (stopCity) {
      res["stop_city"] = boost::any(*stopCity);
    }
    if (stopDepTime) {
      res["stop_dep_time"] = boost::any(*stopDepTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("airline_info") != m.end() && !m["airline_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["airline_info"].type()) {
        TicketChangingFlightListResponseBodyModuleFlightInfoListAirlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["airline_info"]));
        airlineInfo = make_shared<TicketChangingFlightListResponseBodyModuleFlightInfoListAirlineInfo>(model1);
      }
    }
    if (m.find("arr_airport_info") != m.end() && !m["arr_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["arr_airport_info"].type()) {
        TicketChangingFlightListResponseBodyModuleFlightInfoListArrAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["arr_airport_info"]));
        arrAirportInfo = make_shared<TicketChangingFlightListResponseBodyModuleFlightInfoListArrAirportInfo>(model1);
      }
    }
    if (m.find("cabin_list") != m.end() && !m["cabin_list"].empty()) {
      if (typeid(vector<boost::any>) == m["cabin_list"].type()) {
        vector<TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cabin_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cabinList = make_shared<vector<TicketChangingFlightListResponseBodyModuleFlightInfoListCabinList>>(expect1);
      }
    }
    if (m.find("carrier_airline") != m.end() && !m["carrier_airline"].empty()) {
      carrierAirline = make_shared<string>(boost::any_cast<string>(m["carrier_airline"]));
    }
    if (m.find("carrier_no") != m.end() && !m["carrier_no"].empty()) {
      carrierNo = make_shared<string>(boost::any_cast<string>(m["carrier_no"]));
    }
    if (m.find("dep_airport_info") != m.end() && !m["dep_airport_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["dep_airport_info"].type()) {
        TicketChangingFlightListResponseBodyModuleFlightInfoListDepAirportInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dep_airport_info"]));
        depAirportInfo = make_shared<TicketChangingFlightListResponseBodyModuleFlightInfoListDepAirportInfo>(model1);
      }
    }
    if (m.find("flight_no") != m.end() && !m["flight_no"].empty()) {
      flightNo = make_shared<string>(boost::any_cast<string>(m["flight_no"]));
    }
    if (m.find("flight_size") != m.end() && !m["flight_size"].empty()) {
      flightSize = make_shared<string>(boost::any_cast<string>(m["flight_size"]));
    }
    if (m.find("flight_type") != m.end() && !m["flight_type"].empty()) {
      flightType = make_shared<string>(boost::any_cast<string>(m["flight_type"]));
    }
    if (m.find("is_protocol") != m.end() && !m["is_protocol"].empty()) {
      isProtocol = make_shared<bool>(boost::any_cast<bool>(m["is_protocol"]));
    }
    if (m.find("is_share") != m.end() && !m["is_share"].empty()) {
      isShare = make_shared<bool>(boost::any_cast<bool>(m["is_share"]));
    }
    if (m.find("is_stop") != m.end() && !m["is_stop"].empty()) {
      isStop = make_shared<bool>(boost::any_cast<bool>(m["is_stop"]));
    }
    if (m.find("lowest_cabin") != m.end() && !m["lowest_cabin"].empty()) {
      lowestCabin = make_shared<string>(boost::any_cast<string>(m["lowest_cabin"]));
    }
    if (m.find("lowest_cabin_class") != m.end() && !m["lowest_cabin_class"].empty()) {
      lowestCabinClass = make_shared<string>(boost::any_cast<string>(m["lowest_cabin_class"]));
    }
    if (m.find("lowest_cabin_desc") != m.end() && !m["lowest_cabin_desc"].empty()) {
      lowestCabinDesc = make_shared<string>(boost::any_cast<string>(m["lowest_cabin_desc"]));
    }
    if (m.find("lowest_cabin_num") != m.end() && !m["lowest_cabin_num"].empty()) {
      lowestCabinNum = make_shared<string>(boost::any_cast<string>(m["lowest_cabin_num"]));
    }
    if (m.find("lowest_cabin_price") != m.end() && !m["lowest_cabin_price"].empty()) {
      if (typeid(vector<boost::any>) == m["lowest_cabin_price"].type()) {
        vector<TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["lowest_cabin_price"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lowestCabinPrice = make_shared<vector<TicketChangingFlightListResponseBodyModuleFlightInfoListLowestCabinPrice>>(expect1);
      }
    }
    if (m.find("meal_desc") != m.end() && !m["meal_desc"].empty()) {
      mealDesc = make_shared<string>(boost::any_cast<string>(m["meal_desc"]));
    }
    if (m.find("modify_flight_arr_time") != m.end() && !m["modify_flight_arr_time"].empty()) {
      modifyFlightArrTime = make_shared<string>(boost::any_cast<string>(m["modify_flight_arr_time"]));
    }
    if (m.find("modify_flight_dep_date") != m.end() && !m["modify_flight_dep_date"].empty()) {
      modifyFlightDepDate = make_shared<string>(boost::any_cast<string>(m["modify_flight_dep_date"]));
    }
    if (m.find("modify_flight_dep_time") != m.end() && !m["modify_flight_dep_time"].empty()) {
      modifyFlightDepTime = make_shared<string>(boost::any_cast<string>(m["modify_flight_dep_time"]));
    }
    if (m.find("session_id") != m.end() && !m["session_id"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["session_id"]));
    }
    if (m.find("stop_arr_time") != m.end() && !m["stop_arr_time"].empty()) {
      stopArrTime = make_shared<string>(boost::any_cast<string>(m["stop_arr_time"]));
    }
    if (m.find("stop_city") != m.end() && !m["stop_city"].empty()) {
      stopCity = make_shared<string>(boost::any_cast<string>(m["stop_city"]));
    }
    if (m.find("stop_dep_time") != m.end() && !m["stop_dep_time"].empty()) {
      stopDepTime = make_shared<string>(boost::any_cast<string>(m["stop_dep_time"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModuleFlightInfoList() = default;
};
class TicketChangingFlightListResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<TicketChangingFlightListResponseBodyModuleFlightInfoList>> flightInfoList{};

  TicketChangingFlightListResponseBodyModule() {}

  explicit TicketChangingFlightListResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flightInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*flightInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["flight_info_list"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("flight_info_list") != m.end() && !m["flight_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["flight_info_list"].type()) {
        vector<TicketChangingFlightListResponseBodyModuleFlightInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["flight_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TicketChangingFlightListResponseBodyModuleFlightInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flightInfoList = make_shared<vector<TicketChangingFlightListResponseBodyModuleFlightInfoList>>(expect1);
      }
    }
  }


  virtual ~TicketChangingFlightListResponseBodyModule() = default;
};
class TicketChangingFlightListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TicketChangingFlightListResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TicketChangingFlightListResponseBody() {}

  explicit TicketChangingFlightListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TicketChangingFlightListResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TicketChangingFlightListResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TicketChangingFlightListResponseBody() = default;
};
class TicketChangingFlightListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TicketChangingFlightListResponseBody> body{};

  TicketChangingFlightListResponse() {}

  explicit TicketChangingFlightListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TicketChangingFlightListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TicketChangingFlightListResponseBody>(model1);
      }
    }
  }


  virtual ~TicketChangingFlightListResponse() = default;
};
class TicketChangingPayHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TicketChangingPayHeaders() {}

  explicit TicketChangingPayHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TicketChangingPayHeaders() = default;
};
class TicketChangingPayRequest : public Darabonba::Model {
public:
  shared_ptr<long> corpPayPrice{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<map<string, string>> extra{};
  shared_ptr<long> personalPayPrice{};
  shared_ptr<long> totalPayPrice{};

  TicketChangingPayRequest() {}

  explicit TicketChangingPayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpPayPrice) {
      res["corp_pay_price"] = boost::any(*corpPayPrice);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (extra) {
      res["extra"] = boost::any(*extra);
    }
    if (personalPayPrice) {
      res["personal_pay_price"] = boost::any(*personalPayPrice);
    }
    if (totalPayPrice) {
      res["total_pay_price"] = boost::any(*totalPayPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_pay_price") != m.end() && !m["corp_pay_price"].empty()) {
      corpPayPrice = make_shared<long>(boost::any_cast<long>(m["corp_pay_price"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["extra"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extra = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("personal_pay_price") != m.end() && !m["personal_pay_price"].empty()) {
      personalPayPrice = make_shared<long>(boost::any_cast<long>(m["personal_pay_price"]));
    }
    if (m.find("total_pay_price") != m.end() && !m["total_pay_price"].empty()) {
      totalPayPrice = make_shared<long>(boost::any_cast<long>(m["total_pay_price"]));
    }
  }


  virtual ~TicketChangingPayRequest() = default;
};
class TicketChangingPayShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> corpPayPrice{};
  shared_ptr<string> disOrderId{};
  shared_ptr<string> disSubOrderId{};
  shared_ptr<string> extraShrink{};
  shared_ptr<long> personalPayPrice{};
  shared_ptr<long> totalPayPrice{};

  TicketChangingPayShrinkRequest() {}

  explicit TicketChangingPayShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpPayPrice) {
      res["corp_pay_price"] = boost::any(*corpPayPrice);
    }
    if (disOrderId) {
      res["dis_order_id"] = boost::any(*disOrderId);
    }
    if (disSubOrderId) {
      res["dis_sub_order_id"] = boost::any(*disSubOrderId);
    }
    if (extraShrink) {
      res["extra"] = boost::any(*extraShrink);
    }
    if (personalPayPrice) {
      res["personal_pay_price"] = boost::any(*personalPayPrice);
    }
    if (totalPayPrice) {
      res["total_pay_price"] = boost::any(*totalPayPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_pay_price") != m.end() && !m["corp_pay_price"].empty()) {
      corpPayPrice = make_shared<long>(boost::any_cast<long>(m["corp_pay_price"]));
    }
    if (m.find("dis_order_id") != m.end() && !m["dis_order_id"].empty()) {
      disOrderId = make_shared<string>(boost::any_cast<string>(m["dis_order_id"]));
    }
    if (m.find("dis_sub_order_id") != m.end() && !m["dis_sub_order_id"].empty()) {
      disSubOrderId = make_shared<string>(boost::any_cast<string>(m["dis_sub_order_id"]));
    }
    if (m.find("extra") != m.end() && !m["extra"].empty()) {
      extraShrink = make_shared<string>(boost::any_cast<string>(m["extra"]));
    }
    if (m.find("personal_pay_price") != m.end() && !m["personal_pay_price"].empty()) {
      personalPayPrice = make_shared<long>(boost::any_cast<long>(m["personal_pay_price"]));
    }
    if (m.find("total_pay_price") != m.end() && !m["total_pay_price"].empty()) {
      totalPayPrice = make_shared<long>(boost::any_cast<long>(m["total_pay_price"]));
    }
  }


  virtual ~TicketChangingPayShrinkRequest() = default;
};
class TicketChangingPayResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<bool> canRetry{};
  shared_ptr<long> payPrice{};
  shared_ptr<long> payStatus{};
  shared_ptr<string> payTime{};
  shared_ptr<string> tradeNo{};

  TicketChangingPayResponseBodyModule() {}

  explicit TicketChangingPayResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canRetry) {
      res["can_retry"] = boost::any(*canRetry);
    }
    if (payPrice) {
      res["pay_price"] = boost::any(*payPrice);
    }
    if (payStatus) {
      res["pay_status"] = boost::any(*payStatus);
    }
    if (payTime) {
      res["pay_time"] = boost::any(*payTime);
    }
    if (tradeNo) {
      res["trade_no"] = boost::any(*tradeNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("can_retry") != m.end() && !m["can_retry"].empty()) {
      canRetry = make_shared<bool>(boost::any_cast<bool>(m["can_retry"]));
    }
    if (m.find("pay_price") != m.end() && !m["pay_price"].empty()) {
      payPrice = make_shared<long>(boost::any_cast<long>(m["pay_price"]));
    }
    if (m.find("pay_status") != m.end() && !m["pay_status"].empty()) {
      payStatus = make_shared<long>(boost::any_cast<long>(m["pay_status"]));
    }
    if (m.find("pay_time") != m.end() && !m["pay_time"].empty()) {
      payTime = make_shared<string>(boost::any_cast<string>(m["pay_time"]));
    }
    if (m.find("trade_no") != m.end() && !m["trade_no"].empty()) {
      tradeNo = make_shared<string>(boost::any_cast<string>(m["trade_no"]));
    }
  }


  virtual ~TicketChangingPayResponseBodyModule() = default;
};
class TicketChangingPayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TicketChangingPayResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TicketChangingPayResponseBody() {}

  explicit TicketChangingPayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TicketChangingPayResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TicketChangingPayResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TicketChangingPayResponseBody() = default;
};
class TicketChangingPayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TicketChangingPayResponseBody> body{};

  TicketChangingPayResponse() {}

  explicit TicketChangingPayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TicketChangingPayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TicketChangingPayResponseBody>(model1);
      }
    }
  }


  virtual ~TicketChangingPayResponse() = default;
};
class TrainBillSettlementQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  TrainBillSettlementQueryHeaders() {}

  explicit TrainBillSettlementQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~TrainBillSettlementQueryHeaders() = default;
};
class TrainBillSettlementQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};

  TrainBillSettlementQueryRequest() {}

  explicit TrainBillSettlementQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
  }


  virtual ~TrainBillSettlementQueryRequest() = default;
};
class TrainBillSettlementQueryResponseBodyModuleDataList : public Darabonba::Model {
public:
  shared_ptr<string> alipayTradeNo{};
  shared_ptr<string> applyArrCityCode{};
  shared_ptr<string> applyArrCityName{};
  shared_ptr<string> applyDepCityCode{};
  shared_ptr<string> applyDepCityName{};
  shared_ptr<string> applyExtendField{};
  shared_ptr<string> applyId{};
  shared_ptr<string> arrCityCode{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrDate{};
  shared_ptr<string> arrStation{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> billRecordTime{};
  shared_ptr<string> bookTime{};
  shared_ptr<string> bookerId{};
  shared_ptr<string> bookerJobNo{};
  shared_ptr<string> bookerName{};
  shared_ptr<string> businessTripResult{};
  shared_ptr<string> capitalDirection{};
  shared_ptr<string> cascadeDepartment{};
  shared_ptr<double> changeFee{};
  shared_ptr<string> changeResult{};
  shared_ptr<string> coachNo{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<double> coupon{};
  shared_ptr<string> depCityCode{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> department{};
  shared_ptr<string> departmentId{};
  shared_ptr<string> deptDate{};
  shared_ptr<string> deptStation{};
  shared_ptr<string> deptTime{};
  shared_ptr<string> exceedReason{};
  shared_ptr<string> feeType{};
  shared_ptr<string> index{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> isTransferOrder{};
  shared_ptr<string> orderId{};
  shared_ptr<double> orderPrice{};
  shared_ptr<string> overApplyId{};
  shared_ptr<long> primaryId{};
  shared_ptr<double> printTicketPrice{};
  shared_ptr<string> projectCode{};
  shared_ptr<string> projectName{};
  shared_ptr<double> refundFee{};
  shared_ptr<string> refundReason{};
  shared_ptr<string> remark{};
  shared_ptr<string> reserveMode{};
  shared_ptr<string> runTime{};
  shared_ptr<string> seatNo{};
  shared_ptr<string> seatType{};
  shared_ptr<double> serviceFee{};
  shared_ptr<double> settlementFee{};
  shared_ptr<double> settlementGrantFee{};
  shared_ptr<string> settlementTime{};
  shared_ptr<string> settlementType{};
  shared_ptr<string> shortTicketNo{};
  shared_ptr<long> status{};
  shared_ptr<string> taxRate{};
  shared_ptr<string> thirdItineraryId{};
  shared_ptr<string> ticketCorpPayPrice{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> ticketPersonPayPrice{};
  shared_ptr<double> ticketPrice{};
  shared_ptr<string> trainNo{};
  shared_ptr<string> trainType{};
  shared_ptr<string> travelerId{};
  shared_ptr<string> travelerJobNo{};
  shared_ptr<string> travelerMemberTypeName{};
  shared_ptr<string> travelerName{};
  shared_ptr<long> voucherType{};

  TrainBillSettlementQueryResponseBodyModuleDataList() {}

  explicit TrainBillSettlementQueryResponseBodyModuleDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayTradeNo) {
      res["alipay_trade_no"] = boost::any(*alipayTradeNo);
    }
    if (applyArrCityCode) {
      res["apply_arr_city_code"] = boost::any(*applyArrCityCode);
    }
    if (applyArrCityName) {
      res["apply_arr_city_name"] = boost::any(*applyArrCityName);
    }
    if (applyDepCityCode) {
      res["apply_dep_city_code"] = boost::any(*applyDepCityCode);
    }
    if (applyDepCityName) {
      res["apply_dep_city_name"] = boost::any(*applyDepCityName);
    }
    if (applyExtendField) {
      res["apply_extend_field"] = boost::any(*applyExtendField);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (arrCityCode) {
      res["arr_city_code"] = boost::any(*arrCityCode);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrDate) {
      res["arr_date"] = boost::any(*arrDate);
    }
    if (arrStation) {
      res["arr_station"] = boost::any(*arrStation);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (billRecordTime) {
      res["bill_record_time"] = boost::any(*billRecordTime);
    }
    if (bookTime) {
      res["book_time"] = boost::any(*bookTime);
    }
    if (bookerId) {
      res["booker_id"] = boost::any(*bookerId);
    }
    if (bookerJobNo) {
      res["booker_job_no"] = boost::any(*bookerJobNo);
    }
    if (bookerName) {
      res["booker_name"] = boost::any(*bookerName);
    }
    if (businessTripResult) {
      res["business_trip_result"] = boost::any(*businessTripResult);
    }
    if (capitalDirection) {
      res["capital_direction"] = boost::any(*capitalDirection);
    }
    if (cascadeDepartment) {
      res["cascade_department"] = boost::any(*cascadeDepartment);
    }
    if (changeFee) {
      res["change_fee"] = boost::any(*changeFee);
    }
    if (changeResult) {
      res["change_result"] = boost::any(*changeResult);
    }
    if (coachNo) {
      res["coach_no"] = boost::any(*coachNo);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (coupon) {
      res["coupon"] = boost::any(*coupon);
    }
    if (depCityCode) {
      res["dep_city_code"] = boost::any(*depCityCode);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (departmentId) {
      res["department_id"] = boost::any(*departmentId);
    }
    if (deptDate) {
      res["dept_date"] = boost::any(*deptDate);
    }
    if (deptStation) {
      res["dept_station"] = boost::any(*deptStation);
    }
    if (deptTime) {
      res["dept_time"] = boost::any(*deptTime);
    }
    if (exceedReason) {
      res["exceed_reason"] = boost::any(*exceedReason);
    }
    if (feeType) {
      res["fee_type"] = boost::any(*feeType);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (isTransferOrder) {
      res["is_transfer_order"] = boost::any(*isTransferOrder);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderPrice) {
      res["order_price"] = boost::any(*orderPrice);
    }
    if (overApplyId) {
      res["over_apply_id"] = boost::any(*overApplyId);
    }
    if (primaryId) {
      res["primary_id"] = boost::any(*primaryId);
    }
    if (printTicketPrice) {
      res["print_ticket_price"] = boost::any(*printTicketPrice);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectName) {
      res["project_name"] = boost::any(*projectName);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (refundReason) {
      res["refund_reason"] = boost::any(*refundReason);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (reserveMode) {
      res["reserve_mode"] = boost::any(*reserveMode);
    }
    if (runTime) {
      res["run_time"] = boost::any(*runTime);
    }
    if (seatNo) {
      res["seat_no"] = boost::any(*seatNo);
    }
    if (seatType) {
      res["seat_type"] = boost::any(*seatType);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (settlementFee) {
      res["settlement_fee"] = boost::any(*settlementFee);
    }
    if (settlementGrantFee) {
      res["settlement_grant_fee"] = boost::any(*settlementGrantFee);
    }
    if (settlementTime) {
      res["settlement_time"] = boost::any(*settlementTime);
    }
    if (settlementType) {
      res["settlement_type"] = boost::any(*settlementType);
    }
    if (shortTicketNo) {
      res["short_ticket_no"] = boost::any(*shortTicketNo);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (taxRate) {
      res["tax_rate"] = boost::any(*taxRate);
    }
    if (thirdItineraryId) {
      res["third_itinerary_id"] = boost::any(*thirdItineraryId);
    }
    if (ticketCorpPayPrice) {
      res["ticket_corp_pay_price"] = boost::any(*ticketCorpPayPrice);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (ticketPersonPayPrice) {
      res["ticket_person_pay_price"] = boost::any(*ticketPersonPayPrice);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (trainNo) {
      res["train_no"] = boost::any(*trainNo);
    }
    if (trainType) {
      res["train_type"] = boost::any(*trainType);
    }
    if (travelerId) {
      res["traveler_id"] = boost::any(*travelerId);
    }
    if (travelerJobNo) {
      res["traveler_job_no"] = boost::any(*travelerJobNo);
    }
    if (travelerMemberTypeName) {
      res["traveler_member_type_name"] = boost::any(*travelerMemberTypeName);
    }
    if (travelerName) {
      res["traveler_name"] = boost::any(*travelerName);
    }
    if (voucherType) {
      res["voucher_type"] = boost::any(*voucherType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alipay_trade_no") != m.end() && !m["alipay_trade_no"].empty()) {
      alipayTradeNo = make_shared<string>(boost::any_cast<string>(m["alipay_trade_no"]));
    }
    if (m.find("apply_arr_city_code") != m.end() && !m["apply_arr_city_code"].empty()) {
      applyArrCityCode = make_shared<string>(boost::any_cast<string>(m["apply_arr_city_code"]));
    }
    if (m.find("apply_arr_city_name") != m.end() && !m["apply_arr_city_name"].empty()) {
      applyArrCityName = make_shared<string>(boost::any_cast<string>(m["apply_arr_city_name"]));
    }
    if (m.find("apply_dep_city_code") != m.end() && !m["apply_dep_city_code"].empty()) {
      applyDepCityCode = make_shared<string>(boost::any_cast<string>(m["apply_dep_city_code"]));
    }
    if (m.find("apply_dep_city_name") != m.end() && !m["apply_dep_city_name"].empty()) {
      applyDepCityName = make_shared<string>(boost::any_cast<string>(m["apply_dep_city_name"]));
    }
    if (m.find("apply_extend_field") != m.end() && !m["apply_extend_field"].empty()) {
      applyExtendField = make_shared<string>(boost::any_cast<string>(m["apply_extend_field"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("arr_city_code") != m.end() && !m["arr_city_code"].empty()) {
      arrCityCode = make_shared<string>(boost::any_cast<string>(m["arr_city_code"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_date") != m.end() && !m["arr_date"].empty()) {
      arrDate = make_shared<string>(boost::any_cast<string>(m["arr_date"]));
    }
    if (m.find("arr_station") != m.end() && !m["arr_station"].empty()) {
      arrStation = make_shared<string>(boost::any_cast<string>(m["arr_station"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("bill_record_time") != m.end() && !m["bill_record_time"].empty()) {
      billRecordTime = make_shared<string>(boost::any_cast<string>(m["bill_record_time"]));
    }
    if (m.find("book_time") != m.end() && !m["book_time"].empty()) {
      bookTime = make_shared<string>(boost::any_cast<string>(m["book_time"]));
    }
    if (m.find("booker_id") != m.end() && !m["booker_id"].empty()) {
      bookerId = make_shared<string>(boost::any_cast<string>(m["booker_id"]));
    }
    if (m.find("booker_job_no") != m.end() && !m["booker_job_no"].empty()) {
      bookerJobNo = make_shared<string>(boost::any_cast<string>(m["booker_job_no"]));
    }
    if (m.find("booker_name") != m.end() && !m["booker_name"].empty()) {
      bookerName = make_shared<string>(boost::any_cast<string>(m["booker_name"]));
    }
    if (m.find("business_trip_result") != m.end() && !m["business_trip_result"].empty()) {
      businessTripResult = make_shared<string>(boost::any_cast<string>(m["business_trip_result"]));
    }
    if (m.find("capital_direction") != m.end() && !m["capital_direction"].empty()) {
      capitalDirection = make_shared<string>(boost::any_cast<string>(m["capital_direction"]));
    }
    if (m.find("cascade_department") != m.end() && !m["cascade_department"].empty()) {
      cascadeDepartment = make_shared<string>(boost::any_cast<string>(m["cascade_department"]));
    }
    if (m.find("change_fee") != m.end() && !m["change_fee"].empty()) {
      changeFee = make_shared<double>(boost::any_cast<double>(m["change_fee"]));
    }
    if (m.find("change_result") != m.end() && !m["change_result"].empty()) {
      changeResult = make_shared<string>(boost::any_cast<string>(m["change_result"]));
    }
    if (m.find("coach_no") != m.end() && !m["coach_no"].empty()) {
      coachNo = make_shared<string>(boost::any_cast<string>(m["coach_no"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("coupon") != m.end() && !m["coupon"].empty()) {
      coupon = make_shared<double>(boost::any_cast<double>(m["coupon"]));
    }
    if (m.find("dep_city_code") != m.end() && !m["dep_city_code"].empty()) {
      depCityCode = make_shared<string>(boost::any_cast<string>(m["dep_city_code"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("department_id") != m.end() && !m["department_id"].empty()) {
      departmentId = make_shared<string>(boost::any_cast<string>(m["department_id"]));
    }
    if (m.find("dept_date") != m.end() && !m["dept_date"].empty()) {
      deptDate = make_shared<string>(boost::any_cast<string>(m["dept_date"]));
    }
    if (m.find("dept_station") != m.end() && !m["dept_station"].empty()) {
      deptStation = make_shared<string>(boost::any_cast<string>(m["dept_station"]));
    }
    if (m.find("dept_time") != m.end() && !m["dept_time"].empty()) {
      deptTime = make_shared<string>(boost::any_cast<string>(m["dept_time"]));
    }
    if (m.find("exceed_reason") != m.end() && !m["exceed_reason"].empty()) {
      exceedReason = make_shared<string>(boost::any_cast<string>(m["exceed_reason"]));
    }
    if (m.find("fee_type") != m.end() && !m["fee_type"].empty()) {
      feeType = make_shared<string>(boost::any_cast<string>(m["fee_type"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("is_transfer_order") != m.end() && !m["is_transfer_order"].empty()) {
      isTransferOrder = make_shared<string>(boost::any_cast<string>(m["is_transfer_order"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["order_id"]));
    }
    if (m.find("order_price") != m.end() && !m["order_price"].empty()) {
      orderPrice = make_shared<double>(boost::any_cast<double>(m["order_price"]));
    }
    if (m.find("over_apply_id") != m.end() && !m["over_apply_id"].empty()) {
      overApplyId = make_shared<string>(boost::any_cast<string>(m["over_apply_id"]));
    }
    if (m.find("primary_id") != m.end() && !m["primary_id"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["primary_id"]));
    }
    if (m.find("print_ticket_price") != m.end() && !m["print_ticket_price"].empty()) {
      printTicketPrice = make_shared<double>(boost::any_cast<double>(m["print_ticket_price"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_name") != m.end() && !m["project_name"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["project_name"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<double>(boost::any_cast<double>(m["refund_fee"]));
    }
    if (m.find("refund_reason") != m.end() && !m["refund_reason"].empty()) {
      refundReason = make_shared<string>(boost::any_cast<string>(m["refund_reason"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("reserve_mode") != m.end() && !m["reserve_mode"].empty()) {
      reserveMode = make_shared<string>(boost::any_cast<string>(m["reserve_mode"]));
    }
    if (m.find("run_time") != m.end() && !m["run_time"].empty()) {
      runTime = make_shared<string>(boost::any_cast<string>(m["run_time"]));
    }
    if (m.find("seat_no") != m.end() && !m["seat_no"].empty()) {
      seatNo = make_shared<string>(boost::any_cast<string>(m["seat_no"]));
    }
    if (m.find("seat_type") != m.end() && !m["seat_type"].empty()) {
      seatType = make_shared<string>(boost::any_cast<string>(m["seat_type"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<double>(boost::any_cast<double>(m["service_fee"]));
    }
    if (m.find("settlement_fee") != m.end() && !m["settlement_fee"].empty()) {
      settlementFee = make_shared<double>(boost::any_cast<double>(m["settlement_fee"]));
    }
    if (m.find("settlement_grant_fee") != m.end() && !m["settlement_grant_fee"].empty()) {
      settlementGrantFee = make_shared<double>(boost::any_cast<double>(m["settlement_grant_fee"]));
    }
    if (m.find("settlement_time") != m.end() && !m["settlement_time"].empty()) {
      settlementTime = make_shared<string>(boost::any_cast<string>(m["settlement_time"]));
    }
    if (m.find("settlement_type") != m.end() && !m["settlement_type"].empty()) {
      settlementType = make_shared<string>(boost::any_cast<string>(m["settlement_type"]));
    }
    if (m.find("short_ticket_no") != m.end() && !m["short_ticket_no"].empty()) {
      shortTicketNo = make_shared<string>(boost::any_cast<string>(m["short_ticket_no"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("tax_rate") != m.end() && !m["tax_rate"].empty()) {
      taxRate = make_shared<string>(boost::any_cast<string>(m["tax_rate"]));
    }
    if (m.find("third_itinerary_id") != m.end() && !m["third_itinerary_id"].empty()) {
      thirdItineraryId = make_shared<string>(boost::any_cast<string>(m["third_itinerary_id"]));
    }
    if (m.find("ticket_corp_pay_price") != m.end() && !m["ticket_corp_pay_price"].empty()) {
      ticketCorpPayPrice = make_shared<string>(boost::any_cast<string>(m["ticket_corp_pay_price"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("ticket_person_pay_price") != m.end() && !m["ticket_person_pay_price"].empty()) {
      ticketPersonPayPrice = make_shared<string>(boost::any_cast<string>(m["ticket_person_pay_price"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<double>(boost::any_cast<double>(m["ticket_price"]));
    }
    if (m.find("train_no") != m.end() && !m["train_no"].empty()) {
      trainNo = make_shared<string>(boost::any_cast<string>(m["train_no"]));
    }
    if (m.find("train_type") != m.end() && !m["train_type"].empty()) {
      trainType = make_shared<string>(boost::any_cast<string>(m["train_type"]));
    }
    if (m.find("traveler_id") != m.end() && !m["traveler_id"].empty()) {
      travelerId = make_shared<string>(boost::any_cast<string>(m["traveler_id"]));
    }
    if (m.find("traveler_job_no") != m.end() && !m["traveler_job_no"].empty()) {
      travelerJobNo = make_shared<string>(boost::any_cast<string>(m["traveler_job_no"]));
    }
    if (m.find("traveler_member_type_name") != m.end() && !m["traveler_member_type_name"].empty()) {
      travelerMemberTypeName = make_shared<string>(boost::any_cast<string>(m["traveler_member_type_name"]));
    }
    if (m.find("traveler_name") != m.end() && !m["traveler_name"].empty()) {
      travelerName = make_shared<string>(boost::any_cast<string>(m["traveler_name"]));
    }
    if (m.find("voucher_type") != m.end() && !m["voucher_type"].empty()) {
      voucherType = make_shared<long>(boost::any_cast<long>(m["voucher_type"]));
    }
  }


  virtual ~TrainBillSettlementQueryResponseBodyModuleDataList() = default;
};
class TrainBillSettlementQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> category{};
  shared_ptr<string> corpId{};
  shared_ptr<vector<TrainBillSettlementQueryResponseBodyModuleDataList>> dataList{};
  shared_ptr<string> periodEnd{};
  shared_ptr<string> periodStart{};
  shared_ptr<long> totalNum{};

  TrainBillSettlementQueryResponseBodyModule() {}

  explicit TrainBillSettlementQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["category"] = boost::any(*category);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data_list"] = boost::any(temp1);
    }
    if (periodEnd) {
      res["period_end"] = boost::any(*periodEnd);
    }
    if (periodStart) {
      res["period_start"] = boost::any(*periodStart);
    }
    if (totalNum) {
      res["total_num"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category") != m.end() && !m["category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["category"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("data_list") != m.end() && !m["data_list"].empty()) {
      if (typeid(vector<boost::any>) == m["data_list"].type()) {
        vector<TrainBillSettlementQueryResponseBodyModuleDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainBillSettlementQueryResponseBodyModuleDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<TrainBillSettlementQueryResponseBodyModuleDataList>>(expect1);
      }
    }
    if (m.find("period_end") != m.end() && !m["period_end"].empty()) {
      periodEnd = make_shared<string>(boost::any_cast<string>(m["period_end"]));
    }
    if (m.find("period_start") != m.end() && !m["period_start"].empty()) {
      periodStart = make_shared<string>(boost::any_cast<string>(m["period_start"]));
    }
    if (m.find("total_num") != m.end() && !m["total_num"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["total_num"]));
    }
  }


  virtual ~TrainBillSettlementQueryResponseBodyModule() = default;
};
class TrainBillSettlementQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TrainBillSettlementQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TrainBillSettlementQueryResponseBody() {}

  explicit TrainBillSettlementQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TrainBillSettlementQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TrainBillSettlementQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TrainBillSettlementQueryResponseBody() = default;
};
class TrainBillSettlementQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TrainBillSettlementQueryResponseBody> body{};

  TrainBillSettlementQueryResponse() {}

  explicit TrainBillSettlementQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TrainBillSettlementQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TrainBillSettlementQueryResponseBody>(model1);
      }
    }
  }


  virtual ~TrainBillSettlementQueryResponse() = default;
};
class TrainExceedApplyQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  TrainExceedApplyQueryHeaders() {}

  explicit TrainExceedApplyQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~TrainExceedApplyQueryHeaders() = default;
};
class TrainExceedApplyQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};

  TrainExceedApplyQueryRequest() {}

  explicit TrainExceedApplyQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
  }


  virtual ~TrainExceedApplyQueryRequest() = default;
};
class TrainExceedApplyQueryResponseBodyModuleApplyIntentionInfoDO : public Darabonba::Model {
public:
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityName{};
  shared_ptr<string> arrStation{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityName{};
  shared_ptr<string> depStation{};
  shared_ptr<string> depTime{};
  shared_ptr<long> price{};
  shared_ptr<string> seatName{};
  shared_ptr<string> trainNo{};
  shared_ptr<string> trainTypeDesc{};
  shared_ptr<long> type{};

  TrainExceedApplyQueryResponseBodyModuleApplyIntentionInfoDO() {}

  explicit TrainExceedApplyQueryResponseBodyModuleApplyIntentionInfoDO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityName) {
      res["arr_city_name"] = boost::any(*arrCityName);
    }
    if (arrStation) {
      res["arr_station"] = boost::any(*arrStation);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityName) {
      res["dep_city_name"] = boost::any(*depCityName);
    }
    if (depStation) {
      res["dep_station"] = boost::any(*depStation);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (seatName) {
      res["seat_name"] = boost::any(*seatName);
    }
    if (trainNo) {
      res["train_no"] = boost::any(*trainNo);
    }
    if (trainTypeDesc) {
      res["train_type_desc"] = boost::any(*trainTypeDesc);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_name") != m.end() && !m["arr_city_name"].empty()) {
      arrCityName = make_shared<string>(boost::any_cast<string>(m["arr_city_name"]));
    }
    if (m.find("arr_station") != m.end() && !m["arr_station"].empty()) {
      arrStation = make_shared<string>(boost::any_cast<string>(m["arr_station"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_name") != m.end() && !m["dep_city_name"].empty()) {
      depCityName = make_shared<string>(boost::any_cast<string>(m["dep_city_name"]));
    }
    if (m.find("dep_station") != m.end() && !m["dep_station"].empty()) {
      depStation = make_shared<string>(boost::any_cast<string>(m["dep_station"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["price"]));
    }
    if (m.find("seat_name") != m.end() && !m["seat_name"].empty()) {
      seatName = make_shared<string>(boost::any_cast<string>(m["seat_name"]));
    }
    if (m.find("train_no") != m.end() && !m["train_no"].empty()) {
      trainNo = make_shared<string>(boost::any_cast<string>(m["train_no"]));
    }
    if (m.find("train_type_desc") != m.end() && !m["train_type_desc"].empty()) {
      trainTypeDesc = make_shared<string>(boost::any_cast<string>(m["train_type_desc"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~TrainExceedApplyQueryResponseBodyModuleApplyIntentionInfoDO() = default;
};
class TrainExceedApplyQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<TrainExceedApplyQueryResponseBodyModuleApplyIntentionInfoDO> applyIntentionInfoDO{};
  shared_ptr<string> btripCause{};
  shared_ptr<string> corpId{};
  shared_ptr<string> exceedReason{};
  shared_ptr<long> exceedType{};
  shared_ptr<string> originStandard{};
  shared_ptr<long> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartCorpId{};
  shared_ptr<string> userId{};

  TrainExceedApplyQueryResponseBodyModule() {}

  explicit TrainExceedApplyQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (applyIntentionInfoDO) {
      res["apply_intention_info_d_o"] = applyIntentionInfoDO ? boost::any(applyIntentionInfoDO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (btripCause) {
      res["btrip_cause"] = boost::any(*btripCause);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (exceedReason) {
      res["exceed_reason"] = boost::any(*exceedReason);
    }
    if (exceedType) {
      res["exceed_type"] = boost::any(*exceedType);
    }
    if (originStandard) {
      res["origin_standard"] = boost::any(*originStandard);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (submitTime) {
      res["submit_time"] = boost::any(*submitTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartCorpId) {
      res["thirdpart_corp_id"] = boost::any(*thirdpartCorpId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("apply_intention_info_d_o") != m.end() && !m["apply_intention_info_d_o"].empty()) {
      if (typeid(map<string, boost::any>) == m["apply_intention_info_d_o"].type()) {
        TrainExceedApplyQueryResponseBodyModuleApplyIntentionInfoDO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["apply_intention_info_d_o"]));
        applyIntentionInfoDO = make_shared<TrainExceedApplyQueryResponseBodyModuleApplyIntentionInfoDO>(model1);
      }
    }
    if (m.find("btrip_cause") != m.end() && !m["btrip_cause"].empty()) {
      btripCause = make_shared<string>(boost::any_cast<string>(m["btrip_cause"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("exceed_reason") != m.end() && !m["exceed_reason"].empty()) {
      exceedReason = make_shared<string>(boost::any_cast<string>(m["exceed_reason"]));
    }
    if (m.find("exceed_type") != m.end() && !m["exceed_type"].empty()) {
      exceedType = make_shared<long>(boost::any_cast<long>(m["exceed_type"]));
    }
    if (m.find("origin_standard") != m.end() && !m["origin_standard"].empty()) {
      originStandard = make_shared<string>(boost::any_cast<string>(m["origin_standard"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("submit_time") != m.end() && !m["submit_time"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["submit_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_corp_id") != m.end() && !m["thirdpart_corp_id"].empty()) {
      thirdpartCorpId = make_shared<string>(boost::any_cast<string>(m["thirdpart_corp_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainExceedApplyQueryResponseBodyModule() = default;
};
class TrainExceedApplyQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TrainExceedApplyQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TrainExceedApplyQueryResponseBody() {}

  explicit TrainExceedApplyQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TrainExceedApplyQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TrainExceedApplyQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TrainExceedApplyQueryResponseBody() = default;
};
class TrainExceedApplyQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TrainExceedApplyQueryResponseBody> body{};

  TrainExceedApplyQueryResponse() {}

  explicit TrainExceedApplyQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TrainExceedApplyQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TrainExceedApplyQueryResponseBody>(model1);
      }
    }
  }


  virtual ~TrainExceedApplyQueryResponse() = default;
};
class TrainOrderListQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  TrainOrderListQueryHeaders() {}

  explicit TrainOrderListQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~TrainOrderListQueryHeaders() = default;
};
class TrainOrderListQueryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allApply{};
  shared_ptr<long> applyId{};
  shared_ptr<string> departId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> updateEndTime{};
  shared_ptr<string> updateStartTime{};
  shared_ptr<string> userId{};

  TrainOrderListQueryRequest() {}

  explicit TrainOrderListQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allApply) {
      res["all_apply"] = boost::any(*allApply);
    }
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (updateEndTime) {
      res["update_end_time"] = boost::any(*updateEndTime);
    }
    if (updateStartTime) {
      res["update_start_time"] = boost::any(*updateStartTime);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all_apply") != m.end() && !m["all_apply"].empty()) {
      allApply = make_shared<bool>(boost::any_cast<bool>(m["all_apply"]));
    }
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("update_end_time") != m.end() && !m["update_end_time"].empty()) {
      updateEndTime = make_shared<string>(boost::any_cast<string>(m["update_end_time"]));
    }
    if (m.find("update_start_time") != m.end() && !m["update_start_time"].empty()) {
      updateStartTime = make_shared<string>(boost::any_cast<string>(m["update_start_time"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderListQueryRequest() = default;
};
class TrainOrderListQueryResponseBodyModuleCostCenter : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> number{};

  TrainOrderListQueryResponseBodyModuleCostCenter() {}

  explicit TrainOrderListQueryResponseBodyModuleCostCenter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (number) {
      res["number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("number") != m.end() && !m["number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["number"]));
    }
  }


  virtual ~TrainOrderListQueryResponseBodyModuleCostCenter() = default;
};
class TrainOrderListQueryResponseBodyModuleInvoice : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  TrainOrderListQueryResponseBodyModuleInvoice() {}

  explicit TrainOrderListQueryResponseBodyModuleInvoice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TrainOrderListQueryResponseBodyModuleInvoice() = default;
};
class TrainOrderListQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<long> categoryType{};
  shared_ptr<string> endCity{};
  shared_ptr<string> endTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> originalTrainNo{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> payType{};
  shared_ptr<double> price{};
  shared_ptr<string> seatType{};
  shared_ptr<string> startCity{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tradeId{};
  shared_ptr<string> trainNo{};
  shared_ptr<long> type{};

  TrainOrderListQueryResponseBodyModulePriceInfoList() {}

  explicit TrainOrderListQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (categoryType) {
      res["category_type"] = boost::any(*categoryType);
    }
    if (endCity) {
      res["end_city"] = boost::any(*endCity);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (originalTrainNo) {
      res["original_train_no"] = boost::any(*originalTrainNo);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (seatType) {
      res["seat_type"] = boost::any(*seatType);
    }
    if (startCity) {
      res["start_city"] = boost::any(*startCity);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (trainNo) {
      res["train_no"] = boost::any(*trainNo);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("category_type") != m.end() && !m["category_type"].empty()) {
      categoryType = make_shared<long>(boost::any_cast<long>(m["category_type"]));
    }
    if (m.find("end_city") != m.end() && !m["end_city"].empty()) {
      endCity = make_shared<string>(boost::any_cast<string>(m["end_city"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("original_train_no") != m.end() && !m["original_train_no"].empty()) {
      originalTrainNo = make_shared<string>(boost::any_cast<string>(m["original_train_no"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("seat_type") != m.end() && !m["seat_type"].empty()) {
      seatType = make_shared<string>(boost::any_cast<string>(m["seat_type"]));
    }
    if (m.find("start_city") != m.end() && !m["start_city"].empty()) {
      startCity = make_shared<string>(boost::any_cast<string>(m["start_city"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("train_no") != m.end() && !m["train_no"].empty()) {
      trainNo = make_shared<string>(boost::any_cast<string>(m["train_no"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~TrainOrderListQueryResponseBodyModulePriceInfoList() = default;
};
class TrainOrderListQueryResponseBodyModuleUserAffiliateList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  TrainOrderListQueryResponseBodyModuleUserAffiliateList() {}

  explicit TrainOrderListQueryResponseBodyModuleUserAffiliateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~TrainOrderListQueryResponseBodyModuleUserAffiliateList() = default;
};
class TrainOrderListQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<long> applyId{};
  shared_ptr<string> arrCity{};
  shared_ptr<string> arrCityAdCode{};
  shared_ptr<string> arrStation{};
  shared_ptr<string> arrTime{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> contactName{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<TrainOrderListQueryResponseBodyModuleCostCenter> costCenter{};
  shared_ptr<string> depCity{};
  shared_ptr<string> depCityAdCode{};
  shared_ptr<string> depStation{};
  shared_ptr<string> depTime{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<TrainOrderListQueryResponseBodyModuleInvoice> invoice{};
  shared_ptr<vector<TrainOrderListQueryResponseBodyModulePriceInfoList>> priceInfoList{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> riderName{};
  shared_ptr<string> runTime{};
  shared_ptr<string> seatType{};
  shared_ptr<long> status{};
  shared_ptr<string> thirdPartProjectId{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<long> ticketCount{};
  shared_ptr<string> ticketNo12306{};
  shared_ptr<string> trainNumber{};
  shared_ptr<string> trainType{};
  shared_ptr<vector<TrainOrderListQueryResponseBodyModuleUserAffiliateList>> userAffiliateList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  TrainOrderListQueryResponseBodyModule() {}

  explicit TrainOrderListQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (arrCity) {
      res["arr_city"] = boost::any(*arrCity);
    }
    if (arrCityAdCode) {
      res["arr_city_ad_code"] = boost::any(*arrCityAdCode);
    }
    if (arrStation) {
      res["arr_station"] = boost::any(*arrStation);
    }
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (costCenter) {
      res["cost_center"] = costCenter ? boost::any(costCenter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (depCity) {
      res["dep_city"] = boost::any(*depCity);
    }
    if (depCityAdCode) {
      res["dep_city_ad_code"] = boost::any(*depCityAdCode);
    }
    if (depStation) {
      res["dep_station"] = boost::any(*depStation);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmt_modified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (invoice) {
      res["invoice"] = invoice ? boost::any(invoice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (riderName) {
      res["rider_name"] = boost::any(*riderName);
    }
    if (runTime) {
      res["run_time"] = boost::any(*runTime);
    }
    if (seatType) {
      res["seat_type"] = boost::any(*seatType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (thirdPartProjectId) {
      res["third_part_project_id"] = boost::any(*thirdPartProjectId);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (ticketCount) {
      res["ticket_count"] = boost::any(*ticketCount);
    }
    if (ticketNo12306) {
      res["ticket_no12306"] = boost::any(*ticketNo12306);
    }
    if (trainNumber) {
      res["train_number"] = boost::any(*trainNumber);
    }
    if (trainType) {
      res["train_type"] = boost::any(*trainType);
    }
    if (userAffiliateList) {
      vector<boost::any> temp1;
      for(auto item1:*userAffiliateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["user_affiliate_list"] = boost::any(temp1);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<long>(boost::any_cast<long>(m["apply_id"]));
    }
    if (m.find("arr_city") != m.end() && !m["arr_city"].empty()) {
      arrCity = make_shared<string>(boost::any_cast<string>(m["arr_city"]));
    }
    if (m.find("arr_city_ad_code") != m.end() && !m["arr_city_ad_code"].empty()) {
      arrCityAdCode = make_shared<string>(boost::any_cast<string>(m["arr_city_ad_code"]));
    }
    if (m.find("arr_station") != m.end() && !m["arr_station"].empty()) {
      arrStation = make_shared<string>(boost::any_cast<string>(m["arr_station"]));
    }
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      if (typeid(map<string, boost::any>) == m["cost_center"].type()) {
        TrainOrderListQueryResponseBodyModuleCostCenter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cost_center"]));
        costCenter = make_shared<TrainOrderListQueryResponseBodyModuleCostCenter>(model1);
      }
    }
    if (m.find("dep_city") != m.end() && !m["dep_city"].empty()) {
      depCity = make_shared<string>(boost::any_cast<string>(m["dep_city"]));
    }
    if (m.find("dep_city_ad_code") != m.end() && !m["dep_city_ad_code"].empty()) {
      depCityAdCode = make_shared<string>(boost::any_cast<string>(m["dep_city_ad_code"]));
    }
    if (m.find("dep_station") != m.end() && !m["dep_station"].empty()) {
      depStation = make_shared<string>(boost::any_cast<string>(m["dep_station"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modified") != m.end() && !m["gmt_modified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmt_modified"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("invoice") != m.end() && !m["invoice"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice"].type()) {
        TrainOrderListQueryResponseBodyModuleInvoice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice"]));
        invoice = make_shared<TrainOrderListQueryResponseBodyModuleInvoice>(model1);
      }
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<TrainOrderListQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderListQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<TrainOrderListQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("rider_name") != m.end() && !m["rider_name"].empty()) {
      riderName = make_shared<string>(boost::any_cast<string>(m["rider_name"]));
    }
    if (m.find("run_time") != m.end() && !m["run_time"].empty()) {
      runTime = make_shared<string>(boost::any_cast<string>(m["run_time"]));
    }
    if (m.find("seat_type") != m.end() && !m["seat_type"].empty()) {
      seatType = make_shared<string>(boost::any_cast<string>(m["seat_type"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("third_part_project_id") != m.end() && !m["third_part_project_id"].empty()) {
      thirdPartProjectId = make_shared<string>(boost::any_cast<string>(m["third_part_project_id"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("ticket_count") != m.end() && !m["ticket_count"].empty()) {
      ticketCount = make_shared<long>(boost::any_cast<long>(m["ticket_count"]));
    }
    if (m.find("ticket_no12306") != m.end() && !m["ticket_no12306"].empty()) {
      ticketNo12306 = make_shared<string>(boost::any_cast<string>(m["ticket_no12306"]));
    }
    if (m.find("train_number") != m.end() && !m["train_number"].empty()) {
      trainNumber = make_shared<string>(boost::any_cast<string>(m["train_number"]));
    }
    if (m.find("train_type") != m.end() && !m["train_type"].empty()) {
      trainType = make_shared<string>(boost::any_cast<string>(m["train_type"]));
    }
    if (m.find("user_affiliate_list") != m.end() && !m["user_affiliate_list"].empty()) {
      if (typeid(vector<boost::any>) == m["user_affiliate_list"].type()) {
        vector<TrainOrderListQueryResponseBodyModuleUserAffiliateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["user_affiliate_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderListQueryResponseBodyModuleUserAffiliateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userAffiliateList = make_shared<vector<TrainOrderListQueryResponseBodyModuleUserAffiliateList>>(expect1);
      }
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
  }


  virtual ~TrainOrderListQueryResponseBodyModule() = default;
};
class TrainOrderListQueryResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalNumber{};

  TrainOrderListQueryResponseBodyPageInfo() {}

  explicit TrainOrderListQueryResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalNumber) {
      res["total_number"] = boost::any(*totalNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_number") != m.end() && !m["total_number"].empty()) {
      totalNumber = make_shared<long>(boost::any_cast<long>(m["total_number"]));
    }
  }


  virtual ~TrainOrderListQueryResponseBodyPageInfo() = default;
};
class TrainOrderListQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<TrainOrderListQueryResponseBodyModule>> module{};
  shared_ptr<TrainOrderListQueryResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TrainOrderListQueryResponseBody() {}

  explicit TrainOrderListQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["page_info"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<TrainOrderListQueryResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderListQueryResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<TrainOrderListQueryResponseBodyModule>>(expect1);
      }
    }
    if (m.find("page_info") != m.end() && !m["page_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["page_info"].type()) {
        TrainOrderListQueryResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["page_info"]));
        pageInfo = make_shared<TrainOrderListQueryResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TrainOrderListQueryResponseBody() = default;
};
class TrainOrderListQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TrainOrderListQueryResponseBody> body{};

  TrainOrderListQueryResponse() {}

  explicit TrainOrderListQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TrainOrderListQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TrainOrderListQueryResponseBody>(model1);
      }
    }
  }


  virtual ~TrainOrderListQueryResponse() = default;
};
class TrainOrderQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  TrainOrderQueryHeaders() {}

  explicit TrainOrderQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~TrainOrderQueryHeaders() = default;
};
class TrainOrderQueryRequest : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<string> userId{};

  TrainOrderQueryRequest() {}

  explicit TrainOrderQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderQueryRequest() = default;
};
class TrainOrderQueryResponseBodyModuleChangeTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<string> changeCoachNo{};
  shared_ptr<double> changeGapFee{};
  shared_ptr<double> changeHandlingFee{};
  shared_ptr<string> changeSeatNo{};
  shared_ptr<string> changeSeatTypeName{};
  shared_ptr<double> changeServiceFee{};
  shared_ptr<string> changeTrainNo{};
  shared_ptr<string> changeTrainTypeName{};
  shared_ptr<string> checkInTime{};
  shared_ptr<string> checkOutTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> fromStationName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> originTicketNo{};
  shared_ptr<string> outTicketStatus{};
  shared_ptr<string> startTime{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> toStationName{};

  TrainOrderQueryResponseBodyModuleChangeTicketInfoList() {}

  explicit TrainOrderQueryResponseBodyModuleChangeTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeCoachNo) {
      res["change_coach_no"] = boost::any(*changeCoachNo);
    }
    if (changeGapFee) {
      res["change_gap_fee"] = boost::any(*changeGapFee);
    }
    if (changeHandlingFee) {
      res["change_handling_fee"] = boost::any(*changeHandlingFee);
    }
    if (changeSeatNo) {
      res["change_seat_no"] = boost::any(*changeSeatNo);
    }
    if (changeSeatTypeName) {
      res["change_seat_type_name"] = boost::any(*changeSeatTypeName);
    }
    if (changeServiceFee) {
      res["change_service_fee"] = boost::any(*changeServiceFee);
    }
    if (changeTrainNo) {
      res["change_train_no"] = boost::any(*changeTrainNo);
    }
    if (changeTrainTypeName) {
      res["change_train_type_name"] = boost::any(*changeTrainTypeName);
    }
    if (checkInTime) {
      res["check_in_time"] = boost::any(*checkInTime);
    }
    if (checkOutTime) {
      res["check_out_time"] = boost::any(*checkOutTime);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (fromStationName) {
      res["from_station_name"] = boost::any(*fromStationName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (originTicketNo) {
      res["origin_ticket_no"] = boost::any(*originTicketNo);
    }
    if (outTicketStatus) {
      res["out_ticket_status"] = boost::any(*outTicketStatus);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (toStationName) {
      res["to_station_name"] = boost::any(*toStationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("change_coach_no") != m.end() && !m["change_coach_no"].empty()) {
      changeCoachNo = make_shared<string>(boost::any_cast<string>(m["change_coach_no"]));
    }
    if (m.find("change_gap_fee") != m.end() && !m["change_gap_fee"].empty()) {
      changeGapFee = make_shared<double>(boost::any_cast<double>(m["change_gap_fee"]));
    }
    if (m.find("change_handling_fee") != m.end() && !m["change_handling_fee"].empty()) {
      changeHandlingFee = make_shared<double>(boost::any_cast<double>(m["change_handling_fee"]));
    }
    if (m.find("change_seat_no") != m.end() && !m["change_seat_no"].empty()) {
      changeSeatNo = make_shared<string>(boost::any_cast<string>(m["change_seat_no"]));
    }
    if (m.find("change_seat_type_name") != m.end() && !m["change_seat_type_name"].empty()) {
      changeSeatTypeName = make_shared<string>(boost::any_cast<string>(m["change_seat_type_name"]));
    }
    if (m.find("change_service_fee") != m.end() && !m["change_service_fee"].empty()) {
      changeServiceFee = make_shared<double>(boost::any_cast<double>(m["change_service_fee"]));
    }
    if (m.find("change_train_no") != m.end() && !m["change_train_no"].empty()) {
      changeTrainNo = make_shared<string>(boost::any_cast<string>(m["change_train_no"]));
    }
    if (m.find("change_train_type_name") != m.end() && !m["change_train_type_name"].empty()) {
      changeTrainTypeName = make_shared<string>(boost::any_cast<string>(m["change_train_type_name"]));
    }
    if (m.find("check_in_time") != m.end() && !m["check_in_time"].empty()) {
      checkInTime = make_shared<string>(boost::any_cast<string>(m["check_in_time"]));
    }
    if (m.find("check_out_time") != m.end() && !m["check_out_time"].empty()) {
      checkOutTime = make_shared<string>(boost::any_cast<string>(m["check_out_time"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("from_station_name") != m.end() && !m["from_station_name"].empty()) {
      fromStationName = make_shared<string>(boost::any_cast<string>(m["from_station_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("origin_ticket_no") != m.end() && !m["origin_ticket_no"].empty()) {
      originTicketNo = make_shared<string>(boost::any_cast<string>(m["origin_ticket_no"]));
    }
    if (m.find("out_ticket_status") != m.end() && !m["out_ticket_status"].empty()) {
      outTicketStatus = make_shared<string>(boost::any_cast<string>(m["out_ticket_status"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("to_station_name") != m.end() && !m["to_station_name"].empty()) {
      toStationName = make_shared<string>(boost::any_cast<string>(m["to_station_name"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModuleChangeTicketInfoList() = default;
};
class TrainOrderQueryResponseBodyModuleInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  TrainOrderQueryResponseBodyModuleInvoiceInfo() {}

  explicit TrainOrderQueryResponseBodyModuleInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModuleInvoiceInfo() = default;
};
class TrainOrderQueryResponseBodyModuleOrderBaseInfo : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> contactName{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> exceedApplyId{};
  shared_ptr<string> exceedThirdPartApplyId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> itineraryId{};
  shared_ptr<long> orderId{};
  shared_ptr<long> orderStatus{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartCorpId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<long> tripType{};
  shared_ptr<string> userId{};

  TrainOrderQueryResponseBodyModuleOrderBaseInfo() {}

  explicit TrainOrderQueryResponseBodyModuleOrderBaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (exceedApplyId) {
      res["exceed_apply_id"] = boost::any(*exceedApplyId);
    }
    if (exceedThirdPartApplyId) {
      res["exceed_third_part_apply_id"] = boost::any(*exceedThirdPartApplyId);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartCorpId) {
      res["thirdpart_corp_id"] = boost::any(*thirdpartCorpId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("exceed_apply_id") != m.end() && !m["exceed_apply_id"].empty()) {
      exceedApplyId = make_shared<string>(boost::any_cast<string>(m["exceed_apply_id"]));
    }
    if (m.find("exceed_third_part_apply_id") != m.end() && !m["exceed_third_part_apply_id"].empty()) {
      exceedThirdPartApplyId = make_shared<string>(boost::any_cast<string>(m["exceed_third_part_apply_id"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_corp_id") != m.end() && !m["thirdpart_corp_id"].empty()) {
      thirdpartCorpId = make_shared<string>(boost::any_cast<string>(m["thirdpart_corp_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModuleOrderBaseInfo() = default;
};
class TrainOrderQueryResponseBodyModulePassengerInfoList : public Darabonba::Model {
public:
  shared_ptr<long> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdpartProjectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> userType{};

  TrainOrderQueryResponseBodyModulePassengerInfoList() {}

  explicit TrainOrderQueryResponseBodyModulePassengerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdpartProjectId) {
      res["thirdpart_project_id"] = boost::any(*thirdpartProjectId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (userType) {
      res["user_type"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("thirdpart_project_id") != m.end() && !m["thirdpart_project_id"].empty()) {
      thirdpartProjectId = make_shared<string>(boost::any_cast<string>(m["thirdpart_project_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("user_type") != m.end() && !m["user_type"].empty()) {
      userType = make_shared<long>(boost::any_cast<long>(m["user_type"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModulePassengerInfoList() = default;
};
class TrainOrderQueryResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> payType{};
  shared_ptr<double> price{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  TrainOrderQueryResponseBodyModulePriceInfoList() {}

  explicit TrainOrderQueryResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModulePriceInfoList() = default;
};
class TrainOrderQueryResponseBodyModuleRefundTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<double> refundFee{};
  shared_ptr<double> refundServiceFee{};
  shared_ptr<string> ticketNo{};

  TrainOrderQueryResponseBodyModuleRefundTicketInfoList() {}

  explicit TrainOrderQueryResponseBodyModuleRefundTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (refundServiceFee) {
      res["refund_service_fee"] = boost::any(*refundServiceFee);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<double>(boost::any_cast<double>(m["refund_fee"]));
    }
    if (m.find("refund_service_fee") != m.end() && !m["refund_service_fee"].empty()) {
      refundServiceFee = make_shared<double>(boost::any_cast<double>(m["refund_service_fee"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModuleRefundTicketInfoList() = default;
};
class TrainOrderQueryResponseBodyModuleTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<bool> changed{};
  shared_ptr<string> checkInTime{};
  shared_ptr<string> checkOutTime{};
  shared_ptr<string> coachNo{};
  shared_ptr<string> endTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> outTicketStatus{};
  shared_ptr<long> payType{};
  shared_ptr<string> seatNo{};
  shared_ptr<string> seatTypeName{};
  shared_ptr<double> serviceFee{};
  shared_ptr<string> startTime{};
  shared_ptr<string> ticketNo{};
  shared_ptr<double> ticketPrice{};
  shared_ptr<long> ticketStatus{};
  shared_ptr<string> trainTypeName{};
  shared_ptr<string> userId{};

  TrainOrderQueryResponseBodyModuleTicketInfoList() {}

  explicit TrainOrderQueryResponseBodyModuleTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changed) {
      res["changed"] = boost::any(*changed);
    }
    if (checkInTime) {
      res["check_in_time"] = boost::any(*checkInTime);
    }
    if (checkOutTime) {
      res["check_out_time"] = boost::any(*checkOutTime);
    }
    if (coachNo) {
      res["coach_no"] = boost::any(*coachNo);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (outTicketStatus) {
      res["out_ticket_status"] = boost::any(*outTicketStatus);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (seatNo) {
      res["seat_no"] = boost::any(*seatNo);
    }
    if (seatTypeName) {
      res["seat_type_name"] = boost::any(*seatTypeName);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (ticketStatus) {
      res["ticket_status"] = boost::any(*ticketStatus);
    }
    if (trainTypeName) {
      res["train_type_name"] = boost::any(*trainTypeName);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("changed") != m.end() && !m["changed"].empty()) {
      changed = make_shared<bool>(boost::any_cast<bool>(m["changed"]));
    }
    if (m.find("check_in_time") != m.end() && !m["check_in_time"].empty()) {
      checkInTime = make_shared<string>(boost::any_cast<string>(m["check_in_time"]));
    }
    if (m.find("check_out_time") != m.end() && !m["check_out_time"].empty()) {
      checkOutTime = make_shared<string>(boost::any_cast<string>(m["check_out_time"]));
    }
    if (m.find("coach_no") != m.end() && !m["coach_no"].empty()) {
      coachNo = make_shared<string>(boost::any_cast<string>(m["coach_no"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("out_ticket_status") != m.end() && !m["out_ticket_status"].empty()) {
      outTicketStatus = make_shared<string>(boost::any_cast<string>(m["out_ticket_status"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("seat_no") != m.end() && !m["seat_no"].empty()) {
      seatNo = make_shared<string>(boost::any_cast<string>(m["seat_no"]));
    }
    if (m.find("seat_type_name") != m.end() && !m["seat_type_name"].empty()) {
      seatTypeName = make_shared<string>(boost::any_cast<string>(m["seat_type_name"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<double>(boost::any_cast<double>(m["service_fee"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<double>(boost::any_cast<double>(m["ticket_price"]));
    }
    if (m.find("ticket_status") != m.end() && !m["ticket_status"].empty()) {
      ticketStatus = make_shared<long>(boost::any_cast<long>(m["ticket_status"]));
    }
    if (m.find("train_type_name") != m.end() && !m["train_type_name"].empty()) {
      trainTypeName = make_shared<string>(boost::any_cast<string>(m["train_type_name"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModuleTicketInfoList() = default;
};
class TrainOrderQueryResponseBodyModuleTrainInfo : public Darabonba::Model {
public:
  shared_ptr<string> arrTime{};
  shared_ptr<string> depTime{};
  shared_ptr<string> fromCityAdCode{};
  shared_ptr<string> fromStationName{};
  shared_ptr<long> runTime{};
  shared_ptr<string> toCityAdCode{};
  shared_ptr<string> toStationName{};
  shared_ptr<string> trainNo{};

  TrainOrderQueryResponseBodyModuleTrainInfo() {}

  explicit TrainOrderQueryResponseBodyModuleTrainInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (fromCityAdCode) {
      res["from_city_ad_code"] = boost::any(*fromCityAdCode);
    }
    if (fromStationName) {
      res["from_station_name"] = boost::any(*fromStationName);
    }
    if (runTime) {
      res["run_time"] = boost::any(*runTime);
    }
    if (toCityAdCode) {
      res["to_city_ad_code"] = boost::any(*toCityAdCode);
    }
    if (toStationName) {
      res["to_station_name"] = boost::any(*toStationName);
    }
    if (trainNo) {
      res["train_no"] = boost::any(*trainNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("from_city_ad_code") != m.end() && !m["from_city_ad_code"].empty()) {
      fromCityAdCode = make_shared<string>(boost::any_cast<string>(m["from_city_ad_code"]));
    }
    if (m.find("from_station_name") != m.end() && !m["from_station_name"].empty()) {
      fromStationName = make_shared<string>(boost::any_cast<string>(m["from_station_name"]));
    }
    if (m.find("run_time") != m.end() && !m["run_time"].empty()) {
      runTime = make_shared<long>(boost::any_cast<long>(m["run_time"]));
    }
    if (m.find("to_city_ad_code") != m.end() && !m["to_city_ad_code"].empty()) {
      toCityAdCode = make_shared<string>(boost::any_cast<string>(m["to_city_ad_code"]));
    }
    if (m.find("to_station_name") != m.end() && !m["to_station_name"].empty()) {
      toStationName = make_shared<string>(boost::any_cast<string>(m["to_station_name"]));
    }
    if (m.find("train_no") != m.end() && !m["train_no"].empty()) {
      trainNo = make_shared<string>(boost::any_cast<string>(m["train_no"]));
    }
  }


  virtual ~TrainOrderQueryResponseBodyModuleTrainInfo() = default;
};
class TrainOrderQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<TrainOrderQueryResponseBodyModuleChangeTicketInfoList>> changeTicketInfoList{};
  shared_ptr<TrainOrderQueryResponseBodyModuleInvoiceInfo> invoiceInfo{};
  shared_ptr<TrainOrderQueryResponseBodyModuleOrderBaseInfo> orderBaseInfo{};
  shared_ptr<vector<TrainOrderQueryResponseBodyModulePassengerInfoList>> passengerInfoList{};
  shared_ptr<vector<TrainOrderQueryResponseBodyModulePriceInfoList>> priceInfoList{};
  shared_ptr<vector<TrainOrderQueryResponseBodyModuleRefundTicketInfoList>> refundTicketInfoList{};
  shared_ptr<vector<TrainOrderQueryResponseBodyModuleTicketInfoList>> ticketInfoList{};
  shared_ptr<TrainOrderQueryResponseBodyModuleTrainInfo> trainInfo{};

  TrainOrderQueryResponseBodyModule() {}

  explicit TrainOrderQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeTicketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*changeTicketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["change_ticket_info_list"] = boost::any(temp1);
    }
    if (invoiceInfo) {
      res["invoice_info"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderBaseInfo) {
      res["order_base_info"] = orderBaseInfo ? boost::any(orderBaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passengerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_info_list"] = boost::any(temp1);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    if (refundTicketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*refundTicketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_ticket_info_list"] = boost::any(temp1);
    }
    if (ticketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*ticketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ticket_info_list"] = boost::any(temp1);
    }
    if (trainInfo) {
      res["train_info"] = trainInfo ? boost::any(trainInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("change_ticket_info_list") != m.end() && !m["change_ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["change_ticket_info_list"].type()) {
        vector<TrainOrderQueryResponseBodyModuleChangeTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["change_ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryResponseBodyModuleChangeTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeTicketInfoList = make_shared<vector<TrainOrderQueryResponseBodyModuleChangeTicketInfoList>>(expect1);
      }
    }
    if (m.find("invoice_info") != m.end() && !m["invoice_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice_info"].type()) {
        TrainOrderQueryResponseBodyModuleInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice_info"]));
        invoiceInfo = make_shared<TrainOrderQueryResponseBodyModuleInvoiceInfo>(model1);
      }
    }
    if (m.find("order_base_info") != m.end() && !m["order_base_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["order_base_info"].type()) {
        TrainOrderQueryResponseBodyModuleOrderBaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["order_base_info"]));
        orderBaseInfo = make_shared<TrainOrderQueryResponseBodyModuleOrderBaseInfo>(model1);
      }
    }
    if (m.find("passenger_info_list") != m.end() && !m["passenger_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_info_list"].type()) {
        vector<TrainOrderQueryResponseBodyModulePassengerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryResponseBodyModulePassengerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerInfoList = make_shared<vector<TrainOrderQueryResponseBodyModulePassengerInfoList>>(expect1);
      }
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<TrainOrderQueryResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<TrainOrderQueryResponseBodyModulePriceInfoList>>(expect1);
      }
    }
    if (m.find("refund_ticket_info_list") != m.end() && !m["refund_ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_ticket_info_list"].type()) {
        vector<TrainOrderQueryResponseBodyModuleRefundTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryResponseBodyModuleRefundTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundTicketInfoList = make_shared<vector<TrainOrderQueryResponseBodyModuleRefundTicketInfoList>>(expect1);
      }
    }
    if (m.find("ticket_info_list") != m.end() && !m["ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["ticket_info_list"].type()) {
        vector<TrainOrderQueryResponseBodyModuleTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryResponseBodyModuleTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ticketInfoList = make_shared<vector<TrainOrderQueryResponseBodyModuleTicketInfoList>>(expect1);
      }
    }
    if (m.find("train_info") != m.end() && !m["train_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["train_info"].type()) {
        TrainOrderQueryResponseBodyModuleTrainInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["train_info"]));
        trainInfo = make_shared<TrainOrderQueryResponseBodyModuleTrainInfo>(model1);
      }
    }
  }


  virtual ~TrainOrderQueryResponseBodyModule() = default;
};
class TrainOrderQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TrainOrderQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TrainOrderQueryResponseBody() {}

  explicit TrainOrderQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TrainOrderQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TrainOrderQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TrainOrderQueryResponseBody() = default;
};
class TrainOrderQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TrainOrderQueryResponseBody> body{};

  TrainOrderQueryResponse() {}

  explicit TrainOrderQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TrainOrderQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TrainOrderQueryResponseBody>(model1);
      }
    }
  }


  virtual ~TrainOrderQueryResponse() = default;
};
class TrainOrderQueryV2Headers : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripCorpToken{};

  TrainOrderQueryV2Headers() {}

  explicit TrainOrderQueryV2Headers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripCorpToken) {
      res["x-acs-btrip-corp-token"] = boost::any(*xAcsBtripCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-corp-token") != m.end() && !m["x-acs-btrip-corp-token"].empty()) {
      xAcsBtripCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-corp-token"]));
    }
  }


  virtual ~TrainOrderQueryV2Headers() = default;
};
class TrainOrderQueryV2Request : public Darabonba::Model {
public:
  shared_ptr<long> orderId{};
  shared_ptr<string> userId{};

  TrainOrderQueryV2Request() {}

  explicit TrainOrderQueryV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderQueryV2Request() = default;
};
class TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<string> changeCoachNo{};
  shared_ptr<double> changeGapFee{};
  shared_ptr<double> changeHandlingFee{};
  shared_ptr<string> changeSeatNo{};
  shared_ptr<string> changeSeatTypeName{};
  shared_ptr<double> changeServiceFee{};
  shared_ptr<string> changeTrainNo{};
  shared_ptr<string> changeTrainTypeName{};
  shared_ptr<string> checkInTime{};
  shared_ptr<string> checkOutTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> fromCityName{};
  shared_ptr<string> fromStationName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> originTicketNo{};
  shared_ptr<string> outTicketStatus{};
  shared_ptr<long> segmentIndex{};
  shared_ptr<string> startTime{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> toCityName{};
  shared_ptr<string> toStationName{};
  shared_ptr<string> useTicket{};
  shared_ptr<string> userId{};

  TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList() {}

  explicit TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeCoachNo) {
      res["change_coach_no"] = boost::any(*changeCoachNo);
    }
    if (changeGapFee) {
      res["change_gap_fee"] = boost::any(*changeGapFee);
    }
    if (changeHandlingFee) {
      res["change_handling_fee"] = boost::any(*changeHandlingFee);
    }
    if (changeSeatNo) {
      res["change_seat_no"] = boost::any(*changeSeatNo);
    }
    if (changeSeatTypeName) {
      res["change_seat_type_name"] = boost::any(*changeSeatTypeName);
    }
    if (changeServiceFee) {
      res["change_service_fee"] = boost::any(*changeServiceFee);
    }
    if (changeTrainNo) {
      res["change_train_no"] = boost::any(*changeTrainNo);
    }
    if (changeTrainTypeName) {
      res["change_train_type_name"] = boost::any(*changeTrainTypeName);
    }
    if (checkInTime) {
      res["check_in_time"] = boost::any(*checkInTime);
    }
    if (checkOutTime) {
      res["check_out_time"] = boost::any(*checkOutTime);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (fromCityName) {
      res["from_city_name"] = boost::any(*fromCityName);
    }
    if (fromStationName) {
      res["from_station_name"] = boost::any(*fromStationName);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (originTicketNo) {
      res["origin_ticket_no"] = boost::any(*originTicketNo);
    }
    if (outTicketStatus) {
      res["out_ticket_status"] = boost::any(*outTicketStatus);
    }
    if (segmentIndex) {
      res["segment_index"] = boost::any(*segmentIndex);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (toCityName) {
      res["to_city_name"] = boost::any(*toCityName);
    }
    if (toStationName) {
      res["to_station_name"] = boost::any(*toStationName);
    }
    if (useTicket) {
      res["use_ticket"] = boost::any(*useTicket);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("change_coach_no") != m.end() && !m["change_coach_no"].empty()) {
      changeCoachNo = make_shared<string>(boost::any_cast<string>(m["change_coach_no"]));
    }
    if (m.find("change_gap_fee") != m.end() && !m["change_gap_fee"].empty()) {
      changeGapFee = make_shared<double>(boost::any_cast<double>(m["change_gap_fee"]));
    }
    if (m.find("change_handling_fee") != m.end() && !m["change_handling_fee"].empty()) {
      changeHandlingFee = make_shared<double>(boost::any_cast<double>(m["change_handling_fee"]));
    }
    if (m.find("change_seat_no") != m.end() && !m["change_seat_no"].empty()) {
      changeSeatNo = make_shared<string>(boost::any_cast<string>(m["change_seat_no"]));
    }
    if (m.find("change_seat_type_name") != m.end() && !m["change_seat_type_name"].empty()) {
      changeSeatTypeName = make_shared<string>(boost::any_cast<string>(m["change_seat_type_name"]));
    }
    if (m.find("change_service_fee") != m.end() && !m["change_service_fee"].empty()) {
      changeServiceFee = make_shared<double>(boost::any_cast<double>(m["change_service_fee"]));
    }
    if (m.find("change_train_no") != m.end() && !m["change_train_no"].empty()) {
      changeTrainNo = make_shared<string>(boost::any_cast<string>(m["change_train_no"]));
    }
    if (m.find("change_train_type_name") != m.end() && !m["change_train_type_name"].empty()) {
      changeTrainTypeName = make_shared<string>(boost::any_cast<string>(m["change_train_type_name"]));
    }
    if (m.find("check_in_time") != m.end() && !m["check_in_time"].empty()) {
      checkInTime = make_shared<string>(boost::any_cast<string>(m["check_in_time"]));
    }
    if (m.find("check_out_time") != m.end() && !m["check_out_time"].empty()) {
      checkOutTime = make_shared<string>(boost::any_cast<string>(m["check_out_time"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("from_city_name") != m.end() && !m["from_city_name"].empty()) {
      fromCityName = make_shared<string>(boost::any_cast<string>(m["from_city_name"]));
    }
    if (m.find("from_station_name") != m.end() && !m["from_station_name"].empty()) {
      fromStationName = make_shared<string>(boost::any_cast<string>(m["from_station_name"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("origin_ticket_no") != m.end() && !m["origin_ticket_no"].empty()) {
      originTicketNo = make_shared<string>(boost::any_cast<string>(m["origin_ticket_no"]));
    }
    if (m.find("out_ticket_status") != m.end() && !m["out_ticket_status"].empty()) {
      outTicketStatus = make_shared<string>(boost::any_cast<string>(m["out_ticket_status"]));
    }
    if (m.find("segment_index") != m.end() && !m["segment_index"].empty()) {
      segmentIndex = make_shared<long>(boost::any_cast<long>(m["segment_index"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("to_city_name") != m.end() && !m["to_city_name"].empty()) {
      toCityName = make_shared<string>(boost::any_cast<string>(m["to_city_name"]));
    }
    if (m.find("to_station_name") != m.end() && !m["to_station_name"].empty()) {
      toStationName = make_shared<string>(boost::any_cast<string>(m["to_station_name"]));
    }
    if (m.find("use_ticket") != m.end() && !m["use_ticket"].empty()) {
      useTicket = make_shared<string>(boost::any_cast<string>(m["use_ticket"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList() = default;
};
class TrainOrderQueryV2ResponseBodyModuleInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  TrainOrderQueryV2ResponseBodyModuleInvoiceInfo() {}

  explicit TrainOrderQueryV2ResponseBodyModuleInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleInvoiceInfo() = default;
};
class TrainOrderQueryV2ResponseBodyModuleOrderBaseInfo : public Darabonba::Model {
public:
  shared_ptr<string> applyId{};
  shared_ptr<string> btripTitle{};
  shared_ptr<string> contactName{};
  shared_ptr<string> contactPhone{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};
  shared_ptr<string> departId{};
  shared_ptr<string> departName{};
  shared_ptr<string> exceedApplyId{};
  shared_ptr<string> exceedThirdpartApplyId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> itineraryId{};
  shared_ptr<long> orderId{};
  shared_ptr<long> orderStatus{};
  shared_ptr<string> thirdpartApplyId{};
  shared_ptr<string> thirdpartDepartId{};
  shared_ptr<string> thirdpartItineraryId{};
  shared_ptr<long> tripType{};
  shared_ptr<string> userId{};
  shared_ptr<string> userNick{};

  TrainOrderQueryV2ResponseBodyModuleOrderBaseInfo() {}

  explicit TrainOrderQueryV2ResponseBodyModuleOrderBaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyId) {
      res["apply_id"] = boost::any(*applyId);
    }
    if (btripTitle) {
      res["btrip_title"] = boost::any(*btripTitle);
    }
    if (contactName) {
      res["contact_name"] = boost::any(*contactName);
    }
    if (contactPhone) {
      res["contact_phone"] = boost::any(*contactPhone);
    }
    if (corpId) {
      res["corp_id"] = boost::any(*corpId);
    }
    if (corpName) {
      res["corp_name"] = boost::any(*corpName);
    }
    if (departId) {
      res["depart_id"] = boost::any(*departId);
    }
    if (departName) {
      res["depart_name"] = boost::any(*departName);
    }
    if (exceedApplyId) {
      res["exceed_apply_id"] = boost::any(*exceedApplyId);
    }
    if (exceedThirdpartApplyId) {
      res["exceed_thirdpart_apply_id"] = boost::any(*exceedThirdpartApplyId);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (itineraryId) {
      res["itinerary_id"] = boost::any(*itineraryId);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (orderStatus) {
      res["order_status"] = boost::any(*orderStatus);
    }
    if (thirdpartApplyId) {
      res["thirdpart_apply_id"] = boost::any(*thirdpartApplyId);
    }
    if (thirdpartDepartId) {
      res["thirdpart_depart_id"] = boost::any(*thirdpartDepartId);
    }
    if (thirdpartItineraryId) {
      res["thirdpart_itinerary_id"] = boost::any(*thirdpartItineraryId);
    }
    if (tripType) {
      res["trip_type"] = boost::any(*tripType);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userNick) {
      res["user_nick"] = boost::any(*userNick);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apply_id") != m.end() && !m["apply_id"].empty()) {
      applyId = make_shared<string>(boost::any_cast<string>(m["apply_id"]));
    }
    if (m.find("btrip_title") != m.end() && !m["btrip_title"].empty()) {
      btripTitle = make_shared<string>(boost::any_cast<string>(m["btrip_title"]));
    }
    if (m.find("contact_name") != m.end() && !m["contact_name"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["contact_name"]));
    }
    if (m.find("contact_phone") != m.end() && !m["contact_phone"].empty()) {
      contactPhone = make_shared<string>(boost::any_cast<string>(m["contact_phone"]));
    }
    if (m.find("corp_id") != m.end() && !m["corp_id"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corp_id"]));
    }
    if (m.find("corp_name") != m.end() && !m["corp_name"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["corp_name"]));
    }
    if (m.find("depart_id") != m.end() && !m["depart_id"].empty()) {
      departId = make_shared<string>(boost::any_cast<string>(m["depart_id"]));
    }
    if (m.find("depart_name") != m.end() && !m["depart_name"].empty()) {
      departName = make_shared<string>(boost::any_cast<string>(m["depart_name"]));
    }
    if (m.find("exceed_apply_id") != m.end() && !m["exceed_apply_id"].empty()) {
      exceedApplyId = make_shared<string>(boost::any_cast<string>(m["exceed_apply_id"]));
    }
    if (m.find("exceed_thirdpart_apply_id") != m.end() && !m["exceed_thirdpart_apply_id"].empty()) {
      exceedThirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["exceed_thirdpart_apply_id"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("itinerary_id") != m.end() && !m["itinerary_id"].empty()) {
      itineraryId = make_shared<string>(boost::any_cast<string>(m["itinerary_id"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("order_status") != m.end() && !m["order_status"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["order_status"]));
    }
    if (m.find("thirdpart_apply_id") != m.end() && !m["thirdpart_apply_id"].empty()) {
      thirdpartApplyId = make_shared<string>(boost::any_cast<string>(m["thirdpart_apply_id"]));
    }
    if (m.find("thirdpart_depart_id") != m.end() && !m["thirdpart_depart_id"].empty()) {
      thirdpartDepartId = make_shared<string>(boost::any_cast<string>(m["thirdpart_depart_id"]));
    }
    if (m.find("thirdpart_itinerary_id") != m.end() && !m["thirdpart_itinerary_id"].empty()) {
      thirdpartItineraryId = make_shared<string>(boost::any_cast<string>(m["thirdpart_itinerary_id"]));
    }
    if (m.find("trip_type") != m.end() && !m["trip_type"].empty()) {
      tripType = make_shared<long>(boost::any_cast<long>(m["trip_type"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_nick") != m.end() && !m["user_nick"].empty()) {
      userNick = make_shared<string>(boost::any_cast<string>(m["user_nick"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleOrderBaseInfo() = default;
};
class TrainOrderQueryV2ResponseBodyModulePassengerInfoList : public Darabonba::Model {
public:
  shared_ptr<long> costCenterId{};
  shared_ptr<string> costCenterName{};
  shared_ptr<string> costCenterNumber{};
  shared_ptr<string> projectCode{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectTitle{};
  shared_ptr<string> thirdpartCostCenterId{};
  shared_ptr<string> thirdpartProjectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<long> userType{};

  TrainOrderQueryV2ResponseBodyModulePassengerInfoList() {}

  explicit TrainOrderQueryV2ResponseBodyModulePassengerInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costCenterId) {
      res["cost_center_id"] = boost::any(*costCenterId);
    }
    if (costCenterName) {
      res["cost_center_name"] = boost::any(*costCenterName);
    }
    if (costCenterNumber) {
      res["cost_center_number"] = boost::any(*costCenterNumber);
    }
    if (projectCode) {
      res["project_code"] = boost::any(*projectCode);
    }
    if (projectId) {
      res["project_id"] = boost::any(*projectId);
    }
    if (projectTitle) {
      res["project_title"] = boost::any(*projectTitle);
    }
    if (thirdpartCostCenterId) {
      res["thirdpart_cost_center_id"] = boost::any(*thirdpartCostCenterId);
    }
    if (thirdpartProjectId) {
      res["thirdpart_project_id"] = boost::any(*thirdpartProjectId);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    if (userName) {
      res["user_name"] = boost::any(*userName);
    }
    if (userType) {
      res["user_type"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cost_center_id") != m.end() && !m["cost_center_id"].empty()) {
      costCenterId = make_shared<long>(boost::any_cast<long>(m["cost_center_id"]));
    }
    if (m.find("cost_center_name") != m.end() && !m["cost_center_name"].empty()) {
      costCenterName = make_shared<string>(boost::any_cast<string>(m["cost_center_name"]));
    }
    if (m.find("cost_center_number") != m.end() && !m["cost_center_number"].empty()) {
      costCenterNumber = make_shared<string>(boost::any_cast<string>(m["cost_center_number"]));
    }
    if (m.find("project_code") != m.end() && !m["project_code"].empty()) {
      projectCode = make_shared<string>(boost::any_cast<string>(m["project_code"]));
    }
    if (m.find("project_id") != m.end() && !m["project_id"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["project_id"]));
    }
    if (m.find("project_title") != m.end() && !m["project_title"].empty()) {
      projectTitle = make_shared<string>(boost::any_cast<string>(m["project_title"]));
    }
    if (m.find("thirdpart_cost_center_id") != m.end() && !m["thirdpart_cost_center_id"].empty()) {
      thirdpartCostCenterId = make_shared<string>(boost::any_cast<string>(m["thirdpart_cost_center_id"]));
    }
    if (m.find("thirdpart_project_id") != m.end() && !m["thirdpart_project_id"].empty()) {
      thirdpartProjectId = make_shared<string>(boost::any_cast<string>(m["thirdpart_project_id"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
    if (m.find("user_name") != m.end() && !m["user_name"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["user_name"]));
    }
    if (m.find("user_type") != m.end() && !m["user_type"].empty()) {
      userType = make_shared<long>(boost::any_cast<long>(m["user_type"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModulePassengerInfoList() = default;
};
class TrainOrderQueryV2ResponseBodyModulePriceInfoList : public Darabonba::Model {
public:
  shared_ptr<long> categoryCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> passengerName{};
  shared_ptr<long> payType{};
  shared_ptr<double> price{};
  shared_ptr<string> tradeId{};
  shared_ptr<long> type{};

  TrainOrderQueryV2ResponseBodyModulePriceInfoList() {}

  explicit TrainOrderQueryV2ResponseBodyModulePriceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCode) {
      res["category_code"] = boost::any(*categoryCode);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (passengerName) {
      res["passenger_name"] = boost::any(*passengerName);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (tradeId) {
      res["trade_id"] = boost::any(*tradeId);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("category_code") != m.end() && !m["category_code"].empty()) {
      categoryCode = make_shared<long>(boost::any_cast<long>(m["category_code"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("passenger_name") != m.end() && !m["passenger_name"].empty()) {
      passengerName = make_shared<string>(boost::any_cast<string>(m["passenger_name"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<double>(boost::any_cast<double>(m["price"]));
    }
    if (m.find("trade_id") != m.end() && !m["trade_id"].empty()) {
      tradeId = make_shared<string>(boost::any_cast<string>(m["trade_id"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModulePriceInfoList() = default;
};
class TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<double> refundFee{};
  shared_ptr<double> refundServiceFee{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> userId{};

  TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList() {}

  explicit TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (refundFee) {
      res["refund_fee"] = boost::any(*refundFee);
    }
    if (refundServiceFee) {
      res["refund_service_fee"] = boost::any(*refundServiceFee);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("refund_fee") != m.end() && !m["refund_fee"].empty()) {
      refundFee = make_shared<double>(boost::any_cast<double>(m["refund_fee"]));
    }
    if (m.find("refund_service_fee") != m.end() && !m["refund_service_fee"].empty()) {
      refundServiceFee = make_shared<double>(boost::any_cast<double>(m["refund_service_fee"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList() = default;
};
class TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos : public Darabonba::Model {
public:
  shared_ptr<bool> changed{};
  shared_ptr<string> checkInTime{};
  shared_ptr<string> checkOutTime{};
  shared_ptr<string> coachNo{};
  shared_ptr<string> endTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> outTicketStatus{};
  shared_ptr<long> payType{};
  shared_ptr<string> seatNo{};
  shared_ptr<string> seatTypeName{};
  shared_ptr<long> segmentIndex{};
  shared_ptr<double> serviceFee{};
  shared_ptr<string> startTime{};
  shared_ptr<string> ticketNo{};
  shared_ptr<double> ticketPrice{};
  shared_ptr<long> ticketStatus{};
  shared_ptr<string> trainTypeName{};
  shared_ptr<string> useTicket{};
  shared_ptr<string> userId{};

  TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos() {}

  explicit TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changed) {
      res["changed"] = boost::any(*changed);
    }
    if (checkInTime) {
      res["check_in_time"] = boost::any(*checkInTime);
    }
    if (checkOutTime) {
      res["check_out_time"] = boost::any(*checkOutTime);
    }
    if (coachNo) {
      res["coach_no"] = boost::any(*coachNo);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (gmtCreate) {
      res["gmt_create"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["gmt_modify"] = boost::any(*gmtModify);
    }
    if (outTicketStatus) {
      res["out_ticket_status"] = boost::any(*outTicketStatus);
    }
    if (payType) {
      res["pay_type"] = boost::any(*payType);
    }
    if (seatNo) {
      res["seat_no"] = boost::any(*seatNo);
    }
    if (seatTypeName) {
      res["seat_type_name"] = boost::any(*seatTypeName);
    }
    if (segmentIndex) {
      res["segment_index"] = boost::any(*segmentIndex);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (ticketPrice) {
      res["ticket_price"] = boost::any(*ticketPrice);
    }
    if (ticketStatus) {
      res["ticket_status"] = boost::any(*ticketStatus);
    }
    if (trainTypeName) {
      res["train_type_name"] = boost::any(*trainTypeName);
    }
    if (useTicket) {
      res["use_ticket"] = boost::any(*useTicket);
    }
    if (userId) {
      res["user_id"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("changed") != m.end() && !m["changed"].empty()) {
      changed = make_shared<bool>(boost::any_cast<bool>(m["changed"]));
    }
    if (m.find("check_in_time") != m.end() && !m["check_in_time"].empty()) {
      checkInTime = make_shared<string>(boost::any_cast<string>(m["check_in_time"]));
    }
    if (m.find("check_out_time") != m.end() && !m["check_out_time"].empty()) {
      checkOutTime = make_shared<string>(boost::any_cast<string>(m["check_out_time"]));
    }
    if (m.find("coach_no") != m.end() && !m["coach_no"].empty()) {
      coachNo = make_shared<string>(boost::any_cast<string>(m["coach_no"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("gmt_create") != m.end() && !m["gmt_create"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmt_create"]));
    }
    if (m.find("gmt_modify") != m.end() && !m["gmt_modify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["gmt_modify"]));
    }
    if (m.find("out_ticket_status") != m.end() && !m["out_ticket_status"].empty()) {
      outTicketStatus = make_shared<string>(boost::any_cast<string>(m["out_ticket_status"]));
    }
    if (m.find("pay_type") != m.end() && !m["pay_type"].empty()) {
      payType = make_shared<long>(boost::any_cast<long>(m["pay_type"]));
    }
    if (m.find("seat_no") != m.end() && !m["seat_no"].empty()) {
      seatNo = make_shared<string>(boost::any_cast<string>(m["seat_no"]));
    }
    if (m.find("seat_type_name") != m.end() && !m["seat_type_name"].empty()) {
      seatTypeName = make_shared<string>(boost::any_cast<string>(m["seat_type_name"]));
    }
    if (m.find("segment_index") != m.end() && !m["segment_index"].empty()) {
      segmentIndex = make_shared<long>(boost::any_cast<long>(m["segment_index"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<double>(boost::any_cast<double>(m["service_fee"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("ticket_price") != m.end() && !m["ticket_price"].empty()) {
      ticketPrice = make_shared<double>(boost::any_cast<double>(m["ticket_price"]));
    }
    if (m.find("ticket_status") != m.end() && !m["ticket_status"].empty()) {
      ticketStatus = make_shared<long>(boost::any_cast<long>(m["ticket_status"]));
    }
    if (m.find("train_type_name") != m.end() && !m["train_type_name"].empty()) {
      trainTypeName = make_shared<string>(boost::any_cast<string>(m["train_type_name"]));
    }
    if (m.find("use_ticket") != m.end() && !m["use_ticket"].empty()) {
      useTicket = make_shared<string>(boost::any_cast<string>(m["use_ticket"]));
    }
    if (m.find("user_id") != m.end() && !m["user_id"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["user_id"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos() = default;
};
class TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList : public Darabonba::Model {
public:
  shared_ptr<string> arrTime{};
  shared_ptr<string> depTime{};
  shared_ptr<string> fromCityAdCode{};
  shared_ptr<string> fromCityName{};
  shared_ptr<string> fromStationName{};
  shared_ptr<long> itemId{};
  shared_ptr<long> runTime{};
  shared_ptr<string> toCityAdCode{};
  shared_ptr<string> toCityName{};
  shared_ptr<string> toStationName{};
  shared_ptr<string> trainNo{};
  shared_ptr<vector<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos>> trainTicketInfos{};

  TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList() {}

  explicit TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrTime) {
      res["arr_time"] = boost::any(*arrTime);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (fromCityAdCode) {
      res["from_city_ad_code"] = boost::any(*fromCityAdCode);
    }
    if (fromCityName) {
      res["from_city_name"] = boost::any(*fromCityName);
    }
    if (fromStationName) {
      res["from_station_name"] = boost::any(*fromStationName);
    }
    if (itemId) {
      res["item_id"] = boost::any(*itemId);
    }
    if (runTime) {
      res["run_time"] = boost::any(*runTime);
    }
    if (toCityAdCode) {
      res["to_city_ad_code"] = boost::any(*toCityAdCode);
    }
    if (toCityName) {
      res["to_city_name"] = boost::any(*toCityName);
    }
    if (toStationName) {
      res["to_station_name"] = boost::any(*toStationName);
    }
    if (trainNo) {
      res["train_no"] = boost::any(*trainNo);
    }
    if (trainTicketInfos) {
      vector<boost::any> temp1;
      for(auto item1:*trainTicketInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["train_ticket_infos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_time") != m.end() && !m["arr_time"].empty()) {
      arrTime = make_shared<string>(boost::any_cast<string>(m["arr_time"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("from_city_ad_code") != m.end() && !m["from_city_ad_code"].empty()) {
      fromCityAdCode = make_shared<string>(boost::any_cast<string>(m["from_city_ad_code"]));
    }
    if (m.find("from_city_name") != m.end() && !m["from_city_name"].empty()) {
      fromCityName = make_shared<string>(boost::any_cast<string>(m["from_city_name"]));
    }
    if (m.find("from_station_name") != m.end() && !m["from_station_name"].empty()) {
      fromStationName = make_shared<string>(boost::any_cast<string>(m["from_station_name"]));
    }
    if (m.find("item_id") != m.end() && !m["item_id"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["item_id"]));
    }
    if (m.find("run_time") != m.end() && !m["run_time"].empty()) {
      runTime = make_shared<long>(boost::any_cast<long>(m["run_time"]));
    }
    if (m.find("to_city_ad_code") != m.end() && !m["to_city_ad_code"].empty()) {
      toCityAdCode = make_shared<string>(boost::any_cast<string>(m["to_city_ad_code"]));
    }
    if (m.find("to_city_name") != m.end() && !m["to_city_name"].empty()) {
      toCityName = make_shared<string>(boost::any_cast<string>(m["to_city_name"]));
    }
    if (m.find("to_station_name") != m.end() && !m["to_station_name"].empty()) {
      toStationName = make_shared<string>(boost::any_cast<string>(m["to_station_name"]));
    }
    if (m.find("train_no") != m.end() && !m["train_no"].empty()) {
      trainNo = make_shared<string>(boost::any_cast<string>(m["train_no"]));
    }
    if (m.find("train_ticket_infos") != m.end() && !m["train_ticket_infos"].empty()) {
      if (typeid(vector<boost::any>) == m["train_ticket_infos"].type()) {
        vector<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["train_ticket_infos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trainTicketInfos = make_shared<vector<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoListTrainTicketInfos>>(expect1);
      }
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList() = default;
};
class TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainTransferInfo : public Darabonba::Model {
public:
  shared_ptr<string> costTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> fromCityAdCode{};
  shared_ptr<string> fromCityName{};
  shared_ptr<string> fromStationName{};
  shared_ptr<string> middleCity{};
  shared_ptr<string> middleCityAdCode{};
  shared_ptr<string> middleDate{};
  shared_ptr<string> middleStation{};
  shared_ptr<string> middleType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> toCityAdCode{};
  shared_ptr<string> toCityName{};
  shared_ptr<string> toStationName{};
  shared_ptr<string> waitTime{};

  TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainTransferInfo() {}

  explicit TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainTransferInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (costTime) {
      res["cost_time"] = boost::any(*costTime);
    }
    if (endTime) {
      res["end_time"] = boost::any(*endTime);
    }
    if (fromCityAdCode) {
      res["from_city_ad_code"] = boost::any(*fromCityAdCode);
    }
    if (fromCityName) {
      res["from_city_name"] = boost::any(*fromCityName);
    }
    if (fromStationName) {
      res["from_station_name"] = boost::any(*fromStationName);
    }
    if (middleCity) {
      res["middle_city"] = boost::any(*middleCity);
    }
    if (middleCityAdCode) {
      res["middle_city_ad_code"] = boost::any(*middleCityAdCode);
    }
    if (middleDate) {
      res["middle_date"] = boost::any(*middleDate);
    }
    if (middleStation) {
      res["middle_station"] = boost::any(*middleStation);
    }
    if (middleType) {
      res["middle_type"] = boost::any(*middleType);
    }
    if (startTime) {
      res["start_time"] = boost::any(*startTime);
    }
    if (toCityAdCode) {
      res["to_city_ad_code"] = boost::any(*toCityAdCode);
    }
    if (toCityName) {
      res["to_city_name"] = boost::any(*toCityName);
    }
    if (toStationName) {
      res["to_station_name"] = boost::any(*toStationName);
    }
    if (waitTime) {
      res["wait_time"] = boost::any(*waitTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cost_time") != m.end() && !m["cost_time"].empty()) {
      costTime = make_shared<string>(boost::any_cast<string>(m["cost_time"]));
    }
    if (m.find("end_time") != m.end() && !m["end_time"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["end_time"]));
    }
    if (m.find("from_city_ad_code") != m.end() && !m["from_city_ad_code"].empty()) {
      fromCityAdCode = make_shared<string>(boost::any_cast<string>(m["from_city_ad_code"]));
    }
    if (m.find("from_city_name") != m.end() && !m["from_city_name"].empty()) {
      fromCityName = make_shared<string>(boost::any_cast<string>(m["from_city_name"]));
    }
    if (m.find("from_station_name") != m.end() && !m["from_station_name"].empty()) {
      fromStationName = make_shared<string>(boost::any_cast<string>(m["from_station_name"]));
    }
    if (m.find("middle_city") != m.end() && !m["middle_city"].empty()) {
      middleCity = make_shared<string>(boost::any_cast<string>(m["middle_city"]));
    }
    if (m.find("middle_city_ad_code") != m.end() && !m["middle_city_ad_code"].empty()) {
      middleCityAdCode = make_shared<string>(boost::any_cast<string>(m["middle_city_ad_code"]));
    }
    if (m.find("middle_date") != m.end() && !m["middle_date"].empty()) {
      middleDate = make_shared<string>(boost::any_cast<string>(m["middle_date"]));
    }
    if (m.find("middle_station") != m.end() && !m["middle_station"].empty()) {
      middleStation = make_shared<string>(boost::any_cast<string>(m["middle_station"]));
    }
    if (m.find("middle_type") != m.end() && !m["middle_type"].empty()) {
      middleType = make_shared<string>(boost::any_cast<string>(m["middle_type"]));
    }
    if (m.find("start_time") != m.end() && !m["start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["start_time"]));
    }
    if (m.find("to_city_ad_code") != m.end() && !m["to_city_ad_code"].empty()) {
      toCityAdCode = make_shared<string>(boost::any_cast<string>(m["to_city_ad_code"]));
    }
    if (m.find("to_city_name") != m.end() && !m["to_city_name"].empty()) {
      toCityName = make_shared<string>(boost::any_cast<string>(m["to_city_name"]));
    }
    if (m.find("to_station_name") != m.end() && !m["to_station_name"].empty()) {
      toStationName = make_shared<string>(boost::any_cast<string>(m["to_station_name"]));
    }
    if (m.find("wait_time") != m.end() && !m["wait_time"].empty()) {
      waitTime = make_shared<string>(boost::any_cast<string>(m["wait_time"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainTransferInfo() = default;
};
class TrainOrderQueryV2ResponseBodyModuleTrainOrderInfo : public Darabonba::Model {
public:
  shared_ptr<vector<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList>> trainInfoList{};
  shared_ptr<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainTransferInfo> trainTransferInfo{};

  TrainOrderQueryV2ResponseBodyModuleTrainOrderInfo() {}

  explicit TrainOrderQueryV2ResponseBodyModuleTrainOrderInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trainInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*trainInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["train_info_list"] = boost::any(temp1);
    }
    if (trainTransferInfo) {
      res["train_transfer_info"] = trainTransferInfo ? boost::any(trainTransferInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("train_info_list") != m.end() && !m["train_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["train_info_list"].type()) {
        vector<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["train_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trainInfoList = make_shared<vector<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainInfoList>>(expect1);
      }
    }
    if (m.find("train_transfer_info") != m.end() && !m["train_transfer_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["train_transfer_info"].type()) {
        TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainTransferInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["train_transfer_info"]));
        trainTransferInfo = make_shared<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfoTrainTransferInfo>(model1);
      }
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModuleTrainOrderInfo() = default;
};
class TrainOrderQueryV2ResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList>> changeTicketInfoList{};
  shared_ptr<TrainOrderQueryV2ResponseBodyModuleInvoiceInfo> invoiceInfo{};
  shared_ptr<TrainOrderQueryV2ResponseBodyModuleOrderBaseInfo> orderBaseInfo{};
  shared_ptr<vector<TrainOrderQueryV2ResponseBodyModulePassengerInfoList>> passengerInfoList{};
  shared_ptr<vector<TrainOrderQueryV2ResponseBodyModulePriceInfoList>> priceInfoList{};
  shared_ptr<vector<TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList>> refundTicketInfoList{};
  shared_ptr<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfo> trainOrderInfo{};

  TrainOrderQueryV2ResponseBodyModule() {}

  explicit TrainOrderQueryV2ResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeTicketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*changeTicketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["change_ticket_info_list"] = boost::any(temp1);
    }
    if (invoiceInfo) {
      res["invoice_info"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderBaseInfo) {
      res["order_base_info"] = orderBaseInfo ? boost::any(orderBaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (passengerInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*passengerInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["passenger_info_list"] = boost::any(temp1);
    }
    if (priceInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*priceInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["price_info_list"] = boost::any(temp1);
    }
    if (refundTicketInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*refundTicketInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["refund_ticket_info_list"] = boost::any(temp1);
    }
    if (trainOrderInfo) {
      res["train_order_info"] = trainOrderInfo ? boost::any(trainOrderInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("change_ticket_info_list") != m.end() && !m["change_ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["change_ticket_info_list"].type()) {
        vector<TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["change_ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        changeTicketInfoList = make_shared<vector<TrainOrderQueryV2ResponseBodyModuleChangeTicketInfoList>>(expect1);
      }
    }
    if (m.find("invoice_info") != m.end() && !m["invoice_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["invoice_info"].type()) {
        TrainOrderQueryV2ResponseBodyModuleInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["invoice_info"]));
        invoiceInfo = make_shared<TrainOrderQueryV2ResponseBodyModuleInvoiceInfo>(model1);
      }
    }
    if (m.find("order_base_info") != m.end() && !m["order_base_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["order_base_info"].type()) {
        TrainOrderQueryV2ResponseBodyModuleOrderBaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["order_base_info"]));
        orderBaseInfo = make_shared<TrainOrderQueryV2ResponseBodyModuleOrderBaseInfo>(model1);
      }
    }
    if (m.find("passenger_info_list") != m.end() && !m["passenger_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["passenger_info_list"].type()) {
        vector<TrainOrderQueryV2ResponseBodyModulePassengerInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["passenger_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryV2ResponseBodyModulePassengerInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passengerInfoList = make_shared<vector<TrainOrderQueryV2ResponseBodyModulePassengerInfoList>>(expect1);
      }
    }
    if (m.find("price_info_list") != m.end() && !m["price_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["price_info_list"].type()) {
        vector<TrainOrderQueryV2ResponseBodyModulePriceInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["price_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryV2ResponseBodyModulePriceInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        priceInfoList = make_shared<vector<TrainOrderQueryV2ResponseBodyModulePriceInfoList>>(expect1);
      }
    }
    if (m.find("refund_ticket_info_list") != m.end() && !m["refund_ticket_info_list"].empty()) {
      if (typeid(vector<boost::any>) == m["refund_ticket_info_list"].type()) {
        vector<TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["refund_ticket_info_list"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundTicketInfoList = make_shared<vector<TrainOrderQueryV2ResponseBodyModuleRefundTicketInfoList>>(expect1);
      }
    }
    if (m.find("train_order_info") != m.end() && !m["train_order_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["train_order_info"].type()) {
        TrainOrderQueryV2ResponseBodyModuleTrainOrderInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["train_order_info"]));
        trainOrderInfo = make_shared<TrainOrderQueryV2ResponseBodyModuleTrainOrderInfo>(model1);
      }
    }
  }


  virtual ~TrainOrderQueryV2ResponseBodyModule() = default;
};
class TrainOrderQueryV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TrainOrderQueryV2ResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TrainOrderQueryV2ResponseBody() {}

  explicit TrainOrderQueryV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TrainOrderQueryV2ResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TrainOrderQueryV2ResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TrainOrderQueryV2ResponseBody() = default;
};
class TrainOrderQueryV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TrainOrderQueryV2ResponseBody> body{};

  TrainOrderQueryV2Response() {}

  explicit TrainOrderQueryV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TrainOrderQueryV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TrainOrderQueryV2ResponseBody>(model1);
      }
    }
  }


  virtual ~TrainOrderQueryV2Response() = default;
};
class TrainStationSearchHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  TrainStationSearchHeaders() {}

  explicit TrainStationSearchHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~TrainStationSearchHeaders() = default;
};
class TrainStationSearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};

  TrainStationSearchRequest() {}

  explicit TrainStationSearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["keyword"] = boost::any(*keyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("keyword") != m.end() && !m["keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["keyword"]));
    }
  }


  virtual ~TrainStationSearchRequest() = default;
};
class TrainStationSearchResponseBodyModuleCities : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  TrainStationSearchResponseBodyModuleCities() {}

  explicit TrainStationSearchResponseBodyModuleCities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~TrainStationSearchResponseBodyModuleCities() = default;
};
class TrainStationSearchResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<TrainStationSearchResponseBodyModuleCities>> cities{};

  TrainStationSearchResponseBodyModule() {}

  explicit TrainStationSearchResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cities) {
      vector<boost::any> temp1;
      for(auto item1:*cities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cities"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cities") != m.end() && !m["cities"].empty()) {
      if (typeid(vector<boost::any>) == m["cities"].type()) {
        vector<TrainStationSearchResponseBodyModuleCities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainStationSearchResponseBodyModuleCities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cities = make_shared<vector<TrainStationSearchResponseBodyModuleCities>>(expect1);
      }
    }
  }


  virtual ~TrainStationSearchResponseBodyModule() = default;
};
class TrainStationSearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TrainStationSearchResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TrainStationSearchResponseBody() {}

  explicit TrainStationSearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TrainStationSearchResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TrainStationSearchResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TrainStationSearchResponseBody() = default;
};
class TrainStationSearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TrainStationSearchResponseBody> body{};

  TrainStationSearchResponse() {}

  explicit TrainStationSearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TrainStationSearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TrainStationSearchResponseBody>(model1);
      }
    }
  }


  virtual ~TrainStationSearchResponse() = default;
};
class TrainTicketScanQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  TrainTicketScanQueryHeaders() {}

  explicit TrainTicketScanQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~TrainTicketScanQueryHeaders() = default;
};
class TrainTicketScanQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> billDate{};
  shared_ptr<long> billId{};
  shared_ptr<long> invoiceSubTaskId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> ticketNo{};

  TrainTicketScanQueryRequest() {}

  explicit TrainTicketScanQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (billId) {
      res["bill_id"] = boost::any(*billId);
    }
    if (invoiceSubTaskId) {
      res["invoice_sub_task_id"] = boost::any(*invoiceSubTaskId);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (serialNumber) {
      res["serial_number"] = boost::any(*serialNumber);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("bill_id") != m.end() && !m["bill_id"].empty()) {
      billId = make_shared<long>(boost::any_cast<long>(m["bill_id"]));
    }
    if (m.find("invoice_sub_task_id") != m.end() && !m["invoice_sub_task_id"].empty()) {
      invoiceSubTaskId = make_shared<long>(boost::any_cast<long>(m["invoice_sub_task_id"]));
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("serial_number") != m.end() && !m["serial_number"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["serial_number"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
  }


  virtual ~TrainTicketScanQueryRequest() = default;
};
class TrainTicketScanQueryResponseBodyModuleItems : public Darabonba::Model {
public:
  shared_ptr<string> arrStation{};
  shared_ptr<string> billDate{};
  shared_ptr<string> coachName{};
  shared_ptr<string> costCenter{};
  shared_ptr<string> depStation{};
  shared_ptr<string> depTime{};
  shared_ptr<string> department{};
  shared_ptr<string> id{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<long> orderId{};
  shared_ptr<string> ossUrl{};
  shared_ptr<string> passenger{};
  shared_ptr<string> price{};
  shared_ptr<string> project{};
  shared_ptr<string> seat{};
  shared_ptr<string> seatNo{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> taxAmount{};
  shared_ptr<string> taxRate{};
  shared_ptr<string> ticketNo{};
  shared_ptr<string> trainNo{};

  TrainTicketScanQueryResponseBodyModuleItems() {}

  explicit TrainTicketScanQueryResponseBodyModuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrStation) {
      res["arr_station"] = boost::any(*arrStation);
    }
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (coachName) {
      res["coach_name"] = boost::any(*coachName);
    }
    if (costCenter) {
      res["cost_center"] = boost::any(*costCenter);
    }
    if (depStation) {
      res["dep_station"] = boost::any(*depStation);
    }
    if (depTime) {
      res["dep_time"] = boost::any(*depTime);
    }
    if (department) {
      res["department"] = boost::any(*department);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (orderId) {
      res["order_id"] = boost::any(*orderId);
    }
    if (ossUrl) {
      res["oss_url"] = boost::any(*ossUrl);
    }
    if (passenger) {
      res["passenger"] = boost::any(*passenger);
    }
    if (price) {
      res["price"] = boost::any(*price);
    }
    if (project) {
      res["project"] = boost::any(*project);
    }
    if (seat) {
      res["seat"] = boost::any(*seat);
    }
    if (seatNo) {
      res["seat_no"] = boost::any(*seatNo);
    }
    if (serialNumber) {
      res["serial_number"] = boost::any(*serialNumber);
    }
    if (taxAmount) {
      res["tax_amount"] = boost::any(*taxAmount);
    }
    if (taxRate) {
      res["tax_rate"] = boost::any(*taxRate);
    }
    if (ticketNo) {
      res["ticket_no"] = boost::any(*ticketNo);
    }
    if (trainNo) {
      res["train_no"] = boost::any(*trainNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arr_station") != m.end() && !m["arr_station"].empty()) {
      arrStation = make_shared<string>(boost::any_cast<string>(m["arr_station"]));
    }
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("coach_name") != m.end() && !m["coach_name"].empty()) {
      coachName = make_shared<string>(boost::any_cast<string>(m["coach_name"]));
    }
    if (m.find("cost_center") != m.end() && !m["cost_center"].empty()) {
      costCenter = make_shared<string>(boost::any_cast<string>(m["cost_center"]));
    }
    if (m.find("dep_station") != m.end() && !m["dep_station"].empty()) {
      depStation = make_shared<string>(boost::any_cast<string>(m["dep_station"]));
    }
    if (m.find("dep_time") != m.end() && !m["dep_time"].empty()) {
      depTime = make_shared<string>(boost::any_cast<string>(m["dep_time"]));
    }
    if (m.find("department") != m.end() && !m["department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["department"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("order_id") != m.end() && !m["order_id"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["order_id"]));
    }
    if (m.find("oss_url") != m.end() && !m["oss_url"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["oss_url"]));
    }
    if (m.find("passenger") != m.end() && !m["passenger"].empty()) {
      passenger = make_shared<string>(boost::any_cast<string>(m["passenger"]));
    }
    if (m.find("price") != m.end() && !m["price"].empty()) {
      price = make_shared<string>(boost::any_cast<string>(m["price"]));
    }
    if (m.find("project") != m.end() && !m["project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["project"]));
    }
    if (m.find("seat") != m.end() && !m["seat"].empty()) {
      seat = make_shared<string>(boost::any_cast<string>(m["seat"]));
    }
    if (m.find("seat_no") != m.end() && !m["seat_no"].empty()) {
      seatNo = make_shared<string>(boost::any_cast<string>(m["seat_no"]));
    }
    if (m.find("serial_number") != m.end() && !m["serial_number"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["serial_number"]));
    }
    if (m.find("tax_amount") != m.end() && !m["tax_amount"].empty()) {
      taxAmount = make_shared<string>(boost::any_cast<string>(m["tax_amount"]));
    }
    if (m.find("tax_rate") != m.end() && !m["tax_rate"].empty()) {
      taxRate = make_shared<string>(boost::any_cast<string>(m["tax_rate"]));
    }
    if (m.find("ticket_no") != m.end() && !m["ticket_no"].empty()) {
      ticketNo = make_shared<string>(boost::any_cast<string>(m["ticket_no"]));
    }
    if (m.find("train_no") != m.end() && !m["train_no"].empty()) {
      trainNo = make_shared<string>(boost::any_cast<string>(m["train_no"]));
    }
  }


  virtual ~TrainTicketScanQueryResponseBodyModuleItems() = default;
};
class TrainTicketScanQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<TrainTicketScanQueryResponseBodyModuleItems>> items{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalPage{};
  shared_ptr<long> totalSize{};

  TrainTicketScanQueryResponseBodyModule() {}

  explicit TrainTicketScanQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalPage) {
      res["total_page"] = boost::any(*totalPage);
    }
    if (totalSize) {
      res["total_size"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<TrainTicketScanQueryResponseBodyModuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TrainTicketScanQueryResponseBodyModuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<TrainTicketScanQueryResponseBodyModuleItems>>(expect1);
      }
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_page") != m.end() && !m["total_page"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["total_page"]));
    }
    if (m.find("total_size") != m.end() && !m["total_size"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["total_size"]));
    }
  }


  virtual ~TrainTicketScanQueryResponseBodyModule() = default;
};
class TrainTicketScanQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<TrainTicketScanQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  TrainTicketScanQueryResponseBody() {}

  explicit TrainTicketScanQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        TrainTicketScanQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<TrainTicketScanQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~TrainTicketScanQueryResponseBody() = default;
};
class TrainTicketScanQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TrainTicketScanQueryResponseBody> body{};

  TrainTicketScanQueryResponse() {}

  explicit TrainTicketScanQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TrainTicketScanQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TrainTicketScanQueryResponseBody>(model1);
      }
    }
  }


  virtual ~TrainTicketScanQueryResponse() = default;
};
class UserQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  UserQueryHeaders() {}

  explicit UserQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~UserQueryHeaders() = default;
};
class UserQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> modifiedTimeGreaterOrEqualThan{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pageToken{};
  shared_ptr<string> thirdPartJobNo{};

  UserQueryRequest() {}

  explicit UserQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modifiedTimeGreaterOrEqualThan) {
      res["modified_time_greater_or_equal_than"] = boost::any(*modifiedTimeGreaterOrEqualThan);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (pageToken) {
      res["page_token"] = boost::any(*pageToken);
    }
    if (thirdPartJobNo) {
      res["third_part_job_no"] = boost::any(*thirdPartJobNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("modified_time_greater_or_equal_than") != m.end() && !m["modified_time_greater_or_equal_than"].empty()) {
      modifiedTimeGreaterOrEqualThan = make_shared<string>(boost::any_cast<string>(m["modified_time_greater_or_equal_than"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("page_token") != m.end() && !m["page_token"].empty()) {
      pageToken = make_shared<string>(boost::any_cast<string>(m["page_token"]));
    }
    if (m.find("third_part_job_no") != m.end() && !m["third_part_job_no"].empty()) {
      thirdPartJobNo = make_shared<string>(boost::any_cast<string>(m["third_part_job_no"]));
    }
  }


  virtual ~UserQueryRequest() = default;
};
class UserQueryResponseBodyModuleItems : public Darabonba::Model {
public:
  shared_ptr<string> employeeNick{};
  shared_ptr<long> leaveStatus{};
  shared_ptr<string> thirdPartEmployeeId{};
  shared_ptr<string> thirdPartJobNo{};

  UserQueryResponseBodyModuleItems() {}

  explicit UserQueryResponseBodyModuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (employeeNick) {
      res["employee_nick"] = boost::any(*employeeNick);
    }
    if (leaveStatus) {
      res["leave_status"] = boost::any(*leaveStatus);
    }
    if (thirdPartEmployeeId) {
      res["third_part_employee_id"] = boost::any(*thirdPartEmployeeId);
    }
    if (thirdPartJobNo) {
      res["third_part_job_no"] = boost::any(*thirdPartJobNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("employee_nick") != m.end() && !m["employee_nick"].empty()) {
      employeeNick = make_shared<string>(boost::any_cast<string>(m["employee_nick"]));
    }
    if (m.find("leave_status") != m.end() && !m["leave_status"].empty()) {
      leaveStatus = make_shared<long>(boost::any_cast<long>(m["leave_status"]));
    }
    if (m.find("third_part_employee_id") != m.end() && !m["third_part_employee_id"].empty()) {
      thirdPartEmployeeId = make_shared<string>(boost::any_cast<string>(m["third_part_employee_id"]));
    }
    if (m.find("third_part_job_no") != m.end() && !m["third_part_job_no"].empty()) {
      thirdPartJobNo = make_shared<string>(boost::any_cast<string>(m["third_part_job_no"]));
    }
  }


  virtual ~UserQueryResponseBodyModuleItems() = default;
};
class UserQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<UserQueryResponseBodyModuleItems>> items{};
  shared_ptr<string> pageToken{};
  shared_ptr<long> total{};

  UserQueryResponseBodyModule() {}

  explicit UserQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["has_more"] = boost::any(*hasMore);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (pageToken) {
      res["page_token"] = boost::any(*pageToken);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("has_more") != m.end() && !m["has_more"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["has_more"]));
    }
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<UserQueryResponseBodyModuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UserQueryResponseBodyModuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<UserQueryResponseBodyModuleItems>>(expect1);
      }
    }
    if (m.find("page_token") != m.end() && !m["page_token"].empty()) {
      pageToken = make_shared<string>(boost::any_cast<string>(m["page_token"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
  }


  virtual ~UserQueryResponseBodyModule() = default;
};
class UserQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<UserQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  UserQueryResponseBody() {}

  explicit UserQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        UserQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<UserQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~UserQueryResponseBody() = default;
};
class UserQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UserQueryResponseBody> body{};

  UserQueryResponse() {}

  explicit UserQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UserQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UserQueryResponseBody>(model1);
      }
    }
  }


  virtual ~UserQueryResponse() = default;
};
class VatInvoiceScanQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  VatInvoiceScanQueryHeaders() {}

  explicit VatInvoiceScanQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~VatInvoiceScanQueryHeaders() = default;
};
class VatInvoiceScanQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> billDate{};
  shared_ptr<long> billId{};
  shared_ptr<long> invoiceSubTaskId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  VatInvoiceScanQueryRequest() {}

  explicit VatInvoiceScanQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (billId) {
      res["bill_id"] = boost::any(*billId);
    }
    if (invoiceSubTaskId) {
      res["invoice_sub_task_id"] = boost::any(*invoiceSubTaskId);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("bill_id") != m.end() && !m["bill_id"].empty()) {
      billId = make_shared<long>(boost::any_cast<long>(m["bill_id"]));
    }
    if (m.find("invoice_sub_task_id") != m.end() && !m["invoice_sub_task_id"].empty()) {
      invoiceSubTaskId = make_shared<long>(boost::any_cast<long>(m["invoice_sub_task_id"]));
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
  }


  virtual ~VatInvoiceScanQueryRequest() = default;
};
class VatInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails : public Darabonba::Model {
public:
  shared_ptr<string> amount{};
  shared_ptr<string> index{};
  shared_ptr<string> itemName{};
  shared_ptr<string> quantity{};
  shared_ptr<string> specification{};
  shared_ptr<string> tax{};
  shared_ptr<string> taxRate{};
  shared_ptr<string> unit{};
  shared_ptr<string> unitPrice{};

  VatInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails() {}

  explicit VatInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (itemName) {
      res["item_name"] = boost::any(*itemName);
    }
    if (quantity) {
      res["quantity"] = boost::any(*quantity);
    }
    if (specification) {
      res["specification"] = boost::any(*specification);
    }
    if (tax) {
      res["tax"] = boost::any(*tax);
    }
    if (taxRate) {
      res["tax_rate"] = boost::any(*taxRate);
    }
    if (unit) {
      res["unit"] = boost::any(*unit);
    }
    if (unitPrice) {
      res["unit_price"] = boost::any(*unitPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<string>(boost::any_cast<string>(m["amount"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("item_name") != m.end() && !m["item_name"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["item_name"]));
    }
    if (m.find("quantity") != m.end() && !m["quantity"].empty()) {
      quantity = make_shared<string>(boost::any_cast<string>(m["quantity"]));
    }
    if (m.find("specification") != m.end() && !m["specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["specification"]));
    }
    if (m.find("tax") != m.end() && !m["tax"].empty()) {
      tax = make_shared<string>(boost::any_cast<string>(m["tax"]));
    }
    if (m.find("tax_rate") != m.end() && !m["tax_rate"].empty()) {
      taxRate = make_shared<string>(boost::any_cast<string>(m["tax_rate"]));
    }
    if (m.find("unit") != m.end() && !m["unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["unit"]));
    }
    if (m.find("unit_price") != m.end() && !m["unit_price"].empty()) {
      unitPrice = make_shared<string>(boost::any_cast<string>(m["unit_price"]));
    }
  }


  virtual ~VatInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails() = default;
};
class VatInvoiceScanQueryResponseBodyModuleItems : public Darabonba::Model {
public:
  shared_ptr<string> amountWithTax{};
  shared_ptr<string> amountWithoutTax{};
  shared_ptr<string> billDate{};
  shared_ptr<string> checkCode{};
  shared_ptr<string> drawer{};
  shared_ptr<string> id{};
  shared_ptr<string> invoiceCode{};
  shared_ptr<string> invoiceDay{};
  shared_ptr<string> invoiceDetail{};
  shared_ptr<vector<VatInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails>> invoiceDetails{};
  shared_ptr<string> invoiceLocation{};
  shared_ptr<string> invoiceNo{};
  shared_ptr<long> invoiceSubTaskId{};
  shared_ptr<long> invoiceType{};
  shared_ptr<string> invoiceTypeDesc{};
  shared_ptr<string> machineCode{};
  shared_ptr<string> ossUrl{};
  shared_ptr<string> passwordArea{};
  shared_ptr<string> purchaserBankAccountInfo{};
  shared_ptr<string> purchaserContactInfo{};
  shared_ptr<string> purchaserName{};
  shared_ptr<string> purchaserTaxNo{};
  shared_ptr<string> recipient{};
  shared_ptr<string> remarks{};
  shared_ptr<string> reviewer{};
  shared_ptr<string> sellerBankAccountInfo{};
  shared_ptr<string> sellerContactInfo{};
  shared_ptr<string> sellerName{};
  shared_ptr<string> sellerTaxNo{};
  shared_ptr<string> smartCheckCode{};
  shared_ptr<string> taxAmount{};
  shared_ptr<string> taxRate{};
  shared_ptr<string> totalAmountInWords{};

  VatInvoiceScanQueryResponseBodyModuleItems() {}

  explicit VatInvoiceScanQueryResponseBodyModuleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amountWithTax) {
      res["amount_with_tax"] = boost::any(*amountWithTax);
    }
    if (amountWithoutTax) {
      res["amount_without_tax"] = boost::any(*amountWithoutTax);
    }
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    if (checkCode) {
      res["check_code"] = boost::any(*checkCode);
    }
    if (drawer) {
      res["drawer"] = boost::any(*drawer);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (invoiceCode) {
      res["invoice_code"] = boost::any(*invoiceCode);
    }
    if (invoiceDay) {
      res["invoice_day"] = boost::any(*invoiceDay);
    }
    if (invoiceDetail) {
      res["invoice_detail"] = boost::any(*invoiceDetail);
    }
    if (invoiceDetails) {
      vector<boost::any> temp1;
      for(auto item1:*invoiceDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["invoice_details"] = boost::any(temp1);
    }
    if (invoiceLocation) {
      res["invoice_location"] = boost::any(*invoiceLocation);
    }
    if (invoiceNo) {
      res["invoice_no"] = boost::any(*invoiceNo);
    }
    if (invoiceSubTaskId) {
      res["invoice_sub_task_id"] = boost::any(*invoiceSubTaskId);
    }
    if (invoiceType) {
      res["invoice_type"] = boost::any(*invoiceType);
    }
    if (invoiceTypeDesc) {
      res["invoice_type_desc"] = boost::any(*invoiceTypeDesc);
    }
    if (machineCode) {
      res["machine_code"] = boost::any(*machineCode);
    }
    if (ossUrl) {
      res["oss_url"] = boost::any(*ossUrl);
    }
    if (passwordArea) {
      res["password_area"] = boost::any(*passwordArea);
    }
    if (purchaserBankAccountInfo) {
      res["purchaser_bank_account_info"] = boost::any(*purchaserBankAccountInfo);
    }
    if (purchaserContactInfo) {
      res["purchaser_contact_info"] = boost::any(*purchaserContactInfo);
    }
    if (purchaserName) {
      res["purchaser_name"] = boost::any(*purchaserName);
    }
    if (purchaserTaxNo) {
      res["purchaser_tax_no"] = boost::any(*purchaserTaxNo);
    }
    if (recipient) {
      res["recipient"] = boost::any(*recipient);
    }
    if (remarks) {
      res["remarks"] = boost::any(*remarks);
    }
    if (reviewer) {
      res["reviewer"] = boost::any(*reviewer);
    }
    if (sellerBankAccountInfo) {
      res["seller_bank_account_info"] = boost::any(*sellerBankAccountInfo);
    }
    if (sellerContactInfo) {
      res["seller_contact_info"] = boost::any(*sellerContactInfo);
    }
    if (sellerName) {
      res["seller_name"] = boost::any(*sellerName);
    }
    if (sellerTaxNo) {
      res["seller_tax_no"] = boost::any(*sellerTaxNo);
    }
    if (smartCheckCode) {
      res["smart_check_code"] = boost::any(*smartCheckCode);
    }
    if (taxAmount) {
      res["tax_amount"] = boost::any(*taxAmount);
    }
    if (taxRate) {
      res["tax_rate"] = boost::any(*taxRate);
    }
    if (totalAmountInWords) {
      res["total_amount_in_words"] = boost::any(*totalAmountInWords);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount_with_tax") != m.end() && !m["amount_with_tax"].empty()) {
      amountWithTax = make_shared<string>(boost::any_cast<string>(m["amount_with_tax"]));
    }
    if (m.find("amount_without_tax") != m.end() && !m["amount_without_tax"].empty()) {
      amountWithoutTax = make_shared<string>(boost::any_cast<string>(m["amount_without_tax"]));
    }
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
    if (m.find("check_code") != m.end() && !m["check_code"].empty()) {
      checkCode = make_shared<string>(boost::any_cast<string>(m["check_code"]));
    }
    if (m.find("drawer") != m.end() && !m["drawer"].empty()) {
      drawer = make_shared<string>(boost::any_cast<string>(m["drawer"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("invoice_code") != m.end() && !m["invoice_code"].empty()) {
      invoiceCode = make_shared<string>(boost::any_cast<string>(m["invoice_code"]));
    }
    if (m.find("invoice_day") != m.end() && !m["invoice_day"].empty()) {
      invoiceDay = make_shared<string>(boost::any_cast<string>(m["invoice_day"]));
    }
    if (m.find("invoice_detail") != m.end() && !m["invoice_detail"].empty()) {
      invoiceDetail = make_shared<string>(boost::any_cast<string>(m["invoice_detail"]));
    }
    if (m.find("invoice_details") != m.end() && !m["invoice_details"].empty()) {
      if (typeid(vector<boost::any>) == m["invoice_details"].type()) {
        vector<VatInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["invoice_details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            VatInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invoiceDetails = make_shared<vector<VatInvoiceScanQueryResponseBodyModuleItemsInvoiceDetails>>(expect1);
      }
    }
    if (m.find("invoice_location") != m.end() && !m["invoice_location"].empty()) {
      invoiceLocation = make_shared<string>(boost::any_cast<string>(m["invoice_location"]));
    }
    if (m.find("invoice_no") != m.end() && !m["invoice_no"].empty()) {
      invoiceNo = make_shared<string>(boost::any_cast<string>(m["invoice_no"]));
    }
    if (m.find("invoice_sub_task_id") != m.end() && !m["invoice_sub_task_id"].empty()) {
      invoiceSubTaskId = make_shared<long>(boost::any_cast<long>(m["invoice_sub_task_id"]));
    }
    if (m.find("invoice_type") != m.end() && !m["invoice_type"].empty()) {
      invoiceType = make_shared<long>(boost::any_cast<long>(m["invoice_type"]));
    }
    if (m.find("invoice_type_desc") != m.end() && !m["invoice_type_desc"].empty()) {
      invoiceTypeDesc = make_shared<string>(boost::any_cast<string>(m["invoice_type_desc"]));
    }
    if (m.find("machine_code") != m.end() && !m["machine_code"].empty()) {
      machineCode = make_shared<string>(boost::any_cast<string>(m["machine_code"]));
    }
    if (m.find("oss_url") != m.end() && !m["oss_url"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["oss_url"]));
    }
    if (m.find("password_area") != m.end() && !m["password_area"].empty()) {
      passwordArea = make_shared<string>(boost::any_cast<string>(m["password_area"]));
    }
    if (m.find("purchaser_bank_account_info") != m.end() && !m["purchaser_bank_account_info"].empty()) {
      purchaserBankAccountInfo = make_shared<string>(boost::any_cast<string>(m["purchaser_bank_account_info"]));
    }
    if (m.find("purchaser_contact_info") != m.end() && !m["purchaser_contact_info"].empty()) {
      purchaserContactInfo = make_shared<string>(boost::any_cast<string>(m["purchaser_contact_info"]));
    }
    if (m.find("purchaser_name") != m.end() && !m["purchaser_name"].empty()) {
      purchaserName = make_shared<string>(boost::any_cast<string>(m["purchaser_name"]));
    }
    if (m.find("purchaser_tax_no") != m.end() && !m["purchaser_tax_no"].empty()) {
      purchaserTaxNo = make_shared<string>(boost::any_cast<string>(m["purchaser_tax_no"]));
    }
    if (m.find("recipient") != m.end() && !m["recipient"].empty()) {
      recipient = make_shared<string>(boost::any_cast<string>(m["recipient"]));
    }
    if (m.find("remarks") != m.end() && !m["remarks"].empty()) {
      remarks = make_shared<string>(boost::any_cast<string>(m["remarks"]));
    }
    if (m.find("reviewer") != m.end() && !m["reviewer"].empty()) {
      reviewer = make_shared<string>(boost::any_cast<string>(m["reviewer"]));
    }
    if (m.find("seller_bank_account_info") != m.end() && !m["seller_bank_account_info"].empty()) {
      sellerBankAccountInfo = make_shared<string>(boost::any_cast<string>(m["seller_bank_account_info"]));
    }
    if (m.find("seller_contact_info") != m.end() && !m["seller_contact_info"].empty()) {
      sellerContactInfo = make_shared<string>(boost::any_cast<string>(m["seller_contact_info"]));
    }
    if (m.find("seller_name") != m.end() && !m["seller_name"].empty()) {
      sellerName = make_shared<string>(boost::any_cast<string>(m["seller_name"]));
    }
    if (m.find("seller_tax_no") != m.end() && !m["seller_tax_no"].empty()) {
      sellerTaxNo = make_shared<string>(boost::any_cast<string>(m["seller_tax_no"]));
    }
    if (m.find("smart_check_code") != m.end() && !m["smart_check_code"].empty()) {
      smartCheckCode = make_shared<string>(boost::any_cast<string>(m["smart_check_code"]));
    }
    if (m.find("tax_amount") != m.end() && !m["tax_amount"].empty()) {
      taxAmount = make_shared<string>(boost::any_cast<string>(m["tax_amount"]));
    }
    if (m.find("tax_rate") != m.end() && !m["tax_rate"].empty()) {
      taxRate = make_shared<string>(boost::any_cast<string>(m["tax_rate"]));
    }
    if (m.find("total_amount_in_words") != m.end() && !m["total_amount_in_words"].empty()) {
      totalAmountInWords = make_shared<string>(boost::any_cast<string>(m["total_amount_in_words"]));
    }
  }


  virtual ~VatInvoiceScanQueryResponseBodyModuleItems() = default;
};
class VatInvoiceScanQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<vector<VatInvoiceScanQueryResponseBodyModuleItems>> items{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalPage{};
  shared_ptr<long> totalSize{};

  VatInvoiceScanQueryResponseBodyModule() {}

  explicit VatInvoiceScanQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["items"] = boost::any(temp1);
    }
    if (pageNo) {
      res["page_no"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["page_size"] = boost::any(*pageSize);
    }
    if (totalPage) {
      res["total_page"] = boost::any(*totalPage);
    }
    if (totalSize) {
      res["total_size"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("items") != m.end() && !m["items"].empty()) {
      if (typeid(vector<boost::any>) == m["items"].type()) {
        vector<VatInvoiceScanQueryResponseBodyModuleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            VatInvoiceScanQueryResponseBodyModuleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<VatInvoiceScanQueryResponseBodyModuleItems>>(expect1);
      }
    }
    if (m.find("page_no") != m.end() && !m["page_no"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["page_no"]));
    }
    if (m.find("page_size") != m.end() && !m["page_size"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["page_size"]));
    }
    if (m.find("total_page") != m.end() && !m["total_page"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["total_page"]));
    }
    if (m.find("total_size") != m.end() && !m["total_size"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["total_size"]));
    }
  }


  virtual ~VatInvoiceScanQueryResponseBodyModule() = default;
};
class VatInvoiceScanQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<VatInvoiceScanQueryResponseBodyModule> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  VatInvoiceScanQueryResponseBody() {}

  explicit VatInvoiceScanQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      res["module"] = module ? boost::any(module->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(map<string, boost::any>) == m["module"].type()) {
        VatInvoiceScanQueryResponseBodyModule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["module"]));
        module = make_shared<VatInvoiceScanQueryResponseBodyModule>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~VatInvoiceScanQueryResponseBody() = default;
};
class VatInvoiceScanQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VatInvoiceScanQueryResponseBody> body{};

  VatInvoiceScanQueryResponse() {}

  explicit VatInvoiceScanQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VatInvoiceScanQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VatInvoiceScanQueryResponseBody>(model1);
      }
    }
  }


  virtual ~VatInvoiceScanQueryResponse() = default;
};
class WaitApplyInvoiceTaskDetailQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> xAcsBtripSoCorpToken{};

  WaitApplyInvoiceTaskDetailQueryHeaders() {}

  explicit WaitApplyInvoiceTaskDetailQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (xAcsBtripSoCorpToken) {
      res["x-acs-btrip-so-corp-token"] = boost::any(*xAcsBtripSoCorpToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("x-acs-btrip-so-corp-token") != m.end() && !m["x-acs-btrip-so-corp-token"].empty()) {
      xAcsBtripSoCorpToken = make_shared<string>(boost::any_cast<string>(m["x-acs-btrip-so-corp-token"]));
    }
  }


  virtual ~WaitApplyInvoiceTaskDetailQueryHeaders() = default;
};
class WaitApplyInvoiceTaskDetailQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> billDate{};

  WaitApplyInvoiceTaskDetailQueryRequest() {}

  explicit WaitApplyInvoiceTaskDetailQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billDate) {
      res["bill_date"] = boost::any(*billDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bill_date") != m.end() && !m["bill_date"].empty()) {
      billDate = make_shared<string>(boost::any_cast<string>(m["bill_date"]));
    }
  }


  virtual ~WaitApplyInvoiceTaskDetailQueryRequest() = default;
};
class WaitApplyInvoiceTaskDetailQueryResponseBodyModule : public Darabonba::Model {
public:
  shared_ptr<string> contact{};
  shared_ptr<string> email{};
  shared_ptr<string> flightInvoiceFee{};
  shared_ptr<string> fuPointInvoiceFee{};
  shared_ptr<string> hotelNormalInvoiceFee{};
  shared_ptr<string> hotelSpecialInvoiceFee{};
  shared_ptr<string> internationalFlightInvoiceFee{};
  shared_ptr<string> invoiceThirdPartId{};
  shared_ptr<string> invoiceTitle{};
  shared_ptr<string> mailAddress{};
  shared_ptr<string> mailCity{};
  shared_ptr<string> mailFullAddress{};
  shared_ptr<string> mailProvince{};
  shared_ptr<string> penaltyFee{};
  shared_ptr<string> remark{};
  shared_ptr<string> serviceFee{};
  shared_ptr<string> telephone{};
  shared_ptr<string> trainInvoiceFee{};
  shared_ptr<string> vehicleInvoiceFee{};

  WaitApplyInvoiceTaskDetailQueryResponseBodyModule() {}

  explicit WaitApplyInvoiceTaskDetailQueryResponseBodyModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contact) {
      res["contact"] = boost::any(*contact);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (flightInvoiceFee) {
      res["flight_invoice_fee"] = boost::any(*flightInvoiceFee);
    }
    if (fuPointInvoiceFee) {
      res["fu_point_invoice_fee"] = boost::any(*fuPointInvoiceFee);
    }
    if (hotelNormalInvoiceFee) {
      res["hotel_normal_invoice_fee"] = boost::any(*hotelNormalInvoiceFee);
    }
    if (hotelSpecialInvoiceFee) {
      res["hotel_special_invoice_fee"] = boost::any(*hotelSpecialInvoiceFee);
    }
    if (internationalFlightInvoiceFee) {
      res["international_flight_invoice_fee"] = boost::any(*internationalFlightInvoiceFee);
    }
    if (invoiceThirdPartId) {
      res["invoice_third_part_id"] = boost::any(*invoiceThirdPartId);
    }
    if (invoiceTitle) {
      res["invoice_title"] = boost::any(*invoiceTitle);
    }
    if (mailAddress) {
      res["mail_address"] = boost::any(*mailAddress);
    }
    if (mailCity) {
      res["mail_city"] = boost::any(*mailCity);
    }
    if (mailFullAddress) {
      res["mail_full_address"] = boost::any(*mailFullAddress);
    }
    if (mailProvince) {
      res["mail_province"] = boost::any(*mailProvince);
    }
    if (penaltyFee) {
      res["penalty_fee"] = boost::any(*penaltyFee);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (serviceFee) {
      res["service_fee"] = boost::any(*serviceFee);
    }
    if (telephone) {
      res["telephone"] = boost::any(*telephone);
    }
    if (trainInvoiceFee) {
      res["train_invoice_fee"] = boost::any(*trainInvoiceFee);
    }
    if (vehicleInvoiceFee) {
      res["vehicle_invoice_fee"] = boost::any(*vehicleInvoiceFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contact") != m.end() && !m["contact"].empty()) {
      contact = make_shared<string>(boost::any_cast<string>(m["contact"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("flight_invoice_fee") != m.end() && !m["flight_invoice_fee"].empty()) {
      flightInvoiceFee = make_shared<string>(boost::any_cast<string>(m["flight_invoice_fee"]));
    }
    if (m.find("fu_point_invoice_fee") != m.end() && !m["fu_point_invoice_fee"].empty()) {
      fuPointInvoiceFee = make_shared<string>(boost::any_cast<string>(m["fu_point_invoice_fee"]));
    }
    if (m.find("hotel_normal_invoice_fee") != m.end() && !m["hotel_normal_invoice_fee"].empty()) {
      hotelNormalInvoiceFee = make_shared<string>(boost::any_cast<string>(m["hotel_normal_invoice_fee"]));
    }
    if (m.find("hotel_special_invoice_fee") != m.end() && !m["hotel_special_invoice_fee"].empty()) {
      hotelSpecialInvoiceFee = make_shared<string>(boost::any_cast<string>(m["hotel_special_invoice_fee"]));
    }
    if (m.find("international_flight_invoice_fee") != m.end() && !m["international_flight_invoice_fee"].empty()) {
      internationalFlightInvoiceFee = make_shared<string>(boost::any_cast<string>(m["international_flight_invoice_fee"]));
    }
    if (m.find("invoice_third_part_id") != m.end() && !m["invoice_third_part_id"].empty()) {
      invoiceThirdPartId = make_shared<string>(boost::any_cast<string>(m["invoice_third_part_id"]));
    }
    if (m.find("invoice_title") != m.end() && !m["invoice_title"].empty()) {
      invoiceTitle = make_shared<string>(boost::any_cast<string>(m["invoice_title"]));
    }
    if (m.find("mail_address") != m.end() && !m["mail_address"].empty()) {
      mailAddress = make_shared<string>(boost::any_cast<string>(m["mail_address"]));
    }
    if (m.find("mail_city") != m.end() && !m["mail_city"].empty()) {
      mailCity = make_shared<string>(boost::any_cast<string>(m["mail_city"]));
    }
    if (m.find("mail_full_address") != m.end() && !m["mail_full_address"].empty()) {
      mailFullAddress = make_shared<string>(boost::any_cast<string>(m["mail_full_address"]));
    }
    if (m.find("mail_province") != m.end() && !m["mail_province"].empty()) {
      mailProvince = make_shared<string>(boost::any_cast<string>(m["mail_province"]));
    }
    if (m.find("penalty_fee") != m.end() && !m["penalty_fee"].empty()) {
      penaltyFee = make_shared<string>(boost::any_cast<string>(m["penalty_fee"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("service_fee") != m.end() && !m["service_fee"].empty()) {
      serviceFee = make_shared<string>(boost::any_cast<string>(m["service_fee"]));
    }
    if (m.find("telephone") != m.end() && !m["telephone"].empty()) {
      telephone = make_shared<string>(boost::any_cast<string>(m["telephone"]));
    }
    if (m.find("train_invoice_fee") != m.end() && !m["train_invoice_fee"].empty()) {
      trainInvoiceFee = make_shared<string>(boost::any_cast<string>(m["train_invoice_fee"]));
    }
    if (m.find("vehicle_invoice_fee") != m.end() && !m["vehicle_invoice_fee"].empty()) {
      vehicleInvoiceFee = make_shared<string>(boost::any_cast<string>(m["vehicle_invoice_fee"]));
    }
  }


  virtual ~WaitApplyInvoiceTaskDetailQueryResponseBodyModule() = default;
};
class WaitApplyInvoiceTaskDetailQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<WaitApplyInvoiceTaskDetailQueryResponseBodyModule>> module{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> traceId{};

  WaitApplyInvoiceTaskDetailQueryResponseBody() {}

  explicit WaitApplyInvoiceTaskDetailQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (module) {
      vector<boost::any> temp1;
      for(auto item1:*module){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["module"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (traceId) {
      res["traceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("module") != m.end() && !m["module"].empty()) {
      if (typeid(vector<boost::any>) == m["module"].type()) {
        vector<WaitApplyInvoiceTaskDetailQueryResponseBodyModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["module"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WaitApplyInvoiceTaskDetailQueryResponseBodyModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        module = make_shared<vector<WaitApplyInvoiceTaskDetailQueryResponseBodyModule>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("traceId") != m.end() && !m["traceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["traceId"]));
    }
  }


  virtual ~WaitApplyInvoiceTaskDetailQueryResponseBody() = default;
};
class WaitApplyInvoiceTaskDetailQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WaitApplyInvoiceTaskDetailQueryResponseBody> body{};

  WaitApplyInvoiceTaskDetailQueryResponse() {}

  explicit WaitApplyInvoiceTaskDetailQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WaitApplyInvoiceTaskDetailQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WaitApplyInvoiceTaskDetailQueryResponseBody>(model1);
      }
    }
  }


  virtual ~WaitApplyInvoiceTaskDetailQueryResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AccessTokenResponse accessTokenWithOptions(shared_ptr<AccessTokenRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AccessTokenResponse accessToken(shared_ptr<AccessTokenRequest> request);
  AddInvoiceEntityResponse addInvoiceEntityWithOptions(shared_ptr<AddInvoiceEntityRequest> tmpReq, shared_ptr<AddInvoiceEntityHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddInvoiceEntityResponse addInvoiceEntity(shared_ptr<AddInvoiceEntityRequest> request);
  AddressGetResponse addressGetWithOptions(shared_ptr<AddressGetRequest> request, shared_ptr<AddressGetHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddressGetResponse addressGet(shared_ptr<AddressGetRequest> request);
  AirportSearchResponse airportSearchWithOptions(shared_ptr<AirportSearchRequest> request, shared_ptr<AirportSearchHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AirportSearchResponse airportSearch(shared_ptr<AirportSearchRequest> request);
  AllBaseCityInfoQueryResponse allBaseCityInfoQueryWithOptions(shared_ptr<AllBaseCityInfoQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AllBaseCityInfoQueryResponse allBaseCityInfoQuery();
  ApplyAddResponse applyAddWithOptions(shared_ptr<ApplyAddRequest> tmpReq, shared_ptr<ApplyAddHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyAddResponse applyAdd(shared_ptr<ApplyAddRequest> request);
  ApplyApproveResponse applyApproveWithOptions(shared_ptr<ApplyApproveRequest> request, shared_ptr<ApplyApproveHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyApproveResponse applyApprove(shared_ptr<ApplyApproveRequest> request);
  ApplyInvoiceTaskResponse applyInvoiceTaskWithOptions(shared_ptr<ApplyInvoiceTaskRequest> tmpReq, shared_ptr<ApplyInvoiceTaskHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyInvoiceTaskResponse applyInvoiceTask(shared_ptr<ApplyInvoiceTaskRequest> request);
  ApplyListQueryResponse applyListQueryWithOptions(shared_ptr<ApplyListQueryRequest> request, shared_ptr<ApplyListQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyListQueryResponse applyListQuery(shared_ptr<ApplyListQueryRequest> request);
  ApplyModifyResponse applyModifyWithOptions(shared_ptr<ApplyModifyRequest> tmpReq, shared_ptr<ApplyModifyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyModifyResponse applyModify(shared_ptr<ApplyModifyRequest> request);
  ApplyQueryResponse applyQueryWithOptions(shared_ptr<ApplyQueryRequest> request, shared_ptr<ApplyQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyQueryResponse applyQuery(shared_ptr<ApplyQueryRequest> request);
  BtripBillInfoAdjustResponse btripBillInfoAdjustWithOptions(shared_ptr<BtripBillInfoAdjustRequest> request, shared_ptr<BtripBillInfoAdjustHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BtripBillInfoAdjustResponse btripBillInfoAdjust(shared_ptr<BtripBillInfoAdjustRequest> request);
  CarApplyAddResponse carApplyAddWithOptions(shared_ptr<CarApplyAddRequest> tmpReq, shared_ptr<CarApplyAddHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CarApplyAddResponse carApplyAdd(shared_ptr<CarApplyAddRequest> request);
  CarApplyModifyResponse carApplyModifyWithOptions(shared_ptr<CarApplyModifyRequest> request, shared_ptr<CarApplyModifyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CarApplyModifyResponse carApplyModify(shared_ptr<CarApplyModifyRequest> request);
  CarApplyQueryResponse carApplyQueryWithOptions(shared_ptr<CarApplyQueryRequest> request, shared_ptr<CarApplyQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CarApplyQueryResponse carApplyQuery(shared_ptr<CarApplyQueryRequest> request);
  CarBillSettlementQueryResponse carBillSettlementQueryWithOptions(shared_ptr<CarBillSettlementQueryRequest> request, shared_ptr<CarBillSettlementQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CarBillSettlementQueryResponse carBillSettlementQuery(shared_ptr<CarBillSettlementQueryRequest> request);
  CarOrderListQueryResponse carOrderListQueryWithOptions(shared_ptr<CarOrderListQueryRequest> request, shared_ptr<CarOrderListQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CarOrderListQueryResponse carOrderListQuery(shared_ptr<CarOrderListQueryRequest> request);
  CarOrderQueryResponse carOrderQueryWithOptions(shared_ptr<CarOrderQueryRequest> request, shared_ptr<CarOrderQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CarOrderQueryResponse carOrderQuery(shared_ptr<CarOrderQueryRequest> request);
  CarSceneQueryResponse carSceneQueryWithOptions(shared_ptr<CarSceneQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CarSceneQueryResponse carSceneQuery();
  CitySearchResponse citySearchWithOptions(shared_ptr<CitySearchRequest> request, shared_ptr<CitySearchHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CitySearchResponse citySearch(shared_ptr<CitySearchRequest> request);
  CommonApplyQueryResponse commonApplyQueryWithOptions(shared_ptr<CommonApplyQueryRequest> request, shared_ptr<CommonApplyQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CommonApplyQueryResponse commonApplyQuery(shared_ptr<CommonApplyQueryRequest> request);
  CommonApplySyncResponse commonApplySyncWithOptions(shared_ptr<CommonApplySyncRequest> request, shared_ptr<CommonApplySyncHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CommonApplySyncResponse commonApplySync(shared_ptr<CommonApplySyncRequest> request);
  CorpAuthLinkInfoQueryResponse corpAuthLinkInfoQueryWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CorpAuthLinkInfoQueryResponse corpAuthLinkInfoQuery();
  CorpTokenResponse corpTokenWithOptions(shared_ptr<CorpTokenRequest> request, shared_ptr<CorpTokenHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CorpTokenResponse corpToken(shared_ptr<CorpTokenRequest> request);
  CostCenterDeleteResponse costCenterDeleteWithOptions(shared_ptr<CostCenterDeleteRequest> request, shared_ptr<CostCenterDeleteHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CostCenterDeleteResponse costCenterDelete(shared_ptr<CostCenterDeleteRequest> request);
  CostCenterModifyResponse costCenterModifyWithOptions(shared_ptr<CostCenterModifyRequest> request, shared_ptr<CostCenterModifyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CostCenterModifyResponse costCenterModify(shared_ptr<CostCenterModifyRequest> request);
  CostCenterQueryResponse costCenterQueryWithOptions(shared_ptr<CostCenterQueryRequest> request, shared_ptr<CostCenterQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CostCenterQueryResponse costCenterQuery(shared_ptr<CostCenterQueryRequest> request);
  CostCenterSaveResponse costCenterSaveWithOptions(shared_ptr<CostCenterSaveRequest> request, shared_ptr<CostCenterSaveHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CostCenterSaveResponse costCenterSave(shared_ptr<CostCenterSaveRequest> request);
  CreateSubCorpResponse createSubCorpWithOptions(shared_ptr<CreateSubCorpRequest> request, shared_ptr<CreateSubCorpHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSubCorpResponse createSubCorp(shared_ptr<CreateSubCorpRequest> request);
  DeleteInvoiceEntityResponse deleteInvoiceEntityWithOptions(shared_ptr<DeleteInvoiceEntityRequest> tmpReq, shared_ptr<DeleteInvoiceEntityHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInvoiceEntityResponse deleteInvoiceEntity(shared_ptr<DeleteInvoiceEntityRequest> request);
  DepartmentSaveResponse departmentSaveWithOptions(shared_ptr<DepartmentSaveRequest> tmpReq, shared_ptr<DepartmentSaveHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DepartmentSaveResponse departmentSave(shared_ptr<DepartmentSaveRequest> request);
  EntityAddResponse entityAddWithOptions(shared_ptr<EntityAddRequest> tmpReq, shared_ptr<EntityAddHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EntityAddResponse entityAdd(shared_ptr<EntityAddRequest> request);
  EntityDeleteResponse entityDeleteWithOptions(shared_ptr<EntityDeleteRequest> tmpReq, shared_ptr<EntityDeleteHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EntityDeleteResponse entityDelete(shared_ptr<EntityDeleteRequest> request);
  EntitySetResponse entitySetWithOptions(shared_ptr<EntitySetRequest> tmpReq, shared_ptr<EntitySetHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EntitySetResponse entitySet(shared_ptr<EntitySetRequest> request);
  EstimatedPriceQueryResponse estimatedPriceQueryWithOptions(shared_ptr<EstimatedPriceQueryRequest> request, shared_ptr<EstimatedPriceQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EstimatedPriceQueryResponse estimatedPriceQuery(shared_ptr<EstimatedPriceQueryRequest> request);
  ExceedApplySyncResponse exceedApplySyncWithOptions(shared_ptr<ExceedApplySyncRequest> request, shared_ptr<ExceedApplySyncHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExceedApplySyncResponse exceedApplySync(shared_ptr<ExceedApplySyncRequest> request);
  FlightBillSettlementQueryResponse flightBillSettlementQueryWithOptions(shared_ptr<FlightBillSettlementQueryRequest> request, shared_ptr<FlightBillSettlementQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightBillSettlementQueryResponse flightBillSettlementQuery(shared_ptr<FlightBillSettlementQueryRequest> request);
  FlightCancelOrderResponse flightCancelOrderWithOptions(shared_ptr<FlightCancelOrderRequest> request, shared_ptr<FlightCancelOrderHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightCancelOrderResponse flightCancelOrder(shared_ptr<FlightCancelOrderRequest> request);
  FlightCancelOrderV2Response flightCancelOrderV2WithOptions(shared_ptr<FlightCancelOrderV2Request> request, shared_ptr<FlightCancelOrderV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightCancelOrderV2Response flightCancelOrderV2(shared_ptr<FlightCancelOrderV2Request> request);
  FlightCreateOrderResponse flightCreateOrderWithOptions(shared_ptr<FlightCreateOrderRequest> tmpReq, shared_ptr<FlightCreateOrderHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightCreateOrderResponse flightCreateOrder(shared_ptr<FlightCreateOrderRequest> request);
  FlightCreateOrderV2Response flightCreateOrderV2WithOptions(shared_ptr<FlightCreateOrderV2Request> tmpReq, shared_ptr<FlightCreateOrderV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightCreateOrderV2Response flightCreateOrderV2(shared_ptr<FlightCreateOrderV2Request> request);
  FlightExceedApplyQueryResponse flightExceedApplyQueryWithOptions(shared_ptr<FlightExceedApplyQueryRequest> request, shared_ptr<FlightExceedApplyQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightExceedApplyQueryResponse flightExceedApplyQuery(shared_ptr<FlightExceedApplyQueryRequest> request);
  FlightItineraryScanQueryResponse flightItineraryScanQueryWithOptions(shared_ptr<FlightItineraryScanQueryRequest> request, shared_ptr<FlightItineraryScanQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightItineraryScanQueryResponse flightItineraryScanQuery(shared_ptr<FlightItineraryScanQueryRequest> request);
  FlightListingSearchResponse flightListingSearchWithOptions(shared_ptr<FlightListingSearchRequest> request, shared_ptr<FlightListingSearchHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightListingSearchResponse flightListingSearch(shared_ptr<FlightListingSearchRequest> request);
  FlightListingSearchV2Response flightListingSearchV2WithOptions(shared_ptr<FlightListingSearchV2Request> tmpReq, shared_ptr<FlightListingSearchV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightListingSearchV2Response flightListingSearchV2(shared_ptr<FlightListingSearchV2Request> request);
  FlightModifyApplyV2Response flightModifyApplyV2WithOptions(shared_ptr<FlightModifyApplyV2Request> tmpReq, shared_ptr<FlightModifyApplyV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightModifyApplyV2Response flightModifyApplyV2(shared_ptr<FlightModifyApplyV2Request> request);
  FlightModifyCancelV2Response flightModifyCancelV2WithOptions(shared_ptr<FlightModifyCancelV2Request> request, shared_ptr<FlightModifyCancelV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightModifyCancelV2Response flightModifyCancelV2(shared_ptr<FlightModifyCancelV2Request> request);
  FlightModifyListingSearchV2Response flightModifyListingSearchV2WithOptions(shared_ptr<FlightModifyListingSearchV2Request> tmpReq, shared_ptr<FlightModifyListingSearchV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightModifyListingSearchV2Response flightModifyListingSearchV2(shared_ptr<FlightModifyListingSearchV2Request> request);
  FlightModifyOrderDetailV2Response flightModifyOrderDetailV2WithOptions(shared_ptr<FlightModifyOrderDetailV2Request> request, shared_ptr<FlightModifyOrderDetailV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightModifyOrderDetailV2Response flightModifyOrderDetailV2(shared_ptr<FlightModifyOrderDetailV2Request> request);
  FlightModifyOtaSearchV2Response flightModifyOtaSearchV2WithOptions(shared_ptr<FlightModifyOtaSearchV2Request> tmpReq, shared_ptr<FlightModifyOtaSearchV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightModifyOtaSearchV2Response flightModifyOtaSearchV2(shared_ptr<FlightModifyOtaSearchV2Request> request);
  FlightModifyPayV2Response flightModifyPayV2WithOptions(shared_ptr<FlightModifyPayV2Request> tmpReq, shared_ptr<FlightModifyPayV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightModifyPayV2Response flightModifyPayV2(shared_ptr<FlightModifyPayV2Request> request);
  FlightOrderDetailInfoResponse flightOrderDetailInfoWithOptions(shared_ptr<FlightOrderDetailInfoRequest> request, shared_ptr<FlightOrderDetailInfoHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightOrderDetailInfoResponse flightOrderDetailInfo(shared_ptr<FlightOrderDetailInfoRequest> request);
  FlightOrderDetailV2Response flightOrderDetailV2WithOptions(shared_ptr<FlightOrderDetailV2Request> request, shared_ptr<FlightOrderDetailV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightOrderDetailV2Response flightOrderDetailV2(shared_ptr<FlightOrderDetailV2Request> request);
  FlightOrderListQueryResponse flightOrderListQueryWithOptions(shared_ptr<FlightOrderListQueryRequest> request, shared_ptr<FlightOrderListQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightOrderListQueryResponse flightOrderListQuery(shared_ptr<FlightOrderListQueryRequest> request);
  FlightOrderQueryResponse flightOrderQueryWithOptions(shared_ptr<FlightOrderQueryRequest> request, shared_ptr<FlightOrderQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightOrderQueryResponse flightOrderQuery(shared_ptr<FlightOrderQueryRequest> request);
  FlightOtaItemDetailResponse flightOtaItemDetailWithOptions(shared_ptr<FlightOtaItemDetailRequest> request, shared_ptr<FlightOtaItemDetailHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightOtaItemDetailResponse flightOtaItemDetail(shared_ptr<FlightOtaItemDetailRequest> request);
  FlightOtaSearchResponse flightOtaSearchWithOptions(shared_ptr<FlightOtaSearchRequest> request, shared_ptr<FlightOtaSearchHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightOtaSearchResponse flightOtaSearch(shared_ptr<FlightOtaSearchRequest> request);
  FlightOtaSearchV2Response flightOtaSearchV2WithOptions(shared_ptr<FlightOtaSearchV2Request> tmpReq, shared_ptr<FlightOtaSearchV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightOtaSearchV2Response flightOtaSearchV2(shared_ptr<FlightOtaSearchV2Request> request);
  FlightPayOrderResponse flightPayOrderWithOptions(shared_ptr<FlightPayOrderRequest> tmpReq, shared_ptr<FlightPayOrderHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightPayOrderResponse flightPayOrder(shared_ptr<FlightPayOrderRequest> request);
  FlightPayOrderV2Response flightPayOrderV2WithOptions(shared_ptr<FlightPayOrderV2Request> request, shared_ptr<FlightPayOrderV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightPayOrderV2Response flightPayOrderV2(shared_ptr<FlightPayOrderV2Request> request);
  FlightRefundApplyResponse flightRefundApplyWithOptions(shared_ptr<FlightRefundApplyRequest> tmpReq, shared_ptr<FlightRefundApplyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightRefundApplyResponse flightRefundApply(shared_ptr<FlightRefundApplyRequest> request);
  FlightRefundApplyV2Response flightRefundApplyV2WithOptions(shared_ptr<FlightRefundApplyV2Request> tmpReq, shared_ptr<FlightRefundApplyV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightRefundApplyV2Response flightRefundApplyV2(shared_ptr<FlightRefundApplyV2Request> request);
  FlightRefundDetailResponse flightRefundDetailWithOptions(shared_ptr<FlightRefundDetailRequest> request, shared_ptr<FlightRefundDetailHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightRefundDetailResponse flightRefundDetail(shared_ptr<FlightRefundDetailRequest> request);
  FlightRefundDetailV2Response flightRefundDetailV2WithOptions(shared_ptr<FlightRefundDetailV2Request> request, shared_ptr<FlightRefundDetailV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightRefundDetailV2Response flightRefundDetailV2(shared_ptr<FlightRefundDetailV2Request> request);
  FlightRefundPreCalResponse flightRefundPreCalWithOptions(shared_ptr<FlightRefundPreCalRequest> tmpReq, shared_ptr<FlightRefundPreCalHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightRefundPreCalResponse flightRefundPreCal(shared_ptr<FlightRefundPreCalRequest> request);
  FlightRefundPreCalV2Response flightRefundPreCalV2WithOptions(shared_ptr<FlightRefundPreCalV2Request> tmpReq, shared_ptr<FlightRefundPreCalV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightRefundPreCalV2Response flightRefundPreCalV2(shared_ptr<FlightRefundPreCalV2Request> request);
  FlightSearchListResponse flightSearchListWithOptions(shared_ptr<FlightSearchListRequest> request, shared_ptr<FlightSearchListHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FlightSearchListResponse flightSearchList(shared_ptr<FlightSearchListRequest> request);
  GroupCorpTokenResponse groupCorpTokenWithOptions(shared_ptr<GroupCorpTokenRequest> request, shared_ptr<GroupCorpTokenHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GroupCorpTokenResponse groupCorpToken(shared_ptr<GroupCorpTokenRequest> request);
  GroupDepartSaveResponse groupDepartSaveWithOptions(shared_ptr<GroupDepartSaveRequest> tmpReq, shared_ptr<GroupDepartSaveHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GroupDepartSaveResponse groupDepartSave(shared_ptr<GroupDepartSaveRequest> request);
  GroupUserSaveResponse groupUserSaveWithOptions(shared_ptr<GroupUserSaveRequest> tmpReq, shared_ptr<GroupUserSaveHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GroupUserSaveResponse groupUserSave(shared_ptr<GroupUserSaveRequest> request);
  HotelAskingPriceResponse hotelAskingPriceWithOptions(shared_ptr<HotelAskingPriceRequest> tmpReq, shared_ptr<HotelAskingPriceHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelAskingPriceResponse hotelAskingPrice(shared_ptr<HotelAskingPriceRequest> request);
  HotelBillSettlementQueryResponse hotelBillSettlementQueryWithOptions(shared_ptr<HotelBillSettlementQueryRequest> request, shared_ptr<HotelBillSettlementQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelBillSettlementQueryResponse hotelBillSettlementQuery(shared_ptr<HotelBillSettlementQueryRequest> request);
  HotelCityCodeListResponse hotelCityCodeListWithOptions(shared_ptr<HotelCityCodeListRequest> request, shared_ptr<HotelCityCodeListHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelCityCodeListResponse hotelCityCodeList(shared_ptr<HotelCityCodeListRequest> request);
  HotelExceedApplyQueryResponse hotelExceedApplyQueryWithOptions(shared_ptr<HotelExceedApplyQueryRequest> request, shared_ptr<HotelExceedApplyQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelExceedApplyQueryResponse hotelExceedApplyQuery(shared_ptr<HotelExceedApplyQueryRequest> request);
  HotelGoodsQueryResponse hotelGoodsQueryWithOptions(shared_ptr<HotelGoodsQueryRequest> request, shared_ptr<HotelGoodsQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelGoodsQueryResponse hotelGoodsQuery(shared_ptr<HotelGoodsQueryRequest> request);
  HotelIndexInfoResponse hotelIndexInfoWithOptions(shared_ptr<HotelIndexInfoRequest> request, shared_ptr<HotelIndexInfoHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelIndexInfoResponse hotelIndexInfo(shared_ptr<HotelIndexInfoRequest> request);
  HotelOrderCancelResponse hotelOrderCancelWithOptions(shared_ptr<HotelOrderCancelRequest> request, shared_ptr<HotelOrderCancelHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelOrderCancelResponse hotelOrderCancel(shared_ptr<HotelOrderCancelRequest> request);
  HotelOrderCreateResponse hotelOrderCreateWithOptions(shared_ptr<HotelOrderCreateRequest> tmpReq, shared_ptr<HotelOrderCreateHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelOrderCreateResponse hotelOrderCreate(shared_ptr<HotelOrderCreateRequest> request);
  HotelOrderDetailInfoResponse hotelOrderDetailInfoWithOptions(shared_ptr<HotelOrderDetailInfoRequest> request, shared_ptr<HotelOrderDetailInfoHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelOrderDetailInfoResponse hotelOrderDetailInfo(shared_ptr<HotelOrderDetailInfoRequest> request);
  HotelOrderListQueryResponse hotelOrderListQueryWithOptions(shared_ptr<HotelOrderListQueryRequest> request, shared_ptr<HotelOrderListQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelOrderListQueryResponse hotelOrderListQuery(shared_ptr<HotelOrderListQueryRequest> request);
  HotelOrderPayResponse hotelOrderPayWithOptions(shared_ptr<HotelOrderPayRequest> request, shared_ptr<HotelOrderPayHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelOrderPayResponse hotelOrderPay(shared_ptr<HotelOrderPayRequest> request);
  HotelOrderPreValidateResponse hotelOrderPreValidateWithOptions(shared_ptr<HotelOrderPreValidateRequest> tmpReq, shared_ptr<HotelOrderPreValidateHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelOrderPreValidateResponse hotelOrderPreValidate(shared_ptr<HotelOrderPreValidateRequest> request);
  HotelOrderQueryResponse hotelOrderQueryWithOptions(shared_ptr<HotelOrderQueryRequest> request, shared_ptr<HotelOrderQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelOrderQueryResponse hotelOrderQuery(shared_ptr<HotelOrderQueryRequest> request);
  HotelPricePullResponse hotelPricePullWithOptions(shared_ptr<HotelPricePullRequest> tmpReq, shared_ptr<HotelPricePullHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelPricePullResponse hotelPricePull(shared_ptr<HotelPricePullRequest> request);
  HotelRoomInfoResponse hotelRoomInfoWithOptions(shared_ptr<HotelRoomInfoRequest> tmpReq, shared_ptr<HotelRoomInfoHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelRoomInfoResponse hotelRoomInfo(shared_ptr<HotelRoomInfoRequest> request);
  HotelSearchResponse hotelSearchWithOptions(shared_ptr<HotelSearchRequest> tmpReq, shared_ptr<HotelSearchHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelSearchResponse hotelSearch(shared_ptr<HotelSearchRequest> request);
  HotelStaticInfoResponse hotelStaticInfoWithOptions(shared_ptr<HotelStaticInfoRequest> tmpReq, shared_ptr<HotelStaticInfoHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HotelStaticInfoResponse hotelStaticInfo(shared_ptr<HotelStaticInfoRequest> request);
  IeFlightBillSettlementQueryResponse ieFlightBillSettlementQueryWithOptions(shared_ptr<IeFlightBillSettlementQueryRequest> request, shared_ptr<IeFlightBillSettlementQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  IeFlightBillSettlementQueryResponse ieFlightBillSettlementQuery(shared_ptr<IeFlightBillSettlementQueryRequest> request);
  InsInvoiceScanQueryResponse insInvoiceScanQueryWithOptions(shared_ptr<InsInvoiceScanQueryRequest> request, shared_ptr<InsInvoiceScanQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsInvoiceScanQueryResponse insInvoiceScanQuery(shared_ptr<InsInvoiceScanQueryRequest> request);
  InsureOrderApplyResponse insureOrderApplyWithOptions(shared_ptr<InsureOrderApplyRequest> request, shared_ptr<InsureOrderApplyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsureOrderApplyResponse insureOrderApply(shared_ptr<InsureOrderApplyRequest> request);
  InsureOrderCancelResponse insureOrderCancelWithOptions(shared_ptr<string> insOrderId,
                                                         shared_ptr<InsureOrderCancelRequest> request,
                                                         shared_ptr<InsureOrderCancelHeaders> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsureOrderCancelResponse insureOrderCancel(shared_ptr<string> insOrderId, shared_ptr<InsureOrderCancelRequest> request);
  InsureOrderCreateResponse insureOrderCreateWithOptions(shared_ptr<InsureOrderCreateRequest> tmpReq, shared_ptr<InsureOrderCreateHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsureOrderCreateResponse insureOrderCreate(shared_ptr<InsureOrderCreateRequest> request);
  InsureOrderDetailResponse insureOrderDetailWithOptions(shared_ptr<InsureOrderDetailRequest> request, shared_ptr<InsureOrderDetailHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsureOrderDetailResponse insureOrderDetail(shared_ptr<InsureOrderDetailRequest> request);
  InsureOrderPayResponse insureOrderPayWithOptions(shared_ptr<string> insOrderId,
                                                   shared_ptr<InsureOrderPayRequest> request,
                                                   shared_ptr<InsureOrderPayHeaders> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsureOrderPayResponse insureOrderPay(shared_ptr<string> insOrderId, shared_ptr<InsureOrderPayRequest> request);
  InsureOrderRefundResponse insureOrderRefundWithOptions(shared_ptr<string> insOrderId,
                                                         shared_ptr<InsureOrderRefundRequest> tmpReq,
                                                         shared_ptr<InsureOrderRefundHeaders> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsureOrderRefundResponse insureOrderRefund(shared_ptr<string> insOrderId, shared_ptr<InsureOrderRefundRequest> request);
  InsureOrderUrlDetailResponse insureOrderUrlDetailWithOptions(shared_ptr<string> insOrderId, shared_ptr<InsureOrderUrlDetailHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsureOrderUrlDetailResponse insureOrderUrlDetail(shared_ptr<string> insOrderId);
  InsureRefundDetailResponse insureRefundDetailWithOptions(shared_ptr<InsureRefundDetailRequest> request, shared_ptr<InsureRefundDetailHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsureRefundDetailResponse insureRefundDetail(shared_ptr<InsureRefundDetailRequest> request);
  InvoiceAddResponse invoiceAddWithOptions(shared_ptr<InvoiceAddRequest> request, shared_ptr<InvoiceAddHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvoiceAddResponse invoiceAdd(shared_ptr<InvoiceAddRequest> request);
  InvoiceDeleteResponse invoiceDeleteWithOptions(shared_ptr<InvoiceDeleteRequest> request, shared_ptr<InvoiceDeleteHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvoiceDeleteResponse invoiceDelete(shared_ptr<InvoiceDeleteRequest> request);
  InvoiceModifyResponse invoiceModifyWithOptions(shared_ptr<InvoiceModifyRequest> request, shared_ptr<InvoiceModifyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvoiceModifyResponse invoiceModify(shared_ptr<InvoiceModifyRequest> request);
  InvoiceRuleAddResponse invoiceRuleAddWithOptions(shared_ptr<InvoiceRuleAddRequest> tmpReq, shared_ptr<InvoiceRuleAddHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvoiceRuleAddResponse invoiceRuleAdd(shared_ptr<InvoiceRuleAddRequest> request);
  InvoiceRuleDeleteResponse invoiceRuleDeleteWithOptions(shared_ptr<InvoiceRuleDeleteRequest> tmpReq, shared_ptr<InvoiceRuleDeleteHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvoiceRuleDeleteResponse invoiceRuleDelete(shared_ptr<InvoiceRuleDeleteRequest> request);
  InvoiceRuleSaveResponse invoiceRuleSaveWithOptions(shared_ptr<InvoiceRuleSaveRequest> tmpReq, shared_ptr<InvoiceRuleSaveHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvoiceRuleSaveResponse invoiceRuleSave(shared_ptr<InvoiceRuleSaveRequest> request);
  InvoiceSearchResponse invoiceSearchWithOptions(shared_ptr<InvoiceSearchRequest> request, shared_ptr<InvoiceSearchHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvoiceSearchResponse invoiceSearch(shared_ptr<InvoiceSearchRequest> request);
  IsvRuleSaveResponse isvRuleSaveWithOptions(shared_ptr<IsvRuleSaveRequest> tmpReq, shared_ptr<IsvRuleSaveHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  IsvRuleSaveResponse isvRuleSave(shared_ptr<IsvRuleSaveRequest> request);
  IsvUserSaveResponse isvUserSaveWithOptions(shared_ptr<IsvUserSaveRequest> tmpReq, shared_ptr<IsvUserSaveHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  IsvUserSaveResponse isvUserSave(shared_ptr<IsvUserSaveRequest> request);
  MonthBillConfirmResponse monthBillConfirmWithOptions(shared_ptr<MonthBillConfirmRequest> request, shared_ptr<MonthBillConfirmHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MonthBillConfirmResponse monthBillConfirm(shared_ptr<MonthBillConfirmRequest> request);
  MonthBillGetResponse monthBillGetWithOptions(shared_ptr<MonthBillGetRequest> request, shared_ptr<MonthBillGetHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MonthBillGetResponse monthBillGet(shared_ptr<MonthBillGetRequest> request);
  ProjectAddResponse projectAddWithOptions(shared_ptr<ProjectAddRequest> request, shared_ptr<ProjectAddHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ProjectAddResponse projectAdd(shared_ptr<ProjectAddRequest> request);
  ProjectDeleteResponse projectDeleteWithOptions(shared_ptr<ProjectDeleteRequest> request, shared_ptr<ProjectDeleteHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ProjectDeleteResponse projectDelete(shared_ptr<ProjectDeleteRequest> request);
  ProjectModifyResponse projectModifyWithOptions(shared_ptr<ProjectModifyRequest> request, shared_ptr<ProjectModifyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ProjectModifyResponse projectModify(shared_ptr<ProjectModifyRequest> request);
  QueryReimbursementOrderResponse queryReimbursementOrderWithOptions(shared_ptr<QueryReimbursementOrderRequest> request, shared_ptr<QueryReimbursementOrderHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryReimbursementOrderResponse queryReimbursementOrder(shared_ptr<QueryReimbursementOrderRequest> request);
  SyncSingleUserResponse syncSingleUserWithOptions(shared_ptr<SyncSingleUserRequest> tmpReq, shared_ptr<SyncSingleUserHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncSingleUserResponse syncSingleUser(shared_ptr<SyncSingleUserRequest> request);
  SyncThirdUserMappingResponse syncThirdUserMappingWithOptions(shared_ptr<SyncThirdUserMappingRequest> request, shared_ptr<SyncThirdUserMappingHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncThirdUserMappingResponse syncThirdUserMapping(shared_ptr<SyncThirdUserMappingRequest> request);
  TBAccountInfoQueryResponse tBAccountInfoQueryWithOptions(shared_ptr<string> userId, shared_ptr<TBAccountInfoQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TBAccountInfoQueryResponse tBAccountInfoQuery(shared_ptr<string> userId);
  TBAccountUnbindResponse tBAccountUnbindWithOptions(shared_ptr<string> userId, shared_ptr<TBAccountUnbindHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TBAccountUnbindResponse tBAccountUnbind(shared_ptr<string> userId);
  TicketChangingApplyResponse ticketChangingApplyWithOptions(shared_ptr<TicketChangingApplyRequest> tmpReq, shared_ptr<TicketChangingApplyHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TicketChangingApplyResponse ticketChangingApply(shared_ptr<TicketChangingApplyRequest> request);
  TicketChangingCancelResponse ticketChangingCancelWithOptions(shared_ptr<TicketChangingCancelRequest> request, shared_ptr<TicketChangingCancelHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TicketChangingCancelResponse ticketChangingCancel(shared_ptr<TicketChangingCancelRequest> request);
  TicketChangingDetailResponse ticketChangingDetailWithOptions(shared_ptr<TicketChangingDetailRequest> request, shared_ptr<TicketChangingDetailHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TicketChangingDetailResponse ticketChangingDetail(shared_ptr<TicketChangingDetailRequest> request);
  TicketChangingEnquiryResponse ticketChangingEnquiryWithOptions(shared_ptr<TicketChangingEnquiryRequest> request, shared_ptr<TicketChangingEnquiryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TicketChangingEnquiryResponse ticketChangingEnquiry(shared_ptr<TicketChangingEnquiryRequest> request);
  TicketChangingFlightListResponse ticketChangingFlightListWithOptions(shared_ptr<TicketChangingFlightListRequest> tmpReq, shared_ptr<TicketChangingFlightListHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TicketChangingFlightListResponse ticketChangingFlightList(shared_ptr<TicketChangingFlightListRequest> request);
  TicketChangingPayResponse ticketChangingPayWithOptions(shared_ptr<TicketChangingPayRequest> tmpReq, shared_ptr<TicketChangingPayHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TicketChangingPayResponse ticketChangingPay(shared_ptr<TicketChangingPayRequest> request);
  TrainBillSettlementQueryResponse trainBillSettlementQueryWithOptions(shared_ptr<TrainBillSettlementQueryRequest> request, shared_ptr<TrainBillSettlementQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TrainBillSettlementQueryResponse trainBillSettlementQuery(shared_ptr<TrainBillSettlementQueryRequest> request);
  TrainExceedApplyQueryResponse trainExceedApplyQueryWithOptions(shared_ptr<TrainExceedApplyQueryRequest> request, shared_ptr<TrainExceedApplyQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TrainExceedApplyQueryResponse trainExceedApplyQuery(shared_ptr<TrainExceedApplyQueryRequest> request);
  TrainOrderListQueryResponse trainOrderListQueryWithOptions(shared_ptr<TrainOrderListQueryRequest> request, shared_ptr<TrainOrderListQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TrainOrderListQueryResponse trainOrderListQuery(shared_ptr<TrainOrderListQueryRequest> request);
  TrainOrderQueryResponse trainOrderQueryWithOptions(shared_ptr<TrainOrderQueryRequest> request, shared_ptr<TrainOrderQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TrainOrderQueryResponse trainOrderQuery(shared_ptr<TrainOrderQueryRequest> request);
  TrainOrderQueryV2Response trainOrderQueryV2WithOptions(shared_ptr<TrainOrderQueryV2Request> request, shared_ptr<TrainOrderQueryV2Headers> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TrainOrderQueryV2Response trainOrderQueryV2(shared_ptr<TrainOrderQueryV2Request> request);
  TrainStationSearchResponse trainStationSearchWithOptions(shared_ptr<TrainStationSearchRequest> request, shared_ptr<TrainStationSearchHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TrainStationSearchResponse trainStationSearch(shared_ptr<TrainStationSearchRequest> request);
  TrainTicketScanQueryResponse trainTicketScanQueryWithOptions(shared_ptr<TrainTicketScanQueryRequest> request, shared_ptr<TrainTicketScanQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TrainTicketScanQueryResponse trainTicketScanQuery(shared_ptr<TrainTicketScanQueryRequest> request);
  UserQueryResponse userQueryWithOptions(shared_ptr<UserQueryRequest> request, shared_ptr<UserQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UserQueryResponse userQuery(shared_ptr<UserQueryRequest> request);
  VatInvoiceScanQueryResponse vatInvoiceScanQueryWithOptions(shared_ptr<VatInvoiceScanQueryRequest> request, shared_ptr<VatInvoiceScanQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VatInvoiceScanQueryResponse vatInvoiceScanQuery(shared_ptr<VatInvoiceScanQueryRequest> request);
  WaitApplyInvoiceTaskDetailQueryResponse waitApplyInvoiceTaskDetailQueryWithOptions(shared_ptr<WaitApplyInvoiceTaskDetailQueryRequest> request, shared_ptr<WaitApplyInvoiceTaskDetailQueryHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  WaitApplyInvoiceTaskDetailQueryResponse waitApplyInvoiceTaskDetailQuery(shared_ptr<WaitApplyInvoiceTaskDetailQueryRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_BtripOpen20220520

#endif
