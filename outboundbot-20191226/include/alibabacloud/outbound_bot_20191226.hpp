// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_OUTBOUNDBOT20191226_H_
#define ALIBABACLOUD_OUTBOUNDBOT20191226_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_OutboundBot20191226 {
class ApplyNumberDistrictInfoParsingResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> versionId{};

  ApplyNumberDistrictInfoParsingResultRequest() {}

  explicit ApplyNumberDistrictInfoParsingResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~ApplyNumberDistrictInfoParsingResultRequest() = default;
};
class ApplyNumberDistrictInfoParsingResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ApplyNumberDistrictInfoParsingResultResponseBody() {}

  explicit ApplyNumberDistrictInfoParsingResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ApplyNumberDistrictInfoParsingResultResponseBody() = default;
};
class ApplyNumberDistrictInfoParsingResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyNumberDistrictInfoParsingResultResponseBody> body{};

  ApplyNumberDistrictInfoParsingResultResponse() {}

  explicit ApplyNumberDistrictInfoParsingResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyNumberDistrictInfoParsingResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyNumberDistrictInfoParsingResultResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyNumberDistrictInfoParsingResultResponse() = default;
};
class AssignJobsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> callingNumber{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isAsynchrony{};
  shared_ptr<string> jobDataParsingTaskId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<vector<string>> jobsJson{};
  shared_ptr<string> rosterType{};
  shared_ptr<string> strategyJson{};

  AssignJobsRequest() {}

  explicit AssignJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isAsynchrony) {
      res["IsAsynchrony"] = boost::any(*isAsynchrony);
    }
    if (jobDataParsingTaskId) {
      res["JobDataParsingTaskId"] = boost::any(*jobDataParsingTaskId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobsJson) {
      res["JobsJson"] = boost::any(*jobsJson);
    }
    if (rosterType) {
      res["RosterType"] = boost::any(*rosterType);
    }
    if (strategyJson) {
      res["StrategyJson"] = boost::any(*strategyJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumber = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsAsynchrony") != m.end() && !m["IsAsynchrony"].empty()) {
      isAsynchrony = make_shared<bool>(boost::any_cast<bool>(m["IsAsynchrony"]));
    }
    if (m.find("JobDataParsingTaskId") != m.end() && !m["JobDataParsingTaskId"].empty()) {
      jobDataParsingTaskId = make_shared<string>(boost::any_cast<string>(m["JobDataParsingTaskId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobsJson") != m.end() && !m["JobsJson"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobsJson"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobsJson"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobsJson = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RosterType") != m.end() && !m["RosterType"].empty()) {
      rosterType = make_shared<string>(boost::any_cast<string>(m["RosterType"]));
    }
    if (m.find("StrategyJson") != m.end() && !m["StrategyJson"].empty()) {
      strategyJson = make_shared<string>(boost::any_cast<string>(m["StrategyJson"]));
    }
  }


  virtual ~AssignJobsRequest() = default;
};
class AssignJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<vector<string>> jobsId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AssignJobsResponseBody() {}

  explicit AssignJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobsId) {
      res["JobsId"] = boost::any(*jobsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobsId") != m.end() && !m["JobsId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobsId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobsId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobsId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AssignJobsResponseBody() = default;
};
class AssignJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssignJobsResponseBody> body{};

  AssignJobsResponse() {}

  explicit AssignJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssignJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssignJobsResponseBody>(model1);
      }
    }
  }


  virtual ~AssignJobsResponse() = default;
};
class CancelJobsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<vector<string>> jobId{};
  shared_ptr<vector<string>> jobReferenceId{};
  shared_ptr<string> scenarioId{};

  CancelJobsRequest() {}

  explicit CancelJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobReferenceId) {
      res["JobReferenceId"] = boost::any(*jobReferenceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("JobReferenceId") != m.end() && !m["JobReferenceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobReferenceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobReferenceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobReferenceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
  }


  virtual ~CancelJobsRequest() = default;
};
class CancelJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CancelJobsResponseBody() {}

  explicit CancelJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CancelJobsResponseBody() = default;
};
class CancelJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelJobsResponseBody> body{};

  CancelJobsResponse() {}

  explicit CancelJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelJobsResponseBody>(model1);
      }
    }
  }


  virtual ~CancelJobsResponse() = default;
};
class ChangeResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> newResourceGroupId{};
  shared_ptr<string> resourceId{};

  ChangeResourceGroupRequest() {}

  explicit ChangeResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newResourceGroupId) {
      res["NewResourceGroupId"] = boost::any(*newResourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewResourceGroupId") != m.end() && !m["NewResourceGroupId"].empty()) {
      newResourceGroupId = make_shared<string>(boost::any_cast<string>(m["NewResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~ChangeResourceGroupRequest() = default;
};
class ChangeResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ChangeResourceGroupResponseBody() {}

  explicit ChangeResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ChangeResourceGroupResponseBody() = default;
};
class ChangeResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeResourceGroupResponseBody> body{};

  ChangeResourceGroupResponse() {}

  explicit ChangeResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeResourceGroupResponse() = default;
};
class CreateAgentProfileRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentProfileTemplateId{};
  shared_ptr<string> appIp{};
  shared_ptr<string> description{};
  shared_ptr<string> faqCategoryIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instructionJson{};
  shared_ptr<string> labelsJson{};
  shared_ptr<string> model{};
  shared_ptr<string> modelConfig{};
  shared_ptr<string> prompt{};
  shared_ptr<string> promptJson{};
  shared_ptr<string> scenario{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> variablesJson{};

  CreateAgentProfileRequest() {}

  explicit CreateAgentProfileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentProfileTemplateId) {
      res["AgentProfileTemplateId"] = boost::any(*agentProfileTemplateId);
    }
    if (appIp) {
      res["AppIp"] = boost::any(*appIp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (faqCategoryIds) {
      res["FaqCategoryIds"] = boost::any(*faqCategoryIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instructionJson) {
      res["InstructionJson"] = boost::any(*instructionJson);
    }
    if (labelsJson) {
      res["LabelsJson"] = boost::any(*labelsJson);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (modelConfig) {
      res["ModelConfig"] = boost::any(*modelConfig);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (promptJson) {
      res["PromptJson"] = boost::any(*promptJson);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (variablesJson) {
      res["VariablesJson"] = boost::any(*variablesJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentProfileTemplateId") != m.end() && !m["AgentProfileTemplateId"].empty()) {
      agentProfileTemplateId = make_shared<string>(boost::any_cast<string>(m["AgentProfileTemplateId"]));
    }
    if (m.find("AppIp") != m.end() && !m["AppIp"].empty()) {
      appIp = make_shared<string>(boost::any_cast<string>(m["AppIp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FaqCategoryIds") != m.end() && !m["FaqCategoryIds"].empty()) {
      faqCategoryIds = make_shared<string>(boost::any_cast<string>(m["FaqCategoryIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstructionJson") != m.end() && !m["InstructionJson"].empty()) {
      instructionJson = make_shared<string>(boost::any_cast<string>(m["InstructionJson"]));
    }
    if (m.find("LabelsJson") != m.end() && !m["LabelsJson"].empty()) {
      labelsJson = make_shared<string>(boost::any_cast<string>(m["LabelsJson"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("ModelConfig") != m.end() && !m["ModelConfig"].empty()) {
      modelConfig = make_shared<string>(boost::any_cast<string>(m["ModelConfig"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("PromptJson") != m.end() && !m["PromptJson"].empty()) {
      promptJson = make_shared<string>(boost::any_cast<string>(m["PromptJson"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("VariablesJson") != m.end() && !m["VariablesJson"].empty()) {
      variablesJson = make_shared<string>(boost::any_cast<string>(m["VariablesJson"]));
    }
  }


  virtual ~CreateAgentProfileRequest() = default;
};
class CreateAgentProfileResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> agentProfileId{};
  shared_ptr<string> agentProfileTemplateId{};
  shared_ptr<string> agentType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instructionJson{};
  shared_ptr<string> labelsJson{};
  shared_ptr<string> model{};
  shared_ptr<string> modelConfig{};
  shared_ptr<string> prompt{};
  shared_ptr<string> promptJson{};
  shared_ptr<string> scenario{};
  shared_ptr<string> scriptId{};
  shared_ptr<bool> system{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> variablesJson{};

  CreateAgentProfileResponseBodyData() {}

  explicit CreateAgentProfileResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentProfileId) {
      res["AgentProfileId"] = boost::any(*agentProfileId);
    }
    if (agentProfileTemplateId) {
      res["AgentProfileTemplateId"] = boost::any(*agentProfileTemplateId);
    }
    if (agentType) {
      res["AgentType"] = boost::any(*agentType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instructionJson) {
      res["InstructionJson"] = boost::any(*instructionJson);
    }
    if (labelsJson) {
      res["LabelsJson"] = boost::any(*labelsJson);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (modelConfig) {
      res["ModelConfig"] = boost::any(*modelConfig);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (promptJson) {
      res["PromptJson"] = boost::any(*promptJson);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (system) {
      res["System"] = boost::any(*system);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (variablesJson) {
      res["VariablesJson"] = boost::any(*variablesJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentProfileId") != m.end() && !m["AgentProfileId"].empty()) {
      agentProfileId = make_shared<string>(boost::any_cast<string>(m["AgentProfileId"]));
    }
    if (m.find("AgentProfileTemplateId") != m.end() && !m["AgentProfileTemplateId"].empty()) {
      agentProfileTemplateId = make_shared<string>(boost::any_cast<string>(m["AgentProfileTemplateId"]));
    }
    if (m.find("AgentType") != m.end() && !m["AgentType"].empty()) {
      agentType = make_shared<string>(boost::any_cast<string>(m["AgentType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstructionJson") != m.end() && !m["InstructionJson"].empty()) {
      instructionJson = make_shared<string>(boost::any_cast<string>(m["InstructionJson"]));
    }
    if (m.find("LabelsJson") != m.end() && !m["LabelsJson"].empty()) {
      labelsJson = make_shared<string>(boost::any_cast<string>(m["LabelsJson"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("ModelConfig") != m.end() && !m["ModelConfig"].empty()) {
      modelConfig = make_shared<string>(boost::any_cast<string>(m["ModelConfig"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("PromptJson") != m.end() && !m["PromptJson"].empty()) {
      promptJson = make_shared<string>(boost::any_cast<string>(m["PromptJson"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("System") != m.end() && !m["System"].empty()) {
      system = make_shared<bool>(boost::any_cast<bool>(m["System"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VariablesJson") != m.end() && !m["VariablesJson"].empty()) {
      variablesJson = make_shared<string>(boost::any_cast<string>(m["VariablesJson"]));
    }
  }


  virtual ~CreateAgentProfileResponseBodyData() = default;
};
class CreateAgentProfileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateAgentProfileResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateAgentProfileResponseBody() {}

  explicit CreateAgentProfileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateAgentProfileResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateAgentProfileResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateAgentProfileResponseBody() = default;
};
class CreateAgentProfileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAgentProfileResponseBody> body{};

  CreateAgentProfileResponse() {}

  explicit CreateAgentProfileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAgentProfileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAgentProfileResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAgentProfileResponse() = default;
};
class CreateAnnotationMissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentKey{};
  shared_ptr<long> annotationMissionDataSourceType{};
  shared_ptr<vector<long>> annotationMissionDebugDataSourceList{};
  shared_ptr<string> annotationMissionDebugDataSourceListJsonString{};
  shared_ptr<string> annotationMissionName{};
  shared_ptr<string> chatbotId{};
  shared_ptr<long> conversationTimeEndFilter{};
  shared_ptr<long> conversationTimeStartFilter{};
  shared_ptr<bool> excludeOtherSession{};
  shared_ptr<bool> finished{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> samplingCount{};
  shared_ptr<long> samplingRate{};
  shared_ptr<long> samplingType{};
  shared_ptr<string> scriptId{};
  shared_ptr<vector<long>> sessionEndReasonFilterList{};
  shared_ptr<string> sessionEndReasonFilterListJsonString{};

  CreateAnnotationMissionRequest() {}

  explicit CreateAnnotationMissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (annotationMissionDataSourceType) {
      res["AnnotationMissionDataSourceType"] = boost::any(*annotationMissionDataSourceType);
    }
    if (annotationMissionDebugDataSourceList) {
      res["AnnotationMissionDebugDataSourceList"] = boost::any(*annotationMissionDebugDataSourceList);
    }
    if (annotationMissionDebugDataSourceListJsonString) {
      res["AnnotationMissionDebugDataSourceListJsonString"] = boost::any(*annotationMissionDebugDataSourceListJsonString);
    }
    if (annotationMissionName) {
      res["AnnotationMissionName"] = boost::any(*annotationMissionName);
    }
    if (chatbotId) {
      res["ChatbotId"] = boost::any(*chatbotId);
    }
    if (conversationTimeEndFilter) {
      res["ConversationTimeEndFilter"] = boost::any(*conversationTimeEndFilter);
    }
    if (conversationTimeStartFilter) {
      res["ConversationTimeStartFilter"] = boost::any(*conversationTimeStartFilter);
    }
    if (excludeOtherSession) {
      res["ExcludeOtherSession"] = boost::any(*excludeOtherSession);
    }
    if (finished) {
      res["Finished"] = boost::any(*finished);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (samplingCount) {
      res["SamplingCount"] = boost::any(*samplingCount);
    }
    if (samplingRate) {
      res["SamplingRate"] = boost::any(*samplingRate);
    }
    if (samplingType) {
      res["SamplingType"] = boost::any(*samplingType);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (sessionEndReasonFilterList) {
      res["SessionEndReasonFilterList"] = boost::any(*sessionEndReasonFilterList);
    }
    if (sessionEndReasonFilterListJsonString) {
      res["SessionEndReasonFilterListJsonString"] = boost::any(*sessionEndReasonFilterListJsonString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("AnnotationMissionDataSourceType") != m.end() && !m["AnnotationMissionDataSourceType"].empty()) {
      annotationMissionDataSourceType = make_shared<long>(boost::any_cast<long>(m["AnnotationMissionDataSourceType"]));
    }
    if (m.find("AnnotationMissionDebugDataSourceList") != m.end() && !m["AnnotationMissionDebugDataSourceList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AnnotationMissionDebugDataSourceList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AnnotationMissionDebugDataSourceList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      annotationMissionDebugDataSourceList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("AnnotationMissionDebugDataSourceListJsonString") != m.end() && !m["AnnotationMissionDebugDataSourceListJsonString"].empty()) {
      annotationMissionDebugDataSourceListJsonString = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionDebugDataSourceListJsonString"]));
    }
    if (m.find("AnnotationMissionName") != m.end() && !m["AnnotationMissionName"].empty()) {
      annotationMissionName = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionName"]));
    }
    if (m.find("ChatbotId") != m.end() && !m["ChatbotId"].empty()) {
      chatbotId = make_shared<string>(boost::any_cast<string>(m["ChatbotId"]));
    }
    if (m.find("ConversationTimeEndFilter") != m.end() && !m["ConversationTimeEndFilter"].empty()) {
      conversationTimeEndFilter = make_shared<long>(boost::any_cast<long>(m["ConversationTimeEndFilter"]));
    }
    if (m.find("ConversationTimeStartFilter") != m.end() && !m["ConversationTimeStartFilter"].empty()) {
      conversationTimeStartFilter = make_shared<long>(boost::any_cast<long>(m["ConversationTimeStartFilter"]));
    }
    if (m.find("ExcludeOtherSession") != m.end() && !m["ExcludeOtherSession"].empty()) {
      excludeOtherSession = make_shared<bool>(boost::any_cast<bool>(m["ExcludeOtherSession"]));
    }
    if (m.find("Finished") != m.end() && !m["Finished"].empty()) {
      finished = make_shared<bool>(boost::any_cast<bool>(m["Finished"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SamplingCount") != m.end() && !m["SamplingCount"].empty()) {
      samplingCount = make_shared<long>(boost::any_cast<long>(m["SamplingCount"]));
    }
    if (m.find("SamplingRate") != m.end() && !m["SamplingRate"].empty()) {
      samplingRate = make_shared<long>(boost::any_cast<long>(m["SamplingRate"]));
    }
    if (m.find("SamplingType") != m.end() && !m["SamplingType"].empty()) {
      samplingType = make_shared<long>(boost::any_cast<long>(m["SamplingType"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("SessionEndReasonFilterList") != m.end() && !m["SessionEndReasonFilterList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SessionEndReasonFilterList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SessionEndReasonFilterList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      sessionEndReasonFilterList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SessionEndReasonFilterListJsonString") != m.end() && !m["SessionEndReasonFilterListJsonString"].empty()) {
      sessionEndReasonFilterListJsonString = make_shared<string>(boost::any_cast<string>(m["SessionEndReasonFilterListJsonString"]));
    }
  }


  virtual ~CreateAnnotationMissionRequest() = default;
};
class CreateAnnotationMissionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentKey{};
  shared_ptr<long> annotationMissionDataSourceType{};
  shared_ptr<string> annotationMissionDebugDataSourceListShrink{};
  shared_ptr<string> annotationMissionDebugDataSourceListJsonString{};
  shared_ptr<string> annotationMissionName{};
  shared_ptr<string> chatbotId{};
  shared_ptr<long> conversationTimeEndFilter{};
  shared_ptr<long> conversationTimeStartFilter{};
  shared_ptr<bool> excludeOtherSession{};
  shared_ptr<bool> finished{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> samplingCount{};
  shared_ptr<long> samplingRate{};
  shared_ptr<long> samplingType{};
  shared_ptr<string> scriptId{};
  shared_ptr<vector<long>> sessionEndReasonFilterList{};
  shared_ptr<string> sessionEndReasonFilterListJsonString{};

  CreateAnnotationMissionShrinkRequest() {}

  explicit CreateAnnotationMissionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (annotationMissionDataSourceType) {
      res["AnnotationMissionDataSourceType"] = boost::any(*annotationMissionDataSourceType);
    }
    if (annotationMissionDebugDataSourceListShrink) {
      res["AnnotationMissionDebugDataSourceList"] = boost::any(*annotationMissionDebugDataSourceListShrink);
    }
    if (annotationMissionDebugDataSourceListJsonString) {
      res["AnnotationMissionDebugDataSourceListJsonString"] = boost::any(*annotationMissionDebugDataSourceListJsonString);
    }
    if (annotationMissionName) {
      res["AnnotationMissionName"] = boost::any(*annotationMissionName);
    }
    if (chatbotId) {
      res["ChatbotId"] = boost::any(*chatbotId);
    }
    if (conversationTimeEndFilter) {
      res["ConversationTimeEndFilter"] = boost::any(*conversationTimeEndFilter);
    }
    if (conversationTimeStartFilter) {
      res["ConversationTimeStartFilter"] = boost::any(*conversationTimeStartFilter);
    }
    if (excludeOtherSession) {
      res["ExcludeOtherSession"] = boost::any(*excludeOtherSession);
    }
    if (finished) {
      res["Finished"] = boost::any(*finished);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (samplingCount) {
      res["SamplingCount"] = boost::any(*samplingCount);
    }
    if (samplingRate) {
      res["SamplingRate"] = boost::any(*samplingRate);
    }
    if (samplingType) {
      res["SamplingType"] = boost::any(*samplingType);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (sessionEndReasonFilterList) {
      res["SessionEndReasonFilterList"] = boost::any(*sessionEndReasonFilterList);
    }
    if (sessionEndReasonFilterListJsonString) {
      res["SessionEndReasonFilterListJsonString"] = boost::any(*sessionEndReasonFilterListJsonString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("AnnotationMissionDataSourceType") != m.end() && !m["AnnotationMissionDataSourceType"].empty()) {
      annotationMissionDataSourceType = make_shared<long>(boost::any_cast<long>(m["AnnotationMissionDataSourceType"]));
    }
    if (m.find("AnnotationMissionDebugDataSourceList") != m.end() && !m["AnnotationMissionDebugDataSourceList"].empty()) {
      annotationMissionDebugDataSourceListShrink = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionDebugDataSourceList"]));
    }
    if (m.find("AnnotationMissionDebugDataSourceListJsonString") != m.end() && !m["AnnotationMissionDebugDataSourceListJsonString"].empty()) {
      annotationMissionDebugDataSourceListJsonString = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionDebugDataSourceListJsonString"]));
    }
    if (m.find("AnnotationMissionName") != m.end() && !m["AnnotationMissionName"].empty()) {
      annotationMissionName = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionName"]));
    }
    if (m.find("ChatbotId") != m.end() && !m["ChatbotId"].empty()) {
      chatbotId = make_shared<string>(boost::any_cast<string>(m["ChatbotId"]));
    }
    if (m.find("ConversationTimeEndFilter") != m.end() && !m["ConversationTimeEndFilter"].empty()) {
      conversationTimeEndFilter = make_shared<long>(boost::any_cast<long>(m["ConversationTimeEndFilter"]));
    }
    if (m.find("ConversationTimeStartFilter") != m.end() && !m["ConversationTimeStartFilter"].empty()) {
      conversationTimeStartFilter = make_shared<long>(boost::any_cast<long>(m["ConversationTimeStartFilter"]));
    }
    if (m.find("ExcludeOtherSession") != m.end() && !m["ExcludeOtherSession"].empty()) {
      excludeOtherSession = make_shared<bool>(boost::any_cast<bool>(m["ExcludeOtherSession"]));
    }
    if (m.find("Finished") != m.end() && !m["Finished"].empty()) {
      finished = make_shared<bool>(boost::any_cast<bool>(m["Finished"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SamplingCount") != m.end() && !m["SamplingCount"].empty()) {
      samplingCount = make_shared<long>(boost::any_cast<long>(m["SamplingCount"]));
    }
    if (m.find("SamplingRate") != m.end() && !m["SamplingRate"].empty()) {
      samplingRate = make_shared<long>(boost::any_cast<long>(m["SamplingRate"]));
    }
    if (m.find("SamplingType") != m.end() && !m["SamplingType"].empty()) {
      samplingType = make_shared<long>(boost::any_cast<long>(m["SamplingType"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("SessionEndReasonFilterList") != m.end() && !m["SessionEndReasonFilterList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SessionEndReasonFilterList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SessionEndReasonFilterList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      sessionEndReasonFilterList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SessionEndReasonFilterListJsonString") != m.end() && !m["SessionEndReasonFilterListJsonString"].empty()) {
      sessionEndReasonFilterListJsonString = make_shared<string>(boost::any_cast<string>(m["SessionEndReasonFilterListJsonString"]));
    }
  }


  virtual ~CreateAnnotationMissionShrinkRequest() = default;
};
class CreateAnnotationMissionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  CreateAnnotationMissionResponseBodyData() {}

  explicit CreateAnnotationMissionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateAnnotationMissionResponseBodyData() = default;
};
class CreateAnnotationMissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateAnnotationMissionResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateAnnotationMissionResponseBody() {}

  explicit CreateAnnotationMissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateAnnotationMissionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateAnnotationMissionResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateAnnotationMissionResponseBody() = default;
};
class CreateAnnotationMissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAnnotationMissionResponseBody> body{};

  CreateAnnotationMissionResponse() {}

  explicit CreateAnnotationMissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAnnotationMissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAnnotationMissionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAnnotationMissionResponse() = default;
};
class CreateBatchJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> batchJobDescription{};
  shared_ptr<string> batchJobName{};
  shared_ptr<vector<string>> callingNumber{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobFilePath{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> strategyJson{};
  shared_ptr<bool> submitted{};

  CreateBatchJobsRequest() {}

  explicit CreateBatchJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchJobDescription) {
      res["BatchJobDescription"] = boost::any(*batchJobDescription);
    }
    if (batchJobName) {
      res["BatchJobName"] = boost::any(*batchJobName);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobFilePath) {
      res["JobFilePath"] = boost::any(*jobFilePath);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (strategyJson) {
      res["StrategyJson"] = boost::any(*strategyJson);
    }
    if (submitted) {
      res["Submitted"] = boost::any(*submitted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchJobDescription") != m.end() && !m["BatchJobDescription"].empty()) {
      batchJobDescription = make_shared<string>(boost::any_cast<string>(m["BatchJobDescription"]));
    }
    if (m.find("BatchJobName") != m.end() && !m["BatchJobName"].empty()) {
      batchJobName = make_shared<string>(boost::any_cast<string>(m["BatchJobName"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumber = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobFilePath") != m.end() && !m["JobFilePath"].empty()) {
      jobFilePath = make_shared<string>(boost::any_cast<string>(m["JobFilePath"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("StrategyJson") != m.end() && !m["StrategyJson"].empty()) {
      strategyJson = make_shared<string>(boost::any_cast<string>(m["StrategyJson"]));
    }
    if (m.find("Submitted") != m.end() && !m["Submitted"].empty()) {
      submitted = make_shared<bool>(boost::any_cast<bool>(m["Submitted"]));
    }
  }


  virtual ~CreateBatchJobsRequest() = default;
};
class CreateBatchJobsResponseBodyBatchJobStrategyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> beginTime{};
  shared_ptr<string> endTime{};

  CreateBatchJobsResponseBodyBatchJobStrategyWorkingTime() {}

  explicit CreateBatchJobsResponseBodyBatchJobStrategyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~CreateBatchJobsResponseBodyBatchJobStrategyWorkingTime() = default;
};
class CreateBatchJobsResponseBodyBatchJobStrategy : public Darabonba::Model {
public:
  shared_ptr<string> customized{};
  shared_ptr<long> endTime{};
  shared_ptr<string> followUpStrategy{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> repeatBy{};
  shared_ptr<vector<string>> repeatDays{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<long> startTime{};
  shared_ptr<string> strategyDescription{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> strategyName{};
  shared_ptr<string> type{};
  shared_ptr<vector<CreateBatchJobsResponseBodyBatchJobStrategyWorkingTime>> workingTime{};

  CreateBatchJobsResponseBodyBatchJobStrategy() {}

  explicit CreateBatchJobsResponseBodyBatchJobStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (followUpStrategy) {
      res["FollowUpStrategy"] = boost::any(*followUpStrategy);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (repeatBy) {
      res["RepeatBy"] = boost::any(*repeatBy);
    }
    if (repeatDays) {
      res["RepeatDays"] = boost::any(*repeatDays);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (strategyDescription) {
      res["StrategyDescription"] = boost::any(*strategyDescription);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<string>(boost::any_cast<string>(m["Customized"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FollowUpStrategy") != m.end() && !m["FollowUpStrategy"].empty()) {
      followUpStrategy = make_shared<string>(boost::any_cast<string>(m["FollowUpStrategy"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("RepeatBy") != m.end() && !m["RepeatBy"].empty()) {
      repeatBy = make_shared<string>(boost::any_cast<string>(m["RepeatBy"]));
    }
    if (m.find("RepeatDays") != m.end() && !m["RepeatDays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StrategyDescription") != m.end() && !m["StrategyDescription"].empty()) {
      strategyDescription = make_shared<string>(boost::any_cast<string>(m["StrategyDescription"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<CreateBatchJobsResponseBodyBatchJobStrategyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateBatchJobsResponseBodyBatchJobStrategyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<CreateBatchJobsResponseBodyBatchJobStrategyWorkingTime>>(expect1);
      }
    }
  }


  virtual ~CreateBatchJobsResponseBodyBatchJobStrategy() = default;
};
class CreateBatchJobsResponseBodyBatchJob : public Darabonba::Model {
public:
  shared_ptr<string> batchJobId{};
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<long> creationTime{};
  shared_ptr<string> jobFilePath{};
  shared_ptr<string> jobGroupDescription{};
  shared_ptr<string> jobGroupName{};
  shared_ptr<string> scenarioId{};
  shared_ptr<CreateBatchJobsResponseBodyBatchJobStrategy> strategy{};

  CreateBatchJobsResponseBodyBatchJob() {}

  explicit CreateBatchJobsResponseBodyBatchJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchJobId) {
      res["BatchJobId"] = boost::any(*batchJobId);
    }
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (jobFilePath) {
      res["JobFilePath"] = boost::any(*jobFilePath);
    }
    if (jobGroupDescription) {
      res["JobGroupDescription"] = boost::any(*jobGroupDescription);
    }
    if (jobGroupName) {
      res["JobGroupName"] = boost::any(*jobGroupName);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchJobId") != m.end() && !m["BatchJobId"].empty()) {
      batchJobId = make_shared<string>(boost::any_cast<string>(m["BatchJobId"]));
    }
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("JobFilePath") != m.end() && !m["JobFilePath"].empty()) {
      jobFilePath = make_shared<string>(boost::any_cast<string>(m["JobFilePath"]));
    }
    if (m.find("JobGroupDescription") != m.end() && !m["JobGroupDescription"].empty()) {
      jobGroupDescription = make_shared<string>(boost::any_cast<string>(m["JobGroupDescription"]));
    }
    if (m.find("JobGroupName") != m.end() && !m["JobGroupName"].empty()) {
      jobGroupName = make_shared<string>(boost::any_cast<string>(m["JobGroupName"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        CreateBatchJobsResponseBodyBatchJobStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<CreateBatchJobsResponseBodyBatchJobStrategy>(model1);
      }
    }
  }


  virtual ~CreateBatchJobsResponseBodyBatchJob() = default;
};
class CreateBatchJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateBatchJobsResponseBodyBatchJob> batchJob{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateBatchJobsResponseBody() {}

  explicit CreateBatchJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchJob) {
      res["BatchJob"] = batchJob ? boost::any(batchJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchJob") != m.end() && !m["BatchJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["BatchJob"].type()) {
        CreateBatchJobsResponseBodyBatchJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BatchJob"]));
        batchJob = make_shared<CreateBatchJobsResponseBodyBatchJob>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateBatchJobsResponseBody() = default;
};
class CreateBatchJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBatchJobsResponseBody> body{};

  CreateBatchJobsResponse() {}

  explicit CreateBatchJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBatchJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBatchJobsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBatchJobsResponse() = default;
};
class CreateBatchRepeatJobRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> callingNumber{};
  shared_ptr<string> description{};
  shared_ptr<string> filterStatus{};
  shared_ptr<string> flashSmsExtras{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> minConcurrency{};
  shared_ptr<string> name{};
  shared_ptr<string> priority{};
  shared_ptr<vector<string>> recallCallingNumber{};
  shared_ptr<string> recallStrategyJson{};
  shared_ptr<long> ringingDuration{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> sourceGroupId{};
  shared_ptr<string> strategyJson{};

  CreateBatchRepeatJobRequest() {}

  explicit CreateBatchRepeatJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (filterStatus) {
      res["FilterStatus"] = boost::any(*filterStatus);
    }
    if (flashSmsExtras) {
      res["FlashSmsExtras"] = boost::any(*flashSmsExtras);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (minConcurrency) {
      res["MinConcurrency"] = boost::any(*minConcurrency);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (recallCallingNumber) {
      res["RecallCallingNumber"] = boost::any(*recallCallingNumber);
    }
    if (recallStrategyJson) {
      res["RecallStrategyJson"] = boost::any(*recallStrategyJson);
    }
    if (ringingDuration) {
      res["RingingDuration"] = boost::any(*ringingDuration);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (sourceGroupId) {
      res["SourceGroupId"] = boost::any(*sourceGroupId);
    }
    if (strategyJson) {
      res["StrategyJson"] = boost::any(*strategyJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumber = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FilterStatus") != m.end() && !m["FilterStatus"].empty()) {
      filterStatus = make_shared<string>(boost::any_cast<string>(m["FilterStatus"]));
    }
    if (m.find("FlashSmsExtras") != m.end() && !m["FlashSmsExtras"].empty()) {
      flashSmsExtras = make_shared<string>(boost::any_cast<string>(m["FlashSmsExtras"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MinConcurrency") != m.end() && !m["MinConcurrency"].empty()) {
      minConcurrency = make_shared<long>(boost::any_cast<long>(m["MinConcurrency"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("RecallCallingNumber") != m.end() && !m["RecallCallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecallCallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecallCallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recallCallingNumber = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RecallStrategyJson") != m.end() && !m["RecallStrategyJson"].empty()) {
      recallStrategyJson = make_shared<string>(boost::any_cast<string>(m["RecallStrategyJson"]));
    }
    if (m.find("RingingDuration") != m.end() && !m["RingingDuration"].empty()) {
      ringingDuration = make_shared<long>(boost::any_cast<long>(m["RingingDuration"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("SourceGroupId") != m.end() && !m["SourceGroupId"].empty()) {
      sourceGroupId = make_shared<string>(boost::any_cast<string>(m["SourceGroupId"]));
    }
    if (m.find("StrategyJson") != m.end() && !m["StrategyJson"].empty()) {
      strategyJson = make_shared<string>(boost::any_cast<string>(m["StrategyJson"]));
    }
  }


  virtual ~CreateBatchRepeatJobRequest() = default;
};
class CreateBatchRepeatJobResponseBodyJobGroup : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> minConcurrency{};
  shared_ptr<string> priority{};
  shared_ptr<long> ringingDuration{};

  CreateBatchRepeatJobResponseBodyJobGroup() {}

  explicit CreateBatchRepeatJobResponseBodyJobGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (minConcurrency) {
      res["MinConcurrency"] = boost::any(*minConcurrency);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (ringingDuration) {
      res["RingingDuration"] = boost::any(*ringingDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MinConcurrency") != m.end() && !m["MinConcurrency"].empty()) {
      minConcurrency = make_shared<long>(boost::any_cast<long>(m["MinConcurrency"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("RingingDuration") != m.end() && !m["RingingDuration"].empty()) {
      ringingDuration = make_shared<long>(boost::any_cast<long>(m["RingingDuration"]));
    }
  }


  virtual ~CreateBatchRepeatJobResponseBodyJobGroup() = default;
};
class CreateBatchRepeatJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<CreateBatchRepeatJobResponseBodyJobGroup> jobGroup{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateBatchRepeatJobResponseBody() {}

  explicit CreateBatchRepeatJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobGroup) {
      res["JobGroup"] = jobGroup ? boost::any(jobGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("JobGroup") != m.end() && !m["JobGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobGroup"].type()) {
        CreateBatchRepeatJobResponseBodyJobGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobGroup"]));
        jobGroup = make_shared<CreateBatchRepeatJobResponseBodyJobGroup>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateBatchRepeatJobResponseBody() = default;
};
class CreateBatchRepeatJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBatchRepeatJobResponseBody> body{};

  CreateBatchRepeatJobResponse() {}

  explicit CreateBatchRepeatJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBatchRepeatJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBatchRepeatJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBatchRepeatJobResponse() = default;
};
class CreateBeebotIntentRequestIntentDefinition : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> intentName{};

  CreateBeebotIntentRequestIntentDefinition() {}

  explicit CreateBeebotIntentRequestIntentDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (intentName) {
      res["IntentName"] = boost::any(*intentName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("IntentName") != m.end() && !m["IntentName"].empty()) {
      intentName = make_shared<string>(boost::any_cast<string>(m["IntentName"]));
    }
  }


  virtual ~CreateBeebotIntentRequestIntentDefinition() = default;
};
class CreateBeebotIntentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<CreateBeebotIntentRequestIntentDefinition> intentDefinition{};
  shared_ptr<string> scriptId{};

  CreateBeebotIntentRequest() {}

  explicit CreateBeebotIntentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentDefinition) {
      res["IntentDefinition"] = intentDefinition ? boost::any(intentDefinition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentDefinition") != m.end() && !m["IntentDefinition"].empty()) {
      if (typeid(map<string, boost::any>) == m["IntentDefinition"].type()) {
        CreateBeebotIntentRequestIntentDefinition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IntentDefinition"]));
        intentDefinition = make_shared<CreateBeebotIntentRequestIntentDefinition>(model1);
      }
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~CreateBeebotIntentRequest() = default;
};
class CreateBeebotIntentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> intentDefinitionShrink{};
  shared_ptr<string> scriptId{};

  CreateBeebotIntentShrinkRequest() {}

  explicit CreateBeebotIntentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentDefinitionShrink) {
      res["IntentDefinition"] = boost::any(*intentDefinitionShrink);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentDefinition") != m.end() && !m["IntentDefinition"].empty()) {
      intentDefinitionShrink = make_shared<string>(boost::any_cast<string>(m["IntentDefinition"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~CreateBeebotIntentShrinkRequest() = default;
};
class CreateBeebotIntentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beebotRequestId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> intentId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateBeebotIntentResponseBody() {}

  explicit CreateBeebotIntentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beebotRequestId) {
      res["BeebotRequestId"] = boost::any(*beebotRequestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeebotRequestId") != m.end() && !m["BeebotRequestId"].empty()) {
      beebotRequestId = make_shared<string>(boost::any_cast<string>(m["BeebotRequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateBeebotIntentResponseBody() = default;
};
class CreateBeebotIntentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBeebotIntentResponseBody> body{};

  CreateBeebotIntentResponse() {}

  explicit CreateBeebotIntentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBeebotIntentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBeebotIntentResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBeebotIntentResponse() = default;
};
class CreateBeebotIntentLgfRequestLgfDefinition : public Darabonba::Model {
public:
  shared_ptr<long> intentId{};
  shared_ptr<string> ruleText{};

  CreateBeebotIntentLgfRequestLgfDefinition() {}

  explicit CreateBeebotIntentLgfRequestLgfDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (ruleText) {
      res["RuleText"] = boost::any(*ruleText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("RuleText") != m.end() && !m["RuleText"].empty()) {
      ruleText = make_shared<string>(boost::any_cast<string>(m["RuleText"]));
    }
  }


  virtual ~CreateBeebotIntentLgfRequestLgfDefinition() = default;
};
class CreateBeebotIntentLgfRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<CreateBeebotIntentLgfRequestLgfDefinition> lgfDefinition{};
  shared_ptr<string> scriptId{};

  CreateBeebotIntentLgfRequest() {}

  explicit CreateBeebotIntentLgfRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lgfDefinition) {
      res["LgfDefinition"] = lgfDefinition ? boost::any(lgfDefinition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LgfDefinition") != m.end() && !m["LgfDefinition"].empty()) {
      if (typeid(map<string, boost::any>) == m["LgfDefinition"].type()) {
        CreateBeebotIntentLgfRequestLgfDefinition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LgfDefinition"]));
        lgfDefinition = make_shared<CreateBeebotIntentLgfRequestLgfDefinition>(model1);
      }
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~CreateBeebotIntentLgfRequest() = default;
};
class CreateBeebotIntentLgfShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lgfDefinitionShrink{};
  shared_ptr<string> scriptId{};

  CreateBeebotIntentLgfShrinkRequest() {}

  explicit CreateBeebotIntentLgfShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lgfDefinitionShrink) {
      res["LgfDefinition"] = boost::any(*lgfDefinitionShrink);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LgfDefinition") != m.end() && !m["LgfDefinition"].empty()) {
      lgfDefinitionShrink = make_shared<string>(boost::any_cast<string>(m["LgfDefinition"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~CreateBeebotIntentLgfShrinkRequest() = default;
};
class CreateBeebotIntentLgfResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beebotRequestId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> lgfId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateBeebotIntentLgfResponseBody() {}

  explicit CreateBeebotIntentLgfResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beebotRequestId) {
      res["BeebotRequestId"] = boost::any(*beebotRequestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (lgfId) {
      res["LgfId"] = boost::any(*lgfId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeebotRequestId") != m.end() && !m["BeebotRequestId"].empty()) {
      beebotRequestId = make_shared<string>(boost::any_cast<string>(m["BeebotRequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("LgfId") != m.end() && !m["LgfId"].empty()) {
      lgfId = make_shared<long>(boost::any_cast<long>(m["LgfId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateBeebotIntentLgfResponseBody() = default;
};
class CreateBeebotIntentLgfResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBeebotIntentLgfResponseBody> body{};

  CreateBeebotIntentLgfResponse() {}

  explicit CreateBeebotIntentLgfResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBeebotIntentLgfResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBeebotIntentLgfResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBeebotIntentLgfResponse() = default;
};
class CreateBeebotIntentUserSayRequestUserSayDefinition : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> intentId{};

  CreateBeebotIntentUserSayRequestUserSayDefinition() {}

  explicit CreateBeebotIntentUserSayRequestUserSayDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
  }


  virtual ~CreateBeebotIntentUserSayRequestUserSayDefinition() = default;
};
class CreateBeebotIntentUserSayRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};
  shared_ptr<CreateBeebotIntentUserSayRequestUserSayDefinition> userSayDefinition{};

  CreateBeebotIntentUserSayRequest() {}

  explicit CreateBeebotIntentUserSayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (userSayDefinition) {
      res["UserSayDefinition"] = userSayDefinition ? boost::any(userSayDefinition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("UserSayDefinition") != m.end() && !m["UserSayDefinition"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserSayDefinition"].type()) {
        CreateBeebotIntentUserSayRequestUserSayDefinition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserSayDefinition"]));
        userSayDefinition = make_shared<CreateBeebotIntentUserSayRequestUserSayDefinition>(model1);
      }
    }
  }


  virtual ~CreateBeebotIntentUserSayRequest() = default;
};
class CreateBeebotIntentUserSayShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> userSayDefinitionShrink{};

  CreateBeebotIntentUserSayShrinkRequest() {}

  explicit CreateBeebotIntentUserSayShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (userSayDefinitionShrink) {
      res["UserSayDefinition"] = boost::any(*userSayDefinitionShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("UserSayDefinition") != m.end() && !m["UserSayDefinition"].empty()) {
      userSayDefinitionShrink = make_shared<string>(boost::any_cast<string>(m["UserSayDefinition"]));
    }
  }


  virtual ~CreateBeebotIntentUserSayShrinkRequest() = default;
};
class CreateBeebotIntentUserSayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beebotRequestId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> userSayId{};

  CreateBeebotIntentUserSayResponseBody() {}

  explicit CreateBeebotIntentUserSayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beebotRequestId) {
      res["BeebotRequestId"] = boost::any(*beebotRequestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (userSayId) {
      res["UserSayId"] = boost::any(*userSayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeebotRequestId") != m.end() && !m["BeebotRequestId"].empty()) {
      beebotRequestId = make_shared<string>(boost::any_cast<string>(m["BeebotRequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("UserSayId") != m.end() && !m["UserSayId"].empty()) {
      userSayId = make_shared<long>(boost::any_cast<long>(m["UserSayId"]));
    }
  }


  virtual ~CreateBeebotIntentUserSayResponseBody() = default;
};
class CreateBeebotIntentUserSayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBeebotIntentUserSayResponseBody> body{};

  CreateBeebotIntentUserSayResponse() {}

  explicit CreateBeebotIntentUserSayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBeebotIntentUserSayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBeebotIntentUserSayResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBeebotIntentUserSayResponse() = default;
};
class CreateDialogueFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> dialogueFlowType{};
  shared_ptr<string> dialogueName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  CreateDialogueFlowRequest() {}

  explicit CreateDialogueFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dialogueFlowType) {
      res["DialogueFlowType"] = boost::any(*dialogueFlowType);
    }
    if (dialogueName) {
      res["DialogueName"] = boost::any(*dialogueName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DialogueFlowType") != m.end() && !m["DialogueFlowType"].empty()) {
      dialogueFlowType = make_shared<string>(boost::any_cast<string>(m["DialogueFlowType"]));
    }
    if (m.find("DialogueName") != m.end() && !m["DialogueName"].empty()) {
      dialogueName = make_shared<string>(boost::any_cast<string>(m["DialogueName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~CreateDialogueFlowRequest() = default;
};
class CreateDialogueFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dialogueFlowId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDialogueFlowResponseBody() {}

  explicit CreateDialogueFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dialogueFlowId) {
      res["DialogueFlowId"] = boost::any(*dialogueFlowId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DialogueFlowId") != m.end() && !m["DialogueFlowId"].empty()) {
      dialogueFlowId = make_shared<string>(boost::any_cast<string>(m["DialogueFlowId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDialogueFlowResponseBody() = default;
};
class CreateDialogueFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDialogueFlowResponseBody> body{};

  CreateDialogueFlowResponse() {}

  explicit CreateDialogueFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDialogueFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDialogueFlowResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDialogueFlowResponse() = default;
};
class CreateDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> downloadTaskId{};
  shared_ptr<string> fileId{};

  CreateDownloadUrlRequest() {}

  explicit CreateDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadTaskId) {
      res["DownloadTaskId"] = boost::any(*downloadTaskId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadTaskId") != m.end() && !m["DownloadTaskId"].empty()) {
      downloadTaskId = make_shared<string>(boost::any_cast<string>(m["DownloadTaskId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
  }


  virtual ~CreateDownloadUrlRequest() = default;
};
class CreateDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> fileHttpUrl{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDownloadUrlResponseBody() {}

  explicit CreateDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (fileHttpUrl) {
      res["FileHttpUrl"] = boost::any(*fileHttpUrl);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FileHttpUrl") != m.end() && !m["FileHttpUrl"].empty()) {
      fileHttpUrl = make_shared<string>(boost::any_cast<string>(m["FileHttpUrl"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDownloadUrlResponseBody() = default;
};
class CreateDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDownloadUrlResponseBody> body{};

  CreateDownloadUrlResponse() {}

  explicit CreateDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDownloadUrlResponse() = default;
};
class CreateGlobalQuestionRequest : public Darabonba::Model {
public:
  shared_ptr<string> answers{};
  shared_ptr<string> globalQuestionName{};
  shared_ptr<string> globalQuestionType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> questions{};
  shared_ptr<string> scriptId{};

  CreateGlobalQuestionRequest() {}

  explicit CreateGlobalQuestionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answers) {
      res["Answers"] = boost::any(*answers);
    }
    if (globalQuestionName) {
      res["GlobalQuestionName"] = boost::any(*globalQuestionName);
    }
    if (globalQuestionType) {
      res["GlobalQuestionType"] = boost::any(*globalQuestionType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (questions) {
      res["Questions"] = boost::any(*questions);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Answers") != m.end() && !m["Answers"].empty()) {
      answers = make_shared<string>(boost::any_cast<string>(m["Answers"]));
    }
    if (m.find("GlobalQuestionName") != m.end() && !m["GlobalQuestionName"].empty()) {
      globalQuestionName = make_shared<string>(boost::any_cast<string>(m["GlobalQuestionName"]));
    }
    if (m.find("GlobalQuestionType") != m.end() && !m["GlobalQuestionType"].empty()) {
      globalQuestionType = make_shared<string>(boost::any_cast<string>(m["GlobalQuestionType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Questions") != m.end() && !m["Questions"].empty()) {
      questions = make_shared<string>(boost::any_cast<string>(m["Questions"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~CreateGlobalQuestionRequest() = default;
};
class CreateGlobalQuestionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> globalQuestionId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateGlobalQuestionResponseBody() {}

  explicit CreateGlobalQuestionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (globalQuestionId) {
      res["GlobalQuestionId"] = boost::any(*globalQuestionId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("GlobalQuestionId") != m.end() && !m["GlobalQuestionId"].empty()) {
      globalQuestionId = make_shared<string>(boost::any_cast<string>(m["GlobalQuestionId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateGlobalQuestionResponseBody() = default;
};
class CreateGlobalQuestionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateGlobalQuestionResponseBody> body{};

  CreateGlobalQuestionResponse() {}

  explicit CreateGlobalQuestionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateGlobalQuestionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateGlobalQuestionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateGlobalQuestionResponse() = default;
};
class CreateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> callingNumber{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> maxConcurrentConversation{};
  shared_ptr<string> nluServiceType{};
  shared_ptr<string> resourceGroupId{};

  CreateInstanceRequest() {}

  explicit CreateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (maxConcurrentConversation) {
      res["MaxConcurrentConversation"] = boost::any(*maxConcurrentConversation);
    }
    if (nluServiceType) {
      res["NluServiceType"] = boost::any(*nluServiceType);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumber = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("MaxConcurrentConversation") != m.end() && !m["MaxConcurrentConversation"].empty()) {
      maxConcurrentConversation = make_shared<long>(boost::any_cast<long>(m["MaxConcurrentConversation"]));
    }
    if (m.find("NluServiceType") != m.end() && !m["NluServiceType"].empty()) {
      nluServiceType = make_shared<string>(boost::any_cast<string>(m["NluServiceType"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateInstanceRequest() = default;
};
class CreateInstanceResponseBodyInstance : public Darabonba::Model {
public:
  shared_ptr<long> creationTime{};
  shared_ptr<long> creatorId{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> maxConcurrentConversation{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> resourceGroupId{};

  CreateInstanceResponseBodyInstance() {}

  explicit CreateInstanceResponseBodyInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (maxConcurrentConversation) {
      res["MaxConcurrentConversation"] = boost::any(*maxConcurrentConversation);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["CreatorId"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("MaxConcurrentConversation") != m.end() && !m["MaxConcurrentConversation"].empty()) {
      maxConcurrentConversation = make_shared<long>(boost::any_cast<long>(m["MaxConcurrentConversation"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateInstanceResponseBodyInstance() = default;
};
class CreateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<CreateInstanceResponseBodyInstance> instance{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateInstanceResponseBody() {}

  explicit CreateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        CreateInstanceResponseBodyInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<CreateInstanceResponseBodyInstance>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateInstanceResponseBody() = default;
};
class CreateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateInstanceResponseBody> body{};

  CreateInstanceResponse() {}

  explicit CreateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponse() = default;
};
class CreateInstanceBindNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceList{};
  shared_ptr<string> number{};

  CreateInstanceBindNumberRequest() {}

  explicit CreateInstanceBindNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceList) {
      res["InstanceList"] = boost::any(*instanceList);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceList") != m.end() && !m["InstanceList"].empty()) {
      instanceList = make_shared<string>(boost::any_cast<string>(m["InstanceList"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
  }


  virtual ~CreateInstanceBindNumberRequest() = default;
};
class CreateInstanceBindNumberResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> success{};

  CreateInstanceBindNumberResponseBodyDataList() {}

  explicit CreateInstanceBindNumberResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateInstanceBindNumberResponseBodyDataList() = default;
};
class CreateInstanceBindNumberResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<CreateInstanceBindNumberResponseBodyDataList>> list{};

  CreateInstanceBindNumberResponseBodyData() {}

  explicit CreateInstanceBindNumberResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<CreateInstanceBindNumberResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateInstanceBindNumberResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<CreateInstanceBindNumberResponseBodyDataList>>(expect1);
      }
    }
  }


  virtual ~CreateInstanceBindNumberResponseBodyData() = default;
};
class CreateInstanceBindNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateInstanceBindNumberResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateInstanceBindNumberResponseBody() {}

  explicit CreateInstanceBindNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateInstanceBindNumberResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateInstanceBindNumberResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateInstanceBindNumberResponseBody() = default;
};
class CreateInstanceBindNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateInstanceBindNumberResponseBody> body{};

  CreateInstanceBindNumberResponse() {}

  explicit CreateInstanceBindNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceBindNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceBindNumberResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceBindNumberResponse() = default;
};
class CreateIntentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> intentDescription{};
  shared_ptr<string> intentName{};
  shared_ptr<string> keywords{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> utterances{};

  CreateIntentRequest() {}

  explicit CreateIntentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentDescription) {
      res["IntentDescription"] = boost::any(*intentDescription);
    }
    if (intentName) {
      res["IntentName"] = boost::any(*intentName);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (utterances) {
      res["Utterances"] = boost::any(*utterances);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentDescription") != m.end() && !m["IntentDescription"].empty()) {
      intentDescription = make_shared<string>(boost::any_cast<string>(m["IntentDescription"]));
    }
    if (m.find("IntentName") != m.end() && !m["IntentName"].empty()) {
      intentName = make_shared<string>(boost::any_cast<string>(m["IntentName"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywords = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("Utterances") != m.end() && !m["Utterances"].empty()) {
      utterances = make_shared<string>(boost::any_cast<string>(m["Utterances"]));
    }
  }


  virtual ~CreateIntentRequest() = default;
};
class CreateIntentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> intentId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateIntentResponseBody() {}

  explicit CreateIntentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateIntentResponseBody() = default;
};
class CreateIntentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIntentResponseBody> body{};

  CreateIntentResponse() {}

  explicit CreateIntentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIntentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIntentResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIntentResponse() = default;
};
class CreateJobDataParsingTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobFilePath{};

  CreateJobDataParsingTaskRequest() {}

  explicit CreateJobDataParsingTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobFilePath) {
      res["JobFilePath"] = boost::any(*jobFilePath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobFilePath") != m.end() && !m["JobFilePath"].empty()) {
      jobFilePath = make_shared<string>(boost::any_cast<string>(m["JobFilePath"]));
    }
  }


  virtual ~CreateJobDataParsingTaskRequest() = default;
};
class CreateJobDataParsingTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> jobDataParsingTaskId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateJobDataParsingTaskResponseBody() {}

  explicit CreateJobDataParsingTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobDataParsingTaskId) {
      res["JobDataParsingTaskId"] = boost::any(*jobDataParsingTaskId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("JobDataParsingTaskId") != m.end() && !m["JobDataParsingTaskId"].empty()) {
      jobDataParsingTaskId = make_shared<string>(boost::any_cast<string>(m["JobDataParsingTaskId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateJobDataParsingTaskResponseBody() = default;
};
class CreateJobDataParsingTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateJobDataParsingTaskResponseBody> body{};

  CreateJobDataParsingTaskResponse() {}

  explicit CreateJobDataParsingTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateJobDataParsingTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateJobDataParsingTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateJobDataParsingTaskResponse() = default;
};
class CreateJobGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> callingNumber{};
  shared_ptr<string> flashSmsExtras{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupDescription{};
  shared_ptr<string> jobGroupName{};
  shared_ptr<long> minConcurrency{};
  shared_ptr<string> priority{};
  shared_ptr<vector<string>> recallCallingNumber{};
  shared_ptr<string> recallStrategyJson{};
  shared_ptr<long> ringingDuration{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> strategyJson{};

  CreateJobGroupRequest() {}

  explicit CreateJobGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (flashSmsExtras) {
      res["FlashSmsExtras"] = boost::any(*flashSmsExtras);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupDescription) {
      res["JobGroupDescription"] = boost::any(*jobGroupDescription);
    }
    if (jobGroupName) {
      res["JobGroupName"] = boost::any(*jobGroupName);
    }
    if (minConcurrency) {
      res["MinConcurrency"] = boost::any(*minConcurrency);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (recallCallingNumber) {
      res["RecallCallingNumber"] = boost::any(*recallCallingNumber);
    }
    if (recallStrategyJson) {
      res["RecallStrategyJson"] = boost::any(*recallStrategyJson);
    }
    if (ringingDuration) {
      res["RingingDuration"] = boost::any(*ringingDuration);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (strategyJson) {
      res["StrategyJson"] = boost::any(*strategyJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumber = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FlashSmsExtras") != m.end() && !m["FlashSmsExtras"].empty()) {
      flashSmsExtras = make_shared<string>(boost::any_cast<string>(m["FlashSmsExtras"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupDescription") != m.end() && !m["JobGroupDescription"].empty()) {
      jobGroupDescription = make_shared<string>(boost::any_cast<string>(m["JobGroupDescription"]));
    }
    if (m.find("JobGroupName") != m.end() && !m["JobGroupName"].empty()) {
      jobGroupName = make_shared<string>(boost::any_cast<string>(m["JobGroupName"]));
    }
    if (m.find("MinConcurrency") != m.end() && !m["MinConcurrency"].empty()) {
      minConcurrency = make_shared<long>(boost::any_cast<long>(m["MinConcurrency"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("RecallCallingNumber") != m.end() && !m["RecallCallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecallCallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecallCallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recallCallingNumber = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RecallStrategyJson") != m.end() && !m["RecallStrategyJson"].empty()) {
      recallStrategyJson = make_shared<string>(boost::any_cast<string>(m["RecallStrategyJson"]));
    }
    if (m.find("RingingDuration") != m.end() && !m["RingingDuration"].empty()) {
      ringingDuration = make_shared<long>(boost::any_cast<long>(m["RingingDuration"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("StrategyJson") != m.end() && !m["StrategyJson"].empty()) {
      strategyJson = make_shared<string>(boost::any_cast<string>(m["StrategyJson"]));
    }
  }


  virtual ~CreateJobGroupRequest() = default;
};
class CreateJobGroupResponseBodyJobGroupExportProgress : public Darabonba::Model {
public:
  shared_ptr<string> fileHttpUrl{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  CreateJobGroupResponseBodyJobGroupExportProgress() {}

  explicit CreateJobGroupResponseBodyJobGroupExportProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileHttpUrl) {
      res["FileHttpUrl"] = boost::any(*fileHttpUrl);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileHttpUrl") != m.end() && !m["FileHttpUrl"].empty()) {
      fileHttpUrl = make_shared<string>(boost::any_cast<string>(m["FileHttpUrl"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateJobGroupResponseBodyJobGroupExportProgress() = default;
};
class CreateJobGroupResponseBodyJobGroupRecallStrategy : public Darabonba::Model {
public:
  shared_ptr<bool> emptyNumberIgnore{};
  shared_ptr<bool> inArrearsIgnore{};
  shared_ptr<bool> outOfServiceIgnore{};

  CreateJobGroupResponseBodyJobGroupRecallStrategy() {}

  explicit CreateJobGroupResponseBodyJobGroupRecallStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emptyNumberIgnore) {
      res["EmptyNumberIgnore"] = boost::any(*emptyNumberIgnore);
    }
    if (inArrearsIgnore) {
      res["InArrearsIgnore"] = boost::any(*inArrearsIgnore);
    }
    if (outOfServiceIgnore) {
      res["OutOfServiceIgnore"] = boost::any(*outOfServiceIgnore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmptyNumberIgnore") != m.end() && !m["EmptyNumberIgnore"].empty()) {
      emptyNumberIgnore = make_shared<bool>(boost::any_cast<bool>(m["EmptyNumberIgnore"]));
    }
    if (m.find("InArrearsIgnore") != m.end() && !m["InArrearsIgnore"].empty()) {
      inArrearsIgnore = make_shared<bool>(boost::any_cast<bool>(m["InArrearsIgnore"]));
    }
    if (m.find("OutOfServiceIgnore") != m.end() && !m["OutOfServiceIgnore"].empty()) {
      outOfServiceIgnore = make_shared<bool>(boost::any_cast<bool>(m["OutOfServiceIgnore"]));
    }
  }


  virtual ~CreateJobGroupResponseBodyJobGroupRecallStrategy() = default;
};
class CreateJobGroupResponseBodyJobGroupStrategyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> beginTime{};
  shared_ptr<string> endTime{};

  CreateJobGroupResponseBodyJobGroupStrategyWorkingTime() {}

  explicit CreateJobGroupResponseBodyJobGroupStrategyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~CreateJobGroupResponseBodyJobGroupStrategyWorkingTime() = default;
};
class CreateJobGroupResponseBodyJobGroupStrategy : public Darabonba::Model {
public:
  shared_ptr<string> customized{};
  shared_ptr<long> endTime{};
  shared_ptr<string> followUpStrategy{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> repeatBy{};
  shared_ptr<vector<string>> repeatDays{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<long> startTime{};
  shared_ptr<string> strategyDescription{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> strategyName{};
  shared_ptr<string> type{};
  shared_ptr<vector<CreateJobGroupResponseBodyJobGroupStrategyWorkingTime>> workingTime{};

  CreateJobGroupResponseBodyJobGroupStrategy() {}

  explicit CreateJobGroupResponseBodyJobGroupStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (followUpStrategy) {
      res["FollowUpStrategy"] = boost::any(*followUpStrategy);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (repeatBy) {
      res["RepeatBy"] = boost::any(*repeatBy);
    }
    if (repeatDays) {
      res["RepeatDays"] = boost::any(*repeatDays);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (strategyDescription) {
      res["StrategyDescription"] = boost::any(*strategyDescription);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<string>(boost::any_cast<string>(m["Customized"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FollowUpStrategy") != m.end() && !m["FollowUpStrategy"].empty()) {
      followUpStrategy = make_shared<string>(boost::any_cast<string>(m["FollowUpStrategy"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("RepeatBy") != m.end() && !m["RepeatBy"].empty()) {
      repeatBy = make_shared<string>(boost::any_cast<string>(m["RepeatBy"]));
    }
    if (m.find("RepeatDays") != m.end() && !m["RepeatDays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StrategyDescription") != m.end() && !m["StrategyDescription"].empty()) {
      strategyDescription = make_shared<string>(boost::any_cast<string>(m["StrategyDescription"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<CreateJobGroupResponseBodyJobGroupStrategyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateJobGroupResponseBodyJobGroupStrategyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<CreateJobGroupResponseBodyJobGroupStrategyWorkingTime>>(expect1);
      }
    }
  }


  virtual ~CreateJobGroupResponseBodyJobGroupStrategy() = default;
};
class CreateJobGroupResponseBodyJobGroup : public Darabonba::Model {
public:
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<long> creationTime{};
  shared_ptr<CreateJobGroupResponseBodyJobGroupExportProgress> exportProgress{};
  shared_ptr<string> jobDataParsingTaskId{};
  shared_ptr<string> jobFilePath{};
  shared_ptr<string> jobGroupDescription{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobGroupName{};
  shared_ptr<long> minConcurrency{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> priority{};
  shared_ptr<vector<string>> recallCallingNumbers{};
  shared_ptr<CreateJobGroupResponseBodyJobGroupRecallStrategy> recallStrategy{};
  shared_ptr<long> ringingDuration{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> scriptVersion{};
  shared_ptr<string> status{};
  shared_ptr<CreateJobGroupResponseBodyJobGroupStrategy> strategy{};

  CreateJobGroupResponseBodyJobGroup() {}

  explicit CreateJobGroupResponseBodyJobGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (exportProgress) {
      res["ExportProgress"] = exportProgress ? boost::any(exportProgress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobDataParsingTaskId) {
      res["JobDataParsingTaskId"] = boost::any(*jobDataParsingTaskId);
    }
    if (jobFilePath) {
      res["JobFilePath"] = boost::any(*jobFilePath);
    }
    if (jobGroupDescription) {
      res["JobGroupDescription"] = boost::any(*jobGroupDescription);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobGroupName) {
      res["JobGroupName"] = boost::any(*jobGroupName);
    }
    if (minConcurrency) {
      res["MinConcurrency"] = boost::any(*minConcurrency);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (recallCallingNumbers) {
      res["RecallCallingNumbers"] = boost::any(*recallCallingNumbers);
    }
    if (recallStrategy) {
      res["RecallStrategy"] = recallStrategy ? boost::any(recallStrategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ringingDuration) {
      res["RingingDuration"] = boost::any(*ringingDuration);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (scriptVersion) {
      res["ScriptVersion"] = boost::any(*scriptVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("ExportProgress") != m.end() && !m["ExportProgress"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExportProgress"].type()) {
        CreateJobGroupResponseBodyJobGroupExportProgress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExportProgress"]));
        exportProgress = make_shared<CreateJobGroupResponseBodyJobGroupExportProgress>(model1);
      }
    }
    if (m.find("JobDataParsingTaskId") != m.end() && !m["JobDataParsingTaskId"].empty()) {
      jobDataParsingTaskId = make_shared<string>(boost::any_cast<string>(m["JobDataParsingTaskId"]));
    }
    if (m.find("JobFilePath") != m.end() && !m["JobFilePath"].empty()) {
      jobFilePath = make_shared<string>(boost::any_cast<string>(m["JobFilePath"]));
    }
    if (m.find("JobGroupDescription") != m.end() && !m["JobGroupDescription"].empty()) {
      jobGroupDescription = make_shared<string>(boost::any_cast<string>(m["JobGroupDescription"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobGroupName") != m.end() && !m["JobGroupName"].empty()) {
      jobGroupName = make_shared<string>(boost::any_cast<string>(m["JobGroupName"]));
    }
    if (m.find("MinConcurrency") != m.end() && !m["MinConcurrency"].empty()) {
      minConcurrency = make_shared<long>(boost::any_cast<long>(m["MinConcurrency"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("RecallCallingNumbers") != m.end() && !m["RecallCallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecallCallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecallCallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recallCallingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RecallStrategy") != m.end() && !m["RecallStrategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecallStrategy"].type()) {
        CreateJobGroupResponseBodyJobGroupRecallStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecallStrategy"]));
        recallStrategy = make_shared<CreateJobGroupResponseBodyJobGroupRecallStrategy>(model1);
      }
    }
    if (m.find("RingingDuration") != m.end() && !m["RingingDuration"].empty()) {
      ringingDuration = make_shared<long>(boost::any_cast<long>(m["RingingDuration"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("ScriptVersion") != m.end() && !m["ScriptVersion"].empty()) {
      scriptVersion = make_shared<string>(boost::any_cast<string>(m["ScriptVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        CreateJobGroupResponseBodyJobGroupStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<CreateJobGroupResponseBodyJobGroupStrategy>(model1);
      }
    }
  }


  virtual ~CreateJobGroupResponseBodyJobGroup() = default;
};
class CreateJobGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<CreateJobGroupResponseBodyJobGroup> jobGroup{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateJobGroupResponseBody() {}

  explicit CreateJobGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobGroup) {
      res["JobGroup"] = jobGroup ? boost::any(jobGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("JobGroup") != m.end() && !m["JobGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobGroup"].type()) {
        CreateJobGroupResponseBodyJobGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobGroup"]));
        jobGroup = make_shared<CreateJobGroupResponseBodyJobGroup>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateJobGroupResponseBody() = default;
};
class CreateJobGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateJobGroupResponseBody> body{};

  CreateJobGroupResponse() {}

  explicit CreateJobGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateJobGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateJobGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateJobGroupResponse() = default;
};
class CreateJobGroupExportTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<vector<string>> option{};

  CreateJobGroupExportTaskRequest() {}

  explicit CreateJobGroupExportTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (option) {
      res["Option"] = boost::any(*option);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Option"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Option"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      option = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateJobGroupExportTaskRequest() = default;
};
class CreateJobGroupExportTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> taskId{};

  CreateJobGroupExportTaskResponseBody() {}

  explicit CreateJobGroupExportTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateJobGroupExportTaskResponseBody() = default;
};
class CreateJobGroupExportTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateJobGroupExportTaskResponseBody> body{};

  CreateJobGroupExportTaskResponse() {}

  explicit CreateJobGroupExportTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateJobGroupExportTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateJobGroupExportTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateJobGroupExportTaskResponse() = default;
};
class CreateNumberDistrictInfoDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> versionId{};

  CreateNumberDistrictInfoDownloadUrlRequest() {}

  explicit CreateNumberDistrictInfoDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~CreateNumberDistrictInfoDownloadUrlRequest() = default;
};
class CreateNumberDistrictInfoDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> fileHttpUrl{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateNumberDistrictInfoDownloadUrlResponseBody() {}

  explicit CreateNumberDistrictInfoDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (fileHttpUrl) {
      res["FileHttpUrl"] = boost::any(*fileHttpUrl);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FileHttpUrl") != m.end() && !m["FileHttpUrl"].empty()) {
      fileHttpUrl = make_shared<string>(boost::any_cast<string>(m["FileHttpUrl"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateNumberDistrictInfoDownloadUrlResponseBody() = default;
};
class CreateNumberDistrictInfoDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNumberDistrictInfoDownloadUrlResponseBody> body{};

  CreateNumberDistrictInfoDownloadUrlResponse() {}

  explicit CreateNumberDistrictInfoDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNumberDistrictInfoDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNumberDistrictInfoDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNumberDistrictInfoDownloadUrlResponse() = default;
};
class CreateNumberDistrictInfoParsingTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> filePath{};
  shared_ptr<long> fileSize{};

  CreateNumberDistrictInfoParsingTaskRequest() {}

  explicit CreateNumberDistrictInfoParsingTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["FileSize"]));
    }
  }


  virtual ~CreateNumberDistrictInfoParsingTaskRequest() = default;
};
class CreateNumberDistrictInfoParsingTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateNumberDistrictInfoParsingTaskResponseBody() {}

  explicit CreateNumberDistrictInfoParsingTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateNumberDistrictInfoParsingTaskResponseBody() = default;
};
class CreateNumberDistrictInfoParsingTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNumberDistrictInfoParsingTaskResponseBody> body{};

  CreateNumberDistrictInfoParsingTaskResponse() {}

  explicit CreateNumberDistrictInfoParsingTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNumberDistrictInfoParsingTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNumberDistrictInfoParsingTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNumberDistrictInfoParsingTaskResponse() = default;
};
class CreateOutboundCallNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<long> rateLimitCount{};
  shared_ptr<long> rateLimitPeriod{};

  CreateOutboundCallNumberRequest() {}

  explicit CreateOutboundCallNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (rateLimitCount) {
      res["RateLimitCount"] = boost::any(*rateLimitCount);
    }
    if (rateLimitPeriod) {
      res["RateLimitPeriod"] = boost::any(*rateLimitPeriod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("RateLimitCount") != m.end() && !m["RateLimitCount"].empty()) {
      rateLimitCount = make_shared<long>(boost::any_cast<long>(m["RateLimitCount"]));
    }
    if (m.find("RateLimitPeriod") != m.end() && !m["RateLimitPeriod"].empty()) {
      rateLimitPeriod = make_shared<long>(boost::any_cast<long>(m["RateLimitPeriod"]));
    }
  }


  virtual ~CreateOutboundCallNumberRequest() = default;
};
class CreateOutboundCallNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> outboundCallNumberId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateOutboundCallNumberResponseBody() {}

  explicit CreateOutboundCallNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (outboundCallNumberId) {
      res["OutboundCallNumberId"] = boost::any(*outboundCallNumberId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OutboundCallNumberId") != m.end() && !m["OutboundCallNumberId"].empty()) {
      outboundCallNumberId = make_shared<string>(boost::any_cast<string>(m["OutboundCallNumberId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateOutboundCallNumberResponseBody() = default;
};
class CreateOutboundCallNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOutboundCallNumberResponseBody> body{};

  CreateOutboundCallNumberResponse() {}

  explicit CreateOutboundCallNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOutboundCallNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOutboundCallNumberResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOutboundCallNumberResponse() = default;
};
class CreateScriptRequest : public Darabonba::Model {
public:
  shared_ptr<long> agentId{};
  shared_ptr<string> agentKey{};
  shared_ptr<bool> agentLlm{};
  shared_ptr<string> asrConfig{};
  shared_ptr<string> chatbotId{};
  shared_ptr<bool> emotionEnable{};
  shared_ptr<string> industry{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> longWaitEnable{};
  shared_ptr<bool> miniPlaybackEnable{};
  shared_ptr<bool> newBargeInEnable{};
  shared_ptr<string> nluAccessType{};
  shared_ptr<string> nluEngine{};
  shared_ptr<string> scene{};
  shared_ptr<vector<string>> scriptContent{};
  shared_ptr<string> scriptDescription{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> scriptNluProfileJsonString{};
  shared_ptr<vector<string>> scriptWaveform{};
  shared_ptr<string> ttsConfig{};

  CreateScriptRequest() {}

  explicit CreateScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (agentLlm) {
      res["AgentLlm"] = boost::any(*agentLlm);
    }
    if (asrConfig) {
      res["AsrConfig"] = boost::any(*asrConfig);
    }
    if (chatbotId) {
      res["ChatbotId"] = boost::any(*chatbotId);
    }
    if (emotionEnable) {
      res["EmotionEnable"] = boost::any(*emotionEnable);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (longWaitEnable) {
      res["LongWaitEnable"] = boost::any(*longWaitEnable);
    }
    if (miniPlaybackEnable) {
      res["MiniPlaybackEnable"] = boost::any(*miniPlaybackEnable);
    }
    if (newBargeInEnable) {
      res["NewBargeInEnable"] = boost::any(*newBargeInEnable);
    }
    if (nluAccessType) {
      res["NluAccessType"] = boost::any(*nluAccessType);
    }
    if (nluEngine) {
      res["NluEngine"] = boost::any(*nluEngine);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (scriptContent) {
      res["ScriptContent"] = boost::any(*scriptContent);
    }
    if (scriptDescription) {
      res["ScriptDescription"] = boost::any(*scriptDescription);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (scriptNluProfileJsonString) {
      res["ScriptNluProfileJsonString"] = boost::any(*scriptNluProfileJsonString);
    }
    if (scriptWaveform) {
      res["ScriptWaveform"] = boost::any(*scriptWaveform);
    }
    if (ttsConfig) {
      res["TtsConfig"] = boost::any(*ttsConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<long>(boost::any_cast<long>(m["AgentId"]));
    }
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("AgentLlm") != m.end() && !m["AgentLlm"].empty()) {
      agentLlm = make_shared<bool>(boost::any_cast<bool>(m["AgentLlm"]));
    }
    if (m.find("AsrConfig") != m.end() && !m["AsrConfig"].empty()) {
      asrConfig = make_shared<string>(boost::any_cast<string>(m["AsrConfig"]));
    }
    if (m.find("ChatbotId") != m.end() && !m["ChatbotId"].empty()) {
      chatbotId = make_shared<string>(boost::any_cast<string>(m["ChatbotId"]));
    }
    if (m.find("EmotionEnable") != m.end() && !m["EmotionEnable"].empty()) {
      emotionEnable = make_shared<bool>(boost::any_cast<bool>(m["EmotionEnable"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LongWaitEnable") != m.end() && !m["LongWaitEnable"].empty()) {
      longWaitEnable = make_shared<bool>(boost::any_cast<bool>(m["LongWaitEnable"]));
    }
    if (m.find("MiniPlaybackEnable") != m.end() && !m["MiniPlaybackEnable"].empty()) {
      miniPlaybackEnable = make_shared<bool>(boost::any_cast<bool>(m["MiniPlaybackEnable"]));
    }
    if (m.find("NewBargeInEnable") != m.end() && !m["NewBargeInEnable"].empty()) {
      newBargeInEnable = make_shared<bool>(boost::any_cast<bool>(m["NewBargeInEnable"]));
    }
    if (m.find("NluAccessType") != m.end() && !m["NluAccessType"].empty()) {
      nluAccessType = make_shared<string>(boost::any_cast<string>(m["NluAccessType"]));
    }
    if (m.find("NluEngine") != m.end() && !m["NluEngine"].empty()) {
      nluEngine = make_shared<string>(boost::any_cast<string>(m["NluEngine"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("ScriptContent") != m.end() && !m["ScriptContent"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScriptContent"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScriptContent"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scriptContent = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScriptDescription") != m.end() && !m["ScriptDescription"].empty()) {
      scriptDescription = make_shared<string>(boost::any_cast<string>(m["ScriptDescription"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("ScriptNluProfileJsonString") != m.end() && !m["ScriptNluProfileJsonString"].empty()) {
      scriptNluProfileJsonString = make_shared<string>(boost::any_cast<string>(m["ScriptNluProfileJsonString"]));
    }
    if (m.find("ScriptWaveform") != m.end() && !m["ScriptWaveform"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScriptWaveform"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScriptWaveform"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scriptWaveform = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TtsConfig") != m.end() && !m["TtsConfig"].empty()) {
      ttsConfig = make_shared<string>(boost::any_cast<string>(m["TtsConfig"]));
    }
  }


  virtual ~CreateScriptRequest() = default;
};
class CreateScriptResponseBodyScript : public Darabonba::Model {
public:
  shared_ptr<string> debugStatus{};
  shared_ptr<string> industry{};
  shared_ptr<bool> isDebugDrafted{};
  shared_ptr<bool> isDrafted{};
  shared_ptr<string> nluAccessType{};
  shared_ptr<string> nluEngine{};
  shared_ptr<string> scene{};
  shared_ptr<string> scriptDescription{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};

  CreateScriptResponseBodyScript() {}

  explicit CreateScriptResponseBodyScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (debugStatus) {
      res["DebugStatus"] = boost::any(*debugStatus);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (isDebugDrafted) {
      res["IsDebugDrafted"] = boost::any(*isDebugDrafted);
    }
    if (isDrafted) {
      res["IsDrafted"] = boost::any(*isDrafted);
    }
    if (nluAccessType) {
      res["NluAccessType"] = boost::any(*nluAccessType);
    }
    if (nluEngine) {
      res["NluEngine"] = boost::any(*nluEngine);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (scriptDescription) {
      res["ScriptDescription"] = boost::any(*scriptDescription);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DebugStatus") != m.end() && !m["DebugStatus"].empty()) {
      debugStatus = make_shared<string>(boost::any_cast<string>(m["DebugStatus"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("IsDebugDrafted") != m.end() && !m["IsDebugDrafted"].empty()) {
      isDebugDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDebugDrafted"]));
    }
    if (m.find("IsDrafted") != m.end() && !m["IsDrafted"].empty()) {
      isDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDrafted"]));
    }
    if (m.find("NluAccessType") != m.end() && !m["NluAccessType"].empty()) {
      nluAccessType = make_shared<string>(boost::any_cast<string>(m["NluAccessType"]));
    }
    if (m.find("NluEngine") != m.end() && !m["NluEngine"].empty()) {
      nluEngine = make_shared<string>(boost::any_cast<string>(m["NluEngine"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("ScriptDescription") != m.end() && !m["ScriptDescription"].empty()) {
      scriptDescription = make_shared<string>(boost::any_cast<string>(m["ScriptDescription"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~CreateScriptResponseBodyScript() = default;
};
class CreateScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateScriptResponseBodyScript> script{};
  shared_ptr<bool> success{};

  CreateScriptResponseBody() {}

  explicit CreateScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        CreateScriptResponseBodyScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<CreateScriptResponseBodyScript>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateScriptResponseBody() = default;
};
class CreateScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateScriptResponseBody> body{};

  CreateScriptResponse() {}

  explicit CreateScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScriptResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScriptResponse() = default;
};
class CreateScriptWaveformRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptContent{};
  shared_ptr<string> scriptId{};

  CreateScriptWaveformRequest() {}

  explicit CreateScriptWaveformRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptContent) {
      res["ScriptContent"] = boost::any(*scriptContent);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptContent") != m.end() && !m["ScriptContent"].empty()) {
      scriptContent = make_shared<string>(boost::any_cast<string>(m["ScriptContent"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~CreateScriptWaveformRequest() = default;
};
class CreateScriptWaveformResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scriptWaveformId{};
  shared_ptr<bool> success{};

  CreateScriptWaveformResponseBody() {}

  explicit CreateScriptWaveformResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scriptWaveformId) {
      res["ScriptWaveformId"] = boost::any(*scriptWaveformId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScriptWaveformId") != m.end() && !m["ScriptWaveformId"].empty()) {
      scriptWaveformId = make_shared<string>(boost::any_cast<string>(m["ScriptWaveformId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateScriptWaveformResponseBody() = default;
};
class CreateScriptWaveformResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateScriptWaveformResponseBody> body{};

  CreateScriptWaveformResponse() {}

  explicit CreateScriptWaveformResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScriptWaveformResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScriptWaveformResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScriptWaveformResponse() = default;
};
class CreateTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> tagGroup{};
  shared_ptr<string> tagName{};

  CreateTagRequest() {}

  explicit CreateTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (tagGroup) {
      res["TagGroup"] = boost::any(*tagGroup);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("TagGroup") != m.end() && !m["TagGroup"].empty()) {
      tagGroup = make_shared<string>(boost::any_cast<string>(m["TagGroup"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~CreateTagRequest() = default;
};
class CreateTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> tagId{};

  CreateTagResponseBody() {}

  explicit CreateTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tagId) {
      res["TagId"] = boost::any(*tagId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TagId") != m.end() && !m["TagId"].empty()) {
      tagId = make_shared<string>(boost::any_cast<string>(m["TagId"]));
    }
  }


  virtual ~CreateTagResponseBody() = default;
};
class CreateTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTagResponseBody> body{};

  CreateTagResponse() {}

  explicit CreateTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTagResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTagResponse() = default;
};
class CreateTaskExportTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> actualTimeGte{};
  shared_ptr<long> actualTimeLte{};
  shared_ptr<long> callDurationGte{};
  shared_ptr<long> callDurationLte{};
  shared_ptr<string> calledNumber{};
  shared_ptr<bool> hasAnswered{};
  shared_ptr<bool> hasHangUpByRejection{};
  shared_ptr<bool> hasReachedEndOfFlow{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobGroupNameQuery{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobStatusStringList{};
  shared_ptr<string> otherId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> recordingDurationGte{};
  shared_ptr<long> recordingDurationLte{};
  shared_ptr<string> scriptNameQuery{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortOrder{};
  shared_ptr<long> taskCreateTimeGte{};
  shared_ptr<long> taskCreateTimeLte{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskStatusStringList{};
  shared_ptr<string> userIdMatch{};

  CreateTaskExportTaskRequest() {}

  explicit CreateTaskExportTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualTimeGte) {
      res["ActualTimeGte"] = boost::any(*actualTimeGte);
    }
    if (actualTimeLte) {
      res["ActualTimeLte"] = boost::any(*actualTimeLte);
    }
    if (callDurationGte) {
      res["CallDurationGte"] = boost::any(*callDurationGte);
    }
    if (callDurationLte) {
      res["CallDurationLte"] = boost::any(*callDurationLte);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (hasAnswered) {
      res["HasAnswered"] = boost::any(*hasAnswered);
    }
    if (hasHangUpByRejection) {
      res["HasHangUpByRejection"] = boost::any(*hasHangUpByRejection);
    }
    if (hasReachedEndOfFlow) {
      res["HasReachedEndOfFlow"] = boost::any(*hasReachedEndOfFlow);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobGroupNameQuery) {
      res["JobGroupNameQuery"] = boost::any(*jobGroupNameQuery);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobStatusStringList) {
      res["JobStatusStringList"] = boost::any(*jobStatusStringList);
    }
    if (otherId) {
      res["OtherId"] = boost::any(*otherId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recordingDurationGte) {
      res["RecordingDurationGte"] = boost::any(*recordingDurationGte);
    }
    if (recordingDurationLte) {
      res["RecordingDurationLte"] = boost::any(*recordingDurationLte);
    }
    if (scriptNameQuery) {
      res["ScriptNameQuery"] = boost::any(*scriptNameQuery);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (taskCreateTimeGte) {
      res["TaskCreateTimeGte"] = boost::any(*taskCreateTimeGte);
    }
    if (taskCreateTimeLte) {
      res["TaskCreateTimeLte"] = boost::any(*taskCreateTimeLte);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatusStringList) {
      res["TaskStatusStringList"] = boost::any(*taskStatusStringList);
    }
    if (userIdMatch) {
      res["UserIdMatch"] = boost::any(*userIdMatch);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualTimeGte") != m.end() && !m["ActualTimeGte"].empty()) {
      actualTimeGte = make_shared<long>(boost::any_cast<long>(m["ActualTimeGte"]));
    }
    if (m.find("ActualTimeLte") != m.end() && !m["ActualTimeLte"].empty()) {
      actualTimeLte = make_shared<long>(boost::any_cast<long>(m["ActualTimeLte"]));
    }
    if (m.find("CallDurationGte") != m.end() && !m["CallDurationGte"].empty()) {
      callDurationGte = make_shared<long>(boost::any_cast<long>(m["CallDurationGte"]));
    }
    if (m.find("CallDurationLte") != m.end() && !m["CallDurationLte"].empty()) {
      callDurationLte = make_shared<long>(boost::any_cast<long>(m["CallDurationLte"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("HasAnswered") != m.end() && !m["HasAnswered"].empty()) {
      hasAnswered = make_shared<bool>(boost::any_cast<bool>(m["HasAnswered"]));
    }
    if (m.find("HasHangUpByRejection") != m.end() && !m["HasHangUpByRejection"].empty()) {
      hasHangUpByRejection = make_shared<bool>(boost::any_cast<bool>(m["HasHangUpByRejection"]));
    }
    if (m.find("HasReachedEndOfFlow") != m.end() && !m["HasReachedEndOfFlow"].empty()) {
      hasReachedEndOfFlow = make_shared<bool>(boost::any_cast<bool>(m["HasReachedEndOfFlow"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobGroupNameQuery") != m.end() && !m["JobGroupNameQuery"].empty()) {
      jobGroupNameQuery = make_shared<string>(boost::any_cast<string>(m["JobGroupNameQuery"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobStatusStringList") != m.end() && !m["JobStatusStringList"].empty()) {
      jobStatusStringList = make_shared<string>(boost::any_cast<string>(m["JobStatusStringList"]));
    }
    if (m.find("OtherId") != m.end() && !m["OtherId"].empty()) {
      otherId = make_shared<string>(boost::any_cast<string>(m["OtherId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecordingDurationGte") != m.end() && !m["RecordingDurationGte"].empty()) {
      recordingDurationGte = make_shared<long>(boost::any_cast<long>(m["RecordingDurationGte"]));
    }
    if (m.find("RecordingDurationLte") != m.end() && !m["RecordingDurationLte"].empty()) {
      recordingDurationLte = make_shared<long>(boost::any_cast<long>(m["RecordingDurationLte"]));
    }
    if (m.find("ScriptNameQuery") != m.end() && !m["ScriptNameQuery"].empty()) {
      scriptNameQuery = make_shared<string>(boost::any_cast<string>(m["ScriptNameQuery"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("TaskCreateTimeGte") != m.end() && !m["TaskCreateTimeGte"].empty()) {
      taskCreateTimeGte = make_shared<long>(boost::any_cast<long>(m["TaskCreateTimeGte"]));
    }
    if (m.find("TaskCreateTimeLte") != m.end() && !m["TaskCreateTimeLte"].empty()) {
      taskCreateTimeLte = make_shared<long>(boost::any_cast<long>(m["TaskCreateTimeLte"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatusStringList") != m.end() && !m["TaskStatusStringList"].empty()) {
      taskStatusStringList = make_shared<string>(boost::any_cast<string>(m["TaskStatusStringList"]));
    }
    if (m.find("UserIdMatch") != m.end() && !m["UserIdMatch"].empty()) {
      userIdMatch = make_shared<string>(boost::any_cast<string>(m["UserIdMatch"]));
    }
  }


  virtual ~CreateTaskExportTaskRequest() = default;
};
class CreateTaskExportTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> taskId{};

  CreateTaskExportTaskResponseBody() {}

  explicit CreateTaskExportTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateTaskExportTaskResponseBody() = default;
};
class CreateTaskExportTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTaskExportTaskResponseBody> body{};

  CreateTaskExportTaskResponse() {}

  explicit CreateTaskExportTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTaskExportTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTaskExportTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTaskExportTaskResponse() = default;
};
class DeleteAgentProfilesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> agentProfileIds{};
  shared_ptr<string> appIp{};

  DeleteAgentProfilesRequest() {}

  explicit DeleteAgentProfilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentProfileIds) {
      res["AgentProfileIds"] = boost::any(*agentProfileIds);
    }
    if (appIp) {
      res["AppIp"] = boost::any(*appIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentProfileIds") != m.end() && !m["AgentProfileIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AgentProfileIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AgentProfileIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      agentProfileIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AppIp") != m.end() && !m["AppIp"].empty()) {
      appIp = make_shared<string>(boost::any_cast<string>(m["AppIp"]));
    }
  }


  virtual ~DeleteAgentProfilesRequest() = default;
};
class DeleteAgentProfilesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentProfileIdsShrink{};
  shared_ptr<string> appIp{};

  DeleteAgentProfilesShrinkRequest() {}

  explicit DeleteAgentProfilesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentProfileIdsShrink) {
      res["AgentProfileIds"] = boost::any(*agentProfileIdsShrink);
    }
    if (appIp) {
      res["AppIp"] = boost::any(*appIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentProfileIds") != m.end() && !m["AgentProfileIds"].empty()) {
      agentProfileIdsShrink = make_shared<string>(boost::any_cast<string>(m["AgentProfileIds"]));
    }
    if (m.find("AppIp") != m.end() && !m["AppIp"].empty()) {
      appIp = make_shared<string>(boost::any_cast<string>(m["AppIp"]));
    }
  }


  virtual ~DeleteAgentProfilesShrinkRequest() = default;
};
class DeleteAgentProfilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteAgentProfilesResponseBody() {}

  explicit DeleteAgentProfilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteAgentProfilesResponseBody() = default;
};
class DeleteAgentProfilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAgentProfilesResponseBody> body{};

  DeleteAgentProfilesResponse() {}

  explicit DeleteAgentProfilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAgentProfilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAgentProfilesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAgentProfilesResponse() = default;
};
class DeleteAllNumberDistrictInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteAllNumberDistrictInfoResponseBody() {}

  explicit DeleteAllNumberDistrictInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteAllNumberDistrictInfoResponseBody() = default;
};
class DeleteAllNumberDistrictInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAllNumberDistrictInfoResponseBody> body{};

  DeleteAllNumberDistrictInfoResponse() {}

  explicit DeleteAllNumberDistrictInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAllNumberDistrictInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAllNumberDistrictInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAllNumberDistrictInfoResponse() = default;
};
class DeleteBeebotIntentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> intentId{};
  shared_ptr<string> scriptId{};

  DeleteBeebotIntentRequest() {}

  explicit DeleteBeebotIntentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~DeleteBeebotIntentRequest() = default;
};
class DeleteBeebotIntentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beebotRequestId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> intentId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteBeebotIntentResponseBody() {}

  explicit DeleteBeebotIntentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beebotRequestId) {
      res["BeebotRequestId"] = boost::any(*beebotRequestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeebotRequestId") != m.end() && !m["BeebotRequestId"].empty()) {
      beebotRequestId = make_shared<string>(boost::any_cast<string>(m["BeebotRequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteBeebotIntentResponseBody() = default;
};
class DeleteBeebotIntentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBeebotIntentResponseBody> body{};

  DeleteBeebotIntentResponse() {}

  explicit DeleteBeebotIntentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBeebotIntentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBeebotIntentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBeebotIntentResponse() = default;
};
class DeleteBeebotIntentLgfRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> intentId{};
  shared_ptr<long> lgfId{};
  shared_ptr<string> scriptId{};

  DeleteBeebotIntentLgfRequest() {}

  explicit DeleteBeebotIntentLgfRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (lgfId) {
      res["LgfId"] = boost::any(*lgfId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("LgfId") != m.end() && !m["LgfId"].empty()) {
      lgfId = make_shared<long>(boost::any_cast<long>(m["LgfId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~DeleteBeebotIntentLgfRequest() = default;
};
class DeleteBeebotIntentLgfResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beebotRequestId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> lgfId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteBeebotIntentLgfResponseBody() {}

  explicit DeleteBeebotIntentLgfResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beebotRequestId) {
      res["BeebotRequestId"] = boost::any(*beebotRequestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (lgfId) {
      res["LgfId"] = boost::any(*lgfId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeebotRequestId") != m.end() && !m["BeebotRequestId"].empty()) {
      beebotRequestId = make_shared<string>(boost::any_cast<string>(m["BeebotRequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("LgfId") != m.end() && !m["LgfId"].empty()) {
      lgfId = make_shared<long>(boost::any_cast<long>(m["LgfId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteBeebotIntentLgfResponseBody() = default;
};
class DeleteBeebotIntentLgfResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBeebotIntentLgfResponseBody> body{};

  DeleteBeebotIntentLgfResponse() {}

  explicit DeleteBeebotIntentLgfResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBeebotIntentLgfResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBeebotIntentLgfResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBeebotIntentLgfResponse() = default;
};
class DeleteBeebotIntentUserSayRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> intentId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> userSayId{};

  DeleteBeebotIntentUserSayRequest() {}

  explicit DeleteBeebotIntentUserSayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (userSayId) {
      res["UserSayId"] = boost::any(*userSayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("UserSayId") != m.end() && !m["UserSayId"].empty()) {
      userSayId = make_shared<string>(boost::any_cast<string>(m["UserSayId"]));
    }
  }


  virtual ~DeleteBeebotIntentUserSayRequest() = default;
};
class DeleteBeebotIntentUserSayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beebotRequestId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> userSayId{};

  DeleteBeebotIntentUserSayResponseBody() {}

  explicit DeleteBeebotIntentUserSayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beebotRequestId) {
      res["BeebotRequestId"] = boost::any(*beebotRequestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (userSayId) {
      res["UserSayId"] = boost::any(*userSayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeebotRequestId") != m.end() && !m["BeebotRequestId"].empty()) {
      beebotRequestId = make_shared<string>(boost::any_cast<string>(m["BeebotRequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("UserSayId") != m.end() && !m["UserSayId"].empty()) {
      userSayId = make_shared<long>(boost::any_cast<long>(m["UserSayId"]));
    }
  }


  virtual ~DeleteBeebotIntentUserSayResponseBody() = default;
};
class DeleteBeebotIntentUserSayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBeebotIntentUserSayResponseBody> body{};

  DeleteBeebotIntentUserSayResponse() {}

  explicit DeleteBeebotIntentUserSayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBeebotIntentUserSayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBeebotIntentUserSayResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBeebotIntentUserSayResponse() = default;
};
class DeleteContactBlockListRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactBlockListId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> operator_{};

  DeleteContactBlockListRequest() {}

  explicit DeleteContactBlockListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactBlockListId) {
      res["ContactBlockListId"] = boost::any(*contactBlockListId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactBlockListId") != m.end() && !m["ContactBlockListId"].empty()) {
      contactBlockListId = make_shared<string>(boost::any_cast<string>(m["ContactBlockListId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
  }


  virtual ~DeleteContactBlockListRequest() = default;
};
class DeleteContactBlockListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> affectedRows{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteContactBlockListResponseBody() {}

  explicit DeleteContactBlockListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectedRows) {
      res["AffectedRows"] = boost::any(*affectedRows);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectedRows") != m.end() && !m["AffectedRows"].empty()) {
      affectedRows = make_shared<long>(boost::any_cast<long>(m["AffectedRows"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteContactBlockListResponseBody() = default;
};
class DeleteContactBlockListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteContactBlockListResponseBody> body{};

  DeleteContactBlockListResponse() {}

  explicit DeleteContactBlockListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteContactBlockListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteContactBlockListResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteContactBlockListResponse() = default;
};
class DeleteContactWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactWhiteListId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> operator_{};

  DeleteContactWhiteListRequest() {}

  explicit DeleteContactWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactWhiteListId) {
      res["ContactWhiteListId"] = boost::any(*contactWhiteListId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactWhiteListId") != m.end() && !m["ContactWhiteListId"].empty()) {
      contactWhiteListId = make_shared<string>(boost::any_cast<string>(m["ContactWhiteListId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
  }


  virtual ~DeleteContactWhiteListRequest() = default;
};
class DeleteContactWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> affectedRows{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteContactWhiteListResponseBody() {}

  explicit DeleteContactWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectedRows) {
      res["AffectedRows"] = boost::any(*affectedRows);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectedRows") != m.end() && !m["AffectedRows"].empty()) {
      affectedRows = make_shared<long>(boost::any_cast<long>(m["AffectedRows"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteContactWhiteListResponseBody() = default;
};
class DeleteContactWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteContactWhiteListResponseBody> body{};

  DeleteContactWhiteListResponse() {}

  explicit DeleteContactWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteContactWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteContactWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteContactWhiteListResponse() = default;
};
class DeleteDialogueFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> dialogueFlowId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  DeleteDialogueFlowRequest() {}

  explicit DeleteDialogueFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dialogueFlowId) {
      res["DialogueFlowId"] = boost::any(*dialogueFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DialogueFlowId") != m.end() && !m["DialogueFlowId"].empty()) {
      dialogueFlowId = make_shared<string>(boost::any_cast<string>(m["DialogueFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~DeleteDialogueFlowRequest() = default;
};
class DeleteDialogueFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDialogueFlowResponseBody() {}

  explicit DeleteDialogueFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDialogueFlowResponseBody() = default;
};
class DeleteDialogueFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDialogueFlowResponseBody> body{};

  DeleteDialogueFlowResponse() {}

  explicit DeleteDialogueFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDialogueFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDialogueFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDialogueFlowResponse() = default;
};
class DeleteGlobalQuestionRequest : public Darabonba::Model {
public:
  shared_ptr<string> globalQuestionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  DeleteGlobalQuestionRequest() {}

  explicit DeleteGlobalQuestionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalQuestionId) {
      res["GlobalQuestionId"] = boost::any(*globalQuestionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalQuestionId") != m.end() && !m["GlobalQuestionId"].empty()) {
      globalQuestionId = make_shared<string>(boost::any_cast<string>(m["GlobalQuestionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~DeleteGlobalQuestionRequest() = default;
};
class DeleteGlobalQuestionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteGlobalQuestionResponseBody() {}

  explicit DeleteGlobalQuestionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteGlobalQuestionResponseBody() = default;
};
class DeleteGlobalQuestionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGlobalQuestionResponseBody> body{};

  DeleteGlobalQuestionResponse() {}

  explicit DeleteGlobalQuestionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGlobalQuestionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGlobalQuestionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGlobalQuestionResponse() = default;
};
class DeleteInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DeleteInstanceRequest() {}

  explicit DeleteInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteInstanceRequest() = default;
};
class DeleteInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteInstanceResponseBody() {}

  explicit DeleteInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteInstanceResponseBody() = default;
};
class DeleteInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteInstanceResponseBody> body{};

  DeleteInstanceResponse() {}

  explicit DeleteInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInstanceResponse() = default;
};
class DeleteIntentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> intentId{};
  shared_ptr<string> scriptId{};

  DeleteIntentRequest() {}

  explicit DeleteIntentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~DeleteIntentRequest() = default;
};
class DeleteIntentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteIntentResponseBody() {}

  explicit DeleteIntentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteIntentResponseBody() = default;
};
class DeleteIntentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIntentResponseBody> body{};

  DeleteIntentResponse() {}

  explicit DeleteIntentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIntentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIntentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIntentResponse() = default;
};
class DeleteJobGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};

  DeleteJobGroupRequest() {}

  explicit DeleteJobGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
  }


  virtual ~DeleteJobGroupRequest() = default;
};
class DeleteJobGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteJobGroupResponseBody() {}

  explicit DeleteJobGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteJobGroupResponseBody() = default;
};
class DeleteJobGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteJobGroupResponseBody> body{};

  DeleteJobGroupResponse() {}

  explicit DeleteJobGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteJobGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteJobGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteJobGroupResponse() = default;
};
class DeleteOutboundCallNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> outboundCallNumberId{};

  DeleteOutboundCallNumberRequest() {}

  explicit DeleteOutboundCallNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (outboundCallNumberId) {
      res["OutboundCallNumberId"] = boost::any(*outboundCallNumberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OutboundCallNumberId") != m.end() && !m["OutboundCallNumberId"].empty()) {
      outboundCallNumberId = make_shared<string>(boost::any_cast<string>(m["OutboundCallNumberId"]));
    }
  }


  virtual ~DeleteOutboundCallNumberRequest() = default;
};
class DeleteOutboundCallNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteOutboundCallNumberResponseBody() {}

  explicit DeleteOutboundCallNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteOutboundCallNumberResponseBody() = default;
};
class DeleteOutboundCallNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteOutboundCallNumberResponseBody> body{};

  DeleteOutboundCallNumberResponse() {}

  explicit DeleteOutboundCallNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteOutboundCallNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteOutboundCallNumberResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteOutboundCallNumberResponse() = default;
};
class DeleteScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  DeleteScriptRequest() {}

  explicit DeleteScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~DeleteScriptRequest() = default;
};
class DeleteScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteScriptResponseBody() {}

  explicit DeleteScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteScriptResponseBody() = default;
};
class DeleteScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteScriptResponseBody> body{};

  DeleteScriptResponse() {}

  explicit DeleteScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteScriptResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteScriptResponse() = default;
};
class DeleteScriptRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> uuidsJson{};

  DeleteScriptRecordingRequest() {}

  explicit DeleteScriptRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (uuidsJson) {
      res["UuidsJson"] = boost::any(*uuidsJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("UuidsJson") != m.end() && !m["UuidsJson"].empty()) {
      uuidsJson = make_shared<string>(boost::any_cast<string>(m["UuidsJson"]));
    }
  }


  virtual ~DeleteScriptRecordingRequest() = default;
};
class DeleteScriptRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteScriptRecordingResponseBody() {}

  explicit DeleteScriptRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteScriptRecordingResponseBody() = default;
};
class DeleteScriptRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteScriptRecordingResponseBody> body{};

  DeleteScriptRecordingResponse() {}

  explicit DeleteScriptRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteScriptRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteScriptRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteScriptRecordingResponse() = default;
};
class DeleteScriptWaveformRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptWaveformId{};

  DeleteScriptWaveformRequest() {}

  explicit DeleteScriptWaveformRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptWaveformId) {
      res["ScriptWaveformId"] = boost::any(*scriptWaveformId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptWaveformId") != m.end() && !m["ScriptWaveformId"].empty()) {
      scriptWaveformId = make_shared<string>(boost::any_cast<string>(m["ScriptWaveformId"]));
    }
  }


  virtual ~DeleteScriptWaveformRequest() = default;
};
class DeleteScriptWaveformResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteScriptWaveformResponseBody() {}

  explicit DeleteScriptWaveformResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteScriptWaveformResponseBody() = default;
};
class DeleteScriptWaveformResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteScriptWaveformResponseBody> body{};

  DeleteScriptWaveformResponse() {}

  explicit DeleteScriptWaveformResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteScriptWaveformResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteScriptWaveformResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteScriptWaveformResponse() = default;
};
class DescribeBeebotIntentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> intentId{};
  shared_ptr<string> scriptId{};

  DescribeBeebotIntentRequest() {}

  explicit DescribeBeebotIntentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~DescribeBeebotIntentRequest() = default;
};
class DescribeBeebotIntentResponseBodyIntent : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUserId{};
  shared_ptr<string> createUserName{};
  shared_ptr<long> intentId{};
  shared_ptr<string> intentName{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> modifyUserId{};
  shared_ptr<string> modifyUserName{};

  DescribeBeebotIntentResponseBodyIntent() {}

  explicit DescribeBeebotIntentResponseBodyIntent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (createUserName) {
      res["CreateUserName"] = boost::any(*createUserName);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (intentName) {
      res["IntentName"] = boost::any(*intentName);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUserId) {
      res["ModifyUserId"] = boost::any(*modifyUserId);
    }
    if (modifyUserName) {
      res["ModifyUserName"] = boost::any(*modifyUserName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<string>(boost::any_cast<string>(m["CreateUserId"]));
    }
    if (m.find("CreateUserName") != m.end() && !m["CreateUserName"].empty()) {
      createUserName = make_shared<string>(boost::any_cast<string>(m["CreateUserName"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("IntentName") != m.end() && !m["IntentName"].empty()) {
      intentName = make_shared<string>(boost::any_cast<string>(m["IntentName"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("ModifyUserId") != m.end() && !m["ModifyUserId"].empty()) {
      modifyUserId = make_shared<string>(boost::any_cast<string>(m["ModifyUserId"]));
    }
    if (m.find("ModifyUserName") != m.end() && !m["ModifyUserName"].empty()) {
      modifyUserName = make_shared<string>(boost::any_cast<string>(m["ModifyUserName"]));
    }
  }


  virtual ~DescribeBeebotIntentResponseBodyIntent() = default;
};
class DescribeBeebotIntentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beebotRequestId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<DescribeBeebotIntentResponseBodyIntent> intent{};
  shared_ptr<long> intentId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeBeebotIntentResponseBody() {}

  explicit DescribeBeebotIntentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beebotRequestId) {
      res["BeebotRequestId"] = boost::any(*beebotRequestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (intent) {
      res["Intent"] = intent ? boost::any(intent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeebotRequestId") != m.end() && !m["BeebotRequestId"].empty()) {
      beebotRequestId = make_shared<string>(boost::any_cast<string>(m["BeebotRequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Intent") != m.end() && !m["Intent"].empty()) {
      if (typeid(map<string, boost::any>) == m["Intent"].type()) {
        DescribeBeebotIntentResponseBodyIntent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Intent"]));
        intent = make_shared<DescribeBeebotIntentResponseBodyIntent>(model1);
      }
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeBeebotIntentResponseBody() = default;
};
class DescribeBeebotIntentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBeebotIntentResponseBody> body{};

  DescribeBeebotIntentResponse() {}

  explicit DescribeBeebotIntentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBeebotIntentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBeebotIntentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBeebotIntentResponse() = default;
};
class DescribeDialogueNodeStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<long> limit{};

  DescribeDialogueNodeStatisticsRequest() {}

  explicit DescribeDialogueNodeStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
  }


  virtual ~DescribeDialogueNodeStatisticsRequest() = default;
};
class DescribeDialogueNodeStatisticsResponseBodyHangUpDialogueNodes : public Darabonba::Model {
public:
  shared_ptr<long> hangUpNum{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> rateDisplay{};

  DescribeDialogueNodeStatisticsResponseBodyHangUpDialogueNodes() {}

  explicit DescribeDialogueNodeStatisticsResponseBodyHangUpDialogueNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hangUpNum) {
      res["HangUpNum"] = boost::any(*hangUpNum);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (rateDisplay) {
      res["RateDisplay"] = boost::any(*rateDisplay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HangUpNum") != m.end() && !m["HangUpNum"].empty()) {
      hangUpNum = make_shared<long>(boost::any_cast<long>(m["HangUpNum"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("RateDisplay") != m.end() && !m["RateDisplay"].empty()) {
      rateDisplay = make_shared<string>(boost::any_cast<string>(m["RateDisplay"]));
    }
  }


  virtual ~DescribeDialogueNodeStatisticsResponseBodyHangUpDialogueNodes() = default;
};
class DescribeDialogueNodeStatisticsResponseBodyNoAnswerDialogueNodes : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<long> hangUpNum{};
  shared_ptr<long> hitNum{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> noAnswerNum{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};

  DescribeDialogueNodeStatisticsResponseBodyNoAnswerDialogueNodes() {}

  explicit DescribeDialogueNodeStatisticsResponseBodyNoAnswerDialogueNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hangUpNum) {
      res["HangUpNum"] = boost::any(*hangUpNum);
    }
    if (hitNum) {
      res["HitNum"] = boost::any(*hitNum);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (noAnswerNum) {
      res["NoAnswerNum"] = boost::any(*noAnswerNum);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HangUpNum") != m.end() && !m["HangUpNum"].empty()) {
      hangUpNum = make_shared<long>(boost::any_cast<long>(m["HangUpNum"]));
    }
    if (m.find("HitNum") != m.end() && !m["HitNum"].empty()) {
      hitNum = make_shared<long>(boost::any_cast<long>(m["HitNum"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NoAnswerNum") != m.end() && !m["NoAnswerNum"].empty()) {
      noAnswerNum = make_shared<long>(boost::any_cast<long>(m["NoAnswerNum"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
  }


  virtual ~DescribeDialogueNodeStatisticsResponseBodyNoAnswerDialogueNodes() = default;
};
class DescribeDialogueNodeStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<DescribeDialogueNodeStatisticsResponseBodyHangUpDialogueNodes>> hangUpDialogueNodes{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> message{};
  shared_ptr<vector<DescribeDialogueNodeStatisticsResponseBodyNoAnswerDialogueNodes>> noAnswerDialogueNodes{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCompleted{};

  DescribeDialogueNodeStatisticsResponseBody() {}

  explicit DescribeDialogueNodeStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hangUpDialogueNodes) {
      vector<boost::any> temp1;
      for(auto item1:*hangUpDialogueNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HangUpDialogueNodes"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (noAnswerDialogueNodes) {
      vector<boost::any> temp1;
      for(auto item1:*noAnswerDialogueNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NoAnswerDialogueNodes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCompleted) {
      res["TotalCompleted"] = boost::any(*totalCompleted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HangUpDialogueNodes") != m.end() && !m["HangUpDialogueNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["HangUpDialogueNodes"].type()) {
        vector<DescribeDialogueNodeStatisticsResponseBodyHangUpDialogueNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HangUpDialogueNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDialogueNodeStatisticsResponseBodyHangUpDialogueNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hangUpDialogueNodes = make_shared<vector<DescribeDialogueNodeStatisticsResponseBodyHangUpDialogueNodes>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NoAnswerDialogueNodes") != m.end() && !m["NoAnswerDialogueNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["NoAnswerDialogueNodes"].type()) {
        vector<DescribeDialogueNodeStatisticsResponseBodyNoAnswerDialogueNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NoAnswerDialogueNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDialogueNodeStatisticsResponseBodyNoAnswerDialogueNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        noAnswerDialogueNodes = make_shared<vector<DescribeDialogueNodeStatisticsResponseBodyNoAnswerDialogueNodes>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCompleted") != m.end() && !m["TotalCompleted"].empty()) {
      totalCompleted = make_shared<long>(boost::any_cast<long>(m["TotalCompleted"]));
    }
  }


  virtual ~DescribeDialogueNodeStatisticsResponseBody() = default;
};
class DescribeDialogueNodeStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDialogueNodeStatisticsResponseBody> body{};

  DescribeDialogueNodeStatisticsResponse() {}

  explicit DescribeDialogueNodeStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDialogueNodeStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDialogueNodeStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDialogueNodeStatisticsResponse() = default;
};
class DescribeDsReportsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};

  DescribeDsReportsRequest() {}

  explicit DescribeDsReportsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
  }


  virtual ~DescribeDsReportsRequest() = default;
};
class DescribeDsReportsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dsReports{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeDsReportsResponseBody() {}

  explicit DescribeDsReportsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dsReports) {
      res["DsReports"] = boost::any(*dsReports);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DsReports") != m.end() && !m["DsReports"].empty()) {
      dsReports = make_shared<string>(boost::any_cast<string>(m["DsReports"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeDsReportsResponseBody() = default;
};
class DescribeDsReportsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDsReportsResponseBody> body{};

  DescribeDsReportsResponse() {}

  explicit DescribeDsReportsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDsReportsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDsReportsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDsReportsResponse() = default;
};
class DescribeGlobalQuestionRequest : public Darabonba::Model {
public:
  shared_ptr<string> globalQuestionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  DescribeGlobalQuestionRequest() {}

  explicit DescribeGlobalQuestionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalQuestionId) {
      res["GlobalQuestionId"] = boost::any(*globalQuestionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalQuestionId") != m.end() && !m["GlobalQuestionId"].empty()) {
      globalQuestionId = make_shared<string>(boost::any_cast<string>(m["GlobalQuestionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~DescribeGlobalQuestionRequest() = default;
};
class DescribeGlobalQuestionResponseBodyGlobalQuestion : public Darabonba::Model {
public:
  shared_ptr<string> answers{};
  shared_ptr<string> globalQuestionId{};
  shared_ptr<string> globalQuestionName{};
  shared_ptr<string> globalQuestionType{};
  shared_ptr<string> questions{};
  shared_ptr<string> scriptId{};

  DescribeGlobalQuestionResponseBodyGlobalQuestion() {}

  explicit DescribeGlobalQuestionResponseBodyGlobalQuestion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answers) {
      res["Answers"] = boost::any(*answers);
    }
    if (globalQuestionId) {
      res["GlobalQuestionId"] = boost::any(*globalQuestionId);
    }
    if (globalQuestionName) {
      res["GlobalQuestionName"] = boost::any(*globalQuestionName);
    }
    if (globalQuestionType) {
      res["GlobalQuestionType"] = boost::any(*globalQuestionType);
    }
    if (questions) {
      res["Questions"] = boost::any(*questions);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Answers") != m.end() && !m["Answers"].empty()) {
      answers = make_shared<string>(boost::any_cast<string>(m["Answers"]));
    }
    if (m.find("GlobalQuestionId") != m.end() && !m["GlobalQuestionId"].empty()) {
      globalQuestionId = make_shared<string>(boost::any_cast<string>(m["GlobalQuestionId"]));
    }
    if (m.find("GlobalQuestionName") != m.end() && !m["GlobalQuestionName"].empty()) {
      globalQuestionName = make_shared<string>(boost::any_cast<string>(m["GlobalQuestionName"]));
    }
    if (m.find("GlobalQuestionType") != m.end() && !m["GlobalQuestionType"].empty()) {
      globalQuestionType = make_shared<string>(boost::any_cast<string>(m["GlobalQuestionType"]));
    }
    if (m.find("Questions") != m.end() && !m["Questions"].empty()) {
      questions = make_shared<string>(boost::any_cast<string>(m["Questions"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~DescribeGlobalQuestionResponseBodyGlobalQuestion() = default;
};
class DescribeGlobalQuestionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeGlobalQuestionResponseBodyGlobalQuestion> globalQuestion{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeGlobalQuestionResponseBody() {}

  explicit DescribeGlobalQuestionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (globalQuestion) {
      res["GlobalQuestion"] = globalQuestion ? boost::any(globalQuestion->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("GlobalQuestion") != m.end() && !m["GlobalQuestion"].empty()) {
      if (typeid(map<string, boost::any>) == m["GlobalQuestion"].type()) {
        DescribeGlobalQuestionResponseBodyGlobalQuestion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GlobalQuestion"]));
        globalQuestion = make_shared<DescribeGlobalQuestionResponseBodyGlobalQuestion>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeGlobalQuestionResponseBody() = default;
};
class DescribeGlobalQuestionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGlobalQuestionResponseBody> body{};

  DescribeGlobalQuestionResponse() {}

  explicit DescribeGlobalQuestionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGlobalQuestionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGlobalQuestionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGlobalQuestionResponse() = default;
};
class DescribeGroupExecutingInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};

  DescribeGroupExecutingInfoRequest() {}

  explicit DescribeGroupExecutingInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
  }


  virtual ~DescribeGroupExecutingInfoRequest() = default;
};
class DescribeGroupExecutingInfoResponseBodyExecutingInfoJobsProgress : public Darabonba::Model {
public:
  shared_ptr<long> cancelledNum{};
  shared_ptr<long> executingNum{};
  shared_ptr<long> failedNum{};
  shared_ptr<long> pausedNum{};
  shared_ptr<long> schedulingNum{};
  shared_ptr<long> totalCompletedNum{};
  shared_ptr<long> totalJobs{};
  shared_ptr<long> totalNotAnsweredNum{};

  DescribeGroupExecutingInfoResponseBodyExecutingInfoJobsProgress() {}

  explicit DescribeGroupExecutingInfoResponseBodyExecutingInfoJobsProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelledNum) {
      res["CancelledNum"] = boost::any(*cancelledNum);
    }
    if (executingNum) {
      res["ExecutingNum"] = boost::any(*executingNum);
    }
    if (failedNum) {
      res["FailedNum"] = boost::any(*failedNum);
    }
    if (pausedNum) {
      res["PausedNum"] = boost::any(*pausedNum);
    }
    if (schedulingNum) {
      res["SchedulingNum"] = boost::any(*schedulingNum);
    }
    if (totalCompletedNum) {
      res["TotalCompletedNum"] = boost::any(*totalCompletedNum);
    }
    if (totalJobs) {
      res["TotalJobs"] = boost::any(*totalJobs);
    }
    if (totalNotAnsweredNum) {
      res["TotalNotAnsweredNum"] = boost::any(*totalNotAnsweredNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CancelledNum") != m.end() && !m["CancelledNum"].empty()) {
      cancelledNum = make_shared<long>(boost::any_cast<long>(m["CancelledNum"]));
    }
    if (m.find("ExecutingNum") != m.end() && !m["ExecutingNum"].empty()) {
      executingNum = make_shared<long>(boost::any_cast<long>(m["ExecutingNum"]));
    }
    if (m.find("FailedNum") != m.end() && !m["FailedNum"].empty()) {
      failedNum = make_shared<long>(boost::any_cast<long>(m["FailedNum"]));
    }
    if (m.find("PausedNum") != m.end() && !m["PausedNum"].empty()) {
      pausedNum = make_shared<long>(boost::any_cast<long>(m["PausedNum"]));
    }
    if (m.find("SchedulingNum") != m.end() && !m["SchedulingNum"].empty()) {
      schedulingNum = make_shared<long>(boost::any_cast<long>(m["SchedulingNum"]));
    }
    if (m.find("TotalCompletedNum") != m.end() && !m["TotalCompletedNum"].empty()) {
      totalCompletedNum = make_shared<long>(boost::any_cast<long>(m["TotalCompletedNum"]));
    }
    if (m.find("TotalJobs") != m.end() && !m["TotalJobs"].empty()) {
      totalJobs = make_shared<long>(boost::any_cast<long>(m["TotalJobs"]));
    }
    if (m.find("TotalNotAnsweredNum") != m.end() && !m["TotalNotAnsweredNum"].empty()) {
      totalNotAnsweredNum = make_shared<long>(boost::any_cast<long>(m["TotalNotAnsweredNum"]));
    }
  }


  virtual ~DescribeGroupExecutingInfoResponseBodyExecutingInfoJobsProgress() = default;
};
class DescribeGroupExecutingInfoResponseBodyExecutingInfo : public Darabonba::Model {
public:
  shared_ptr<long> callFailedNum{};
  shared_ptr<long> callNum{};
  shared_ptr<string> creatorName{};
  shared_ptr<long> endTime{};
  shared_ptr<long> finishedNum{};
  shared_ptr<long> hangUpByClientNum{};
  shared_ptr<DescribeGroupExecutingInfoResponseBodyExecutingInfoJobsProgress> jobsProgress{};
  shared_ptr<long> noInteractionNum{};
  shared_ptr<long> startTime{};
  shared_ptr<long> transferByIntentNum{};
  shared_ptr<long> transferByNoAnswer{};

  DescribeGroupExecutingInfoResponseBodyExecutingInfo() {}

  explicit DescribeGroupExecutingInfoResponseBodyExecutingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callFailedNum) {
      res["CallFailedNum"] = boost::any(*callFailedNum);
    }
    if (callNum) {
      res["CallNum"] = boost::any(*callNum);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (finishedNum) {
      res["FinishedNum"] = boost::any(*finishedNum);
    }
    if (hangUpByClientNum) {
      res["HangUpByClientNum"] = boost::any(*hangUpByClientNum);
    }
    if (jobsProgress) {
      res["JobsProgress"] = jobsProgress ? boost::any(jobsProgress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (noInteractionNum) {
      res["NoInteractionNum"] = boost::any(*noInteractionNum);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (transferByIntentNum) {
      res["TransferByIntentNum"] = boost::any(*transferByIntentNum);
    }
    if (transferByNoAnswer) {
      res["TransferByNoAnswer"] = boost::any(*transferByNoAnswer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallFailedNum") != m.end() && !m["CallFailedNum"].empty()) {
      callFailedNum = make_shared<long>(boost::any_cast<long>(m["CallFailedNum"]));
    }
    if (m.find("CallNum") != m.end() && !m["CallNum"].empty()) {
      callNum = make_shared<long>(boost::any_cast<long>(m["CallNum"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FinishedNum") != m.end() && !m["FinishedNum"].empty()) {
      finishedNum = make_shared<long>(boost::any_cast<long>(m["FinishedNum"]));
    }
    if (m.find("HangUpByClientNum") != m.end() && !m["HangUpByClientNum"].empty()) {
      hangUpByClientNum = make_shared<long>(boost::any_cast<long>(m["HangUpByClientNum"]));
    }
    if (m.find("JobsProgress") != m.end() && !m["JobsProgress"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobsProgress"].type()) {
        DescribeGroupExecutingInfoResponseBodyExecutingInfoJobsProgress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobsProgress"]));
        jobsProgress = make_shared<DescribeGroupExecutingInfoResponseBodyExecutingInfoJobsProgress>(model1);
      }
    }
    if (m.find("NoInteractionNum") != m.end() && !m["NoInteractionNum"].empty()) {
      noInteractionNum = make_shared<long>(boost::any_cast<long>(m["NoInteractionNum"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TransferByIntentNum") != m.end() && !m["TransferByIntentNum"].empty()) {
      transferByIntentNum = make_shared<long>(boost::any_cast<long>(m["TransferByIntentNum"]));
    }
    if (m.find("TransferByNoAnswer") != m.end() && !m["TransferByNoAnswer"].empty()) {
      transferByNoAnswer = make_shared<long>(boost::any_cast<long>(m["TransferByNoAnswer"]));
    }
  }


  virtual ~DescribeGroupExecutingInfoResponseBodyExecutingInfo() = default;
};
class DescribeGroupExecutingInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeGroupExecutingInfoResponseBodyExecutingInfo> executingInfo{};
  shared_ptr<string> groupId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeGroupExecutingInfoResponseBody() {}

  explicit DescribeGroupExecutingInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (executingInfo) {
      res["ExecutingInfo"] = executingInfo ? boost::any(executingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExecutingInfo") != m.end() && !m["ExecutingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExecutingInfo"].type()) {
        DescribeGroupExecutingInfoResponseBodyExecutingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExecutingInfo"]));
        executingInfo = make_shared<DescribeGroupExecutingInfoResponseBodyExecutingInfo>(model1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeGroupExecutingInfoResponseBody() = default;
};
class DescribeGroupExecutingInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupExecutingInfoResponseBody> body{};

  DescribeGroupExecutingInfoResponse() {}

  explicit DescribeGroupExecutingInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupExecutingInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupExecutingInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupExecutingInfoResponse() = default;
};
class DescribeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeInstanceRequest() {}

  explicit DescribeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceRequest() = default;
};
class DescribeInstanceResponseBodyInstance : public Darabonba::Model {
public:
  shared_ptr<long> creationTime{};
  shared_ptr<long> creatorId{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> maxConcurrentConversation{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> resourceGroupId{};

  DescribeInstanceResponseBodyInstance() {}

  explicit DescribeInstanceResponseBodyInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (maxConcurrentConversation) {
      res["MaxConcurrentConversation"] = boost::any(*maxConcurrentConversation);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["CreatorId"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("MaxConcurrentConversation") != m.end() && !m["MaxConcurrentConversation"].empty()) {
      maxConcurrentConversation = make_shared<long>(boost::any_cast<long>(m["MaxConcurrentConversation"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstance() = default;
};
class DescribeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<DescribeInstanceResponseBodyInstance> instance{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeInstanceResponseBody() {}

  explicit DescribeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        DescribeInstanceResponseBodyInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<DescribeInstanceResponseBodyInstance>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeInstanceResponseBody() = default;
};
class DescribeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceResponseBody> body{};

  DescribeInstanceResponse() {}

  explicit DescribeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceResponse() = default;
};
class DescribeIntentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> intentId{};
  shared_ptr<string> scriptId{};

  DescribeIntentRequest() {}

  explicit DescribeIntentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~DescribeIntentRequest() = default;
};
class DescribeIntentResponseBodyIntent : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> intentDescription{};
  shared_ptr<string> intentId{};
  shared_ptr<string> intentName{};
  shared_ptr<string> keywords{};
  shared_ptr<string> scriptId{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> utterances{};

  DescribeIntentResponseBodyIntent() {}

  explicit DescribeIntentResponseBodyIntent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (intentDescription) {
      res["IntentDescription"] = boost::any(*intentDescription);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (intentName) {
      res["IntentName"] = boost::any(*intentName);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (utterances) {
      res["Utterances"] = boost::any(*utterances);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("IntentDescription") != m.end() && !m["IntentDescription"].empty()) {
      intentDescription = make_shared<string>(boost::any_cast<string>(m["IntentDescription"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
    if (m.find("IntentName") != m.end() && !m["IntentName"].empty()) {
      intentName = make_shared<string>(boost::any_cast<string>(m["IntentName"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywords = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Utterances") != m.end() && !m["Utterances"].empty()) {
      utterances = make_shared<string>(boost::any_cast<string>(m["Utterances"]));
    }
  }


  virtual ~DescribeIntentResponseBodyIntent() = default;
};
class DescribeIntentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<DescribeIntentResponseBodyIntent> intent{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeIntentResponseBody() {}

  explicit DescribeIntentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (intent) {
      res["Intent"] = intent ? boost::any(intent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Intent") != m.end() && !m["Intent"].empty()) {
      if (typeid(map<string, boost::any>) == m["Intent"].type()) {
        DescribeIntentResponseBodyIntent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Intent"]));
        intent = make_shared<DescribeIntentResponseBodyIntent>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeIntentResponseBody() = default;
};
class DescribeIntentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIntentResponseBody> body{};

  DescribeIntentResponse() {}

  explicit DescribeIntentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIntentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIntentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIntentResponse() = default;
};
class DescribeIntentStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<long> limit{};

  DescribeIntentStatisticsRequest() {}

  explicit DescribeIntentStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
  }


  virtual ~DescribeIntentStatisticsRequest() = default;
};
class DescribeIntentStatisticsResponseBodyGlobalIntents : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<long> hitAfterNoAnswer{};
  shared_ptr<long> hitNum{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> intentId{};
  shared_ptr<string> intentName{};
  shared_ptr<string> type{};

  DescribeIntentStatisticsResponseBodyGlobalIntents() {}

  explicit DescribeIntentStatisticsResponseBodyGlobalIntents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hitAfterNoAnswer) {
      res["HitAfterNoAnswer"] = boost::any(*hitAfterNoAnswer);
    }
    if (hitNum) {
      res["HitNum"] = boost::any(*hitNum);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (intentName) {
      res["IntentName"] = boost::any(*intentName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HitAfterNoAnswer") != m.end() && !m["HitAfterNoAnswer"].empty()) {
      hitAfterNoAnswer = make_shared<long>(boost::any_cast<long>(m["HitAfterNoAnswer"]));
    }
    if (m.find("HitNum") != m.end() && !m["HitNum"].empty()) {
      hitNum = make_shared<long>(boost::any_cast<long>(m["HitNum"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
    if (m.find("IntentName") != m.end() && !m["IntentName"].empty()) {
      intentName = make_shared<string>(boost::any_cast<string>(m["IntentName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeIntentStatisticsResponseBodyGlobalIntents() = default;
};
class DescribeIntentStatisticsResponseBodyIntentsAfterNoAnswer : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<long> hitAfterNoAnswer{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> intentId{};
  shared_ptr<string> intentName{};

  DescribeIntentStatisticsResponseBodyIntentsAfterNoAnswer() {}

  explicit DescribeIntentStatisticsResponseBodyIntentsAfterNoAnswer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hitAfterNoAnswer) {
      res["HitAfterNoAnswer"] = boost::any(*hitAfterNoAnswer);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (intentName) {
      res["IntentName"] = boost::any(*intentName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HitAfterNoAnswer") != m.end() && !m["HitAfterNoAnswer"].empty()) {
      hitAfterNoAnswer = make_shared<long>(boost::any_cast<long>(m["HitAfterNoAnswer"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
    if (m.find("IntentName") != m.end() && !m["IntentName"].empty()) {
      intentName = make_shared<string>(boost::any_cast<string>(m["IntentName"]));
    }
  }


  virtual ~DescribeIntentStatisticsResponseBodyIntentsAfterNoAnswer() = default;
};
class DescribeIntentStatisticsResponseBodyProcessIntents : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<long> hitAfterNoAnswer{};
  shared_ptr<long> hitNum{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> intentId{};
  shared_ptr<string> intentName{};
  shared_ptr<string> rateDisplay{};
  shared_ptr<string> type{};

  DescribeIntentStatisticsResponseBodyProcessIntents() {}

  explicit DescribeIntentStatisticsResponseBodyProcessIntents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hitAfterNoAnswer) {
      res["HitAfterNoAnswer"] = boost::any(*hitAfterNoAnswer);
    }
    if (hitNum) {
      res["HitNum"] = boost::any(*hitNum);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (intentName) {
      res["IntentName"] = boost::any(*intentName);
    }
    if (rateDisplay) {
      res["RateDisplay"] = boost::any(*rateDisplay);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HitAfterNoAnswer") != m.end() && !m["HitAfterNoAnswer"].empty()) {
      hitAfterNoAnswer = make_shared<long>(boost::any_cast<long>(m["HitAfterNoAnswer"]));
    }
    if (m.find("HitNum") != m.end() && !m["HitNum"].empty()) {
      hitNum = make_shared<long>(boost::any_cast<long>(m["HitNum"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
    if (m.find("IntentName") != m.end() && !m["IntentName"].empty()) {
      intentName = make_shared<string>(boost::any_cast<string>(m["IntentName"]));
    }
    if (m.find("RateDisplay") != m.end() && !m["RateDisplay"].empty()) {
      rateDisplay = make_shared<string>(boost::any_cast<string>(m["RateDisplay"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeIntentStatisticsResponseBodyProcessIntents() = default;
};
class DescribeIntentStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> globalIntentNum{};
  shared_ptr<vector<DescribeIntentStatisticsResponseBodyGlobalIntents>> globalIntents{};
  shared_ptr<string> groupId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<DescribeIntentStatisticsResponseBodyIntentsAfterNoAnswer>> intentsAfterNoAnswer{};
  shared_ptr<string> message{};
  shared_ptr<long> processIntentNum{};
  shared_ptr<vector<DescribeIntentStatisticsResponseBodyProcessIntents>> processIntents{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeIntentStatisticsResponseBody() {}

  explicit DescribeIntentStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (globalIntentNum) {
      res["GlobalIntentNum"] = boost::any(*globalIntentNum);
    }
    if (globalIntents) {
      vector<boost::any> temp1;
      for(auto item1:*globalIntents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GlobalIntents"] = boost::any(temp1);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentsAfterNoAnswer) {
      vector<boost::any> temp1;
      for(auto item1:*intentsAfterNoAnswer){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IntentsAfterNoAnswer"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (processIntentNum) {
      res["ProcessIntentNum"] = boost::any(*processIntentNum);
    }
    if (processIntents) {
      vector<boost::any> temp1;
      for(auto item1:*processIntents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProcessIntents"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("GlobalIntentNum") != m.end() && !m["GlobalIntentNum"].empty()) {
      globalIntentNum = make_shared<long>(boost::any_cast<long>(m["GlobalIntentNum"]));
    }
    if (m.find("GlobalIntents") != m.end() && !m["GlobalIntents"].empty()) {
      if (typeid(vector<boost::any>) == m["GlobalIntents"].type()) {
        vector<DescribeIntentStatisticsResponseBodyGlobalIntents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GlobalIntents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIntentStatisticsResponseBodyGlobalIntents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        globalIntents = make_shared<vector<DescribeIntentStatisticsResponseBodyGlobalIntents>>(expect1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentsAfterNoAnswer") != m.end() && !m["IntentsAfterNoAnswer"].empty()) {
      if (typeid(vector<boost::any>) == m["IntentsAfterNoAnswer"].type()) {
        vector<DescribeIntentStatisticsResponseBodyIntentsAfterNoAnswer> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IntentsAfterNoAnswer"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIntentStatisticsResponseBodyIntentsAfterNoAnswer model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        intentsAfterNoAnswer = make_shared<vector<DescribeIntentStatisticsResponseBodyIntentsAfterNoAnswer>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ProcessIntentNum") != m.end() && !m["ProcessIntentNum"].empty()) {
      processIntentNum = make_shared<long>(boost::any_cast<long>(m["ProcessIntentNum"]));
    }
    if (m.find("ProcessIntents") != m.end() && !m["ProcessIntents"].empty()) {
      if (typeid(vector<boost::any>) == m["ProcessIntents"].type()) {
        vector<DescribeIntentStatisticsResponseBodyProcessIntents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProcessIntents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIntentStatisticsResponseBodyProcessIntents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        processIntents = make_shared<vector<DescribeIntentStatisticsResponseBodyProcessIntents>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeIntentStatisticsResponseBody() = default;
};
class DescribeIntentStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIntentStatisticsResponseBody> body{};

  DescribeIntentStatisticsResponse() {}

  explicit DescribeIntentStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIntentStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIntentStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIntentStatisticsResponse() = default;
};
class DescribeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> withScript{};

  DescribeJobRequest() {}

  explicit DescribeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (withScript) {
      res["WithScript"] = boost::any(*withScript);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("WithScript") != m.end() && !m["WithScript"].empty()) {
      withScript = make_shared<bool>(boost::any_cast<bool>(m["WithScript"]));
    }
  }


  virtual ~DescribeJobRequest() = default;
};
class DescribeJobResponseBodyJobContacts : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> honorific{};
  shared_ptr<string> jobId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> role{};
  shared_ptr<string> state{};

  DescribeJobResponseBodyJobContacts() {}

  explicit DescribeJobResponseBodyJobContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeJobResponseBodyJobContacts() = default;
};
class DescribeJobResponseBodyJobExtras : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeJobResponseBodyJobExtras() {}

  explicit DescribeJobResponseBodyJobExtras(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeJobResponseBodyJobExtras() = default;
};
class DescribeJobResponseBodyJobScript : public Darabonba::Model {
public:
  shared_ptr<string> asrConfig{};
  shared_ptr<string> chatbotId{};
  shared_ptr<string> debugStatus{};
  shared_ptr<string> industry{};
  shared_ptr<bool> isDebugDrafted{};
  shared_ptr<bool> isDrafted{};
  shared_ptr<bool> miniPlaybackConfigEnabled{};
  shared_ptr<string> name{};
  shared_ptr<string> scene{};
  shared_ptr<string> scriptDescription{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> status{};
  shared_ptr<string> ttsConfig{};
  shared_ptr<long> updateTime{};

  DescribeJobResponseBodyJobScript() {}

  explicit DescribeJobResponseBodyJobScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asrConfig) {
      res["AsrConfig"] = boost::any(*asrConfig);
    }
    if (chatbotId) {
      res["ChatbotId"] = boost::any(*chatbotId);
    }
    if (debugStatus) {
      res["DebugStatus"] = boost::any(*debugStatus);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (isDebugDrafted) {
      res["IsDebugDrafted"] = boost::any(*isDebugDrafted);
    }
    if (isDrafted) {
      res["IsDrafted"] = boost::any(*isDrafted);
    }
    if (miniPlaybackConfigEnabled) {
      res["MiniPlaybackConfigEnabled"] = boost::any(*miniPlaybackConfigEnabled);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (scriptDescription) {
      res["ScriptDescription"] = boost::any(*scriptDescription);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (ttsConfig) {
      res["TtsConfig"] = boost::any(*ttsConfig);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsrConfig") != m.end() && !m["AsrConfig"].empty()) {
      asrConfig = make_shared<string>(boost::any_cast<string>(m["AsrConfig"]));
    }
    if (m.find("ChatbotId") != m.end() && !m["ChatbotId"].empty()) {
      chatbotId = make_shared<string>(boost::any_cast<string>(m["ChatbotId"]));
    }
    if (m.find("DebugStatus") != m.end() && !m["DebugStatus"].empty()) {
      debugStatus = make_shared<string>(boost::any_cast<string>(m["DebugStatus"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("IsDebugDrafted") != m.end() && !m["IsDebugDrafted"].empty()) {
      isDebugDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDebugDrafted"]));
    }
    if (m.find("IsDrafted") != m.end() && !m["IsDrafted"].empty()) {
      isDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDrafted"]));
    }
    if (m.find("MiniPlaybackConfigEnabled") != m.end() && !m["MiniPlaybackConfigEnabled"].empty()) {
      miniPlaybackConfigEnabled = make_shared<bool>(boost::any_cast<bool>(m["MiniPlaybackConfigEnabled"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("ScriptDescription") != m.end() && !m["ScriptDescription"].empty()) {
      scriptDescription = make_shared<string>(boost::any_cast<string>(m["ScriptDescription"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TtsConfig") != m.end() && !m["TtsConfig"].empty()) {
      ttsConfig = make_shared<string>(boost::any_cast<string>(m["TtsConfig"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeJobResponseBodyJobScript() = default;
};
class DescribeJobResponseBodyJobSummary : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> content{};
  shared_ptr<string> summaryName{};

  DescribeJobResponseBodyJobSummary() {}

  explicit DescribeJobResponseBodyJobSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
  }


  virtual ~DescribeJobResponseBodyJobSummary() = default;
};
class DescribeJobResponseBodyJobTasksContact : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> honorific{};
  shared_ptr<string> jobId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> role{};
  shared_ptr<string> state{};

  DescribeJobResponseBodyJobTasksContact() {}

  explicit DescribeJobResponseBodyJobTasksContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeJobResponseBodyJobTasksContact() = default;
};
class DescribeJobResponseBodyJobTasksConversationSummary : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> content{};
  shared_ptr<string> summaryName{};

  DescribeJobResponseBodyJobTasksConversationSummary() {}

  explicit DescribeJobResponseBodyJobTasksConversationSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
  }


  virtual ~DescribeJobResponseBodyJobTasksConversationSummary() = default;
};
class DescribeJobResponseBodyJobTasksConversation : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> actionParams{};
  shared_ptr<string> script{};
  shared_ptr<string> sequenceId{};
  shared_ptr<string> speaker{};
  shared_ptr<vector<DescribeJobResponseBodyJobTasksConversationSummary>> summary{};
  shared_ptr<long> timestamp{};

  DescribeJobResponseBodyJobTasksConversation() {}

  explicit DescribeJobResponseBodyJobTasksConversation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (actionParams) {
      res["ActionParams"] = boost::any(*actionParams);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (sequenceId) {
      res["SequenceId"] = boost::any(*sequenceId);
    }
    if (speaker) {
      res["Speaker"] = boost::any(*speaker);
    }
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("ActionParams") != m.end() && !m["ActionParams"].empty()) {
      actionParams = make_shared<string>(boost::any_cast<string>(m["ActionParams"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("SequenceId") != m.end() && !m["SequenceId"].empty()) {
      sequenceId = make_shared<string>(boost::any_cast<string>(m["SequenceId"]));
    }
    if (m.find("Speaker") != m.end() && !m["Speaker"].empty()) {
      speaker = make_shared<string>(boost::any_cast<string>(m["Speaker"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<DescribeJobResponseBodyJobTasksConversationSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobResponseBodyJobTasksConversationSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<DescribeJobResponseBodyJobTasksConversationSummary>>(expect1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~DescribeJobResponseBodyJobTasksConversation() = default;
};
class DescribeJobResponseBodyJobTasks : public Darabonba::Model {
public:
  shared_ptr<long> actualTime{};
  shared_ptr<string> brief{};
  shared_ptr<string> callId{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> chatbotId{};
  shared_ptr<DescribeJobResponseBodyJobTasksContact> contact{};
  shared_ptr<vector<DescribeJobResponseBodyJobTasksConversation>> conversation{};
  shared_ptr<long> duration{};
  shared_ptr<string> endReason{};
  shared_ptr<long> endTime{};
  shared_ptr<string> hangUpDirection{};
  shared_ptr<string> jobId{};
  shared_ptr<long> planedTime{};
  shared_ptr<long> realRingingDuration{};
  shared_ptr<long> ringingDuration{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> sipCode{};
  shared_ptr<long> sipDuration{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  DescribeJobResponseBodyJobTasks() {}

  explicit DescribeJobResponseBodyJobTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualTime) {
      res["ActualTime"] = boost::any(*actualTime);
    }
    if (brief) {
      res["Brief"] = boost::any(*brief);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (chatbotId) {
      res["ChatbotId"] = boost::any(*chatbotId);
    }
    if (contact) {
      res["Contact"] = contact ? boost::any(contact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conversation) {
      vector<boost::any> temp1;
      for(auto item1:*conversation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conversation"] = boost::any(temp1);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endReason) {
      res["EndReason"] = boost::any(*endReason);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (hangUpDirection) {
      res["HangUpDirection"] = boost::any(*hangUpDirection);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (planedTime) {
      res["PlanedTime"] = boost::any(*planedTime);
    }
    if (realRingingDuration) {
      res["RealRingingDuration"] = boost::any(*realRingingDuration);
    }
    if (ringingDuration) {
      res["RingingDuration"] = boost::any(*ringingDuration);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (sipCode) {
      res["SipCode"] = boost::any(*sipCode);
    }
    if (sipDuration) {
      res["SipDuration"] = boost::any(*sipDuration);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualTime") != m.end() && !m["ActualTime"].empty()) {
      actualTime = make_shared<long>(boost::any_cast<long>(m["ActualTime"]));
    }
    if (m.find("Brief") != m.end() && !m["Brief"].empty()) {
      brief = make_shared<string>(boost::any_cast<string>(m["Brief"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("ChatbotId") != m.end() && !m["ChatbotId"].empty()) {
      chatbotId = make_shared<string>(boost::any_cast<string>(m["ChatbotId"]));
    }
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      if (typeid(map<string, boost::any>) == m["Contact"].type()) {
        DescribeJobResponseBodyJobTasksContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Contact"]));
        contact = make_shared<DescribeJobResponseBodyJobTasksContact>(model1);
      }
    }
    if (m.find("Conversation") != m.end() && !m["Conversation"].empty()) {
      if (typeid(vector<boost::any>) == m["Conversation"].type()) {
        vector<DescribeJobResponseBodyJobTasksConversation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conversation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobResponseBodyJobTasksConversation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conversation = make_shared<vector<DescribeJobResponseBodyJobTasksConversation>>(expect1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("EndReason") != m.end() && !m["EndReason"].empty()) {
      endReason = make_shared<string>(boost::any_cast<string>(m["EndReason"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("HangUpDirection") != m.end() && !m["HangUpDirection"].empty()) {
      hangUpDirection = make_shared<string>(boost::any_cast<string>(m["HangUpDirection"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("PlanedTime") != m.end() && !m["PlanedTime"].empty()) {
      planedTime = make_shared<long>(boost::any_cast<long>(m["PlanedTime"]));
    }
    if (m.find("RealRingingDuration") != m.end() && !m["RealRingingDuration"].empty()) {
      realRingingDuration = make_shared<long>(boost::any_cast<long>(m["RealRingingDuration"]));
    }
    if (m.find("RingingDuration") != m.end() && !m["RingingDuration"].empty()) {
      ringingDuration = make_shared<long>(boost::any_cast<long>(m["RingingDuration"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("SipCode") != m.end() && !m["SipCode"].empty()) {
      sipCode = make_shared<string>(boost::any_cast<string>(m["SipCode"]));
    }
    if (m.find("SipDuration") != m.end() && !m["SipDuration"].empty()) {
      sipDuration = make_shared<long>(boost::any_cast<long>(m["SipDuration"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeJobResponseBodyJobTasks() = default;
};
class DescribeJobResponseBodyJob : public Darabonba::Model {
public:
  shared_ptr<long> actualTime{};
  shared_ptr<string> calledNumber{};
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<vector<DescribeJobResponseBodyJobContacts>> contacts{};
  shared_ptr<string> dsReport{};
  shared_ptr<long> endReason{};
  shared_ptr<vector<DescribeJobResponseBodyJobExtras>> extras{};
  shared_ptr<string> failureReason{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> nextExecutionTime{};
  shared_ptr<long> priority{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<DescribeJobResponseBodyJobScript> script{};
  shared_ptr<string> status{};
  shared_ptr<string> strategyId{};
  shared_ptr<vector<DescribeJobResponseBodyJobSummary>> summary{};
  shared_ptr<long> systemPriority{};
  shared_ptr<vector<DescribeJobResponseBodyJobTasks>> tasks{};

  DescribeJobResponseBodyJob() {}

  explicit DescribeJobResponseBodyJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualTime) {
      res["ActualTime"] = boost::any(*actualTime);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (dsReport) {
      res["DsReport"] = boost::any(*dsReport);
    }
    if (endReason) {
      res["EndReason"] = boost::any(*endReason);
    }
    if (extras) {
      vector<boost::any> temp1;
      for(auto item1:*extras){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Extras"] = boost::any(temp1);
    }
    if (failureReason) {
      res["FailureReason"] = boost::any(*failureReason);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextExecutionTime) {
      res["NextExecutionTime"] = boost::any(*nextExecutionTime);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (systemPriority) {
      res["SystemPriority"] = boost::any(*systemPriority);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualTime") != m.end() && !m["ActualTime"].empty()) {
      actualTime = make_shared<long>(boost::any_cast<long>(m["ActualTime"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<DescribeJobResponseBodyJobContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobResponseBodyJobContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<DescribeJobResponseBodyJobContacts>>(expect1);
      }
    }
    if (m.find("DsReport") != m.end() && !m["DsReport"].empty()) {
      dsReport = make_shared<string>(boost::any_cast<string>(m["DsReport"]));
    }
    if (m.find("EndReason") != m.end() && !m["EndReason"].empty()) {
      endReason = make_shared<long>(boost::any_cast<long>(m["EndReason"]));
    }
    if (m.find("Extras") != m.end() && !m["Extras"].empty()) {
      if (typeid(vector<boost::any>) == m["Extras"].type()) {
        vector<DescribeJobResponseBodyJobExtras> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Extras"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobResponseBodyJobExtras model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extras = make_shared<vector<DescribeJobResponseBodyJobExtras>>(expect1);
      }
    }
    if (m.find("FailureReason") != m.end() && !m["FailureReason"].empty()) {
      failureReason = make_shared<string>(boost::any_cast<string>(m["FailureReason"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextExecutionTime") != m.end() && !m["NextExecutionTime"].empty()) {
      nextExecutionTime = make_shared<long>(boost::any_cast<long>(m["NextExecutionTime"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        DescribeJobResponseBodyJobScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<DescribeJobResponseBodyJobScript>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<DescribeJobResponseBodyJobSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobResponseBodyJobSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<DescribeJobResponseBodyJobSummary>>(expect1);
      }
    }
    if (m.find("SystemPriority") != m.end() && !m["SystemPriority"].empty()) {
      systemPriority = make_shared<long>(boost::any_cast<long>(m["SystemPriority"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<DescribeJobResponseBodyJobTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobResponseBodyJobTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<DescribeJobResponseBodyJobTasks>>(expect1);
      }
    }
  }


  virtual ~DescribeJobResponseBodyJob() = default;
};
class DescribeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<DescribeJobResponseBodyJob> job{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeJobResponseBody() {}

  explicit DescribeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        DescribeJobResponseBodyJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<DescribeJobResponseBodyJob>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeJobResponseBody() = default;
};
class DescribeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeJobResponseBody> body{};

  DescribeJobResponse() {}

  explicit DescribeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeJobResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeJobResponse() = default;
};
class DescribeJobDataParsingTaskProgressRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobDataParsingTaskId{};

  DescribeJobDataParsingTaskProgressRequest() {}

  explicit DescribeJobDataParsingTaskProgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobDataParsingTaskId) {
      res["JobDataParsingTaskId"] = boost::any(*jobDataParsingTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobDataParsingTaskId") != m.end() && !m["JobDataParsingTaskId"].empty()) {
      jobDataParsingTaskId = make_shared<string>(boost::any_cast<string>(m["JobDataParsingTaskId"]));
    }
  }


  virtual ~DescribeJobDataParsingTaskProgressRequest() = default;
};
class DescribeJobDataParsingTaskProgressResponseBodyProgress : public Darabonba::Model {
public:
  shared_ptr<string> failErrorCode{};
  shared_ptr<string> failReason{};
  shared_ptr<string> feedbackUrl{};
  shared_ptr<long> handledJobCount{};
  shared_ptr<string> status{};
  shared_ptr<long> totalJobCount{};

  DescribeJobDataParsingTaskProgressResponseBodyProgress() {}

  explicit DescribeJobDataParsingTaskProgressResponseBodyProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failErrorCode) {
      res["FailErrorCode"] = boost::any(*failErrorCode);
    }
    if (failReason) {
      res["FailReason"] = boost::any(*failReason);
    }
    if (feedbackUrl) {
      res["FeedbackUrl"] = boost::any(*feedbackUrl);
    }
    if (handledJobCount) {
      res["HandledJobCount"] = boost::any(*handledJobCount);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalJobCount) {
      res["TotalJobCount"] = boost::any(*totalJobCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailErrorCode") != m.end() && !m["FailErrorCode"].empty()) {
      failErrorCode = make_shared<string>(boost::any_cast<string>(m["FailErrorCode"]));
    }
    if (m.find("FailReason") != m.end() && !m["FailReason"].empty()) {
      failReason = make_shared<string>(boost::any_cast<string>(m["FailReason"]));
    }
    if (m.find("FeedbackUrl") != m.end() && !m["FeedbackUrl"].empty()) {
      feedbackUrl = make_shared<string>(boost::any_cast<string>(m["FeedbackUrl"]));
    }
    if (m.find("HandledJobCount") != m.end() && !m["HandledJobCount"].empty()) {
      handledJobCount = make_shared<long>(boost::any_cast<long>(m["HandledJobCount"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalJobCount") != m.end() && !m["TotalJobCount"].empty()) {
      totalJobCount = make_shared<long>(boost::any_cast<long>(m["TotalJobCount"]));
    }
  }


  virtual ~DescribeJobDataParsingTaskProgressResponseBodyProgress() = default;
};
class DescribeJobDataParsingTaskProgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<DescribeJobDataParsingTaskProgressResponseBodyProgress> progress{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeJobDataParsingTaskProgressResponseBody() {}

  explicit DescribeJobDataParsingTaskProgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (progress) {
      res["Progress"] = progress ? boost::any(progress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      if (typeid(map<string, boost::any>) == m["Progress"].type()) {
        DescribeJobDataParsingTaskProgressResponseBodyProgress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Progress"]));
        progress = make_shared<DescribeJobDataParsingTaskProgressResponseBodyProgress>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeJobDataParsingTaskProgressResponseBody() = default;
};
class DescribeJobDataParsingTaskProgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeJobDataParsingTaskProgressResponseBody> body{};

  DescribeJobDataParsingTaskProgressResponse() {}

  explicit DescribeJobDataParsingTaskProgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeJobDataParsingTaskProgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeJobDataParsingTaskProgressResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeJobDataParsingTaskProgressResponse() = default;
};
class DescribeJobGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> briefTypes{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};

  DescribeJobGroupRequest() {}

  explicit DescribeJobGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (briefTypes) {
      res["BriefTypes"] = boost::any(*briefTypes);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BriefTypes") != m.end() && !m["BriefTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BriefTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BriefTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      briefTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
  }


  virtual ~DescribeJobGroupRequest() = default;
};
class DescribeJobGroupResponseBodyJobGroupExportProgress : public Darabonba::Model {
public:
  shared_ptr<string> fileHttpUrl{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeJobGroupResponseBodyJobGroupExportProgress() {}

  explicit DescribeJobGroupResponseBodyJobGroupExportProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileHttpUrl) {
      res["FileHttpUrl"] = boost::any(*fileHttpUrl);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileHttpUrl") != m.end() && !m["FileHttpUrl"].empty()) {
      fileHttpUrl = make_shared<string>(boost::any_cast<string>(m["FileHttpUrl"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeJobGroupResponseBodyJobGroupExportProgress() = default;
};
class DescribeJobGroupResponseBodyJobGroupFlashSmsExtras : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> templateId{};

  DescribeJobGroupResponseBodyJobGroupFlashSmsExtras() {}

  explicit DescribeJobGroupResponseBodyJobGroupFlashSmsExtras(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DescribeJobGroupResponseBodyJobGroupFlashSmsExtras() = default;
};
class DescribeJobGroupResponseBodyJobGroupProgressBriefs : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeJobGroupResponseBodyJobGroupProgressBriefs() {}

  explicit DescribeJobGroupResponseBodyJobGroupProgressBriefs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeJobGroupResponseBodyJobGroupProgressBriefs() = default;
};
class DescribeJobGroupResponseBodyJobGroupProgressCategories : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeJobGroupResponseBodyJobGroupProgressCategories() {}

  explicit DescribeJobGroupResponseBodyJobGroupProgressCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeJobGroupResponseBodyJobGroupProgressCategories() = default;
};
class DescribeJobGroupResponseBodyJobGroupProgress : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeJobGroupResponseBodyJobGroupProgressBriefs>> briefs{};
  shared_ptr<long> cancelled{};
  shared_ptr<vector<DescribeJobGroupResponseBodyJobGroupProgressCategories>> categories{};
  shared_ptr<long> duration{};
  shared_ptr<long> executing{};
  shared_ptr<long> failed{};
  shared_ptr<long> paused{};
  shared_ptr<long> scheduling{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<long> totalCompleted{};
  shared_ptr<long> totalJobs{};
  shared_ptr<long> totalNotAnswered{};

  DescribeJobGroupResponseBodyJobGroupProgress() {}

  explicit DescribeJobGroupResponseBodyJobGroupProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (briefs) {
      vector<boost::any> temp1;
      for(auto item1:*briefs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Briefs"] = boost::any(temp1);
    }
    if (cancelled) {
      res["Cancelled"] = boost::any(*cancelled);
    }
    if (categories) {
      vector<boost::any> temp1;
      for(auto item1:*categories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Categories"] = boost::any(temp1);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (executing) {
      res["Executing"] = boost::any(*executing);
    }
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (paused) {
      res["Paused"] = boost::any(*paused);
    }
    if (scheduling) {
      res["Scheduling"] = boost::any(*scheduling);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalCompleted) {
      res["TotalCompleted"] = boost::any(*totalCompleted);
    }
    if (totalJobs) {
      res["TotalJobs"] = boost::any(*totalJobs);
    }
    if (totalNotAnswered) {
      res["TotalNotAnswered"] = boost::any(*totalNotAnswered);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Briefs") != m.end() && !m["Briefs"].empty()) {
      if (typeid(vector<boost::any>) == m["Briefs"].type()) {
        vector<DescribeJobGroupResponseBodyJobGroupProgressBriefs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Briefs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobGroupResponseBodyJobGroupProgressBriefs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        briefs = make_shared<vector<DescribeJobGroupResponseBodyJobGroupProgressBriefs>>(expect1);
      }
    }
    if (m.find("Cancelled") != m.end() && !m["Cancelled"].empty()) {
      cancelled = make_shared<long>(boost::any_cast<long>(m["Cancelled"]));
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<DescribeJobGroupResponseBodyJobGroupProgressCategories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Categories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobGroupResponseBodyJobGroupProgressCategories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        categories = make_shared<vector<DescribeJobGroupResponseBodyJobGroupProgressCategories>>(expect1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Executing") != m.end() && !m["Executing"].empty()) {
      executing = make_shared<long>(boost::any_cast<long>(m["Executing"]));
    }
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Paused") != m.end() && !m["Paused"].empty()) {
      paused = make_shared<long>(boost::any_cast<long>(m["Paused"]));
    }
    if (m.find("Scheduling") != m.end() && !m["Scheduling"].empty()) {
      scheduling = make_shared<long>(boost::any_cast<long>(m["Scheduling"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalCompleted") != m.end() && !m["TotalCompleted"].empty()) {
      totalCompleted = make_shared<long>(boost::any_cast<long>(m["TotalCompleted"]));
    }
    if (m.find("TotalJobs") != m.end() && !m["TotalJobs"].empty()) {
      totalJobs = make_shared<long>(boost::any_cast<long>(m["TotalJobs"]));
    }
    if (m.find("TotalNotAnswered") != m.end() && !m["TotalNotAnswered"].empty()) {
      totalNotAnswered = make_shared<long>(boost::any_cast<long>(m["TotalNotAnswered"]));
    }
  }


  virtual ~DescribeJobGroupResponseBodyJobGroupProgress() = default;
};
class DescribeJobGroupResponseBodyJobGroupRecallStrategy : public Darabonba::Model {
public:
  shared_ptr<bool> emptyNumberIgnore{};
  shared_ptr<bool> inArrearsIgnore{};
  shared_ptr<bool> outOfServiceIgnore{};

  DescribeJobGroupResponseBodyJobGroupRecallStrategy() {}

  explicit DescribeJobGroupResponseBodyJobGroupRecallStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emptyNumberIgnore) {
      res["EmptyNumberIgnore"] = boost::any(*emptyNumberIgnore);
    }
    if (inArrearsIgnore) {
      res["InArrearsIgnore"] = boost::any(*inArrearsIgnore);
    }
    if (outOfServiceIgnore) {
      res["OutOfServiceIgnore"] = boost::any(*outOfServiceIgnore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmptyNumberIgnore") != m.end() && !m["EmptyNumberIgnore"].empty()) {
      emptyNumberIgnore = make_shared<bool>(boost::any_cast<bool>(m["EmptyNumberIgnore"]));
    }
    if (m.find("InArrearsIgnore") != m.end() && !m["InArrearsIgnore"].empty()) {
      inArrearsIgnore = make_shared<bool>(boost::any_cast<bool>(m["InArrearsIgnore"]));
    }
    if (m.find("OutOfServiceIgnore") != m.end() && !m["OutOfServiceIgnore"].empty()) {
      outOfServiceIgnore = make_shared<bool>(boost::any_cast<bool>(m["OutOfServiceIgnore"]));
    }
  }


  virtual ~DescribeJobGroupResponseBodyJobGroupRecallStrategy() = default;
};
class DescribeJobGroupResponseBodyJobGroupResult : public Darabonba::Model {
public:
  shared_ptr<long> clientHangupNum{};
  shared_ptr<long> finishedNum{};
  shared_ptr<long> noInteractNum{};
  shared_ptr<long> timeoutHangupNum{};
  shared_ptr<long> unrecognizedNum{};

  DescribeJobGroupResponseBodyJobGroupResult() {}

  explicit DescribeJobGroupResponseBodyJobGroupResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientHangupNum) {
      res["ClientHangupNum"] = boost::any(*clientHangupNum);
    }
    if (finishedNum) {
      res["FinishedNum"] = boost::any(*finishedNum);
    }
    if (noInteractNum) {
      res["NoInteractNum"] = boost::any(*noInteractNum);
    }
    if (timeoutHangupNum) {
      res["TimeoutHangupNum"] = boost::any(*timeoutHangupNum);
    }
    if (unrecognizedNum) {
      res["UnrecognizedNum"] = boost::any(*unrecognizedNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientHangupNum") != m.end() && !m["ClientHangupNum"].empty()) {
      clientHangupNum = make_shared<long>(boost::any_cast<long>(m["ClientHangupNum"]));
    }
    if (m.find("FinishedNum") != m.end() && !m["FinishedNum"].empty()) {
      finishedNum = make_shared<long>(boost::any_cast<long>(m["FinishedNum"]));
    }
    if (m.find("NoInteractNum") != m.end() && !m["NoInteractNum"].empty()) {
      noInteractNum = make_shared<long>(boost::any_cast<long>(m["NoInteractNum"]));
    }
    if (m.find("TimeoutHangupNum") != m.end() && !m["TimeoutHangupNum"].empty()) {
      timeoutHangupNum = make_shared<long>(boost::any_cast<long>(m["TimeoutHangupNum"]));
    }
    if (m.find("UnrecognizedNum") != m.end() && !m["UnrecognizedNum"].empty()) {
      unrecognizedNum = make_shared<long>(boost::any_cast<long>(m["UnrecognizedNum"]));
    }
  }


  virtual ~DescribeJobGroupResponseBodyJobGroupResult() = default;
};
class DescribeJobGroupResponseBodyJobGroupStrategyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> beginTime{};
  shared_ptr<string> endTime{};

  DescribeJobGroupResponseBodyJobGroupStrategyWorkingTime() {}

  explicit DescribeJobGroupResponseBodyJobGroupStrategyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeJobGroupResponseBodyJobGroupStrategyWorkingTime() = default;
};
class DescribeJobGroupResponseBodyJobGroupStrategy : public Darabonba::Model {
public:
  shared_ptr<string> customized{};
  shared_ptr<long> endTime{};
  shared_ptr<string> followUpStrategy{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> repeatBy{};
  shared_ptr<vector<string>> repeatDays{};
  shared_ptr<bool> repeatable{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<long> startTime{};
  shared_ptr<string> strategyDescription{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> strategyName{};
  shared_ptr<string> type{};
  shared_ptr<vector<DescribeJobGroupResponseBodyJobGroupStrategyWorkingTime>> workingTime{};

  DescribeJobGroupResponseBodyJobGroupStrategy() {}

  explicit DescribeJobGroupResponseBodyJobGroupStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (followUpStrategy) {
      res["FollowUpStrategy"] = boost::any(*followUpStrategy);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (repeatBy) {
      res["RepeatBy"] = boost::any(*repeatBy);
    }
    if (repeatDays) {
      res["RepeatDays"] = boost::any(*repeatDays);
    }
    if (repeatable) {
      res["Repeatable"] = boost::any(*repeatable);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (strategyDescription) {
      res["StrategyDescription"] = boost::any(*strategyDescription);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<string>(boost::any_cast<string>(m["Customized"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FollowUpStrategy") != m.end() && !m["FollowUpStrategy"].empty()) {
      followUpStrategy = make_shared<string>(boost::any_cast<string>(m["FollowUpStrategy"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("RepeatBy") != m.end() && !m["RepeatBy"].empty()) {
      repeatBy = make_shared<string>(boost::any_cast<string>(m["RepeatBy"]));
    }
    if (m.find("RepeatDays") != m.end() && !m["RepeatDays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Repeatable") != m.end() && !m["Repeatable"].empty()) {
      repeatable = make_shared<bool>(boost::any_cast<bool>(m["Repeatable"]));
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StrategyDescription") != m.end() && !m["StrategyDescription"].empty()) {
      strategyDescription = make_shared<string>(boost::any_cast<string>(m["StrategyDescription"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<DescribeJobGroupResponseBodyJobGroupStrategyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobGroupResponseBodyJobGroupStrategyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<DescribeJobGroupResponseBodyJobGroupStrategyWorkingTime>>(expect1);
      }
    }
  }


  virtual ~DescribeJobGroupResponseBodyJobGroupStrategy() = default;
};
class DescribeJobGroupResponseBodyJobGroup : public Darabonba::Model {
public:
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<long> creationTime{};
  shared_ptr<DescribeJobGroupResponseBodyJobGroupExportProgress> exportProgress{};
  shared_ptr<DescribeJobGroupResponseBodyJobGroupFlashSmsExtras> flashSmsExtras{};
  shared_ptr<string> jobDataParsingTaskId{};
  shared_ptr<string> jobFilePath{};
  shared_ptr<string> jobGroupDescription{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobGroupName{};
  shared_ptr<long> minConcurrency{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> priority{};
  shared_ptr<DescribeJobGroupResponseBodyJobGroupProgress> progress{};
  shared_ptr<vector<string>> recallCallingNumbers{};
  shared_ptr<DescribeJobGroupResponseBodyJobGroupRecallStrategy> recallStrategy{};
  shared_ptr<DescribeJobGroupResponseBodyJobGroupResult> result{};
  shared_ptr<long> ringingDuration{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> scriptVersion{};
  shared_ptr<string> status{};
  shared_ptr<DescribeJobGroupResponseBodyJobGroupStrategy> strategy{};

  DescribeJobGroupResponseBodyJobGroup() {}

  explicit DescribeJobGroupResponseBodyJobGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (exportProgress) {
      res["ExportProgress"] = exportProgress ? boost::any(exportProgress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flashSmsExtras) {
      res["FlashSmsExtras"] = flashSmsExtras ? boost::any(flashSmsExtras->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobDataParsingTaskId) {
      res["JobDataParsingTaskId"] = boost::any(*jobDataParsingTaskId);
    }
    if (jobFilePath) {
      res["JobFilePath"] = boost::any(*jobFilePath);
    }
    if (jobGroupDescription) {
      res["JobGroupDescription"] = boost::any(*jobGroupDescription);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobGroupName) {
      res["JobGroupName"] = boost::any(*jobGroupName);
    }
    if (minConcurrency) {
      res["MinConcurrency"] = boost::any(*minConcurrency);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (progress) {
      res["Progress"] = progress ? boost::any(progress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recallCallingNumbers) {
      res["RecallCallingNumbers"] = boost::any(*recallCallingNumbers);
    }
    if (recallStrategy) {
      res["RecallStrategy"] = recallStrategy ? boost::any(recallStrategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ringingDuration) {
      res["RingingDuration"] = boost::any(*ringingDuration);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (scriptVersion) {
      res["ScriptVersion"] = boost::any(*scriptVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("ExportProgress") != m.end() && !m["ExportProgress"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExportProgress"].type()) {
        DescribeJobGroupResponseBodyJobGroupExportProgress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExportProgress"]));
        exportProgress = make_shared<DescribeJobGroupResponseBodyJobGroupExportProgress>(model1);
      }
    }
    if (m.find("FlashSmsExtras") != m.end() && !m["FlashSmsExtras"].empty()) {
      if (typeid(map<string, boost::any>) == m["FlashSmsExtras"].type()) {
        DescribeJobGroupResponseBodyJobGroupFlashSmsExtras model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FlashSmsExtras"]));
        flashSmsExtras = make_shared<DescribeJobGroupResponseBodyJobGroupFlashSmsExtras>(model1);
      }
    }
    if (m.find("JobDataParsingTaskId") != m.end() && !m["JobDataParsingTaskId"].empty()) {
      jobDataParsingTaskId = make_shared<string>(boost::any_cast<string>(m["JobDataParsingTaskId"]));
    }
    if (m.find("JobFilePath") != m.end() && !m["JobFilePath"].empty()) {
      jobFilePath = make_shared<string>(boost::any_cast<string>(m["JobFilePath"]));
    }
    if (m.find("JobGroupDescription") != m.end() && !m["JobGroupDescription"].empty()) {
      jobGroupDescription = make_shared<string>(boost::any_cast<string>(m["JobGroupDescription"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobGroupName") != m.end() && !m["JobGroupName"].empty()) {
      jobGroupName = make_shared<string>(boost::any_cast<string>(m["JobGroupName"]));
    }
    if (m.find("MinConcurrency") != m.end() && !m["MinConcurrency"].empty()) {
      minConcurrency = make_shared<long>(boost::any_cast<long>(m["MinConcurrency"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      if (typeid(map<string, boost::any>) == m["Progress"].type()) {
        DescribeJobGroupResponseBodyJobGroupProgress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Progress"]));
        progress = make_shared<DescribeJobGroupResponseBodyJobGroupProgress>(model1);
      }
    }
    if (m.find("RecallCallingNumbers") != m.end() && !m["RecallCallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecallCallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecallCallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recallCallingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RecallStrategy") != m.end() && !m["RecallStrategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecallStrategy"].type()) {
        DescribeJobGroupResponseBodyJobGroupRecallStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecallStrategy"]));
        recallStrategy = make_shared<DescribeJobGroupResponseBodyJobGroupRecallStrategy>(model1);
      }
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeJobGroupResponseBodyJobGroupResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeJobGroupResponseBodyJobGroupResult>(model1);
      }
    }
    if (m.find("RingingDuration") != m.end() && !m["RingingDuration"].empty()) {
      ringingDuration = make_shared<long>(boost::any_cast<long>(m["RingingDuration"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("ScriptVersion") != m.end() && !m["ScriptVersion"].empty()) {
      scriptVersion = make_shared<string>(boost::any_cast<string>(m["ScriptVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        DescribeJobGroupResponseBodyJobGroupStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<DescribeJobGroupResponseBodyJobGroupStrategy>(model1);
      }
    }
  }


  virtual ~DescribeJobGroupResponseBodyJobGroup() = default;
};
class DescribeJobGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<DescribeJobGroupResponseBodyJobGroup> jobGroup{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeJobGroupResponseBody() {}

  explicit DescribeJobGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobGroup) {
      res["JobGroup"] = jobGroup ? boost::any(jobGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("JobGroup") != m.end() && !m["JobGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobGroup"].type()) {
        DescribeJobGroupResponseBodyJobGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobGroup"]));
        jobGroup = make_shared<DescribeJobGroupResponseBodyJobGroup>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeJobGroupResponseBody() = default;
};
class DescribeJobGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeJobGroupResponseBody> body{};

  DescribeJobGroupResponse() {}

  explicit DescribeJobGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeJobGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeJobGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeJobGroupResponse() = default;
};
class DescribeJobGroupExportTaskProgressRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> taskId{};

  DescribeJobGroupExportTaskProgressRequest() {}

  explicit DescribeJobGroupExportTaskProgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeJobGroupExportTaskProgressRequest() = default;
};
class DescribeJobGroupExportTaskProgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> fileHttpUrl{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<double> progress{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeJobGroupExportTaskProgressResponseBody() {}

  explicit DescribeJobGroupExportTaskProgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (fileHttpUrl) {
      res["FileHttpUrl"] = boost::any(*fileHttpUrl);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FileHttpUrl") != m.end() && !m["FileHttpUrl"].empty()) {
      fileHttpUrl = make_shared<string>(boost::any_cast<string>(m["FileHttpUrl"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<double>(boost::any_cast<double>(m["Progress"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeJobGroupExportTaskProgressResponseBody() = default;
};
class DescribeJobGroupExportTaskProgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeJobGroupExportTaskProgressResponseBody> body{};

  DescribeJobGroupExportTaskProgressResponse() {}

  explicit DescribeJobGroupExportTaskProgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeJobGroupExportTaskProgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeJobGroupExportTaskProgressResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeJobGroupExportTaskProgressResponse() = default;
};
class DescribeNumberDistrictInfoStatusResponseBodyAppliedVersion : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> versionId{};

  DescribeNumberDistrictInfoStatusResponseBodyAppliedVersion() {}

  explicit DescribeNumberDistrictInfoStatusResponseBodyAppliedVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["FileSize"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~DescribeNumberDistrictInfoStatusResponseBodyAppliedVersion() = default;
};
class DescribeNumberDistrictInfoStatusResponseBodyParsingVersion : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<long> fileSize{};
  shared_ptr<long> parseProgress{};
  shared_ptr<string> versionId{};

  DescribeNumberDistrictInfoStatusResponseBodyParsingVersion() {}

  explicit DescribeNumberDistrictInfoStatusResponseBodyParsingVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (parseProgress) {
      res["ParseProgress"] = boost::any(*parseProgress);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["FileSize"]));
    }
    if (m.find("ParseProgress") != m.end() && !m["ParseProgress"].empty()) {
      parseProgress = make_shared<long>(boost::any_cast<long>(m["ParseProgress"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~DescribeNumberDistrictInfoStatusResponseBodyParsingVersion() = default;
};
class DescribeNumberDistrictInfoStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeNumberDistrictInfoStatusResponseBodyAppliedVersion> appliedVersion{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<DescribeNumberDistrictInfoStatusResponseBodyParsingVersion> parsingVersion{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<bool> success{};

  DescribeNumberDistrictInfoStatusResponseBody() {}

  explicit DescribeNumberDistrictInfoStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appliedVersion) {
      res["AppliedVersion"] = appliedVersion ? boost::any(appliedVersion->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (parsingVersion) {
      res["ParsingVersion"] = parsingVersion ? boost::any(parsingVersion->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppliedVersion") != m.end() && !m["AppliedVersion"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppliedVersion"].type()) {
        DescribeNumberDistrictInfoStatusResponseBodyAppliedVersion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppliedVersion"]));
        appliedVersion = make_shared<DescribeNumberDistrictInfoStatusResponseBodyAppliedVersion>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ParsingVersion") != m.end() && !m["ParsingVersion"].empty()) {
      if (typeid(map<string, boost::any>) == m["ParsingVersion"].type()) {
        DescribeNumberDistrictInfoStatusResponseBodyParsingVersion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ParsingVersion"]));
        parsingVersion = make_shared<DescribeNumberDistrictInfoStatusResponseBodyParsingVersion>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeNumberDistrictInfoStatusResponseBody() = default;
};
class DescribeNumberDistrictInfoStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNumberDistrictInfoStatusResponseBody> body{};

  DescribeNumberDistrictInfoStatusResponse() {}

  explicit DescribeNumberDistrictInfoStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNumberDistrictInfoStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNumberDistrictInfoStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNumberDistrictInfoStatusResponse() = default;
};
class DescribeScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  DescribeScriptRequest() {}

  explicit DescribeScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~DescribeScriptRequest() = default;
};
class DescribeScriptResponseBodyScriptNluProfile : public Darabonba::Model {
public:
  shared_ptr<string> fcFunction{};
  shared_ptr<string> fcHttpTriggerUrl{};
  shared_ptr<string> fcRegion{};

  DescribeScriptResponseBodyScriptNluProfile() {}

  explicit DescribeScriptResponseBodyScriptNluProfile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fcFunction) {
      res["FcFunction"] = boost::any(*fcFunction);
    }
    if (fcHttpTriggerUrl) {
      res["FcHttpTriggerUrl"] = boost::any(*fcHttpTriggerUrl);
    }
    if (fcRegion) {
      res["FcRegion"] = boost::any(*fcRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FcFunction") != m.end() && !m["FcFunction"].empty()) {
      fcFunction = make_shared<string>(boost::any_cast<string>(m["FcFunction"]));
    }
    if (m.find("FcHttpTriggerUrl") != m.end() && !m["FcHttpTriggerUrl"].empty()) {
      fcHttpTriggerUrl = make_shared<string>(boost::any_cast<string>(m["FcHttpTriggerUrl"]));
    }
    if (m.find("FcRegion") != m.end() && !m["FcRegion"].empty()) {
      fcRegion = make_shared<string>(boost::any_cast<string>(m["FcRegion"]));
    }
  }


  virtual ~DescribeScriptResponseBodyScriptNluProfile() = default;
};
class DescribeScriptResponseBodyScript : public Darabonba::Model {
public:
  shared_ptr<long> agentId{};
  shared_ptr<string> agentKey{};
  shared_ptr<bool> agentLlm{};
  shared_ptr<string> asrConfig{};
  shared_ptr<string> chatConfig{};
  shared_ptr<string> chatbotId{};
  shared_ptr<string> debugStatus{};
  shared_ptr<bool> emotionEnable{};
  shared_ptr<string> industry{};
  shared_ptr<bool> isDebugDrafted{};
  shared_ptr<bool> isDrafted{};
  shared_ptr<string> labelConfig{};
  shared_ptr<bool> longWaitEnable{};
  shared_ptr<bool> miniPlaybackEnable{};
  shared_ptr<bool> newBargeInEnable{};
  shared_ptr<string> nluEngine{};
  shared_ptr<DescribeScriptResponseBodyScriptNluProfile> nluProfile{};
  shared_ptr<string> scene{};
  shared_ptr<string> scriptDescription{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> status{};
  shared_ptr<string> ttsConfig{};
  shared_ptr<long> updateTime{};

  DescribeScriptResponseBodyScript() {}

  explicit DescribeScriptResponseBodyScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (agentLlm) {
      res["AgentLlm"] = boost::any(*agentLlm);
    }
    if (asrConfig) {
      res["AsrConfig"] = boost::any(*asrConfig);
    }
    if (chatConfig) {
      res["ChatConfig"] = boost::any(*chatConfig);
    }
    if (chatbotId) {
      res["ChatbotId"] = boost::any(*chatbotId);
    }
    if (debugStatus) {
      res["DebugStatus"] = boost::any(*debugStatus);
    }
    if (emotionEnable) {
      res["EmotionEnable"] = boost::any(*emotionEnable);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (isDebugDrafted) {
      res["IsDebugDrafted"] = boost::any(*isDebugDrafted);
    }
    if (isDrafted) {
      res["IsDrafted"] = boost::any(*isDrafted);
    }
    if (labelConfig) {
      res["LabelConfig"] = boost::any(*labelConfig);
    }
    if (longWaitEnable) {
      res["LongWaitEnable"] = boost::any(*longWaitEnable);
    }
    if (miniPlaybackEnable) {
      res["MiniPlaybackEnable"] = boost::any(*miniPlaybackEnable);
    }
    if (newBargeInEnable) {
      res["NewBargeInEnable"] = boost::any(*newBargeInEnable);
    }
    if (nluEngine) {
      res["NluEngine"] = boost::any(*nluEngine);
    }
    if (nluProfile) {
      res["NluProfile"] = nluProfile ? boost::any(nluProfile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (scriptDescription) {
      res["ScriptDescription"] = boost::any(*scriptDescription);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (ttsConfig) {
      res["TtsConfig"] = boost::any(*ttsConfig);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<long>(boost::any_cast<long>(m["AgentId"]));
    }
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("AgentLlm") != m.end() && !m["AgentLlm"].empty()) {
      agentLlm = make_shared<bool>(boost::any_cast<bool>(m["AgentLlm"]));
    }
    if (m.find("AsrConfig") != m.end() && !m["AsrConfig"].empty()) {
      asrConfig = make_shared<string>(boost::any_cast<string>(m["AsrConfig"]));
    }
    if (m.find("ChatConfig") != m.end() && !m["ChatConfig"].empty()) {
      chatConfig = make_shared<string>(boost::any_cast<string>(m["ChatConfig"]));
    }
    if (m.find("ChatbotId") != m.end() && !m["ChatbotId"].empty()) {
      chatbotId = make_shared<string>(boost::any_cast<string>(m["ChatbotId"]));
    }
    if (m.find("DebugStatus") != m.end() && !m["DebugStatus"].empty()) {
      debugStatus = make_shared<string>(boost::any_cast<string>(m["DebugStatus"]));
    }
    if (m.find("EmotionEnable") != m.end() && !m["EmotionEnable"].empty()) {
      emotionEnable = make_shared<bool>(boost::any_cast<bool>(m["EmotionEnable"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("IsDebugDrafted") != m.end() && !m["IsDebugDrafted"].empty()) {
      isDebugDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDebugDrafted"]));
    }
    if (m.find("IsDrafted") != m.end() && !m["IsDrafted"].empty()) {
      isDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDrafted"]));
    }
    if (m.find("LabelConfig") != m.end() && !m["LabelConfig"].empty()) {
      labelConfig = make_shared<string>(boost::any_cast<string>(m["LabelConfig"]));
    }
    if (m.find("LongWaitEnable") != m.end() && !m["LongWaitEnable"].empty()) {
      longWaitEnable = make_shared<bool>(boost::any_cast<bool>(m["LongWaitEnable"]));
    }
    if (m.find("MiniPlaybackEnable") != m.end() && !m["MiniPlaybackEnable"].empty()) {
      miniPlaybackEnable = make_shared<bool>(boost::any_cast<bool>(m["MiniPlaybackEnable"]));
    }
    if (m.find("NewBargeInEnable") != m.end() && !m["NewBargeInEnable"].empty()) {
      newBargeInEnable = make_shared<bool>(boost::any_cast<bool>(m["NewBargeInEnable"]));
    }
    if (m.find("NluEngine") != m.end() && !m["NluEngine"].empty()) {
      nluEngine = make_shared<string>(boost::any_cast<string>(m["NluEngine"]));
    }
    if (m.find("NluProfile") != m.end() && !m["NluProfile"].empty()) {
      if (typeid(map<string, boost::any>) == m["NluProfile"].type()) {
        DescribeScriptResponseBodyScriptNluProfile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NluProfile"]));
        nluProfile = make_shared<DescribeScriptResponseBodyScriptNluProfile>(model1);
      }
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("ScriptDescription") != m.end() && !m["ScriptDescription"].empty()) {
      scriptDescription = make_shared<string>(boost::any_cast<string>(m["ScriptDescription"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TtsConfig") != m.end() && !m["TtsConfig"].empty()) {
      ttsConfig = make_shared<string>(boost::any_cast<string>(m["TtsConfig"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeScriptResponseBodyScript() = default;
};
class DescribeScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> nlsConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeScriptResponseBodyScript> script{};
  shared_ptr<bool> success{};

  DescribeScriptResponseBody() {}

  explicit DescribeScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nlsConfig) {
      res["NlsConfig"] = boost::any(*nlsConfig);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NlsConfig") != m.end() && !m["NlsConfig"].empty()) {
      nlsConfig = make_shared<string>(boost::any_cast<string>(m["NlsConfig"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        DescribeScriptResponseBodyScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<DescribeScriptResponseBodyScript>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeScriptResponseBody() = default;
};
class DescribeScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScriptResponseBody> body{};

  DescribeScriptResponse() {}

  explicit DescribeScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScriptResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScriptResponse() = default;
};
class DescribeScriptVoiceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptVoiceConfigId{};

  DescribeScriptVoiceConfigRequest() {}

  explicit DescribeScriptVoiceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptVoiceConfigId) {
      res["ScriptVoiceConfigId"] = boost::any(*scriptVoiceConfigId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptVoiceConfigId") != m.end() && !m["ScriptVoiceConfigId"].empty()) {
      scriptVoiceConfigId = make_shared<string>(boost::any_cast<string>(m["ScriptVoiceConfigId"]));
    }
  }


  virtual ~DescribeScriptVoiceConfigRequest() = default;
};
class DescribeScriptVoiceConfigResponseBodyScriptVoiceConfig : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptContent{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptVoiceConfigId{};
  shared_ptr<string> scriptWaveformRelation{};
  shared_ptr<string> source{};
  shared_ptr<string> type{};

  DescribeScriptVoiceConfigResponseBodyScriptVoiceConfig() {}

  explicit DescribeScriptVoiceConfigResponseBodyScriptVoiceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptContent) {
      res["ScriptContent"] = boost::any(*scriptContent);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptVoiceConfigId) {
      res["ScriptVoiceConfigId"] = boost::any(*scriptVoiceConfigId);
    }
    if (scriptWaveformRelation) {
      res["ScriptWaveformRelation"] = boost::any(*scriptWaveformRelation);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptContent") != m.end() && !m["ScriptContent"].empty()) {
      scriptContent = make_shared<string>(boost::any_cast<string>(m["ScriptContent"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptVoiceConfigId") != m.end() && !m["ScriptVoiceConfigId"].empty()) {
      scriptVoiceConfigId = make_shared<string>(boost::any_cast<string>(m["ScriptVoiceConfigId"]));
    }
    if (m.find("ScriptWaveformRelation") != m.end() && !m["ScriptWaveformRelation"].empty()) {
      scriptWaveformRelation = make_shared<string>(boost::any_cast<string>(m["ScriptWaveformRelation"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeScriptVoiceConfigResponseBodyScriptVoiceConfig() = default;
};
class DescribeScriptVoiceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeScriptVoiceConfigResponseBodyScriptVoiceConfig> scriptVoiceConfig{};
  shared_ptr<bool> success{};

  DescribeScriptVoiceConfigResponseBody() {}

  explicit DescribeScriptVoiceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scriptVoiceConfig) {
      res["ScriptVoiceConfig"] = scriptVoiceConfig ? boost::any(scriptVoiceConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScriptVoiceConfig") != m.end() && !m["ScriptVoiceConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptVoiceConfig"].type()) {
        DescribeScriptVoiceConfigResponseBodyScriptVoiceConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptVoiceConfig"]));
        scriptVoiceConfig = make_shared<DescribeScriptVoiceConfigResponseBodyScriptVoiceConfig>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeScriptVoiceConfigResponseBody() = default;
};
class DescribeScriptVoiceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScriptVoiceConfigResponseBody> body{};

  DescribeScriptVoiceConfigResponse() {}

  explicit DescribeScriptVoiceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScriptVoiceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScriptVoiceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScriptVoiceConfigResponse() = default;
};
class DescribeTTSConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  DescribeTTSConfigRequest() {}

  explicit DescribeTTSConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~DescribeTTSConfigRequest() = default;
};
class DescribeTTSConfigResponseBodyTTSConfig : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nlsServiceType{};
  shared_ptr<string> speechRate{};
  shared_ptr<string> voice{};
  shared_ptr<string> volume{};

  DescribeTTSConfigResponseBodyTTSConfig() {}

  explicit DescribeTTSConfigResponseBodyTTSConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nlsServiceType) {
      res["NlsServiceType"] = boost::any(*nlsServiceType);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NlsServiceType") != m.end() && !m["NlsServiceType"].empty()) {
      nlsServiceType = make_shared<string>(boost::any_cast<string>(m["NlsServiceType"]));
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<string>(boost::any_cast<string>(m["SpeechRate"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<string>(boost::any_cast<string>(m["Volume"]));
    }
  }


  virtual ~DescribeTTSConfigResponseBodyTTSConfig() = default;
};
class DescribeTTSConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<DescribeTTSConfigResponseBodyTTSConfig> TTSConfig{};

  DescribeTTSConfigResponseBody() {}

  explicit DescribeTTSConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (TTSConfig) {
      res["TTSConfig"] = TTSConfig ? boost::any(TTSConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TTSConfig") != m.end() && !m["TTSConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TTSConfig"].type()) {
        DescribeTTSConfigResponseBodyTTSConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TTSConfig"]));
        TTSConfig = make_shared<DescribeTTSConfigResponseBodyTTSConfig>(model1);
      }
    }
  }


  virtual ~DescribeTTSConfigResponseBody() = default;
};
class DescribeTTSConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTTSConfigResponseBody> body{};

  DescribeTTSConfigResponse() {}

  explicit DescribeTTSConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTTSConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTTSConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTTSConfigResponse() = default;
};
class DescribeTTSDemoRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> aliCustomizedVoice{};
  shared_ptr<string> appKey{};
  shared_ptr<string> engine{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nlsServiceType{};
  shared_ptr<long> pitchRate{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> secretKey{};
  shared_ptr<long> speechRate{};
  shared_ptr<string> text{};
  shared_ptr<string> voice{};
  shared_ptr<long> volume{};

  DescribeTTSDemoRequest() {}

  explicit DescribeTTSDemoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (aliCustomizedVoice) {
      res["AliCustomizedVoice"] = boost::any(*aliCustomizedVoice);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nlsServiceType) {
      res["NlsServiceType"] = boost::any(*nlsServiceType);
    }
    if (pitchRate) {
      res["PitchRate"] = boost::any(*pitchRate);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("AliCustomizedVoice") != m.end() && !m["AliCustomizedVoice"].empty()) {
      aliCustomizedVoice = make_shared<string>(boost::any_cast<string>(m["AliCustomizedVoice"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NlsServiceType") != m.end() && !m["NlsServiceType"].empty()) {
      nlsServiceType = make_shared<string>(boost::any_cast<string>(m["NlsServiceType"]));
    }
    if (m.find("PitchRate") != m.end() && !m["PitchRate"].empty()) {
      pitchRate = make_shared<long>(boost::any_cast<long>(m["PitchRate"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<long>(boost::any_cast<long>(m["SpeechRate"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
  }


  virtual ~DescribeTTSDemoRequest() = default;
};
class DescribeTTSDemoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> auditionUrl{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeTTSDemoResponseBody() {}

  explicit DescribeTTSDemoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditionUrl) {
      res["AuditionUrl"] = boost::any(*auditionUrl);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditionUrl") != m.end() && !m["AuditionUrl"].empty()) {
      auditionUrl = make_shared<string>(boost::any_cast<string>(m["AuditionUrl"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeTTSDemoResponseBody() = default;
};
class DescribeTTSDemoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTTSDemoResponseBody> body{};

  DescribeTTSDemoResponse() {}

  explicit DescribeTTSDemoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTTSDemoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTTSDemoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTTSDemoResponse() = default;
};
class DescribeTagHitsSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};

  DescribeTagHitsSummaryRequest() {}

  explicit DescribeTagHitsSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
  }


  virtual ~DescribeTagHitsSummaryRequest() = default;
};
class DescribeTagHitsSummaryResponseBodyTagGroups : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> tagGroup{};
  shared_ptr<long> tagGroupIndex{};

  DescribeTagHitsSummaryResponseBodyTagGroups() {}

  explicit DescribeTagHitsSummaryResponseBodyTagGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (tagGroup) {
      res["TagGroup"] = boost::any(*tagGroup);
    }
    if (tagGroupIndex) {
      res["TagGroupIndex"] = boost::any(*tagGroupIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("TagGroup") != m.end() && !m["TagGroup"].empty()) {
      tagGroup = make_shared<string>(boost::any_cast<string>(m["TagGroup"]));
    }
    if (m.find("TagGroupIndex") != m.end() && !m["TagGroupIndex"].empty()) {
      tagGroupIndex = make_shared<long>(boost::any_cast<long>(m["TagGroupIndex"]));
    }
  }


  virtual ~DescribeTagHitsSummaryResponseBodyTagGroups() = default;
};
class DescribeTagHitsSummaryResponseBodyTagHitsList : public Darabonba::Model {
public:
  shared_ptr<long> hitCount{};
  shared_ptr<string> tagGroup{};
  shared_ptr<string> tagName{};

  DescribeTagHitsSummaryResponseBodyTagHitsList() {}

  explicit DescribeTagHitsSummaryResponseBodyTagHitsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hitCount) {
      res["HitCount"] = boost::any(*hitCount);
    }
    if (tagGroup) {
      res["TagGroup"] = boost::any(*tagGroup);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HitCount") != m.end() && !m["HitCount"].empty()) {
      hitCount = make_shared<long>(boost::any_cast<long>(m["HitCount"]));
    }
    if (m.find("TagGroup") != m.end() && !m["TagGroup"].empty()) {
      tagGroup = make_shared<string>(boost::any_cast<string>(m["TagGroup"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~DescribeTagHitsSummaryResponseBodyTagHitsList() = default;
};
class DescribeTagHitsSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<DescribeTagHitsSummaryResponseBodyTagGroups>> tagGroups{};
  shared_ptr<vector<DescribeTagHitsSummaryResponseBodyTagHitsList>> tagHitsList{};

  DescribeTagHitsSummaryResponseBody() {}

  explicit DescribeTagHitsSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tagGroups) {
      vector<boost::any> temp1;
      for(auto item1:*tagGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagGroups"] = boost::any(temp1);
    }
    if (tagHitsList) {
      vector<boost::any> temp1;
      for(auto item1:*tagHitsList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagHitsList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TagGroups") != m.end() && !m["TagGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["TagGroups"].type()) {
        vector<DescribeTagHitsSummaryResponseBodyTagGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagHitsSummaryResponseBodyTagGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagGroups = make_shared<vector<DescribeTagHitsSummaryResponseBodyTagGroups>>(expect1);
      }
    }
    if (m.find("TagHitsList") != m.end() && !m["TagHitsList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagHitsList"].type()) {
        vector<DescribeTagHitsSummaryResponseBodyTagHitsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagHitsList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagHitsSummaryResponseBodyTagHitsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagHitsList = make_shared<vector<DescribeTagHitsSummaryResponseBodyTagHitsList>>(expect1);
      }
    }
  }


  virtual ~DescribeTagHitsSummaryResponseBody() = default;
};
class DescribeTagHitsSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagHitsSummaryResponseBody> body{};

  DescribeTagHitsSummaryResponse() {}

  explicit DescribeTagHitsSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagHitsSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagHitsSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagHitsSummaryResponse() = default;
};
class DescribeTenantBindNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> number{};

  DescribeTenantBindNumberRequest() {}

  explicit DescribeTenantBindNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
  }


  virtual ~DescribeTenantBindNumberRequest() = default;
};
class DescribeTenantBindNumberResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<bool> isBinding{};

  DescribeTenantBindNumberResponseBodyDataList() {}

  explicit DescribeTenantBindNumberResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (isBinding) {
      res["IsBinding"] = boost::any(*isBinding);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("IsBinding") != m.end() && !m["IsBinding"].empty()) {
      isBinding = make_shared<bool>(boost::any_cast<bool>(m["IsBinding"]));
    }
  }


  virtual ~DescribeTenantBindNumberResponseBodyDataList() = default;
};
class DescribeTenantBindNumberResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTenantBindNumberResponseBodyDataList>> list{};

  DescribeTenantBindNumberResponseBodyData() {}

  explicit DescribeTenantBindNumberResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeTenantBindNumberResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTenantBindNumberResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeTenantBindNumberResponseBodyDataList>>(expect1);
      }
    }
  }


  virtual ~DescribeTenantBindNumberResponseBodyData() = default;
};
class DescribeTenantBindNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeTenantBindNumberResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeTenantBindNumberResponseBody() {}

  explicit DescribeTenantBindNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeTenantBindNumberResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeTenantBindNumberResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeTenantBindNumberResponseBody() = default;
};
class DescribeTenantBindNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTenantBindNumberResponseBody> body{};

  DescribeTenantBindNumberResponse() {}

  explicit DescribeTenantBindNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTenantBindNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTenantBindNumberResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTenantBindNumberResponse() = default;
};
class DialogueRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionKey{};
  shared_ptr<string> actionParams{};
  shared_ptr<string> callId{};
  shared_ptr<string> callType{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> utterance{};

  DialogueRequest() {}

  explicit DialogueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionKey) {
      res["ActionKey"] = boost::any(*actionKey);
    }
    if (actionParams) {
      res["ActionParams"] = boost::any(*actionParams);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (utterance) {
      res["Utterance"] = boost::any(*utterance);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionKey") != m.end() && !m["ActionKey"].empty()) {
      actionKey = make_shared<string>(boost::any_cast<string>(m["ActionKey"]));
    }
    if (m.find("ActionParams") != m.end() && !m["ActionParams"].empty()) {
      actionParams = make_shared<string>(boost::any_cast<string>(m["ActionParams"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Utterance") != m.end() && !m["Utterance"].empty()) {
      utterance = make_shared<string>(boost::any_cast<string>(m["Utterance"]));
    }
  }


  virtual ~DialogueRequest() = default;
};
class DialogueResponseBodyFeedback : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> actionParams{};
  shared_ptr<string> content{};
  shared_ptr<string> contentParams{};
  shared_ptr<bool> interruptible{};

  DialogueResponseBodyFeedback() {}

  explicit DialogueResponseBodyFeedback(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (actionParams) {
      res["ActionParams"] = boost::any(*actionParams);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentParams) {
      res["ContentParams"] = boost::any(*contentParams);
    }
    if (interruptible) {
      res["Interruptible"] = boost::any(*interruptible);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("ActionParams") != m.end() && !m["ActionParams"].empty()) {
      actionParams = make_shared<string>(boost::any_cast<string>(m["ActionParams"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentParams") != m.end() && !m["ContentParams"].empty()) {
      contentParams = make_shared<string>(boost::any_cast<string>(m["ContentParams"]));
    }
    if (m.find("Interruptible") != m.end() && !m["Interruptible"].empty()) {
      interruptible = make_shared<bool>(boost::any_cast<bool>(m["Interruptible"]));
    }
  }


  virtual ~DialogueResponseBodyFeedback() = default;
};
class DialogueResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DialogueResponseBodyFeedback> feedback{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DialogueResponseBody() {}

  explicit DialogueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (feedback) {
      res["Feedback"] = feedback ? boost::any(feedback->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Feedback") != m.end() && !m["Feedback"].empty()) {
      if (typeid(map<string, boost::any>) == m["Feedback"].type()) {
        DialogueResponseBodyFeedback model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Feedback"]));
        feedback = make_shared<DialogueResponseBodyFeedback>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DialogueResponseBody() = default;
};
class DialogueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DialogueResponseBody> body{};

  DialogueResponse() {}

  explicit DialogueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DialogueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DialogueResponseBody>(model1);
      }
    }
  }


  virtual ~DialogueResponse() = default;
};
class DismissNumberDistrictInfoParsingResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> versionId{};

  DismissNumberDistrictInfoParsingResultRequest() {}

  explicit DismissNumberDistrictInfoParsingResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~DismissNumberDistrictInfoParsingResultRequest() = default;
};
class DismissNumberDistrictInfoParsingResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DismissNumberDistrictInfoParsingResultResponseBody() {}

  explicit DismissNumberDistrictInfoParsingResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DismissNumberDistrictInfoParsingResultResponseBody() = default;
};
class DismissNumberDistrictInfoParsingResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DismissNumberDistrictInfoParsingResultResponseBody> body{};

  DismissNumberDistrictInfoParsingResultResponse() {}

  explicit DismissNumberDistrictInfoParsingResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DismissNumberDistrictInfoParsingResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DismissNumberDistrictInfoParsingResultResponseBody>(model1);
      }
    }
  }


  virtual ~DismissNumberDistrictInfoParsingResultResponse() = default;
};
class DownloadRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> needVoiceSliceRecording{};
  shared_ptr<string> taskId{};

  DownloadRecordingRequest() {}

  explicit DownloadRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (needVoiceSliceRecording) {
      res["NeedVoiceSliceRecording"] = boost::any(*needVoiceSliceRecording);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NeedVoiceSliceRecording") != m.end() && !m["NeedVoiceSliceRecording"].empty()) {
      needVoiceSliceRecording = make_shared<bool>(boost::any_cast<bool>(m["NeedVoiceSliceRecording"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DownloadRecordingRequest() = default;
};
class DownloadRecordingResponseBodyDownloadParams : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> signatureUrl{};
  shared_ptr<string> voiceSliceRecordingListJson{};

  DownloadRecordingResponseBodyDownloadParams() {}

  explicit DownloadRecordingResponseBodyDownloadParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (signatureUrl) {
      res["SignatureUrl"] = boost::any(*signatureUrl);
    }
    if (voiceSliceRecordingListJson) {
      res["VoiceSliceRecordingListJson"] = boost::any(*voiceSliceRecordingListJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("SignatureUrl") != m.end() && !m["SignatureUrl"].empty()) {
      signatureUrl = make_shared<string>(boost::any_cast<string>(m["SignatureUrl"]));
    }
    if (m.find("VoiceSliceRecordingListJson") != m.end() && !m["VoiceSliceRecordingListJson"].empty()) {
      voiceSliceRecordingListJson = make_shared<string>(boost::any_cast<string>(m["VoiceSliceRecordingListJson"]));
    }
  }


  virtual ~DownloadRecordingResponseBodyDownloadParams() = default;
};
class DownloadRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DownloadRecordingResponseBodyDownloadParams> downloadParams{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DownloadRecordingResponseBody() {}

  explicit DownloadRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (downloadParams) {
      res["DownloadParams"] = downloadParams ? boost::any(downloadParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DownloadParams") != m.end() && !m["DownloadParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadParams"].type()) {
        DownloadRecordingResponseBodyDownloadParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadParams"]));
        downloadParams = make_shared<DownloadRecordingResponseBodyDownloadParams>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DownloadRecordingResponseBody() = default;
};
class DownloadRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadRecordingResponseBody> body{};

  DownloadRecordingResponse() {}

  explicit DownloadRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadRecordingResponse() = default;
};
class DownloadScriptRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> uuid{};

  DownloadScriptRecordingRequest() {}

  explicit DownloadScriptRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DownloadScriptRecordingRequest() = default;
};
class DownloadScriptRecordingResponseBodyDownloadParams : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> signatureUrl{};

  DownloadScriptRecordingResponseBodyDownloadParams() {}

  explicit DownloadScriptRecordingResponseBodyDownloadParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (signatureUrl) {
      res["SignatureUrl"] = boost::any(*signatureUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("SignatureUrl") != m.end() && !m["SignatureUrl"].empty()) {
      signatureUrl = make_shared<string>(boost::any_cast<string>(m["SignatureUrl"]));
    }
  }


  virtual ~DownloadScriptRecordingResponseBodyDownloadParams() = default;
};
class DownloadScriptRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DownloadScriptRecordingResponseBodyDownloadParams> downloadParams{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DownloadScriptRecordingResponseBody() {}

  explicit DownloadScriptRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (downloadParams) {
      res["DownloadParams"] = downloadParams ? boost::any(downloadParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DownloadParams") != m.end() && !m["DownloadParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadParams"].type()) {
        DownloadScriptRecordingResponseBodyDownloadParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadParams"]));
        downloadParams = make_shared<DownloadScriptRecordingResponseBodyDownloadParams>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DownloadScriptRecordingResponseBody() = default;
};
class DownloadScriptRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadScriptRecordingResponseBody> body{};

  DownloadScriptRecordingResponse() {}

  explicit DownloadScriptRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadScriptRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadScriptRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadScriptRecordingResponse() = default;
};
class DuplicateScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceScriptId{};

  DuplicateScriptRequest() {}

  explicit DuplicateScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sourceScriptId) {
      res["SourceScriptId"] = boost::any(*sourceScriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SourceScriptId") != m.end() && !m["SourceScriptId"].empty()) {
      sourceScriptId = make_shared<string>(boost::any_cast<string>(m["SourceScriptId"]));
    }
  }


  virtual ~DuplicateScriptRequest() = default;
};
class DuplicateScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scriptId{};
  shared_ptr<bool> success{};

  DuplicateScriptResponseBody() {}

  explicit DuplicateScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DuplicateScriptResponseBody() = default;
};
class DuplicateScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DuplicateScriptResponseBody> body{};

  DuplicateScriptResponse() {}

  explicit DuplicateScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DuplicateScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DuplicateScriptResponseBody>(model1);
      }
    }
  }


  virtual ~DuplicateScriptResponse() = default;
};
class ExportScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  ExportScriptRequest() {}

  explicit ExportScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ExportScriptRequest() = default;
};
class ExportScriptResponseBodyDownloadParams : public Darabonba::Model {
public:
  shared_ptr<string> signatureUrl{};

  ExportScriptResponseBodyDownloadParams() {}

  explicit ExportScriptResponseBodyDownloadParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signatureUrl) {
      res["SignatureUrl"] = boost::any(*signatureUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SignatureUrl") != m.end() && !m["SignatureUrl"].empty()) {
      signatureUrl = make_shared<string>(boost::any_cast<string>(m["SignatureUrl"]));
    }
  }


  virtual ~ExportScriptResponseBodyDownloadParams() = default;
};
class ExportScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ExportScriptResponseBodyDownloadParams> downloadParams{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExportScriptResponseBody() {}

  explicit ExportScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (downloadParams) {
      res["DownloadParams"] = downloadParams ? boost::any(downloadParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DownloadParams") != m.end() && !m["DownloadParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadParams"].type()) {
        ExportScriptResponseBodyDownloadParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadParams"]));
        downloadParams = make_shared<ExportScriptResponseBodyDownloadParams>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExportScriptResponseBody() = default;
};
class ExportScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportScriptResponseBody> body{};

  ExportScriptResponse() {}

  explicit ExportScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportScriptResponseBody>(model1);
      }
    }
  }


  virtual ~ExportScriptResponse() = default;
};
class GenerateUploadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> key{};

  GenerateUploadUrlRequest() {}

  explicit GenerateUploadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~GenerateUploadUrlRequest() = default;
};
class GenerateUploadUrlResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<long> expire{};
  shared_ptr<string> folder{};
  shared_ptr<string> host{};
  shared_ptr<string> message{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};
  shared_ptr<bool> success{};

  GenerateUploadUrlResponseBodyData() {}

  explicit GenerateUploadUrlResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (folder) {
      res["Folder"] = boost::any(*folder);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
    if (m.find("Folder") != m.end() && !m["Folder"].empty()) {
      folder = make_shared<string>(boost::any_cast<string>(m["Folder"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GenerateUploadUrlResponseBodyData() = default;
};
class GenerateUploadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GenerateUploadUrlResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GenerateUploadUrlResponseBody() {}

  explicit GenerateUploadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GenerateUploadUrlResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GenerateUploadUrlResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GenerateUploadUrlResponseBody() = default;
};
class GenerateUploadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateUploadUrlResponseBody> body{};

  GenerateUploadUrlResponse() {}

  explicit GenerateUploadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateUploadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateUploadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateUploadUrlResponse() = default;
};
class GetAfterAnswerDelayPlaybackRequest : public Darabonba::Model {
public:
  shared_ptr<string> entryId{};
  shared_ptr<long> strategyLevel{};

  GetAfterAnswerDelayPlaybackRequest() {}

  explicit GetAfterAnswerDelayPlaybackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entryId) {
      res["EntryId"] = boost::any(*entryId);
    }
    if (strategyLevel) {
      res["StrategyLevel"] = boost::any(*strategyLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntryId") != m.end() && !m["EntryId"].empty()) {
      entryId = make_shared<string>(boost::any_cast<string>(m["EntryId"]));
    }
    if (m.find("StrategyLevel") != m.end() && !m["StrategyLevel"].empty()) {
      strategyLevel = make_shared<long>(boost::any_cast<long>(m["StrategyLevel"]));
    }
  }


  virtual ~GetAfterAnswerDelayPlaybackRequest() = default;
};
class GetAfterAnswerDelayPlaybackResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> afterAnswerDelayPlayback{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAfterAnswerDelayPlaybackResponseBody() {}

  explicit GetAfterAnswerDelayPlaybackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (afterAnswerDelayPlayback) {
      res["AfterAnswerDelayPlayback"] = boost::any(*afterAnswerDelayPlayback);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AfterAnswerDelayPlayback") != m.end() && !m["AfterAnswerDelayPlayback"].empty()) {
      afterAnswerDelayPlayback = make_shared<long>(boost::any_cast<long>(m["AfterAnswerDelayPlayback"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAfterAnswerDelayPlaybackResponseBody() = default;
};
class GetAfterAnswerDelayPlaybackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAfterAnswerDelayPlaybackResponseBody> body{};

  GetAfterAnswerDelayPlaybackResponse() {}

  explicit GetAfterAnswerDelayPlaybackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAfterAnswerDelayPlaybackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAfterAnswerDelayPlaybackResponseBody>(model1);
      }
    }
  }


  virtual ~GetAfterAnswerDelayPlaybackResponse() = default;
};
class GetAgentProfileRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentProfileId{};
  shared_ptr<string> appIp{};
  shared_ptr<string> instanceId{};

  GetAgentProfileRequest() {}

  explicit GetAgentProfileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentProfileId) {
      res["AgentProfileId"] = boost::any(*agentProfileId);
    }
    if (appIp) {
      res["AppIp"] = boost::any(*appIp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentProfileId") != m.end() && !m["AgentProfileId"].empty()) {
      agentProfileId = make_shared<string>(boost::any_cast<string>(m["AgentProfileId"]));
    }
    if (m.find("AppIp") != m.end() && !m["AppIp"].empty()) {
      appIp = make_shared<string>(boost::any_cast<string>(m["AppIp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetAgentProfileRequest() = default;
};
class GetAgentProfileResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> agentProfileId{};
  shared_ptr<string> agentProfileTemplateId{};
  shared_ptr<string> agentType{};
  shared_ptr<string> apiPluginJson{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instructionJson{};
  shared_ptr<string> labelsJson{};
  shared_ptr<string> model{};
  shared_ptr<string> modelConfig{};
  shared_ptr<string> nluConfigJson{};
  shared_ptr<string> prompt{};
  shared_ptr<string> promptJson{};
  shared_ptr<string> scenario{};
  shared_ptr<string> scriptId{};
  shared_ptr<bool> system{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> variablesJson{};

  GetAgentProfileResponseBodyData() {}

  explicit GetAgentProfileResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentProfileId) {
      res["AgentProfileId"] = boost::any(*agentProfileId);
    }
    if (agentProfileTemplateId) {
      res["AgentProfileTemplateId"] = boost::any(*agentProfileTemplateId);
    }
    if (agentType) {
      res["AgentType"] = boost::any(*agentType);
    }
    if (apiPluginJson) {
      res["ApiPluginJson"] = boost::any(*apiPluginJson);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instructionJson) {
      res["InstructionJson"] = boost::any(*instructionJson);
    }
    if (labelsJson) {
      res["LabelsJson"] = boost::any(*labelsJson);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (modelConfig) {
      res["ModelConfig"] = boost::any(*modelConfig);
    }
    if (nluConfigJson) {
      res["NluConfigJson"] = boost::any(*nluConfigJson);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (promptJson) {
      res["PromptJson"] = boost::any(*promptJson);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (system) {
      res["System"] = boost::any(*system);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (variablesJson) {
      res["VariablesJson"] = boost::any(*variablesJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentProfileId") != m.end() && !m["AgentProfileId"].empty()) {
      agentProfileId = make_shared<string>(boost::any_cast<string>(m["AgentProfileId"]));
    }
    if (m.find("AgentProfileTemplateId") != m.end() && !m["AgentProfileTemplateId"].empty()) {
      agentProfileTemplateId = make_shared<string>(boost::any_cast<string>(m["AgentProfileTemplateId"]));
    }
    if (m.find("AgentType") != m.end() && !m["AgentType"].empty()) {
      agentType = make_shared<string>(boost::any_cast<string>(m["AgentType"]));
    }
    if (m.find("ApiPluginJson") != m.end() && !m["ApiPluginJson"].empty()) {
      apiPluginJson = make_shared<string>(boost::any_cast<string>(m["ApiPluginJson"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstructionJson") != m.end() && !m["InstructionJson"].empty()) {
      instructionJson = make_shared<string>(boost::any_cast<string>(m["InstructionJson"]));
    }
    if (m.find("LabelsJson") != m.end() && !m["LabelsJson"].empty()) {
      labelsJson = make_shared<string>(boost::any_cast<string>(m["LabelsJson"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("ModelConfig") != m.end() && !m["ModelConfig"].empty()) {
      modelConfig = make_shared<string>(boost::any_cast<string>(m["ModelConfig"]));
    }
    if (m.find("NluConfigJson") != m.end() && !m["NluConfigJson"].empty()) {
      nluConfigJson = make_shared<string>(boost::any_cast<string>(m["NluConfigJson"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("PromptJson") != m.end() && !m["PromptJson"].empty()) {
      promptJson = make_shared<string>(boost::any_cast<string>(m["PromptJson"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("System") != m.end() && !m["System"].empty()) {
      system = make_shared<bool>(boost::any_cast<bool>(m["System"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VariablesJson") != m.end() && !m["VariablesJson"].empty()) {
      variablesJson = make_shared<string>(boost::any_cast<string>(m["VariablesJson"]));
    }
  }


  virtual ~GetAgentProfileResponseBodyData() = default;
};
class GetAgentProfileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetAgentProfileResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAgentProfileResponseBody() {}

  explicit GetAgentProfileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAgentProfileResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAgentProfileResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAgentProfileResponseBody() = default;
};
class GetAgentProfileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAgentProfileResponseBody> body{};

  GetAgentProfileResponse() {}

  explicit GetAgentProfileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAgentProfileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAgentProfileResponseBody>(model1);
      }
    }
  }


  virtual ~GetAgentProfileResponse() = default;
};
class GetAgentProfileTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentProfileTemplateId{};
  shared_ptr<string> appIp{};

  GetAgentProfileTemplateRequest() {}

  explicit GetAgentProfileTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentProfileTemplateId) {
      res["AgentProfileTemplateId"] = boost::any(*agentProfileTemplateId);
    }
    if (appIp) {
      res["AppIp"] = boost::any(*appIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentProfileTemplateId") != m.end() && !m["AgentProfileTemplateId"].empty()) {
      agentProfileTemplateId = make_shared<string>(boost::any_cast<string>(m["AgentProfileTemplateId"]));
    }
    if (m.find("AppIp") != m.end() && !m["AppIp"].empty()) {
      appIp = make_shared<string>(boost::any_cast<string>(m["AppIp"]));
    }
  }


  virtual ~GetAgentProfileTemplateRequest() = default;
};
class GetAgentProfileTemplateResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> agentProfileTemplateId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> promptSchema{};
  shared_ptr<string> updateTime{};

  GetAgentProfileTemplateResponseBodyData() {}

  explicit GetAgentProfileTemplateResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentProfileTemplateId) {
      res["AgentProfileTemplateId"] = boost::any(*agentProfileTemplateId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (promptSchema) {
      res["PromptSchema"] = boost::any(*promptSchema);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentProfileTemplateId") != m.end() && !m["AgentProfileTemplateId"].empty()) {
      agentProfileTemplateId = make_shared<string>(boost::any_cast<string>(m["AgentProfileTemplateId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PromptSchema") != m.end() && !m["PromptSchema"].empty()) {
      promptSchema = make_shared<string>(boost::any_cast<string>(m["PromptSchema"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetAgentProfileTemplateResponseBodyData() = default;
};
class GetAgentProfileTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetAgentProfileTemplateResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAgentProfileTemplateResponseBody() {}

  explicit GetAgentProfileTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAgentProfileTemplateResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAgentProfileTemplateResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAgentProfileTemplateResponseBody() = default;
};
class GetAgentProfileTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAgentProfileTemplateResponseBody> body{};

  GetAgentProfileTemplateResponse() {}

  explicit GetAgentProfileTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAgentProfileTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAgentProfileTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetAgentProfileTemplateResponse() = default;
};
class GetAnnotationMissionSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionId{};

  GetAnnotationMissionSummaryRequest() {}

  explicit GetAnnotationMissionSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
  }


  virtual ~GetAnnotationMissionSummaryRequest() = default;
};
class GetAnnotationMissionSummaryResponseBodyDataAsrSummaryInfo : public Darabonba::Model {
public:
  shared_ptr<long> addCustomizationDataCount{};
  shared_ptr<long> addVocabularyDataCount{};
  shared_ptr<long> annotationInvalid{};
  shared_ptr<long> characterCorrectRate{};
  shared_ptr<long> characterErrorRate{};
  shared_ptr<long> chatTotalCount{};
  shared_ptr<long> noAnnotation{};
  shared_ptr<long> sentenceErrorRate{};
  shared_ptr<long> wordErrorRate{};

  GetAnnotationMissionSummaryResponseBodyDataAsrSummaryInfo() {}

  explicit GetAnnotationMissionSummaryResponseBodyDataAsrSummaryInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addCustomizationDataCount) {
      res["AddCustomizationDataCount"] = boost::any(*addCustomizationDataCount);
    }
    if (addVocabularyDataCount) {
      res["AddVocabularyDataCount"] = boost::any(*addVocabularyDataCount);
    }
    if (annotationInvalid) {
      res["AnnotationInvalid"] = boost::any(*annotationInvalid);
    }
    if (characterCorrectRate) {
      res["CharacterCorrectRate"] = boost::any(*characterCorrectRate);
    }
    if (characterErrorRate) {
      res["CharacterErrorRate"] = boost::any(*characterErrorRate);
    }
    if (chatTotalCount) {
      res["ChatTotalCount"] = boost::any(*chatTotalCount);
    }
    if (noAnnotation) {
      res["NoAnnotation"] = boost::any(*noAnnotation);
    }
    if (sentenceErrorRate) {
      res["SentenceErrorRate"] = boost::any(*sentenceErrorRate);
    }
    if (wordErrorRate) {
      res["WordErrorRate"] = boost::any(*wordErrorRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddCustomizationDataCount") != m.end() && !m["AddCustomizationDataCount"].empty()) {
      addCustomizationDataCount = make_shared<long>(boost::any_cast<long>(m["AddCustomizationDataCount"]));
    }
    if (m.find("AddVocabularyDataCount") != m.end() && !m["AddVocabularyDataCount"].empty()) {
      addVocabularyDataCount = make_shared<long>(boost::any_cast<long>(m["AddVocabularyDataCount"]));
    }
    if (m.find("AnnotationInvalid") != m.end() && !m["AnnotationInvalid"].empty()) {
      annotationInvalid = make_shared<long>(boost::any_cast<long>(m["AnnotationInvalid"]));
    }
    if (m.find("CharacterCorrectRate") != m.end() && !m["CharacterCorrectRate"].empty()) {
      characterCorrectRate = make_shared<long>(boost::any_cast<long>(m["CharacterCorrectRate"]));
    }
    if (m.find("CharacterErrorRate") != m.end() && !m["CharacterErrorRate"].empty()) {
      characterErrorRate = make_shared<long>(boost::any_cast<long>(m["CharacterErrorRate"]));
    }
    if (m.find("ChatTotalCount") != m.end() && !m["ChatTotalCount"].empty()) {
      chatTotalCount = make_shared<long>(boost::any_cast<long>(m["ChatTotalCount"]));
    }
    if (m.find("NoAnnotation") != m.end() && !m["NoAnnotation"].empty()) {
      noAnnotation = make_shared<long>(boost::any_cast<long>(m["NoAnnotation"]));
    }
    if (m.find("SentenceErrorRate") != m.end() && !m["SentenceErrorRate"].empty()) {
      sentenceErrorRate = make_shared<long>(boost::any_cast<long>(m["SentenceErrorRate"]));
    }
    if (m.find("WordErrorRate") != m.end() && !m["WordErrorRate"].empty()) {
      wordErrorRate = make_shared<long>(boost::any_cast<long>(m["WordErrorRate"]));
    }
  }


  virtual ~GetAnnotationMissionSummaryResponseBodyDataAsrSummaryInfo() = default;
};
class GetAnnotationMissionSummaryResponseBodyDataIntentSummaryInfo : public Darabonba::Model {
public:
  shared_ptr<long> annotationCorrectCount{};
  shared_ptr<long> annotationInvalid{};
  shared_ptr<long> chatTotalCount{};
  shared_ptr<long> intentUserSayCount{};
  shared_ptr<long> intentionNotCoveredCount{};
  shared_ptr<long> matchErrorCount{};
  shared_ptr<long> noAnnotation{};
  shared_ptr<long> translationUnrecognizedCount{};

  GetAnnotationMissionSummaryResponseBodyDataIntentSummaryInfo() {}

  explicit GetAnnotationMissionSummaryResponseBodyDataIntentSummaryInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationCorrectCount) {
      res["AnnotationCorrectCount"] = boost::any(*annotationCorrectCount);
    }
    if (annotationInvalid) {
      res["AnnotationInvalid"] = boost::any(*annotationInvalid);
    }
    if (chatTotalCount) {
      res["ChatTotalCount"] = boost::any(*chatTotalCount);
    }
    if (intentUserSayCount) {
      res["IntentUserSayCount"] = boost::any(*intentUserSayCount);
    }
    if (intentionNotCoveredCount) {
      res["IntentionNotCoveredCount"] = boost::any(*intentionNotCoveredCount);
    }
    if (matchErrorCount) {
      res["MatchErrorCount"] = boost::any(*matchErrorCount);
    }
    if (noAnnotation) {
      res["NoAnnotation"] = boost::any(*noAnnotation);
    }
    if (translationUnrecognizedCount) {
      res["TranslationUnrecognizedCount"] = boost::any(*translationUnrecognizedCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationCorrectCount") != m.end() && !m["AnnotationCorrectCount"].empty()) {
      annotationCorrectCount = make_shared<long>(boost::any_cast<long>(m["AnnotationCorrectCount"]));
    }
    if (m.find("AnnotationInvalid") != m.end() && !m["AnnotationInvalid"].empty()) {
      annotationInvalid = make_shared<long>(boost::any_cast<long>(m["AnnotationInvalid"]));
    }
    if (m.find("ChatTotalCount") != m.end() && !m["ChatTotalCount"].empty()) {
      chatTotalCount = make_shared<long>(boost::any_cast<long>(m["ChatTotalCount"]));
    }
    if (m.find("IntentUserSayCount") != m.end() && !m["IntentUserSayCount"].empty()) {
      intentUserSayCount = make_shared<long>(boost::any_cast<long>(m["IntentUserSayCount"]));
    }
    if (m.find("IntentionNotCoveredCount") != m.end() && !m["IntentionNotCoveredCount"].empty()) {
      intentionNotCoveredCount = make_shared<long>(boost::any_cast<long>(m["IntentionNotCoveredCount"]));
    }
    if (m.find("MatchErrorCount") != m.end() && !m["MatchErrorCount"].empty()) {
      matchErrorCount = make_shared<long>(boost::any_cast<long>(m["MatchErrorCount"]));
    }
    if (m.find("NoAnnotation") != m.end() && !m["NoAnnotation"].empty()) {
      noAnnotation = make_shared<long>(boost::any_cast<long>(m["NoAnnotation"]));
    }
    if (m.find("TranslationUnrecognizedCount") != m.end() && !m["TranslationUnrecognizedCount"].empty()) {
      translationUnrecognizedCount = make_shared<long>(boost::any_cast<long>(m["TranslationUnrecognizedCount"]));
    }
  }


  virtual ~GetAnnotationMissionSummaryResponseBodyDataIntentSummaryInfo() = default;
};
class GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfoTagSummaryInfoDetailList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> name{};

  GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfoTagSummaryInfoDetailList() {}

  explicit GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfoTagSummaryInfoDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfoTagSummaryInfoDetailList() = default;
};
class GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfo : public Darabonba::Model {
public:
  shared_ptr<vector<GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfoTagSummaryInfoDetailList>> tagSummaryInfoDetailList{};

  GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfo() {}

  explicit GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagSummaryInfoDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*tagSummaryInfoDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagSummaryInfoDetailList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagSummaryInfoDetailList") != m.end() && !m["TagSummaryInfoDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagSummaryInfoDetailList"].type()) {
        vector<GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfoTagSummaryInfoDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagSummaryInfoDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfoTagSummaryInfoDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagSummaryInfoDetailList = make_shared<vector<GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfoTagSummaryInfoDetailList>>(expect1);
      }
    }
  }


  virtual ~GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfo() = default;
};
class GetAnnotationMissionSummaryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionId{};
  shared_ptr<GetAnnotationMissionSummaryResponseBodyDataAsrSummaryInfo> asrSummaryInfo{};
  shared_ptr<GetAnnotationMissionSummaryResponseBodyDataIntentSummaryInfo> intentSummaryInfo{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};
  shared_ptr<GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfo> tagSummaryInfo{};

  GetAnnotationMissionSummaryResponseBodyData() {}

  explicit GetAnnotationMissionSummaryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (asrSummaryInfo) {
      res["AsrSummaryInfo"] = asrSummaryInfo ? boost::any(asrSummaryInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (intentSummaryInfo) {
      res["IntentSummaryInfo"] = intentSummaryInfo ? boost::any(intentSummaryInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tagSummaryInfo) {
      res["TagSummaryInfo"] = tagSummaryInfo ? boost::any(tagSummaryInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AsrSummaryInfo") != m.end() && !m["AsrSummaryInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsrSummaryInfo"].type()) {
        GetAnnotationMissionSummaryResponseBodyDataAsrSummaryInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsrSummaryInfo"]));
        asrSummaryInfo = make_shared<GetAnnotationMissionSummaryResponseBodyDataAsrSummaryInfo>(model1);
      }
    }
    if (m.find("IntentSummaryInfo") != m.end() && !m["IntentSummaryInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["IntentSummaryInfo"].type()) {
        GetAnnotationMissionSummaryResponseBodyDataIntentSummaryInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IntentSummaryInfo"]));
        intentSummaryInfo = make_shared<GetAnnotationMissionSummaryResponseBodyDataIntentSummaryInfo>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TagSummaryInfo") != m.end() && !m["TagSummaryInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagSummaryInfo"].type()) {
        GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagSummaryInfo"]));
        tagSummaryInfo = make_shared<GetAnnotationMissionSummaryResponseBodyDataTagSummaryInfo>(model1);
      }
    }
  }


  virtual ~GetAnnotationMissionSummaryResponseBodyData() = default;
};
class GetAnnotationMissionSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetAnnotationMissionSummaryResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAnnotationMissionSummaryResponseBody() {}

  explicit GetAnnotationMissionSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAnnotationMissionSummaryResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAnnotationMissionSummaryResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAnnotationMissionSummaryResponseBody() = default;
};
class GetAnnotationMissionSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAnnotationMissionSummaryResponseBody> body{};

  GetAnnotationMissionSummaryResponse() {}

  explicit GetAnnotationMissionSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAnnotationMissionSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAnnotationMissionSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~GetAnnotationMissionSummaryResponse() = default;
};
class GetAnnotationMissionTagInfoListRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  GetAnnotationMissionTagInfoListRequest() {}

  explicit GetAnnotationMissionTagInfoListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetAnnotationMissionTagInfoListRequest() = default;
};
class GetAnnotationMissionTagInfoListResponseBodyDataAnnotationMissionTagInfoList : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionTagInfoDescription{};
  shared_ptr<string> annotationMissionTagInfoId{};
  shared_ptr<string> annotationMissionTagInfoName{};
  shared_ptr<bool> delete_{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};

  GetAnnotationMissionTagInfoListResponseBodyDataAnnotationMissionTagInfoList() {}

  explicit GetAnnotationMissionTagInfoListResponseBodyDataAnnotationMissionTagInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionTagInfoDescription) {
      res["AnnotationMissionTagInfoDescription"] = boost::any(*annotationMissionTagInfoDescription);
    }
    if (annotationMissionTagInfoId) {
      res["AnnotationMissionTagInfoId"] = boost::any(*annotationMissionTagInfoId);
    }
    if (annotationMissionTagInfoName) {
      res["AnnotationMissionTagInfoName"] = boost::any(*annotationMissionTagInfoName);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionTagInfoDescription") != m.end() && !m["AnnotationMissionTagInfoDescription"].empty()) {
      annotationMissionTagInfoDescription = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionTagInfoDescription"]));
    }
    if (m.find("AnnotationMissionTagInfoId") != m.end() && !m["AnnotationMissionTagInfoId"].empty()) {
      annotationMissionTagInfoId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionTagInfoId"]));
    }
    if (m.find("AnnotationMissionTagInfoName") != m.end() && !m["AnnotationMissionTagInfoName"].empty()) {
      annotationMissionTagInfoName = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionTagInfoName"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<bool>(boost::any_cast<bool>(m["Delete"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~GetAnnotationMissionTagInfoListResponseBodyDataAnnotationMissionTagInfoList() = default;
};
class GetAnnotationMissionTagInfoListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetAnnotationMissionTagInfoListResponseBodyDataAnnotationMissionTagInfoList>> annotationMissionTagInfoList{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  GetAnnotationMissionTagInfoListResponseBodyData() {}

  explicit GetAnnotationMissionTagInfoListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionTagInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionTagInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionTagInfoList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionTagInfoList") != m.end() && !m["AnnotationMissionTagInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionTagInfoList"].type()) {
        vector<GetAnnotationMissionTagInfoListResponseBodyDataAnnotationMissionTagInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionTagInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAnnotationMissionTagInfoListResponseBodyDataAnnotationMissionTagInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionTagInfoList = make_shared<vector<GetAnnotationMissionTagInfoListResponseBodyDataAnnotationMissionTagInfoList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAnnotationMissionTagInfoListResponseBodyData() = default;
};
class GetAnnotationMissionTagInfoListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetAnnotationMissionTagInfoListResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAnnotationMissionTagInfoListResponseBody() {}

  explicit GetAnnotationMissionTagInfoListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAnnotationMissionTagInfoListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAnnotationMissionTagInfoListResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAnnotationMissionTagInfoListResponseBody() = default;
};
class GetAnnotationMissionTagInfoListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAnnotationMissionTagInfoListResponseBody> body{};

  GetAnnotationMissionTagInfoListResponse() {}

  explicit GetAnnotationMissionTagInfoListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAnnotationMissionTagInfoListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAnnotationMissionTagInfoListResponseBody>(model1);
      }
    }
  }


  virtual ~GetAnnotationMissionTagInfoListResponse() = default;
};
class GetAsrServerInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> entryId{};
  shared_ptr<long> strategyLevel{};

  GetAsrServerInfoRequest() {}

  explicit GetAsrServerInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entryId) {
      res["EntryId"] = boost::any(*entryId);
    }
    if (strategyLevel) {
      res["StrategyLevel"] = boost::any(*strategyLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntryId") != m.end() && !m["EntryId"].empty()) {
      entryId = make_shared<string>(boost::any_cast<string>(m["EntryId"]));
    }
    if (m.find("StrategyLevel") != m.end() && !m["StrategyLevel"].empty()) {
      strategyLevel = make_shared<long>(boost::any_cast<long>(m["StrategyLevel"]));
    }
  }


  virtual ~GetAsrServerInfoRequest() = default;
};
class GetAsrServerInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAsrServerInfoResponseBody() {}

  explicit GetAsrServerInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAsrServerInfoResponseBody() = default;
};
class GetAsrServerInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAsrServerInfoResponseBody> body{};

  GetAsrServerInfoResponse() {}

  explicit GetAsrServerInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAsrServerInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAsrServerInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetAsrServerInfoResponse() = default;
};
class GetBaseStrategyPeriodRequest : public Darabonba::Model {
public:
  shared_ptr<string> entryId{};
  shared_ptr<long> strategyLevel{};

  GetBaseStrategyPeriodRequest() {}

  explicit GetBaseStrategyPeriodRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entryId) {
      res["EntryId"] = boost::any(*entryId);
    }
    if (strategyLevel) {
      res["StrategyLevel"] = boost::any(*strategyLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntryId") != m.end() && !m["EntryId"].empty()) {
      entryId = make_shared<string>(boost::any_cast<string>(m["EntryId"]));
    }
    if (m.find("StrategyLevel") != m.end() && !m["StrategyLevel"].empty()) {
      strategyLevel = make_shared<long>(boost::any_cast<long>(m["StrategyLevel"]));
    }
  }


  virtual ~GetBaseStrategyPeriodRequest() = default;
};
class GetBaseStrategyPeriodResponseBodyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> beginTime{};
  shared_ptr<long> beginTimeMillis{};
  shared_ptr<string> endTime{};
  shared_ptr<long> endTimeMillis{};

  GetBaseStrategyPeriodResponseBodyWorkingTime() {}

  explicit GetBaseStrategyPeriodResponseBodyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (beginTimeMillis) {
      res["BeginTimeMillis"] = boost::any(*beginTimeMillis);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endTimeMillis) {
      res["EndTimeMillis"] = boost::any(*endTimeMillis);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
    if (m.find("BeginTimeMillis") != m.end() && !m["BeginTimeMillis"].empty()) {
      beginTimeMillis = make_shared<long>(boost::any_cast<long>(m["BeginTimeMillis"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EndTimeMillis") != m.end() && !m["EndTimeMillis"].empty()) {
      endTimeMillis = make_shared<long>(boost::any_cast<long>(m["EndTimeMillis"]));
    }
  }


  virtual ~GetBaseStrategyPeriodResponseBodyWorkingTime() = default;
};
class GetBaseStrategyPeriodResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<bool> onlyWeekdays{};
  shared_ptr<bool> onlyWorkdays{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<GetBaseStrategyPeriodResponseBodyWorkingTime>> workingTime{};

  GetBaseStrategyPeriodResponseBody() {}

  explicit GetBaseStrategyPeriodResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (onlyWeekdays) {
      res["OnlyWeekdays"] = boost::any(*onlyWeekdays);
    }
    if (onlyWorkdays) {
      res["OnlyWorkdays"] = boost::any(*onlyWorkdays);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OnlyWeekdays") != m.end() && !m["OnlyWeekdays"].empty()) {
      onlyWeekdays = make_shared<bool>(boost::any_cast<bool>(m["OnlyWeekdays"]));
    }
    if (m.find("OnlyWorkdays") != m.end() && !m["OnlyWorkdays"].empty()) {
      onlyWorkdays = make_shared<bool>(boost::any_cast<bool>(m["OnlyWorkdays"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<GetBaseStrategyPeriodResponseBodyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBaseStrategyPeriodResponseBodyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<GetBaseStrategyPeriodResponseBodyWorkingTime>>(expect1);
      }
    }
  }


  virtual ~GetBaseStrategyPeriodResponseBody() = default;
};
class GetBaseStrategyPeriodResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBaseStrategyPeriodResponseBody> body{};

  GetBaseStrategyPeriodResponse() {}

  explicit GetBaseStrategyPeriodResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBaseStrategyPeriodResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBaseStrategyPeriodResponseBody>(model1);
      }
    }
  }


  virtual ~GetBaseStrategyPeriodResponse() = default;
};
class GetConcurrentConversationQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> maxConcurrent{};
  shared_ptr<string> message{};
  shared_ptr<long> remainingConcurrent{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetConcurrentConversationQuotaResponseBody() {}

  explicit GetConcurrentConversationQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (maxConcurrent) {
      res["MaxConcurrent"] = boost::any(*maxConcurrent);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (remainingConcurrent) {
      res["RemainingConcurrent"] = boost::any(*remainingConcurrent);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MaxConcurrent") != m.end() && !m["MaxConcurrent"].empty()) {
      maxConcurrent = make_shared<long>(boost::any_cast<long>(m["MaxConcurrent"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RemainingConcurrent") != m.end() && !m["RemainingConcurrent"].empty()) {
      remainingConcurrent = make_shared<long>(boost::any_cast<long>(m["RemainingConcurrent"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetConcurrentConversationQuotaResponseBody() = default;
};
class GetConcurrentConversationQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetConcurrentConversationQuotaResponseBody> body{};

  GetConcurrentConversationQuotaResponse() {}

  explicit GetConcurrentConversationQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConcurrentConversationQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConcurrentConversationQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~GetConcurrentConversationQuotaResponse() = default;
};
class GetContactBlockListRequest : public Darabonba::Model {
public:
  shared_ptr<bool> countTotalRow{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  GetContactBlockListRequest() {}

  explicit GetContactBlockListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (countTotalRow) {
      res["CountTotalRow"] = boost::any(*countTotalRow);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CountTotalRow") != m.end() && !m["CountTotalRow"].empty()) {
      countTotalRow = make_shared<bool>(boost::any_cast<bool>(m["CountTotalRow"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetContactBlockListRequest() = default;
};
class GetContactBlockListResponseBodyContactBlocklistListList : public Darabonba::Model {
public:
  shared_ptr<string> contactBlockListId{};
  shared_ptr<long> creationTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> operator_{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> remark{};

  GetContactBlockListResponseBodyContactBlocklistListList() {}

  explicit GetContactBlockListResponseBodyContactBlocklistListList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactBlockListId) {
      res["ContactBlockListId"] = boost::any(*contactBlockListId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactBlockListId") != m.end() && !m["ContactBlockListId"].empty()) {
      contactBlockListId = make_shared<string>(boost::any_cast<string>(m["ContactBlockListId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~GetContactBlockListResponseBodyContactBlocklistListList() = default;
};
class GetContactBlockListResponseBodyContactBlocklistList : public Darabonba::Model {
public:
  shared_ptr<vector<GetContactBlockListResponseBodyContactBlocklistListList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  GetContactBlockListResponseBodyContactBlocklistList() {}

  explicit GetContactBlockListResponseBodyContactBlocklistList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetContactBlockListResponseBodyContactBlocklistListList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetContactBlockListResponseBodyContactBlocklistListList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetContactBlockListResponseBodyContactBlocklistListList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetContactBlockListResponseBodyContactBlocklistList() = default;
};
class GetContactBlockListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetContactBlockListResponseBodyContactBlocklistList> contactBlocklistList{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetContactBlockListResponseBody() {}

  explicit GetContactBlockListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (contactBlocklistList) {
      res["ContactBlocklistList"] = contactBlocklistList ? boost::any(contactBlocklistList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ContactBlocklistList") != m.end() && !m["ContactBlocklistList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactBlocklistList"].type()) {
        GetContactBlockListResponseBodyContactBlocklistList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactBlocklistList"]));
        contactBlocklistList = make_shared<GetContactBlockListResponseBodyContactBlocklistList>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetContactBlockListResponseBody() = default;
};
class GetContactBlockListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetContactBlockListResponseBody> body{};

  GetContactBlockListResponse() {}

  explicit GetContactBlockListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetContactBlockListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetContactBlockListResponseBody>(model1);
      }
    }
  }


  virtual ~GetContactBlockListResponse() = default;
};
class GetContactWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<bool> countTotalRow{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  GetContactWhiteListRequest() {}

  explicit GetContactWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (countTotalRow) {
      res["CountTotalRow"] = boost::any(*countTotalRow);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CountTotalRow") != m.end() && !m["CountTotalRow"].empty()) {
      countTotalRow = make_shared<bool>(boost::any_cast<bool>(m["CountTotalRow"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetContactWhiteListRequest() = default;
};
class GetContactWhiteListResponseBodyContactWhitelistListList : public Darabonba::Model {
public:
  shared_ptr<string> contactWhiteListId{};
  shared_ptr<long> creationTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> operator_{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> remark{};

  GetContactWhiteListResponseBodyContactWhitelistListList() {}

  explicit GetContactWhiteListResponseBodyContactWhitelistListList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactWhiteListId) {
      res["ContactWhiteListId"] = boost::any(*contactWhiteListId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactWhiteListId") != m.end() && !m["ContactWhiteListId"].empty()) {
      contactWhiteListId = make_shared<string>(boost::any_cast<string>(m["ContactWhiteListId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~GetContactWhiteListResponseBodyContactWhitelistListList() = default;
};
class GetContactWhiteListResponseBodyContactWhitelistList : public Darabonba::Model {
public:
  shared_ptr<vector<GetContactWhiteListResponseBodyContactWhitelistListList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  GetContactWhiteListResponseBodyContactWhitelistList() {}

  explicit GetContactWhiteListResponseBodyContactWhitelistList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetContactWhiteListResponseBodyContactWhitelistListList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetContactWhiteListResponseBodyContactWhitelistListList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetContactWhiteListResponseBodyContactWhitelistListList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetContactWhiteListResponseBodyContactWhitelistList() = default;
};
class GetContactWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetContactWhiteListResponseBodyContactWhitelistList> contactWhitelistList{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetContactWhiteListResponseBody() {}

  explicit GetContactWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (contactWhitelistList) {
      res["ContactWhitelistList"] = contactWhitelistList ? boost::any(contactWhitelistList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ContactWhitelistList") != m.end() && !m["ContactWhitelistList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactWhitelistList"].type()) {
        GetContactWhiteListResponseBodyContactWhitelistList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactWhitelistList"]));
        contactWhitelistList = make_shared<GetContactWhiteListResponseBodyContactWhitelistList>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetContactWhiteListResponseBody() = default;
};
class GetContactWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetContactWhiteListResponseBody> body{};

  GetContactWhiteListResponse() {}

  explicit GetContactWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetContactWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetContactWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~GetContactWhiteListResponse() = default;
};
class GetCurrentConcurrencyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetCurrentConcurrencyRequest() {}

  explicit GetCurrentConcurrencyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetCurrentConcurrencyRequest() = default;
};
class GetCurrentConcurrencyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> currentConcurrency{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxConcurrentConversation{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetCurrentConcurrencyResponseBody() {}

  explicit GetCurrentConcurrencyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (currentConcurrency) {
      res["CurrentConcurrency"] = boost::any(*currentConcurrency);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxConcurrentConversation) {
      res["MaxConcurrentConversation"] = boost::any(*maxConcurrentConversation);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CurrentConcurrency") != m.end() && !m["CurrentConcurrency"].empty()) {
      currentConcurrency = make_shared<long>(boost::any_cast<long>(m["CurrentConcurrency"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxConcurrentConversation") != m.end() && !m["MaxConcurrentConversation"].empty()) {
      maxConcurrentConversation = make_shared<long>(boost::any_cast<long>(m["MaxConcurrentConversation"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetCurrentConcurrencyResponseBody() = default;
};
class GetCurrentConcurrencyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCurrentConcurrencyResponseBody> body{};

  GetCurrentConcurrencyResponse() {}

  explicit GetCurrentConcurrencyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCurrentConcurrencyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCurrentConcurrencyResponseBody>(model1);
      }
    }
  }


  virtual ~GetCurrentConcurrencyResponse() = default;
};
class GetEffectiveDaysRequest : public Darabonba::Model {
public:
  shared_ptr<string> entryId{};
  shared_ptr<long> strategyLevel{};

  GetEffectiveDaysRequest() {}

  explicit GetEffectiveDaysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entryId) {
      res["EntryId"] = boost::any(*entryId);
    }
    if (strategyLevel) {
      res["StrategyLevel"] = boost::any(*strategyLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntryId") != m.end() && !m["EntryId"].empty()) {
      entryId = make_shared<string>(boost::any_cast<string>(m["EntryId"]));
    }
    if (m.find("StrategyLevel") != m.end() && !m["StrategyLevel"].empty()) {
      strategyLevel = make_shared<long>(boost::any_cast<long>(m["StrategyLevel"]));
    }
  }


  virtual ~GetEffectiveDaysRequest() = default;
};
class GetEffectiveDaysResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> effectiveDays{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetEffectiveDaysResponseBody() {}

  explicit GetEffectiveDaysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (effectiveDays) {
      res["EffectiveDays"] = boost::any(*effectiveDays);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EffectiveDays") != m.end() && !m["EffectiveDays"].empty()) {
      effectiveDays = make_shared<long>(boost::any_cast<long>(m["EffectiveDays"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetEffectiveDaysResponseBody() = default;
};
class GetEffectiveDaysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEffectiveDaysResponseBody> body{};

  GetEffectiveDaysResponse() {}

  explicit GetEffectiveDaysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEffectiveDaysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEffectiveDaysResponseBody>(model1);
      }
    }
  }


  virtual ~GetEffectiveDaysResponse() = default;
};
class GetEmptyNumberNoMoreCallsInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> entryId{};
  shared_ptr<long> strategyLevel{};

  GetEmptyNumberNoMoreCallsInfoRequest() {}

  explicit GetEmptyNumberNoMoreCallsInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entryId) {
      res["EntryId"] = boost::any(*entryId);
    }
    if (strategyLevel) {
      res["StrategyLevel"] = boost::any(*strategyLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntryId") != m.end() && !m["EntryId"].empty()) {
      entryId = make_shared<string>(boost::any_cast<string>(m["EntryId"]));
    }
    if (m.find("StrategyLevel") != m.end() && !m["StrategyLevel"].empty()) {
      strategyLevel = make_shared<long>(boost::any_cast<long>(m["StrategyLevel"]));
    }
  }


  virtual ~GetEmptyNumberNoMoreCallsInfoRequest() = default;
};
class GetEmptyNumberNoMoreCallsInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> emptyNumberNoMoreCalls{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetEmptyNumberNoMoreCallsInfoResponseBody() {}

  explicit GetEmptyNumberNoMoreCallsInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (emptyNumberNoMoreCalls) {
      res["EmptyNumberNoMoreCalls"] = boost::any(*emptyNumberNoMoreCalls);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EmptyNumberNoMoreCalls") != m.end() && !m["EmptyNumberNoMoreCalls"].empty()) {
      emptyNumberNoMoreCalls = make_shared<bool>(boost::any_cast<bool>(m["EmptyNumberNoMoreCalls"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetEmptyNumberNoMoreCallsInfoResponseBody() = default;
};
class GetEmptyNumberNoMoreCallsInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEmptyNumberNoMoreCallsInfoResponseBody> body{};

  GetEmptyNumberNoMoreCallsInfoResponse() {}

  explicit GetEmptyNumberNoMoreCallsInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEmptyNumberNoMoreCallsInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEmptyNumberNoMoreCallsInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetEmptyNumberNoMoreCallsInfoResponse() = default;
};
class GetJobDataUploadParamsRequest : public Darabonba::Model {
public:
  shared_ptr<string> busiType{};
  shared_ptr<string> fileName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> path{};
  shared_ptr<string> uniqueId{};

  GetJobDataUploadParamsRequest() {}

  explicit GetJobDataUploadParamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (busiType) {
      res["BusiType"] = boost::any(*busiType);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (uniqueId) {
      res["UniqueId"] = boost::any(*uniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusiType") != m.end() && !m["BusiType"].empty()) {
      busiType = make_shared<string>(boost::any_cast<string>(m["BusiType"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("UniqueId") != m.end() && !m["UniqueId"].empty()) {
      uniqueId = make_shared<string>(boost::any_cast<string>(m["UniqueId"]));
    }
  }


  virtual ~GetJobDataUploadParamsRequest() = default;
};
class GetJobDataUploadParamsResponseBodyUploadParams : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<long> expire{};
  shared_ptr<string> folder{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  GetJobDataUploadParamsResponseBodyUploadParams() {}

  explicit GetJobDataUploadParamsResponseBodyUploadParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (folder) {
      res["Folder"] = boost::any(*folder);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
    if (m.find("Folder") != m.end() && !m["Folder"].empty()) {
      folder = make_shared<string>(boost::any_cast<string>(m["Folder"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~GetJobDataUploadParamsResponseBodyUploadParams() = default;
};
class GetJobDataUploadParamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetJobDataUploadParamsResponseBodyUploadParams> uploadParams{};

  GetJobDataUploadParamsResponseBody() {}

  explicit GetJobDataUploadParamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (uploadParams) {
      res["UploadParams"] = uploadParams ? boost::any(uploadParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("UploadParams") != m.end() && !m["UploadParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["UploadParams"].type()) {
        GetJobDataUploadParamsResponseBodyUploadParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UploadParams"]));
        uploadParams = make_shared<GetJobDataUploadParamsResponseBodyUploadParams>(model1);
      }
    }
  }


  virtual ~GetJobDataUploadParamsResponseBody() = default;
};
class GetJobDataUploadParamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetJobDataUploadParamsResponseBody> body{};

  GetJobDataUploadParamsResponse() {}

  explicit GetJobDataUploadParamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetJobDataUploadParamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetJobDataUploadParamsResponseBody>(model1);
      }
    }
  }


  virtual ~GetJobDataUploadParamsResponse() = default;
};
class GetMaxAttemptsPerDayRequest : public Darabonba::Model {
public:
  shared_ptr<string> entryId{};
  shared_ptr<long> strategyLevel{};

  GetMaxAttemptsPerDayRequest() {}

  explicit GetMaxAttemptsPerDayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entryId) {
      res["EntryId"] = boost::any(*entryId);
    }
    if (strategyLevel) {
      res["StrategyLevel"] = boost::any(*strategyLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntryId") != m.end() && !m["EntryId"].empty()) {
      entryId = make_shared<string>(boost::any_cast<string>(m["EntryId"]));
    }
    if (m.find("StrategyLevel") != m.end() && !m["StrategyLevel"].empty()) {
      strategyLevel = make_shared<long>(boost::any_cast<long>(m["StrategyLevel"]));
    }
  }


  virtual ~GetMaxAttemptsPerDayRequest() = default;
};
class GetMaxAttemptsPerDayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetMaxAttemptsPerDayResponseBody() {}

  explicit GetMaxAttemptsPerDayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMaxAttemptsPerDayResponseBody() = default;
};
class GetMaxAttemptsPerDayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMaxAttemptsPerDayResponseBody> body{};

  GetMaxAttemptsPerDayResponse() {}

  explicit GetMaxAttemptsPerDayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMaxAttemptsPerDayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMaxAttemptsPerDayResponseBody>(model1);
      }
    }
  }


  virtual ~GetMaxAttemptsPerDayResponse() = default;
};
class GetNumberDistrictInfoTemplateDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> fileHttpUrl{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetNumberDistrictInfoTemplateDownloadUrlResponseBody() {}

  explicit GetNumberDistrictInfoTemplateDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (fileHttpUrl) {
      res["FileHttpUrl"] = boost::any(*fileHttpUrl);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FileHttpUrl") != m.end() && !m["FileHttpUrl"].empty()) {
      fileHttpUrl = make_shared<string>(boost::any_cast<string>(m["FileHttpUrl"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetNumberDistrictInfoTemplateDownloadUrlResponseBody() = default;
};
class GetNumberDistrictInfoTemplateDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNumberDistrictInfoTemplateDownloadUrlResponseBody> body{};

  GetNumberDistrictInfoTemplateDownloadUrlResponse() {}

  explicit GetNumberDistrictInfoTemplateDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNumberDistrictInfoTemplateDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNumberDistrictInfoTemplateDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetNumberDistrictInfoTemplateDownloadUrlResponse() = default;
};
class GetRealtimeConcurrencyReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  GetRealtimeConcurrencyReportRequest() {}

  explicit GetRealtimeConcurrencyReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetRealtimeConcurrencyReportRequest() = default;
};
class GetRealtimeConcurrencyReportResponseBodyReportsList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobGroupName{};
  shared_ptr<long> maxConcurrencyLimit{};
  shared_ptr<long> minConcurrencyLimit{};
  shared_ptr<long> occupiedConcurrencyCount{};
  shared_ptr<long> reportDate{};

  GetRealtimeConcurrencyReportResponseBodyReportsList() {}

  explicit GetRealtimeConcurrencyReportResponseBodyReportsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobGroupName) {
      res["JobGroupName"] = boost::any(*jobGroupName);
    }
    if (maxConcurrencyLimit) {
      res["MaxConcurrencyLimit"] = boost::any(*maxConcurrencyLimit);
    }
    if (minConcurrencyLimit) {
      res["MinConcurrencyLimit"] = boost::any(*minConcurrencyLimit);
    }
    if (occupiedConcurrencyCount) {
      res["OccupiedConcurrencyCount"] = boost::any(*occupiedConcurrencyCount);
    }
    if (reportDate) {
      res["ReportDate"] = boost::any(*reportDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobGroupName") != m.end() && !m["JobGroupName"].empty()) {
      jobGroupName = make_shared<string>(boost::any_cast<string>(m["JobGroupName"]));
    }
    if (m.find("MaxConcurrencyLimit") != m.end() && !m["MaxConcurrencyLimit"].empty()) {
      maxConcurrencyLimit = make_shared<long>(boost::any_cast<long>(m["MaxConcurrencyLimit"]));
    }
    if (m.find("MinConcurrencyLimit") != m.end() && !m["MinConcurrencyLimit"].empty()) {
      minConcurrencyLimit = make_shared<long>(boost::any_cast<long>(m["MinConcurrencyLimit"]));
    }
    if (m.find("OccupiedConcurrencyCount") != m.end() && !m["OccupiedConcurrencyCount"].empty()) {
      occupiedConcurrencyCount = make_shared<long>(boost::any_cast<long>(m["OccupiedConcurrencyCount"]));
    }
    if (m.find("ReportDate") != m.end() && !m["ReportDate"].empty()) {
      reportDate = make_shared<long>(boost::any_cast<long>(m["ReportDate"]));
    }
  }


  virtual ~GetRealtimeConcurrencyReportResponseBodyReportsList() = default;
};
class GetRealtimeConcurrencyReportResponseBodyReports : public Darabonba::Model {
public:
  shared_ptr<vector<GetRealtimeConcurrencyReportResponseBodyReportsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  GetRealtimeConcurrencyReportResponseBodyReports() {}

  explicit GetRealtimeConcurrencyReportResponseBodyReports(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetRealtimeConcurrencyReportResponseBodyReportsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRealtimeConcurrencyReportResponseBodyReportsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetRealtimeConcurrencyReportResponseBodyReportsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetRealtimeConcurrencyReportResponseBodyReports() = default;
};
class GetRealtimeConcurrencyReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<long> reportDate{};
  shared_ptr<GetRealtimeConcurrencyReportResponseBodyReports> reports{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetRealtimeConcurrencyReportResponseBody() {}

  explicit GetRealtimeConcurrencyReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (reportDate) {
      res["ReportDate"] = boost::any(*reportDate);
    }
    if (reports) {
      res["Reports"] = reports ? boost::any(reports->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ReportDate") != m.end() && !m["ReportDate"].empty()) {
      reportDate = make_shared<long>(boost::any_cast<long>(m["ReportDate"]));
    }
    if (m.find("Reports") != m.end() && !m["Reports"].empty()) {
      if (typeid(map<string, boost::any>) == m["Reports"].type()) {
        GetRealtimeConcurrencyReportResponseBodyReports model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Reports"]));
        reports = make_shared<GetRealtimeConcurrencyReportResponseBodyReports>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetRealtimeConcurrencyReportResponseBody() = default;
};
class GetRealtimeConcurrencyReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRealtimeConcurrencyReportResponseBody> body{};

  GetRealtimeConcurrencyReportResponse() {}

  explicit GetRealtimeConcurrencyReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRealtimeConcurrencyReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRealtimeConcurrencyReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetRealtimeConcurrencyReportResponse() = default;
};
class GetSummaryInfoRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIdList{};

  GetSummaryInfoRequest() {}

  explicit GetSummaryInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdList) {
      res["InstanceIdList"] = boost::any(*instanceIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIdList") != m.end() && !m["InstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetSummaryInfoRequest() = default;
};
class GetSummaryInfoResponseBodyAgentBotInstanceSummaryList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> totalCallCount{};
  shared_ptr<long> totalCallTime{};
  shared_ptr<long> usedRecordingStorageSpace{};

  GetSummaryInfoResponseBodyAgentBotInstanceSummaryList() {}

  explicit GetSummaryInfoResponseBodyAgentBotInstanceSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (totalCallCount) {
      res["TotalCallCount"] = boost::any(*totalCallCount);
    }
    if (totalCallTime) {
      res["TotalCallTime"] = boost::any(*totalCallTime);
    }
    if (usedRecordingStorageSpace) {
      res["UsedRecordingStorageSpace"] = boost::any(*usedRecordingStorageSpace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TotalCallCount") != m.end() && !m["TotalCallCount"].empty()) {
      totalCallCount = make_shared<long>(boost::any_cast<long>(m["TotalCallCount"]));
    }
    if (m.find("TotalCallTime") != m.end() && !m["TotalCallTime"].empty()) {
      totalCallTime = make_shared<long>(boost::any_cast<long>(m["TotalCallTime"]));
    }
    if (m.find("UsedRecordingStorageSpace") != m.end() && !m["UsedRecordingStorageSpace"].empty()) {
      usedRecordingStorageSpace = make_shared<long>(boost::any_cast<long>(m["UsedRecordingStorageSpace"]));
    }
  }


  virtual ~GetSummaryInfoResponseBodyAgentBotInstanceSummaryList() = default;
};
class GetSummaryInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetSummaryInfoResponseBodyAgentBotInstanceSummaryList>> agentBotInstanceSummaryList{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetSummaryInfoResponseBody() {}

  explicit GetSummaryInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentBotInstanceSummaryList) {
      vector<boost::any> temp1;
      for(auto item1:*agentBotInstanceSummaryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AgentBotInstanceSummaryList"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentBotInstanceSummaryList") != m.end() && !m["AgentBotInstanceSummaryList"].empty()) {
      if (typeid(vector<boost::any>) == m["AgentBotInstanceSummaryList"].type()) {
        vector<GetSummaryInfoResponseBodyAgentBotInstanceSummaryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AgentBotInstanceSummaryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSummaryInfoResponseBodyAgentBotInstanceSummaryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        agentBotInstanceSummaryList = make_shared<vector<GetSummaryInfoResponseBodyAgentBotInstanceSummaryList>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSummaryInfoResponseBody() = default;
};
class GetSummaryInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSummaryInfoResponseBody> body{};

  GetSummaryInfoResponse() {}

  explicit GetSummaryInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSummaryInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSummaryInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetSummaryInfoResponse() = default;
};
class GetTaskByUuidRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> taskId{};
  shared_ptr<bool> withConversations{};

  GetTaskByUuidRequest() {}

  explicit GetTaskByUuidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (withConversations) {
      res["WithConversations"] = boost::any(*withConversations);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WithConversations") != m.end() && !m["WithConversations"].empty()) {
      withConversations = make_shared<bool>(boost::any_cast<bool>(m["WithConversations"]));
    }
  }


  virtual ~GetTaskByUuidRequest() = default;
};
class GetTaskByUuidResponseBodyTaskConversations : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> script{};
  shared_ptr<string> sequenceId{};
  shared_ptr<string> speaker{};
  shared_ptr<long> timestamp{};

  GetTaskByUuidResponseBodyTaskConversations() {}

  explicit GetTaskByUuidResponseBodyTaskConversations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (sequenceId) {
      res["SequenceId"] = boost::any(*sequenceId);
    }
    if (speaker) {
      res["Speaker"] = boost::any(*speaker);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("SequenceId") != m.end() && !m["SequenceId"].empty()) {
      sequenceId = make_shared<string>(boost::any_cast<string>(m["SequenceId"]));
    }
    if (m.find("Speaker") != m.end() && !m["Speaker"].empty()) {
      speaker = make_shared<string>(boost::any_cast<string>(m["Speaker"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~GetTaskByUuidResponseBodyTaskConversations() = default;
};
class GetTaskByUuidResponseBodyTask : public Darabonba::Model {
public:
  shared_ptr<long> actualTime{};
  shared_ptr<string> callId{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> callingNumber{};
  shared_ptr<vector<GetTaskByUuidResponseBodyTaskConversations>> conversations{};
  shared_ptr<long> endReason{};
  shared_ptr<long> endTime{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> plannedTime{};

  GetTaskByUuidResponseBodyTask() {}

  explicit GetTaskByUuidResponseBodyTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualTime) {
      res["ActualTime"] = boost::any(*actualTime);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (conversations) {
      vector<boost::any> temp1;
      for(auto item1:*conversations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conversations"] = boost::any(temp1);
    }
    if (endReason) {
      res["EndReason"] = boost::any(*endReason);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (plannedTime) {
      res["PlannedTime"] = boost::any(*plannedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualTime") != m.end() && !m["ActualTime"].empty()) {
      actualTime = make_shared<long>(boost::any_cast<long>(m["ActualTime"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("Conversations") != m.end() && !m["Conversations"].empty()) {
      if (typeid(vector<boost::any>) == m["Conversations"].type()) {
        vector<GetTaskByUuidResponseBodyTaskConversations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conversations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskByUuidResponseBodyTaskConversations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conversations = make_shared<vector<GetTaskByUuidResponseBodyTaskConversations>>(expect1);
      }
    }
    if (m.find("EndReason") != m.end() && !m["EndReason"].empty()) {
      endReason = make_shared<long>(boost::any_cast<long>(m["EndReason"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("PlannedTime") != m.end() && !m["PlannedTime"].empty()) {
      plannedTime = make_shared<long>(boost::any_cast<long>(m["PlannedTime"]));
    }
  }


  virtual ~GetTaskByUuidResponseBodyTask() = default;
};
class GetTaskByUuidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetTaskByUuidResponseBodyTask> task{};

  GetTaskByUuidResponseBody() {}

  explicit GetTaskByUuidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (task) {
      res["Task"] = task ? boost::any(task->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(map<string, boost::any>) == m["Task"].type()) {
        GetTaskByUuidResponseBodyTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Task"]));
        task = make_shared<GetTaskByUuidResponseBodyTask>(model1);
      }
    }
  }


  virtual ~GetTaskByUuidResponseBody() = default;
};
class GetTaskByUuidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTaskByUuidResponseBody> body{};

  GetTaskByUuidResponse() {}

  explicit GetTaskByUuidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskByUuidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskByUuidResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskByUuidResponse() = default;
};
class GetVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> version{};

  GetVersionResponseBody() {}

  explicit GetVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetVersionResponseBody() = default;
};
class GetVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVersionResponseBody> body{};

  GetVersionResponse() {}

  explicit GetVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVersionResponseBody>(model1);
      }
    }
  }


  virtual ~GetVersionResponse() = default;
};
class ImportScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> nluEngine{};
  shared_ptr<string> signatureUrl{};

  ImportScriptRequest() {}

  explicit ImportScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nluEngine) {
      res["NluEngine"] = boost::any(*nluEngine);
    }
    if (signatureUrl) {
      res["SignatureUrl"] = boost::any(*signatureUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NluEngine") != m.end() && !m["NluEngine"].empty()) {
      nluEngine = make_shared<string>(boost::any_cast<string>(m["NluEngine"]));
    }
    if (m.find("SignatureUrl") != m.end() && !m["SignatureUrl"].empty()) {
      signatureUrl = make_shared<string>(boost::any_cast<string>(m["SignatureUrl"]));
    }
  }


  virtual ~ImportScriptRequest() = default;
};
class ImportScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scriptId{};
  shared_ptr<bool> success{};

  ImportScriptResponseBody() {}

  explicit ImportScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ImportScriptResponseBody() = default;
};
class ImportScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportScriptResponseBody> body{};

  ImportScriptResponse() {}

  explicit ImportScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportScriptResponseBody>(model1);
      }
    }
  }


  virtual ~ImportScriptResponse() = default;
};
class InflightTaskTimeoutRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> instanceOwnerId{};
  shared_ptr<string> taskId{};

  InflightTaskTimeoutRequest() {}

  explicit InflightTaskTimeoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceOwnerId) {
      res["InstanceOwnerId"] = boost::any(*instanceOwnerId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceOwnerId") != m.end() && !m["InstanceOwnerId"].empty()) {
      instanceOwnerId = make_shared<long>(boost::any_cast<long>(m["InstanceOwnerId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~InflightTaskTimeoutRequest() = default;
};
class InflightTaskTimeoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InflightTaskTimeoutResponseBody() {}

  explicit InflightTaskTimeoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InflightTaskTimeoutResponseBody() = default;
};
class InflightTaskTimeoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InflightTaskTimeoutResponseBody> body{};

  InflightTaskTimeoutResponse() {}

  explicit InflightTaskTimeoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InflightTaskTimeoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InflightTaskTimeoutResponseBody>(model1);
      }
    }
  }


  virtual ~InflightTaskTimeoutResponse() = default;
};
class ListAgentProfilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appIp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  ListAgentProfilesRequest() {}

  explicit ListAgentProfilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIp) {
      res["AppIp"] = boost::any(*appIp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIp") != m.end() && !m["AppIp"].empty()) {
      appIp = make_shared<string>(boost::any_cast<string>(m["AppIp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ListAgentProfilesRequest() = default;
};
class ListAgentProfilesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> agentProfileId{};
  shared_ptr<string> agentProfileTemplateId{};
  shared_ptr<string> agentType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instructionJson{};
  shared_ptr<string> labelsJson{};
  shared_ptr<string> model{};
  shared_ptr<string> modelConfig{};
  shared_ptr<string> prompt{};
  shared_ptr<string> promptJson{};
  shared_ptr<string> scenario{};
  shared_ptr<string> scriptId{};
  shared_ptr<bool> system{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> variablesJson{};

  ListAgentProfilesResponseBodyData() {}

  explicit ListAgentProfilesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentProfileId) {
      res["AgentProfileId"] = boost::any(*agentProfileId);
    }
    if (agentProfileTemplateId) {
      res["AgentProfileTemplateId"] = boost::any(*agentProfileTemplateId);
    }
    if (agentType) {
      res["AgentType"] = boost::any(*agentType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instructionJson) {
      res["InstructionJson"] = boost::any(*instructionJson);
    }
    if (labelsJson) {
      res["LabelsJson"] = boost::any(*labelsJson);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (modelConfig) {
      res["ModelConfig"] = boost::any(*modelConfig);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (promptJson) {
      res["PromptJson"] = boost::any(*promptJson);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (system) {
      res["System"] = boost::any(*system);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (variablesJson) {
      res["VariablesJson"] = boost::any(*variablesJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentProfileId") != m.end() && !m["AgentProfileId"].empty()) {
      agentProfileId = make_shared<string>(boost::any_cast<string>(m["AgentProfileId"]));
    }
    if (m.find("AgentProfileTemplateId") != m.end() && !m["AgentProfileTemplateId"].empty()) {
      agentProfileTemplateId = make_shared<string>(boost::any_cast<string>(m["AgentProfileTemplateId"]));
    }
    if (m.find("AgentType") != m.end() && !m["AgentType"].empty()) {
      agentType = make_shared<string>(boost::any_cast<string>(m["AgentType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstructionJson") != m.end() && !m["InstructionJson"].empty()) {
      instructionJson = make_shared<string>(boost::any_cast<string>(m["InstructionJson"]));
    }
    if (m.find("LabelsJson") != m.end() && !m["LabelsJson"].empty()) {
      labelsJson = make_shared<string>(boost::any_cast<string>(m["LabelsJson"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("ModelConfig") != m.end() && !m["ModelConfig"].empty()) {
      modelConfig = make_shared<string>(boost::any_cast<string>(m["ModelConfig"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("PromptJson") != m.end() && !m["PromptJson"].empty()) {
      promptJson = make_shared<string>(boost::any_cast<string>(m["PromptJson"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("System") != m.end() && !m["System"].empty()) {
      system = make_shared<bool>(boost::any_cast<bool>(m["System"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VariablesJson") != m.end() && !m["VariablesJson"].empty()) {
      variablesJson = make_shared<string>(boost::any_cast<string>(m["VariablesJson"]));
    }
  }


  virtual ~ListAgentProfilesResponseBodyData() = default;
};
class ListAgentProfilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListAgentProfilesResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAgentProfilesResponseBody() {}

  explicit ListAgentProfilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAgentProfilesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentProfilesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAgentProfilesResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAgentProfilesResponseBody() = default;
};
class ListAgentProfilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAgentProfilesResponseBody> body{};

  ListAgentProfilesResponse() {}

  explicit ListAgentProfilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAgentProfilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAgentProfilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAgentProfilesResponse() = default;
};
class ListAllTenantBindNumberBindingResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> billingType{};
  shared_ptr<string> bindingId{};
  shared_ptr<vector<string>> instanceNameList{};
  shared_ptr<string> number{};
  shared_ptr<string> serializedParams{};
  shared_ptr<string> trunkName{};

  ListAllTenantBindNumberBindingResponseBodyDataList() {}

  explicit ListAllTenantBindNumberBindingResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billingType) {
      res["BillingType"] = boost::any(*billingType);
    }
    if (bindingId) {
      res["BindingId"] = boost::any(*bindingId);
    }
    if (instanceNameList) {
      res["InstanceNameList"] = boost::any(*instanceNameList);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (serializedParams) {
      res["SerializedParams"] = boost::any(*serializedParams);
    }
    if (trunkName) {
      res["TrunkName"] = boost::any(*trunkName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillingType") != m.end() && !m["BillingType"].empty()) {
      billingType = make_shared<string>(boost::any_cast<string>(m["BillingType"]));
    }
    if (m.find("BindingId") != m.end() && !m["BindingId"].empty()) {
      bindingId = make_shared<string>(boost::any_cast<string>(m["BindingId"]));
    }
    if (m.find("InstanceNameList") != m.end() && !m["InstanceNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("SerializedParams") != m.end() && !m["SerializedParams"].empty()) {
      serializedParams = make_shared<string>(boost::any_cast<string>(m["SerializedParams"]));
    }
    if (m.find("TrunkName") != m.end() && !m["TrunkName"].empty()) {
      trunkName = make_shared<string>(boost::any_cast<string>(m["TrunkName"]));
    }
  }


  virtual ~ListAllTenantBindNumberBindingResponseBodyDataList() = default;
};
class ListAllTenantBindNumberBindingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListAllTenantBindNumberBindingResponseBodyDataList>> list{};

  ListAllTenantBindNumberBindingResponseBodyData() {}

  explicit ListAllTenantBindNumberBindingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListAllTenantBindNumberBindingResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllTenantBindNumberBindingResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListAllTenantBindNumberBindingResponseBodyDataList>>(expect1);
      }
    }
  }


  virtual ~ListAllTenantBindNumberBindingResponseBodyData() = default;
};
class ListAllTenantBindNumberBindingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListAllTenantBindNumberBindingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAllTenantBindNumberBindingResponseBody() {}

  explicit ListAllTenantBindNumberBindingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAllTenantBindNumberBindingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAllTenantBindNumberBindingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAllTenantBindNumberBindingResponseBody() = default;
};
class ListAllTenantBindNumberBindingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAllTenantBindNumberBindingResponseBody> body{};

  ListAllTenantBindNumberBindingResponse() {}

  explicit ListAllTenantBindNumberBindingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAllTenantBindNumberBindingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAllTenantBindNumberBindingResponseBody>(model1);
      }
    }
  }


  virtual ~ListAllTenantBindNumberBindingResponse() = default;
};
class ListAnnotationMissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionName{};
  shared_ptr<vector<long>> annotationStatusListFilter{};
  shared_ptr<string> annotationStatusListStringFilter{};
  shared_ptr<long> createTimeEndFilter{};
  shared_ptr<long> createTimeStartFilter{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListAnnotationMissionRequest() {}

  explicit ListAnnotationMissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionName) {
      res["AnnotationMissionName"] = boost::any(*annotationMissionName);
    }
    if (annotationStatusListFilter) {
      res["AnnotationStatusListFilter"] = boost::any(*annotationStatusListFilter);
    }
    if (annotationStatusListStringFilter) {
      res["AnnotationStatusListStringFilter"] = boost::any(*annotationStatusListStringFilter);
    }
    if (createTimeEndFilter) {
      res["CreateTimeEndFilter"] = boost::any(*createTimeEndFilter);
    }
    if (createTimeStartFilter) {
      res["CreateTimeStartFilter"] = boost::any(*createTimeStartFilter);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionName") != m.end() && !m["AnnotationMissionName"].empty()) {
      annotationMissionName = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionName"]));
    }
    if (m.find("AnnotationStatusListFilter") != m.end() && !m["AnnotationStatusListFilter"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AnnotationStatusListFilter"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AnnotationStatusListFilter"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      annotationStatusListFilter = make_shared<vector<long>>(toVec1);
    }
    if (m.find("AnnotationStatusListStringFilter") != m.end() && !m["AnnotationStatusListStringFilter"].empty()) {
      annotationStatusListStringFilter = make_shared<string>(boost::any_cast<string>(m["AnnotationStatusListStringFilter"]));
    }
    if (m.find("CreateTimeEndFilter") != m.end() && !m["CreateTimeEndFilter"].empty()) {
      createTimeEndFilter = make_shared<long>(boost::any_cast<long>(m["CreateTimeEndFilter"]));
    }
    if (m.find("CreateTimeStartFilter") != m.end() && !m["CreateTimeStartFilter"].empty()) {
      createTimeStartFilter = make_shared<long>(boost::any_cast<long>(m["CreateTimeStartFilter"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListAnnotationMissionRequest() = default;
};
class ListAnnotationMissionResponseBodyDataAnnotationMissionList : public Darabonba::Model {
public:
  shared_ptr<long> annotationMissionDataSourceType{};
  shared_ptr<vector<long>> annotationMissionDebugDataSourceList{};
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionName{};
  shared_ptr<long> annotationStatus{};
  shared_ptr<long> conversationTimeEndFilter{};
  shared_ptr<long> conversationTimeStartFilter{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> excludeOtherMissionSession{};
  shared_ptr<long> finishTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> samplingCount{};
  shared_ptr<string> samplingDescription{};
  shared_ptr<long> samplingRate{};
  shared_ptr<long> samplingType{};
  shared_ptr<vector<long>> sessionEndReasonFilterList{};
  shared_ptr<long> sessionFinishCount{};
  shared_ptr<long> sessionTotalCount{};

  ListAnnotationMissionResponseBodyDataAnnotationMissionList() {}

  explicit ListAnnotationMissionResponseBodyDataAnnotationMissionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionDataSourceType) {
      res["AnnotationMissionDataSourceType"] = boost::any(*annotationMissionDataSourceType);
    }
    if (annotationMissionDebugDataSourceList) {
      res["AnnotationMissionDebugDataSourceList"] = boost::any(*annotationMissionDebugDataSourceList);
    }
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionName) {
      res["AnnotationMissionName"] = boost::any(*annotationMissionName);
    }
    if (annotationStatus) {
      res["AnnotationStatus"] = boost::any(*annotationStatus);
    }
    if (conversationTimeEndFilter) {
      res["ConversationTimeEndFilter"] = boost::any(*conversationTimeEndFilter);
    }
    if (conversationTimeStartFilter) {
      res["ConversationTimeStartFilter"] = boost::any(*conversationTimeStartFilter);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (excludeOtherMissionSession) {
      res["ExcludeOtherMissionSession"] = boost::any(*excludeOtherMissionSession);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (samplingCount) {
      res["SamplingCount"] = boost::any(*samplingCount);
    }
    if (samplingDescription) {
      res["SamplingDescription"] = boost::any(*samplingDescription);
    }
    if (samplingRate) {
      res["SamplingRate"] = boost::any(*samplingRate);
    }
    if (samplingType) {
      res["SamplingType"] = boost::any(*samplingType);
    }
    if (sessionEndReasonFilterList) {
      res["SessionEndReasonFilterList"] = boost::any(*sessionEndReasonFilterList);
    }
    if (sessionFinishCount) {
      res["SessionFinishCount"] = boost::any(*sessionFinishCount);
    }
    if (sessionTotalCount) {
      res["SessionTotalCount"] = boost::any(*sessionTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionDataSourceType") != m.end() && !m["AnnotationMissionDataSourceType"].empty()) {
      annotationMissionDataSourceType = make_shared<long>(boost::any_cast<long>(m["AnnotationMissionDataSourceType"]));
    }
    if (m.find("AnnotationMissionDebugDataSourceList") != m.end() && !m["AnnotationMissionDebugDataSourceList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AnnotationMissionDebugDataSourceList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AnnotationMissionDebugDataSourceList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      annotationMissionDebugDataSourceList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionName") != m.end() && !m["AnnotationMissionName"].empty()) {
      annotationMissionName = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionName"]));
    }
    if (m.find("AnnotationStatus") != m.end() && !m["AnnotationStatus"].empty()) {
      annotationStatus = make_shared<long>(boost::any_cast<long>(m["AnnotationStatus"]));
    }
    if (m.find("ConversationTimeEndFilter") != m.end() && !m["ConversationTimeEndFilter"].empty()) {
      conversationTimeEndFilter = make_shared<long>(boost::any_cast<long>(m["ConversationTimeEndFilter"]));
    }
    if (m.find("ConversationTimeStartFilter") != m.end() && !m["ConversationTimeStartFilter"].empty()) {
      conversationTimeStartFilter = make_shared<long>(boost::any_cast<long>(m["ConversationTimeStartFilter"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExcludeOtherMissionSession") != m.end() && !m["ExcludeOtherMissionSession"].empty()) {
      excludeOtherMissionSession = make_shared<bool>(boost::any_cast<bool>(m["ExcludeOtherMissionSession"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SamplingCount") != m.end() && !m["SamplingCount"].empty()) {
      samplingCount = make_shared<long>(boost::any_cast<long>(m["SamplingCount"]));
    }
    if (m.find("SamplingDescription") != m.end() && !m["SamplingDescription"].empty()) {
      samplingDescription = make_shared<string>(boost::any_cast<string>(m["SamplingDescription"]));
    }
    if (m.find("SamplingRate") != m.end() && !m["SamplingRate"].empty()) {
      samplingRate = make_shared<long>(boost::any_cast<long>(m["SamplingRate"]));
    }
    if (m.find("SamplingType") != m.end() && !m["SamplingType"].empty()) {
      samplingType = make_shared<long>(boost::any_cast<long>(m["SamplingType"]));
    }
    if (m.find("SessionEndReasonFilterList") != m.end() && !m["SessionEndReasonFilterList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SessionEndReasonFilterList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SessionEndReasonFilterList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      sessionEndReasonFilterList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SessionFinishCount") != m.end() && !m["SessionFinishCount"].empty()) {
      sessionFinishCount = make_shared<long>(boost::any_cast<long>(m["SessionFinishCount"]));
    }
    if (m.find("SessionTotalCount") != m.end() && !m["SessionTotalCount"].empty()) {
      sessionTotalCount = make_shared<long>(boost::any_cast<long>(m["SessionTotalCount"]));
    }
  }


  virtual ~ListAnnotationMissionResponseBodyDataAnnotationMissionList() = default;
};
class ListAnnotationMissionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListAnnotationMissionResponseBodyDataAnnotationMissionList>> annotationMissionList{};
  shared_ptr<string> message{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalPageCount{};

  ListAnnotationMissionResponseBodyData() {}

  explicit ListAnnotationMissionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionList") != m.end() && !m["AnnotationMissionList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionList"].type()) {
        vector<ListAnnotationMissionResponseBodyDataAnnotationMissionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnnotationMissionResponseBodyDataAnnotationMissionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionList = make_shared<vector<ListAnnotationMissionResponseBodyDataAnnotationMissionList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
  }


  virtual ~ListAnnotationMissionResponseBodyData() = default;
};
class ListAnnotationMissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListAnnotationMissionResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAnnotationMissionResponseBody() {}

  explicit ListAnnotationMissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAnnotationMissionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAnnotationMissionResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAnnotationMissionResponseBody() = default;
};
class ListAnnotationMissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAnnotationMissionResponseBody> body{};

  ListAnnotationMissionResponse() {}

  explicit ListAnnotationMissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAnnotationMissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAnnotationMissionResponseBody>(model1);
      }
    }
  }


  virtual ~ListAnnotationMissionResponse() = default;
};
class ListAnnotationMissionSessionRequest : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionSessionId{};
  shared_ptr<long> environment{};
  shared_ptr<string> includeStatusListJsonString{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListAnnotationMissionSessionRequest() {}

  explicit ListAnnotationMissionSessionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionSessionId) {
      res["AnnotationMissionSessionId"] = boost::any(*annotationMissionSessionId);
    }
    if (environment) {
      res["Environment"] = boost::any(*environment);
    }
    if (includeStatusListJsonString) {
      res["IncludeStatusListJsonString"] = boost::any(*includeStatusListJsonString);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionSessionId") != m.end() && !m["AnnotationMissionSessionId"].empty()) {
      annotationMissionSessionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionId"]));
    }
    if (m.find("Environment") != m.end() && !m["Environment"].empty()) {
      environment = make_shared<long>(boost::any_cast<long>(m["Environment"]));
    }
    if (m.find("IncludeStatusListJsonString") != m.end() && !m["IncludeStatusListJsonString"].empty()) {
      includeStatusListJsonString = make_shared<string>(boost::any_cast<string>(m["IncludeStatusListJsonString"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListAnnotationMissionSessionRequest() = default;
};
class ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionChatCustomizationDataInfoId{};
  shared_ptr<string> annotationMissionChatId{};
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionSessionId{};
  shared_ptr<string> content{};
  shared_ptr<bool> create{};
  shared_ptr<long> createTime{};
  shared_ptr<string> customizationDataDescription{};
  shared_ptr<string> customizationDataId{};
  shared_ptr<string> customizationDataName{};
  shared_ptr<long> customizationDataWeight{};
  shared_ptr<bool> delete_{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> modifiedTime{};

  ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList() {}

  explicit ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionChatCustomizationDataInfoId) {
      res["AnnotationMissionChatCustomizationDataInfoId"] = boost::any(*annotationMissionChatCustomizationDataInfoId);
    }
    if (annotationMissionChatId) {
      res["AnnotationMissionChatId"] = boost::any(*annotationMissionChatId);
    }
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionSessionId) {
      res["AnnotationMissionSessionId"] = boost::any(*annotationMissionSessionId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customizationDataDescription) {
      res["CustomizationDataDescription"] = boost::any(*customizationDataDescription);
    }
    if (customizationDataId) {
      res["CustomizationDataId"] = boost::any(*customizationDataId);
    }
    if (customizationDataName) {
      res["CustomizationDataName"] = boost::any(*customizationDataName);
    }
    if (customizationDataWeight) {
      res["CustomizationDataWeight"] = boost::any(*customizationDataWeight);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionChatCustomizationDataInfoId") != m.end() && !m["AnnotationMissionChatCustomizationDataInfoId"].empty()) {
      annotationMissionChatCustomizationDataInfoId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatCustomizationDataInfoId"]));
    }
    if (m.find("AnnotationMissionChatId") != m.end() && !m["AnnotationMissionChatId"].empty()) {
      annotationMissionChatId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatId"]));
    }
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionSessionId") != m.end() && !m["AnnotationMissionSessionId"].empty()) {
      annotationMissionSessionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<bool>(boost::any_cast<bool>(m["Create"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CustomizationDataDescription") != m.end() && !m["CustomizationDataDescription"].empty()) {
      customizationDataDescription = make_shared<string>(boost::any_cast<string>(m["CustomizationDataDescription"]));
    }
    if (m.find("CustomizationDataId") != m.end() && !m["CustomizationDataId"].empty()) {
      customizationDataId = make_shared<string>(boost::any_cast<string>(m["CustomizationDataId"]));
    }
    if (m.find("CustomizationDataName") != m.end() && !m["CustomizationDataName"].empty()) {
      customizationDataName = make_shared<string>(boost::any_cast<string>(m["CustomizationDataName"]));
    }
    if (m.find("CustomizationDataWeight") != m.end() && !m["CustomizationDataWeight"].empty()) {
      customizationDataWeight = make_shared<long>(boost::any_cast<long>(m["CustomizationDataWeight"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<bool>(boost::any_cast<bool>(m["Delete"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
  }


  virtual ~ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList() = default;
};
class ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionChatId{};
  shared_ptr<string> annotationMissionChatIntentUserSayInfoId{};
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionSessionId{};
  shared_ptr<string> botId{};
  shared_ptr<string> content{};
  shared_ptr<bool> create{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> delete_{};
  shared_ptr<long> dialogId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> intentId{};
  shared_ptr<long> modifiedTime{};

  ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList() {}

  explicit ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionChatId) {
      res["AnnotationMissionChatId"] = boost::any(*annotationMissionChatId);
    }
    if (annotationMissionChatIntentUserSayInfoId) {
      res["AnnotationMissionChatIntentUserSayInfoId"] = boost::any(*annotationMissionChatIntentUserSayInfoId);
    }
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionSessionId) {
      res["AnnotationMissionSessionId"] = boost::any(*annotationMissionSessionId);
    }
    if (botId) {
      res["BotId"] = boost::any(*botId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    if (dialogId) {
      res["DialogId"] = boost::any(*dialogId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionChatId") != m.end() && !m["AnnotationMissionChatId"].empty()) {
      annotationMissionChatId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatId"]));
    }
    if (m.find("AnnotationMissionChatIntentUserSayInfoId") != m.end() && !m["AnnotationMissionChatIntentUserSayInfoId"].empty()) {
      annotationMissionChatIntentUserSayInfoId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatIntentUserSayInfoId"]));
    }
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionSessionId") != m.end() && !m["AnnotationMissionSessionId"].empty()) {
      annotationMissionSessionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionId"]));
    }
    if (m.find("BotId") != m.end() && !m["BotId"].empty()) {
      botId = make_shared<string>(boost::any_cast<string>(m["BotId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<bool>(boost::any_cast<bool>(m["Create"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<bool>(boost::any_cast<bool>(m["Delete"]));
    }
    if (m.find("DialogId") != m.end() && !m["DialogId"].empty()) {
      dialogId = make_shared<long>(boost::any_cast<long>(m["DialogId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
  }


  virtual ~ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList() = default;
};
class ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionChatId{};
  shared_ptr<string> annotationMissionChatTagInfoId{};
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionSessionId{};
  shared_ptr<string> annotationMissionTagInfoId{};
  shared_ptr<string> annotationMissionTagInfoName{};
  shared_ptr<bool> create{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> delete_{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> modifiedTime{};

  ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList() {}

  explicit ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionChatId) {
      res["AnnotationMissionChatId"] = boost::any(*annotationMissionChatId);
    }
    if (annotationMissionChatTagInfoId) {
      res["AnnotationMissionChatTagInfoId"] = boost::any(*annotationMissionChatTagInfoId);
    }
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionSessionId) {
      res["AnnotationMissionSessionId"] = boost::any(*annotationMissionSessionId);
    }
    if (annotationMissionTagInfoId) {
      res["AnnotationMissionTagInfoId"] = boost::any(*annotationMissionTagInfoId);
    }
    if (annotationMissionTagInfoName) {
      res["AnnotationMissionTagInfoName"] = boost::any(*annotationMissionTagInfoName);
    }
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionChatId") != m.end() && !m["AnnotationMissionChatId"].empty()) {
      annotationMissionChatId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatId"]));
    }
    if (m.find("AnnotationMissionChatTagInfoId") != m.end() && !m["AnnotationMissionChatTagInfoId"].empty()) {
      annotationMissionChatTagInfoId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatTagInfoId"]));
    }
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionSessionId") != m.end() && !m["AnnotationMissionSessionId"].empty()) {
      annotationMissionSessionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionId"]));
    }
    if (m.find("AnnotationMissionTagInfoId") != m.end() && !m["AnnotationMissionTagInfoId"].empty()) {
      annotationMissionTagInfoId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionTagInfoId"]));
    }
    if (m.find("AnnotationMissionTagInfoName") != m.end() && !m["AnnotationMissionTagInfoName"].empty()) {
      annotationMissionTagInfoName = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionTagInfoName"]));
    }
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<bool>(boost::any_cast<bool>(m["Create"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<bool>(boost::any_cast<bool>(m["Delete"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
  }


  virtual ~ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList() = default;
};
class ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionChatId{};
  shared_ptr<string> annotationMissionChatVocabularyInfoId{};
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionSessionId{};
  shared_ptr<bool> create{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> delete_{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> vocabulary{};
  shared_ptr<string> vocabularyDescription{};
  shared_ptr<string> vocabularyId{};
  shared_ptr<string> vocabularyName{};
  shared_ptr<long> vocabularyWeight{};

  ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList() {}

  explicit ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionChatId) {
      res["AnnotationMissionChatId"] = boost::any(*annotationMissionChatId);
    }
    if (annotationMissionChatVocabularyInfoId) {
      res["AnnotationMissionChatVocabularyInfoId"] = boost::any(*annotationMissionChatVocabularyInfoId);
    }
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionSessionId) {
      res["AnnotationMissionSessionId"] = boost::any(*annotationMissionSessionId);
    }
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (vocabulary) {
      res["Vocabulary"] = boost::any(*vocabulary);
    }
    if (vocabularyDescription) {
      res["VocabularyDescription"] = boost::any(*vocabularyDescription);
    }
    if (vocabularyId) {
      res["VocabularyId"] = boost::any(*vocabularyId);
    }
    if (vocabularyName) {
      res["VocabularyName"] = boost::any(*vocabularyName);
    }
    if (vocabularyWeight) {
      res["VocabularyWeight"] = boost::any(*vocabularyWeight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionChatId") != m.end() && !m["AnnotationMissionChatId"].empty()) {
      annotationMissionChatId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatId"]));
    }
    if (m.find("AnnotationMissionChatVocabularyInfoId") != m.end() && !m["AnnotationMissionChatVocabularyInfoId"].empty()) {
      annotationMissionChatVocabularyInfoId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatVocabularyInfoId"]));
    }
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionSessionId") != m.end() && !m["AnnotationMissionSessionId"].empty()) {
      annotationMissionSessionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionId"]));
    }
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<bool>(boost::any_cast<bool>(m["Create"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<bool>(boost::any_cast<bool>(m["Delete"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("Vocabulary") != m.end() && !m["Vocabulary"].empty()) {
      vocabulary = make_shared<string>(boost::any_cast<string>(m["Vocabulary"]));
    }
    if (m.find("VocabularyDescription") != m.end() && !m["VocabularyDescription"].empty()) {
      vocabularyDescription = make_shared<string>(boost::any_cast<string>(m["VocabularyDescription"]));
    }
    if (m.find("VocabularyId") != m.end() && !m["VocabularyId"].empty()) {
      vocabularyId = make_shared<string>(boost::any_cast<string>(m["VocabularyId"]));
    }
    if (m.find("VocabularyName") != m.end() && !m["VocabularyName"].empty()) {
      vocabularyName = make_shared<string>(boost::any_cast<string>(m["VocabularyName"]));
    }
    if (m.find("VocabularyWeight") != m.end() && !m["VocabularyWeight"].empty()) {
      vocabularyWeight = make_shared<long>(boost::any_cast<long>(m["VocabularyWeight"]));
    }
  }


  virtual ~ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList() = default;
};
class ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatList : public Darabonba::Model {
public:
  shared_ptr<string> annotationAsrResult{};
  shared_ptr<vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList>> annotationMissionChatCustomizationDataInfoList{};
  shared_ptr<string> annotationMissionChatId{};
  shared_ptr<vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList>> annotationMissionChatIntentUserSayInfoList{};
  shared_ptr<vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList>> annotationMissionChatTagInfoList{};
  shared_ptr<vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList>> annotationMissionChatVocabularyInfoList{};
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionSessionId{};
  shared_ptr<long> annotationStatus{};
  shared_ptr<string> answer{};
  shared_ptr<long> asrAnnotationStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> intentAnnotationStatus{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<long> occurTime{};
  shared_ptr<string> originalAsrResult{};
  shared_ptr<string> sequenceId{};
  shared_ptr<long> subStatus{};
  shared_ptr<long> tagAnnotationStatus{};
  shared_ptr<long> translationError{};

  ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatList() {}

  explicit ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationAsrResult) {
      res["AnnotationAsrResult"] = boost::any(*annotationAsrResult);
    }
    if (annotationMissionChatCustomizationDataInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionChatCustomizationDataInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionChatCustomizationDataInfoList"] = boost::any(temp1);
    }
    if (annotationMissionChatId) {
      res["AnnotationMissionChatId"] = boost::any(*annotationMissionChatId);
    }
    if (annotationMissionChatIntentUserSayInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionChatIntentUserSayInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionChatIntentUserSayInfoList"] = boost::any(temp1);
    }
    if (annotationMissionChatTagInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionChatTagInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionChatTagInfoList"] = boost::any(temp1);
    }
    if (annotationMissionChatVocabularyInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionChatVocabularyInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionChatVocabularyInfoList"] = boost::any(temp1);
    }
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionSessionId) {
      res["AnnotationMissionSessionId"] = boost::any(*annotationMissionSessionId);
    }
    if (annotationStatus) {
      res["AnnotationStatus"] = boost::any(*annotationStatus);
    }
    if (answer) {
      res["Answer"] = boost::any(*answer);
    }
    if (asrAnnotationStatus) {
      res["AsrAnnotationStatus"] = boost::any(*asrAnnotationStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentAnnotationStatus) {
      res["IntentAnnotationStatus"] = boost::any(*intentAnnotationStatus);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (occurTime) {
      res["OccurTime"] = boost::any(*occurTime);
    }
    if (originalAsrResult) {
      res["OriginalAsrResult"] = boost::any(*originalAsrResult);
    }
    if (sequenceId) {
      res["SequenceId"] = boost::any(*sequenceId);
    }
    if (subStatus) {
      res["SubStatus"] = boost::any(*subStatus);
    }
    if (tagAnnotationStatus) {
      res["TagAnnotationStatus"] = boost::any(*tagAnnotationStatus);
    }
    if (translationError) {
      res["TranslationError"] = boost::any(*translationError);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationAsrResult") != m.end() && !m["AnnotationAsrResult"].empty()) {
      annotationAsrResult = make_shared<string>(boost::any_cast<string>(m["AnnotationAsrResult"]));
    }
    if (m.find("AnnotationMissionChatCustomizationDataInfoList") != m.end() && !m["AnnotationMissionChatCustomizationDataInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionChatCustomizationDataInfoList"].type()) {
        vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionChatCustomizationDataInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionChatCustomizationDataInfoList = make_shared<vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList>>(expect1);
      }
    }
    if (m.find("AnnotationMissionChatId") != m.end() && !m["AnnotationMissionChatId"].empty()) {
      annotationMissionChatId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatId"]));
    }
    if (m.find("AnnotationMissionChatIntentUserSayInfoList") != m.end() && !m["AnnotationMissionChatIntentUserSayInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionChatIntentUserSayInfoList"].type()) {
        vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionChatIntentUserSayInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionChatIntentUserSayInfoList = make_shared<vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList>>(expect1);
      }
    }
    if (m.find("AnnotationMissionChatTagInfoList") != m.end() && !m["AnnotationMissionChatTagInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionChatTagInfoList"].type()) {
        vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionChatTagInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionChatTagInfoList = make_shared<vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList>>(expect1);
      }
    }
    if (m.find("AnnotationMissionChatVocabularyInfoList") != m.end() && !m["AnnotationMissionChatVocabularyInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionChatVocabularyInfoList"].type()) {
        vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionChatVocabularyInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionChatVocabularyInfoList = make_shared<vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList>>(expect1);
      }
    }
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionSessionId") != m.end() && !m["AnnotationMissionSessionId"].empty()) {
      annotationMissionSessionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionId"]));
    }
    if (m.find("AnnotationStatus") != m.end() && !m["AnnotationStatus"].empty()) {
      annotationStatus = make_shared<long>(boost::any_cast<long>(m["AnnotationStatus"]));
    }
    if (m.find("Answer") != m.end() && !m["Answer"].empty()) {
      answer = make_shared<string>(boost::any_cast<string>(m["Answer"]));
    }
    if (m.find("AsrAnnotationStatus") != m.end() && !m["AsrAnnotationStatus"].empty()) {
      asrAnnotationStatus = make_shared<long>(boost::any_cast<long>(m["AsrAnnotationStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentAnnotationStatus") != m.end() && !m["IntentAnnotationStatus"].empty()) {
      intentAnnotationStatus = make_shared<long>(boost::any_cast<long>(m["IntentAnnotationStatus"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("OccurTime") != m.end() && !m["OccurTime"].empty()) {
      occurTime = make_shared<long>(boost::any_cast<long>(m["OccurTime"]));
    }
    if (m.find("OriginalAsrResult") != m.end() && !m["OriginalAsrResult"].empty()) {
      originalAsrResult = make_shared<string>(boost::any_cast<string>(m["OriginalAsrResult"]));
    }
    if (m.find("SequenceId") != m.end() && !m["SequenceId"].empty()) {
      sequenceId = make_shared<string>(boost::any_cast<string>(m["SequenceId"]));
    }
    if (m.find("SubStatus") != m.end() && !m["SubStatus"].empty()) {
      subStatus = make_shared<long>(boost::any_cast<long>(m["SubStatus"]));
    }
    if (m.find("TagAnnotationStatus") != m.end() && !m["TagAnnotationStatus"].empty()) {
      tagAnnotationStatus = make_shared<long>(boost::any_cast<long>(m["TagAnnotationStatus"]));
    }
    if (m.find("TranslationError") != m.end() && !m["TranslationError"].empty()) {
      translationError = make_shared<long>(boost::any_cast<long>(m["TranslationError"]));
    }
  }


  virtual ~ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatList() = default;
};
class ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatList>> annotationMissionChatList{};
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionSessionId{};
  shared_ptr<long> annotationStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> debugConversation{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> sessionId{};
  shared_ptr<long> version{};

  ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionList() {}

  explicit ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionChatList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionChatList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionChatList"] = boost::any(temp1);
    }
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionSessionId) {
      res["AnnotationMissionSessionId"] = boost::any(*annotationMissionSessionId);
    }
    if (annotationStatus) {
      res["AnnotationStatus"] = boost::any(*annotationStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (debugConversation) {
      res["DebugConversation"] = boost::any(*debugConversation);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionChatList") != m.end() && !m["AnnotationMissionChatList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionChatList"].type()) {
        vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionChatList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionChatList = make_shared<vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionListAnnotationMissionChatList>>(expect1);
      }
    }
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionSessionId") != m.end() && !m["AnnotationMissionSessionId"].empty()) {
      annotationMissionSessionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionId"]));
    }
    if (m.find("AnnotationStatus") != m.end() && !m["AnnotationStatus"].empty()) {
      annotationStatus = make_shared<long>(boost::any_cast<long>(m["AnnotationStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DebugConversation") != m.end() && !m["DebugConversation"].empty()) {
      debugConversation = make_shared<bool>(boost::any_cast<bool>(m["DebugConversation"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionList() = default;
};
class ListAnnotationMissionSessionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionId{};
  shared_ptr<vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionList>> annotationMissionSessionList{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListAnnotationMissionSessionResponseBodyData() {}

  explicit ListAnnotationMissionSessionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionSessionList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionSessionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionSessionList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionSessionList") != m.end() && !m["AnnotationMissionSessionList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionSessionList"].type()) {
        vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionSessionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionSessionList = make_shared<vector<ListAnnotationMissionSessionResponseBodyDataAnnotationMissionSessionList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAnnotationMissionSessionResponseBodyData() = default;
};
class ListAnnotationMissionSessionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListAnnotationMissionSessionResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAnnotationMissionSessionResponseBody() {}

  explicit ListAnnotationMissionSessionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAnnotationMissionSessionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAnnotationMissionSessionResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAnnotationMissionSessionResponseBody() = default;
};
class ListAnnotationMissionSessionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAnnotationMissionSessionResponseBody> body{};

  ListAnnotationMissionSessionResponse() {}

  explicit ListAnnotationMissionSessionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAnnotationMissionSessionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAnnotationMissionSessionResponseBody>(model1);
      }
    }
  }


  virtual ~ListAnnotationMissionSessionResponse() = default;
};
class ListApiPluginsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> uuidsJson{};

  ListApiPluginsRequest() {}

  explicit ListApiPluginsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (uuidsJson) {
      res["UuidsJson"] = boost::any(*uuidsJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("UuidsJson") != m.end() && !m["UuidsJson"].empty()) {
      uuidsJson = make_shared<string>(boost::any_cast<string>(m["UuidsJson"]));
    }
  }


  virtual ~ListApiPluginsRequest() = default;
};
class ListApiPluginsResponseBodyApiPlugins : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> draftedConfigJson{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> publishedConfigJson{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};

  ListApiPluginsResponseBodyApiPlugins() {}

  explicit ListApiPluginsResponseBodyApiPlugins(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (draftedConfigJson) {
      res["DraftedConfigJson"] = boost::any(*draftedConfigJson);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (publishedConfigJson) {
      res["PublishedConfigJson"] = boost::any(*publishedConfigJson);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DraftedConfigJson") != m.end() && !m["DraftedConfigJson"].empty()) {
      draftedConfigJson = make_shared<string>(boost::any_cast<string>(m["DraftedConfigJson"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PublishedConfigJson") != m.end() && !m["PublishedConfigJson"].empty()) {
      publishedConfigJson = make_shared<string>(boost::any_cast<string>(m["PublishedConfigJson"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ListApiPluginsResponseBodyApiPlugins() = default;
};
class ListApiPluginsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListApiPluginsResponseBodyApiPlugins>> apiPlugins{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListApiPluginsResponseBody() {}

  explicit ListApiPluginsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiPlugins) {
      vector<boost::any> temp1;
      for(auto item1:*apiPlugins){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiPlugins"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiPlugins") != m.end() && !m["ApiPlugins"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiPlugins"].type()) {
        vector<ListApiPluginsResponseBodyApiPlugins> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiPlugins"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApiPluginsResponseBodyApiPlugins model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiPlugins = make_shared<vector<ListApiPluginsResponseBodyApiPlugins>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListApiPluginsResponseBody() = default;
};
class ListApiPluginsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApiPluginsResponseBody> body{};

  ListApiPluginsResponse() {}

  explicit ListApiPluginsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApiPluginsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApiPluginsResponseBody>(model1);
      }
    }
  }


  virtual ~ListApiPluginsResponse() = default;
};
class ListBeebotIntentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> intentName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scriptId{};

  ListBeebotIntentRequest() {}

  explicit ListBeebotIntentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentName) {
      res["IntentName"] = boost::any(*intentName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentName") != m.end() && !m["IntentName"].empty()) {
      intentName = make_shared<string>(boost::any_cast<string>(m["IntentName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ListBeebotIntentRequest() = default;
};
class ListBeebotIntentResponseBodyIntents : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUserId{};
  shared_ptr<string> createUserName{};
  shared_ptr<long> intentId{};
  shared_ptr<string> intentName{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> modifyUserId{};
  shared_ptr<string> modifyUserName{};

  ListBeebotIntentResponseBodyIntents() {}

  explicit ListBeebotIntentResponseBodyIntents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUserId) {
      res["CreateUserId"] = boost::any(*createUserId);
    }
    if (createUserName) {
      res["CreateUserName"] = boost::any(*createUserName);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (intentName) {
      res["IntentName"] = boost::any(*intentName);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (modifyUserId) {
      res["ModifyUserId"] = boost::any(*modifyUserId);
    }
    if (modifyUserName) {
      res["ModifyUserName"] = boost::any(*modifyUserName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUserId") != m.end() && !m["CreateUserId"].empty()) {
      createUserId = make_shared<string>(boost::any_cast<string>(m["CreateUserId"]));
    }
    if (m.find("CreateUserName") != m.end() && !m["CreateUserName"].empty()) {
      createUserName = make_shared<string>(boost::any_cast<string>(m["CreateUserName"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("IntentName") != m.end() && !m["IntentName"].empty()) {
      intentName = make_shared<string>(boost::any_cast<string>(m["IntentName"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("ModifyUserId") != m.end() && !m["ModifyUserId"].empty()) {
      modifyUserId = make_shared<string>(boost::any_cast<string>(m["ModifyUserId"]));
    }
    if (m.find("ModifyUserName") != m.end() && !m["ModifyUserName"].empty()) {
      modifyUserName = make_shared<string>(boost::any_cast<string>(m["ModifyUserName"]));
    }
  }


  virtual ~ListBeebotIntentResponseBodyIntents() = default;
};
class ListBeebotIntentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beebotRequestId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<ListBeebotIntentResponseBodyIntents>> intents{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListBeebotIntentResponseBody() {}

  explicit ListBeebotIntentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beebotRequestId) {
      res["BeebotRequestId"] = boost::any(*beebotRequestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (intents) {
      vector<boost::any> temp1;
      for(auto item1:*intents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Intents"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeebotRequestId") != m.end() && !m["BeebotRequestId"].empty()) {
      beebotRequestId = make_shared<string>(boost::any_cast<string>(m["BeebotRequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Intents") != m.end() && !m["Intents"].empty()) {
      if (typeid(vector<boost::any>) == m["Intents"].type()) {
        vector<ListBeebotIntentResponseBodyIntents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Intents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBeebotIntentResponseBodyIntents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        intents = make_shared<vector<ListBeebotIntentResponseBodyIntents>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListBeebotIntentResponseBody() = default;
};
class ListBeebotIntentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBeebotIntentResponseBody> body{};

  ListBeebotIntentResponse() {}

  explicit ListBeebotIntentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBeebotIntentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBeebotIntentResponseBody>(model1);
      }
    }
  }


  virtual ~ListBeebotIntentResponse() = default;
};
class ListBeebotIntentLgfRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> intentId{};
  shared_ptr<string> lgfText{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scriptId{};

  ListBeebotIntentLgfRequest() {}

  explicit ListBeebotIntentLgfRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (lgfText) {
      res["LgfText"] = boost::any(*lgfText);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
    if (m.find("LgfText") != m.end() && !m["LgfText"].empty()) {
      lgfText = make_shared<string>(boost::any_cast<string>(m["LgfText"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ListBeebotIntentLgfRequest() = default;
};
class ListBeebotIntentLgfResponseBodyLgfs : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> intentId{};
  shared_ptr<long> lgfId{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> ruleText{};

  ListBeebotIntentLgfResponseBodyLgfs() {}

  explicit ListBeebotIntentLgfResponseBodyLgfs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (lgfId) {
      res["LgfId"] = boost::any(*lgfId);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (ruleText) {
      res["RuleText"] = boost::any(*ruleText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("LgfId") != m.end() && !m["LgfId"].empty()) {
      lgfId = make_shared<long>(boost::any_cast<long>(m["LgfId"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("RuleText") != m.end() && !m["RuleText"].empty()) {
      ruleText = make_shared<string>(boost::any_cast<string>(m["RuleText"]));
    }
  }


  virtual ~ListBeebotIntentLgfResponseBodyLgfs() = default;
};
class ListBeebotIntentLgfResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beebotRequestId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<ListBeebotIntentLgfResponseBodyLgfs>> lgfs{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListBeebotIntentLgfResponseBody() {}

  explicit ListBeebotIntentLgfResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beebotRequestId) {
      res["BeebotRequestId"] = boost::any(*beebotRequestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (lgfs) {
      vector<boost::any> temp1;
      for(auto item1:*lgfs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Lgfs"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeebotRequestId") != m.end() && !m["BeebotRequestId"].empty()) {
      beebotRequestId = make_shared<string>(boost::any_cast<string>(m["BeebotRequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Lgfs") != m.end() && !m["Lgfs"].empty()) {
      if (typeid(vector<boost::any>) == m["Lgfs"].type()) {
        vector<ListBeebotIntentLgfResponseBodyLgfs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Lgfs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBeebotIntentLgfResponseBodyLgfs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lgfs = make_shared<vector<ListBeebotIntentLgfResponseBodyLgfs>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListBeebotIntentLgfResponseBody() = default;
};
class ListBeebotIntentLgfResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBeebotIntentLgfResponseBody> body{};

  ListBeebotIntentLgfResponse() {}

  explicit ListBeebotIntentLgfResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBeebotIntentLgfResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBeebotIntentLgfResponseBody>(model1);
      }
    }
  }


  virtual ~ListBeebotIntentLgfResponse() = default;
};
class ListBeebotIntentUserSayRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> intentId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scriptId{};

  ListBeebotIntentUserSayRequest() {}

  explicit ListBeebotIntentUserSayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ListBeebotIntentUserSayRequest() = default;
};
class ListBeebotIntentUserSayResponseBodyUserSays : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> createTime{};
  shared_ptr<long> intentId{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> userSayId{};

  ListBeebotIntentUserSayResponseBodyUserSays() {}

  explicit ListBeebotIntentUserSayResponseBodyUserSays(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (userSayId) {
      res["UserSayId"] = boost::any(*userSayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("UserSayId") != m.end() && !m["UserSayId"].empty()) {
      userSayId = make_shared<string>(boost::any_cast<string>(m["UserSayId"]));
    }
  }


  virtual ~ListBeebotIntentUserSayResponseBodyUserSays() = default;
};
class ListBeebotIntentUserSayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beebotRequestId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListBeebotIntentUserSayResponseBodyUserSays>> userSays{};

  ListBeebotIntentUserSayResponseBody() {}

  explicit ListBeebotIntentUserSayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beebotRequestId) {
      res["BeebotRequestId"] = boost::any(*beebotRequestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (userSays) {
      vector<boost::any> temp1;
      for(auto item1:*userSays){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserSays"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeebotRequestId") != m.end() && !m["BeebotRequestId"].empty()) {
      beebotRequestId = make_shared<string>(boost::any_cast<string>(m["BeebotRequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UserSays") != m.end() && !m["UserSays"].empty()) {
      if (typeid(vector<boost::any>) == m["UserSays"].type()) {
        vector<ListBeebotIntentUserSayResponseBodyUserSays> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserSays"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBeebotIntentUserSayResponseBodyUserSays model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userSays = make_shared<vector<ListBeebotIntentUserSayResponseBodyUserSays>>(expect1);
      }
    }
  }


  virtual ~ListBeebotIntentUserSayResponseBody() = default;
};
class ListBeebotIntentUserSayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBeebotIntentUserSayResponseBody> body{};

  ListBeebotIntentUserSayResponse() {}

  explicit ListBeebotIntentUserSayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBeebotIntentUserSayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBeebotIntentUserSayResponseBody>(model1);
      }
    }
  }


  virtual ~ListBeebotIntentUserSayResponse() = default;
};
class ListChatbotInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListChatbotInstancesRequest() {}

  explicit ListChatbotInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListChatbotInstancesRequest() = default;
};
class ListChatbotInstancesResponseBodyBots : public Darabonba::Model {
public:
  shared_ptr<string> avatar{};
  shared_ptr<string> createTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> introduction{};
  shared_ptr<string> languageCode{};
  shared_ptr<string> name{};
  shared_ptr<string> timeZone{};

  ListChatbotInstancesResponseBodyBots() {}

  explicit ListChatbotInstancesResponseBodyBots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatar) {
      res["Avatar"] = boost::any(*avatar);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (introduction) {
      res["Introduction"] = boost::any(*introduction);
    }
    if (languageCode) {
      res["LanguageCode"] = boost::any(*languageCode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avatar") != m.end() && !m["Avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["Avatar"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Introduction") != m.end() && !m["Introduction"].empty()) {
      introduction = make_shared<string>(boost::any_cast<string>(m["Introduction"]));
    }
    if (m.find("LanguageCode") != m.end() && !m["LanguageCode"].empty()) {
      languageCode = make_shared<string>(boost::any_cast<string>(m["LanguageCode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~ListChatbotInstancesResponseBodyBots() = default;
};
class ListChatbotInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListChatbotInstancesResponseBodyBots>> bots{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListChatbotInstancesResponseBody() {}

  explicit ListChatbotInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bots) {
      vector<boost::any> temp1;
      for(auto item1:*bots){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Bots"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bots") != m.end() && !m["Bots"].empty()) {
      if (typeid(vector<boost::any>) == m["Bots"].type()) {
        vector<ListChatbotInstancesResponseBodyBots> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Bots"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListChatbotInstancesResponseBodyBots model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bots = make_shared<vector<ListChatbotInstancesResponseBodyBots>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListChatbotInstancesResponseBody() = default;
};
class ListChatbotInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListChatbotInstancesResponseBody> body{};

  ListChatbotInstancesResponse() {}

  explicit ListChatbotInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListChatbotInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListChatbotInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListChatbotInstancesResponse() = default;
};
class ListDialogueFlowsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  ListDialogueFlowsRequest() {}

  explicit ListDialogueFlowsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ListDialogueFlowsRequest() = default;
};
class ListDialogueFlowsResponseBodyDialogueFlows : public Darabonba::Model {
public:
  shared_ptr<string> dialogueFlowDefinition{};
  shared_ptr<string> dialogueFlowId{};
  shared_ptr<string> dialogueFlowName{};
  shared_ptr<string> dialogueFlowType{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptVersion{};

  ListDialogueFlowsResponseBodyDialogueFlows() {}

  explicit ListDialogueFlowsResponseBodyDialogueFlows(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dialogueFlowDefinition) {
      res["DialogueFlowDefinition"] = boost::any(*dialogueFlowDefinition);
    }
    if (dialogueFlowId) {
      res["DialogueFlowId"] = boost::any(*dialogueFlowId);
    }
    if (dialogueFlowName) {
      res["DialogueFlowName"] = boost::any(*dialogueFlowName);
    }
    if (dialogueFlowType) {
      res["DialogueFlowType"] = boost::any(*dialogueFlowType);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptVersion) {
      res["ScriptVersion"] = boost::any(*scriptVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DialogueFlowDefinition") != m.end() && !m["DialogueFlowDefinition"].empty()) {
      dialogueFlowDefinition = make_shared<string>(boost::any_cast<string>(m["DialogueFlowDefinition"]));
    }
    if (m.find("DialogueFlowId") != m.end() && !m["DialogueFlowId"].empty()) {
      dialogueFlowId = make_shared<string>(boost::any_cast<string>(m["DialogueFlowId"]));
    }
    if (m.find("DialogueFlowName") != m.end() && !m["DialogueFlowName"].empty()) {
      dialogueFlowName = make_shared<string>(boost::any_cast<string>(m["DialogueFlowName"]));
    }
    if (m.find("DialogueFlowType") != m.end() && !m["DialogueFlowType"].empty()) {
      dialogueFlowType = make_shared<string>(boost::any_cast<string>(m["DialogueFlowType"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptVersion") != m.end() && !m["ScriptVersion"].empty()) {
      scriptVersion = make_shared<string>(boost::any_cast<string>(m["ScriptVersion"]));
    }
  }


  virtual ~ListDialogueFlowsResponseBodyDialogueFlows() = default;
};
class ListDialogueFlowsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListDialogueFlowsResponseBodyDialogueFlows>> dialogueFlows{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListDialogueFlowsResponseBody() {}

  explicit ListDialogueFlowsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dialogueFlows) {
      vector<boost::any> temp1;
      for(auto item1:*dialogueFlows){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DialogueFlows"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DialogueFlows") != m.end() && !m["DialogueFlows"].empty()) {
      if (typeid(vector<boost::any>) == m["DialogueFlows"].type()) {
        vector<ListDialogueFlowsResponseBodyDialogueFlows> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DialogueFlows"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDialogueFlowsResponseBodyDialogueFlows model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dialogueFlows = make_shared<vector<ListDialogueFlowsResponseBodyDialogueFlows>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListDialogueFlowsResponseBody() = default;
};
class ListDialogueFlowsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDialogueFlowsResponseBody> body{};

  ListDialogueFlowsResponse() {}

  explicit ListDialogueFlowsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDialogueFlowsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDialogueFlowsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDialogueFlowsResponse() = default;
};
class ListDownloadTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListDownloadTasksRequest() {}

  explicit ListDownloadTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListDownloadTasksRequest() = default;
};
class ListDownloadTasksResponseBodyDownloadTasksListDownloadTaskFiles : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<long> progress{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};

  ListDownloadTasksResponseBodyDownloadTasksListDownloadTaskFiles() {}

  explicit ListDownloadTasksResponseBodyDownloadTasksListDownloadTaskFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~ListDownloadTasksResponseBodyDownloadTasksListDownloadTaskFiles() = default;
};
class ListDownloadTasksResponseBodyDownloadTasksList : public Darabonba::Model {
public:
  shared_ptr<vector<ListDownloadTasksResponseBodyDownloadTasksListDownloadTaskFiles>> downloadTaskFiles{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> title{};

  ListDownloadTasksResponseBodyDownloadTasksList() {}

  explicit ListDownloadTasksResponseBodyDownloadTasksList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadTaskFiles) {
      vector<boost::any> temp1;
      for(auto item1:*downloadTaskFiles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DownloadTaskFiles"] = boost::any(temp1);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadTaskFiles") != m.end() && !m["DownloadTaskFiles"].empty()) {
      if (typeid(vector<boost::any>) == m["DownloadTaskFiles"].type()) {
        vector<ListDownloadTasksResponseBodyDownloadTasksListDownloadTaskFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DownloadTaskFiles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDownloadTasksResponseBodyDownloadTasksListDownloadTaskFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        downloadTaskFiles = make_shared<vector<ListDownloadTasksResponseBodyDownloadTasksListDownloadTaskFiles>>(expect1);
      }
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~ListDownloadTasksResponseBodyDownloadTasksList() = default;
};
class ListDownloadTasksResponseBodyDownloadTasks : public Darabonba::Model {
public:
  shared_ptr<vector<ListDownloadTasksResponseBodyDownloadTasksList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDownloadTasksResponseBodyDownloadTasks() {}

  explicit ListDownloadTasksResponseBodyDownloadTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListDownloadTasksResponseBodyDownloadTasksList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDownloadTasksResponseBodyDownloadTasksList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListDownloadTasksResponseBodyDownloadTasksList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDownloadTasksResponseBodyDownloadTasks() = default;
};
class ListDownloadTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListDownloadTasksResponseBodyDownloadTasks> downloadTasks{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListDownloadTasksResponseBody() {}

  explicit ListDownloadTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (downloadTasks) {
      res["DownloadTasks"] = downloadTasks ? boost::any(downloadTasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DownloadTasks") != m.end() && !m["DownloadTasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadTasks"].type()) {
        ListDownloadTasksResponseBodyDownloadTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadTasks"]));
        downloadTasks = make_shared<ListDownloadTasksResponseBodyDownloadTasks>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListDownloadTasksResponseBody() = default;
};
class ListDownloadTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDownloadTasksResponseBody> body{};

  ListDownloadTasksResponse() {}

  explicit ListDownloadTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDownloadTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDownloadTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListDownloadTasksResponse() = default;
};
class ListFlashSmsTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> providerId{};

  ListFlashSmsTemplatesRequest() {}

  explicit ListFlashSmsTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
  }


  virtual ~ListFlashSmsTemplatesRequest() = default;
};
class ListFlashSmsTemplatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> templateContent{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  ListFlashSmsTemplatesResponseBodyData() {}

  explicit ListFlashSmsTemplatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~ListFlashSmsTemplatesResponseBodyData() = default;
};
class ListFlashSmsTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListFlashSmsTemplatesResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListFlashSmsTemplatesResponseBody() {}

  explicit ListFlashSmsTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListFlashSmsTemplatesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlashSmsTemplatesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListFlashSmsTemplatesResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListFlashSmsTemplatesResponseBody() = default;
};
class ListFlashSmsTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlashSmsTemplatesResponseBody> body{};

  ListFlashSmsTemplatesResponse() {}

  explicit ListFlashSmsTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlashSmsTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlashSmsTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlashSmsTemplatesResponse() = default;
};
class ListGlobalQuestionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scriptId{};

  ListGlobalQuestionsRequest() {}

  explicit ListGlobalQuestionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ListGlobalQuestionsRequest() = default;
};
class ListGlobalQuestionsResponseBodyGlobalQuestionsList : public Darabonba::Model {
public:
  shared_ptr<string> answers{};
  shared_ptr<string> globalQuestionId{};
  shared_ptr<string> globalQuestionName{};
  shared_ptr<string> globalQuestionType{};
  shared_ptr<string> questions{};
  shared_ptr<string> scriptId{};

  ListGlobalQuestionsResponseBodyGlobalQuestionsList() {}

  explicit ListGlobalQuestionsResponseBodyGlobalQuestionsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answers) {
      res["Answers"] = boost::any(*answers);
    }
    if (globalQuestionId) {
      res["GlobalQuestionId"] = boost::any(*globalQuestionId);
    }
    if (globalQuestionName) {
      res["GlobalQuestionName"] = boost::any(*globalQuestionName);
    }
    if (globalQuestionType) {
      res["GlobalQuestionType"] = boost::any(*globalQuestionType);
    }
    if (questions) {
      res["Questions"] = boost::any(*questions);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Answers") != m.end() && !m["Answers"].empty()) {
      answers = make_shared<string>(boost::any_cast<string>(m["Answers"]));
    }
    if (m.find("GlobalQuestionId") != m.end() && !m["GlobalQuestionId"].empty()) {
      globalQuestionId = make_shared<string>(boost::any_cast<string>(m["GlobalQuestionId"]));
    }
    if (m.find("GlobalQuestionName") != m.end() && !m["GlobalQuestionName"].empty()) {
      globalQuestionName = make_shared<string>(boost::any_cast<string>(m["GlobalQuestionName"]));
    }
    if (m.find("GlobalQuestionType") != m.end() && !m["GlobalQuestionType"].empty()) {
      globalQuestionType = make_shared<string>(boost::any_cast<string>(m["GlobalQuestionType"]));
    }
    if (m.find("Questions") != m.end() && !m["Questions"].empty()) {
      questions = make_shared<string>(boost::any_cast<string>(m["Questions"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ListGlobalQuestionsResponseBodyGlobalQuestionsList() = default;
};
class ListGlobalQuestionsResponseBodyGlobalQuestions : public Darabonba::Model {
public:
  shared_ptr<vector<ListGlobalQuestionsResponseBodyGlobalQuestionsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListGlobalQuestionsResponseBodyGlobalQuestions() {}

  explicit ListGlobalQuestionsResponseBodyGlobalQuestions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListGlobalQuestionsResponseBodyGlobalQuestionsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGlobalQuestionsResponseBodyGlobalQuestionsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListGlobalQuestionsResponseBodyGlobalQuestionsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListGlobalQuestionsResponseBodyGlobalQuestions() = default;
};
class ListGlobalQuestionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListGlobalQuestionsResponseBodyGlobalQuestions> globalQuestions{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListGlobalQuestionsResponseBody() {}

  explicit ListGlobalQuestionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (globalQuestions) {
      res["GlobalQuestions"] = globalQuestions ? boost::any(globalQuestions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("GlobalQuestions") != m.end() && !m["GlobalQuestions"].empty()) {
      if (typeid(map<string, boost::any>) == m["GlobalQuestions"].type()) {
        ListGlobalQuestionsResponseBodyGlobalQuestions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GlobalQuestions"]));
        globalQuestions = make_shared<ListGlobalQuestionsResponseBodyGlobalQuestions>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListGlobalQuestionsResponseBody() = default;
};
class ListGlobalQuestionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGlobalQuestionsResponseBody> body{};

  ListGlobalQuestionsResponse() {}

  explicit ListGlobalQuestionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGlobalQuestionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGlobalQuestionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListGlobalQuestionsResponse() = default;
};
class ListInstancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListInstancesRequestTag() {}

  explicit ListInstancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListInstancesRequestTag() = default;
};
class ListInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListInstancesRequestTag>> tag{};

  ListInstancesRequest() {}

  explicit ListInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListInstancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListInstancesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListInstancesRequest() = default;
};
class ListInstancesResponseBodyInstancesResourceTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListInstancesResponseBodyInstancesResourceTags() {}

  explicit ListInstancesResponseBodyInstancesResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListInstancesResponseBodyInstancesResourceTags() = default;
};
class ListInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<long> creationTime{};
  shared_ptr<long> creatorId{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<bool> isPreset{};
  shared_ptr<long> maxConcurrentConversation{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListInstancesResponseBodyInstancesResourceTags>> resourceTags{};

  ListInstancesResponseBodyInstances() {}

  explicit ListInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (isPreset) {
      res["IsPreset"] = boost::any(*isPreset);
    }
    if (maxConcurrentConversation) {
      res["MaxConcurrentConversation"] = boost::any(*maxConcurrentConversation);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceTags) {
      vector<boost::any> temp1;
      for(auto item1:*resourceTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceTags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["CreatorId"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("IsPreset") != m.end() && !m["IsPreset"].empty()) {
      isPreset = make_shared<bool>(boost::any_cast<bool>(m["IsPreset"]));
    }
    if (m.find("MaxConcurrentConversation") != m.end() && !m["MaxConcurrentConversation"].empty()) {
      maxConcurrentConversation = make_shared<long>(boost::any_cast<long>(m["MaxConcurrentConversation"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceTags") != m.end() && !m["ResourceTags"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceTags"].type()) {
        vector<ListInstancesResponseBodyInstancesResourceTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseBodyInstancesResourceTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceTags = make_shared<vector<ListInstancesResponseBodyInstancesResourceTags>>(expect1);
      }
    }
  }


  virtual ~ListInstancesResponseBodyInstances() = default;
};
class ListInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<ListInstancesResponseBodyInstances>> instances{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListInstancesResponseBody() {}

  explicit ListInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<ListInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<ListInstancesResponseBodyInstances>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInstancesResponseBody() = default;
};
class ListInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstancesResponseBody> body{};

  ListInstancesResponse() {}

  explicit ListInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstancesResponse() = default;
};
class ListIntentionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> annotationMissionDataSourceType{};
  shared_ptr<string> botId{};
  shared_ptr<long> environment{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> intentId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> userNick{};

  ListIntentionsRequest() {}

  explicit ListIntentionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionDataSourceType) {
      res["AnnotationMissionDataSourceType"] = boost::any(*annotationMissionDataSourceType);
    }
    if (botId) {
      res["BotId"] = boost::any(*botId);
    }
    if (environment) {
      res["Environment"] = boost::any(*environment);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (userNick) {
      res["UserNick"] = boost::any(*userNick);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionDataSourceType") != m.end() && !m["AnnotationMissionDataSourceType"].empty()) {
      annotationMissionDataSourceType = make_shared<long>(boost::any_cast<long>(m["AnnotationMissionDataSourceType"]));
    }
    if (m.find("BotId") != m.end() && !m["BotId"].empty()) {
      botId = make_shared<string>(boost::any_cast<string>(m["BotId"]));
    }
    if (m.find("Environment") != m.end() && !m["Environment"].empty()) {
      environment = make_shared<long>(boost::any_cast<long>(m["Environment"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("UserNick") != m.end() && !m["UserNick"].empty()) {
      userNick = make_shared<string>(boost::any_cast<string>(m["UserNick"]));
    }
  }


  virtual ~ListIntentionsRequest() = default;
};
class ListIntentionsResponseBodyDataIntentListRuleCheck : public Darabonba::Model {
public:
  shared_ptr<vector<string>> error{};
  shared_ptr<bool> strict{};
  shared_ptr<string> text{};
  shared_ptr<vector<string>> warning{};

  ListIntentionsResponseBodyDataIntentListRuleCheck() {}

  explicit ListIntentionsResponseBodyDataIntentListRuleCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (strict) {
      res["Strict"] = boost::any(*strict);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (warning) {
      res["Warning"] = boost::any(*warning);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Error"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Error"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      error = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Strict") != m.end() && !m["Strict"].empty()) {
      strict = make_shared<bool>(boost::any_cast<bool>(m["Strict"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Warning") != m.end() && !m["Warning"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Warning"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Warning"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      warning = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListIntentionsResponseBodyDataIntentListRuleCheck() = default;
};
class ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctionsSwitch : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> label{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctionsSwitch() {}

  explicit ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctionsSwitch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctionsSwitch() = default;
};
class ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctions : public Darabonba::Model {
public:
  shared_ptr<string> aliyunFunction{};
  shared_ptr<string> aliyunService{};
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> endPoint{};
  shared_ptr<string> function{};
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> params{};
  shared_ptr<vector<ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctionsSwitch>> switch_{};
  shared_ptr<string> type{};

  ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctions() {}

  explicit ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunFunction) {
      res["AliyunFunction"] = boost::any(*aliyunFunction);
    }
    if (aliyunService) {
      res["AliyunService"] = boost::any(*aliyunService);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endPoint) {
      res["EndPoint"] = boost::any(*endPoint);
    }
    if (function) {
      res["Function"] = boost::any(*function);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (switch_) {
      vector<boost::any> temp1;
      for(auto item1:*switch_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Switch"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunFunction") != m.end() && !m["AliyunFunction"].empty()) {
      aliyunFunction = make_shared<string>(boost::any_cast<string>(m["AliyunFunction"]));
    }
    if (m.find("AliyunService") != m.end() && !m["AliyunService"].empty()) {
      aliyunService = make_shared<string>(boost::any_cast<string>(m["AliyunService"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndPoint") != m.end() && !m["EndPoint"].empty()) {
      endPoint = make_shared<string>(boost::any_cast<string>(m["EndPoint"]));
    }
    if (m.find("Function") != m.end() && !m["Function"].empty()) {
      function = make_shared<string>(boost::any_cast<string>(m["Function"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Params"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      params = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Switch") != m.end() && !m["Switch"].empty()) {
      if (typeid(vector<boost::any>) == m["Switch"].type()) {
        vector<ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctionsSwitch> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Switch"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctionsSwitch model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        switch_ = make_shared<vector<ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctionsSwitch>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctions() = default;
};
class ListIntentionsResponseBodyDataIntentListSlotTags : public Darabonba::Model {
public:
  shared_ptr<string> userSayId{};
  shared_ptr<string> value{};

  ListIntentionsResponseBodyDataIntentListSlotTags() {}

  explicit ListIntentionsResponseBodyDataIntentListSlotTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userSayId) {
      res["UserSayId"] = boost::any(*userSayId);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserSayId") != m.end() && !m["UserSayId"].empty()) {
      userSayId = make_shared<string>(boost::any_cast<string>(m["UserSayId"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListIntentionsResponseBodyDataIntentListSlotTags() = default;
};
class ListIntentionsResponseBodyDataIntentListSlot : public Darabonba::Model {
public:
  shared_ptr<vector<ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctions>> feedbackFunctions{};
  shared_ptr<string> feedbackType{};
  shared_ptr<string> id{};
  shared_ptr<bool> isArray{};
  shared_ptr<bool> isEncrypt{};
  shared_ptr<bool> isInteractive{};
  shared_ptr<bool> isNecessary{};
  shared_ptr<long> lifeSpan{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> question{};
  shared_ptr<vector<ListIntentionsResponseBodyDataIntentListSlotTags>> tags{};
  shared_ptr<string> value{};

  ListIntentionsResponseBodyDataIntentListSlot() {}

  explicit ListIntentionsResponseBodyDataIntentListSlot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feedbackFunctions) {
      vector<boost::any> temp1;
      for(auto item1:*feedbackFunctions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FeedbackFunctions"] = boost::any(temp1);
    }
    if (feedbackType) {
      res["FeedbackType"] = boost::any(*feedbackType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isArray) {
      res["IsArray"] = boost::any(*isArray);
    }
    if (isEncrypt) {
      res["IsEncrypt"] = boost::any(*isEncrypt);
    }
    if (isInteractive) {
      res["IsInteractive"] = boost::any(*isInteractive);
    }
    if (isNecessary) {
      res["IsNecessary"] = boost::any(*isNecessary);
    }
    if (lifeSpan) {
      res["LifeSpan"] = boost::any(*lifeSpan);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (question) {
      res["Question"] = boost::any(*question);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FeedbackFunctions") != m.end() && !m["FeedbackFunctions"].empty()) {
      if (typeid(vector<boost::any>) == m["FeedbackFunctions"].type()) {
        vector<ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FeedbackFunctions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        feedbackFunctions = make_shared<vector<ListIntentionsResponseBodyDataIntentListSlotFeedbackFunctions>>(expect1);
      }
    }
    if (m.find("FeedbackType") != m.end() && !m["FeedbackType"].empty()) {
      feedbackType = make_shared<string>(boost::any_cast<string>(m["FeedbackType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsArray") != m.end() && !m["IsArray"].empty()) {
      isArray = make_shared<bool>(boost::any_cast<bool>(m["IsArray"]));
    }
    if (m.find("IsEncrypt") != m.end() && !m["IsEncrypt"].empty()) {
      isEncrypt = make_shared<bool>(boost::any_cast<bool>(m["IsEncrypt"]));
    }
    if (m.find("IsInteractive") != m.end() && !m["IsInteractive"].empty()) {
      isInteractive = make_shared<bool>(boost::any_cast<bool>(m["IsInteractive"]));
    }
    if (m.find("IsNecessary") != m.end() && !m["IsNecessary"].empty()) {
      isNecessary = make_shared<bool>(boost::any_cast<bool>(m["IsNecessary"]));
    }
    if (m.find("LifeSpan") != m.end() && !m["LifeSpan"].empty()) {
      lifeSpan = make_shared<long>(boost::any_cast<long>(m["LifeSpan"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Question") != m.end() && !m["Question"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Question"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Question"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      question = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListIntentionsResponseBodyDataIntentListSlotTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntentionsResponseBodyDataIntentListSlotTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListIntentionsResponseBodyDataIntentListSlotTags>>(expect1);
      }
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListIntentionsResponseBodyDataIntentListSlot() = default;
};
class ListIntentionsResponseBodyDataIntentListUserSayUserSayData : public Darabonba::Model {
public:
  shared_ptr<string> slotId{};
  shared_ptr<string> text{};

  ListIntentionsResponseBodyDataIntentListUserSayUserSayData() {}

  explicit ListIntentionsResponseBodyDataIntentListUserSayUserSayData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slotId) {
      res["SlotId"] = boost::any(*slotId);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlotId") != m.end() && !m["SlotId"].empty()) {
      slotId = make_shared<string>(boost::any_cast<string>(m["SlotId"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~ListIntentionsResponseBodyDataIntentListUserSayUserSayData() = default;
};
class ListIntentionsResponseBodyDataIntentListUserSay : public Darabonba::Model {
public:
  shared_ptr<string> fromId{};
  shared_ptr<string> id{};
  shared_ptr<bool> strict{};
  shared_ptr<vector<ListIntentionsResponseBodyDataIntentListUserSayUserSayData>> userSayData{};

  ListIntentionsResponseBodyDataIntentListUserSay() {}

  explicit ListIntentionsResponseBodyDataIntentListUserSay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromId) {
      res["FromId"] = boost::any(*fromId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (strict) {
      res["Strict"] = boost::any(*strict);
    }
    if (userSayData) {
      vector<boost::any> temp1;
      for(auto item1:*userSayData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserSayData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromId") != m.end() && !m["FromId"].empty()) {
      fromId = make_shared<string>(boost::any_cast<string>(m["FromId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Strict") != m.end() && !m["Strict"].empty()) {
      strict = make_shared<bool>(boost::any_cast<bool>(m["Strict"]));
    }
    if (m.find("UserSayData") != m.end() && !m["UserSayData"].empty()) {
      if (typeid(vector<boost::any>) == m["UserSayData"].type()) {
        vector<ListIntentionsResponseBodyDataIntentListUserSayUserSayData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserSayData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntentionsResponseBodyDataIntentListUserSayUserSayData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userSayData = make_shared<vector<ListIntentionsResponseBodyDataIntentListUserSayUserSayData>>(expect1);
      }
    }
  }


  virtual ~ListIntentionsResponseBodyDataIntentListUserSay() = default;
};
class ListIntentionsResponseBodyDataIntentList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> alias{};
  shared_ptr<long> botId{};
  shared_ptr<string> botName{};
  shared_ptr<string> dialogId{};
  shared_ptr<long> id{};
  shared_ptr<string> language{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListIntentionsResponseBodyDataIntentListRuleCheck>> ruleCheck{};
  shared_ptr<vector<ListIntentionsResponseBodyDataIntentListSlot>> slot{};
  shared_ptr<long> tableId{};
  shared_ptr<long> type{};
  shared_ptr<vector<ListIntentionsResponseBodyDataIntentListUserSay>> userSay{};

  ListIntentionsResponseBodyDataIntentList() {}

  explicit ListIntentionsResponseBodyDataIntentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (botId) {
      res["BotId"] = boost::any(*botId);
    }
    if (botName) {
      res["BotName"] = boost::any(*botName);
    }
    if (dialogId) {
      res["DialogId"] = boost::any(*dialogId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleCheck) {
      vector<boost::any> temp1;
      for(auto item1:*ruleCheck){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleCheck"] = boost::any(temp1);
    }
    if (slot) {
      vector<boost::any> temp1;
      for(auto item1:*slot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Slot"] = boost::any(temp1);
    }
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userSay) {
      vector<boost::any> temp1;
      for(auto item1:*userSay){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserSay"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Alias"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Alias"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alias = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BotId") != m.end() && !m["BotId"].empty()) {
      botId = make_shared<long>(boost::any_cast<long>(m["BotId"]));
    }
    if (m.find("BotName") != m.end() && !m["BotName"].empty()) {
      botName = make_shared<string>(boost::any_cast<string>(m["BotName"]));
    }
    if (m.find("DialogId") != m.end() && !m["DialogId"].empty()) {
      dialogId = make_shared<string>(boost::any_cast<string>(m["DialogId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleCheck") != m.end() && !m["RuleCheck"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleCheck"].type()) {
        vector<ListIntentionsResponseBodyDataIntentListRuleCheck> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleCheck"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntentionsResponseBodyDataIntentListRuleCheck model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleCheck = make_shared<vector<ListIntentionsResponseBodyDataIntentListRuleCheck>>(expect1);
      }
    }
    if (m.find("Slot") != m.end() && !m["Slot"].empty()) {
      if (typeid(vector<boost::any>) == m["Slot"].type()) {
        vector<ListIntentionsResponseBodyDataIntentListSlot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Slot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntentionsResponseBodyDataIntentListSlot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        slot = make_shared<vector<ListIntentionsResponseBodyDataIntentListSlot>>(expect1);
      }
    }
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<long>(boost::any_cast<long>(m["TableId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UserSay") != m.end() && !m["UserSay"].empty()) {
      if (typeid(vector<boost::any>) == m["UserSay"].type()) {
        vector<ListIntentionsResponseBodyDataIntentListUserSay> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserSay"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntentionsResponseBodyDataIntentListUserSay model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userSay = make_shared<vector<ListIntentionsResponseBodyDataIntentListUserSay>>(expect1);
      }
    }
  }


  virtual ~ListIntentionsResponseBodyDataIntentList() = default;
};
class ListIntentionsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> botId{};
  shared_ptr<vector<ListIntentionsResponseBodyDataIntentList>> intentList{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  ListIntentionsResponseBodyData() {}

  explicit ListIntentionsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (botId) {
      res["BotId"] = boost::any(*botId);
    }
    if (intentList) {
      vector<boost::any> temp1;
      for(auto item1:*intentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IntentList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BotId") != m.end() && !m["BotId"].empty()) {
      botId = make_shared<string>(boost::any_cast<string>(m["BotId"]));
    }
    if (m.find("IntentList") != m.end() && !m["IntentList"].empty()) {
      if (typeid(vector<boost::any>) == m["IntentList"].type()) {
        vector<ListIntentionsResponseBodyDataIntentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IntentList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntentionsResponseBodyDataIntentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        intentList = make_shared<vector<ListIntentionsResponseBodyDataIntentList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListIntentionsResponseBodyData() = default;
};
class ListIntentionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListIntentionsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListIntentionsResponseBody() {}

  explicit ListIntentionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListIntentionsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListIntentionsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListIntentionsResponseBody() = default;
};
class ListIntentionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntentionsResponseBody> body{};

  ListIntentionsResponse() {}

  explicit ListIntentionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntentionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntentionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntentionsResponse() = default;
};
class ListIntentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scriptId{};

  ListIntentsRequest() {}

  explicit ListIntentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ListIntentsRequest() = default;
};
class ListIntentsResponseBodyIntentsList : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> intentDescription{};
  shared_ptr<string> intentId{};
  shared_ptr<string> intentName{};
  shared_ptr<string> keywords{};
  shared_ptr<string> scriptId{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> utterances{};

  ListIntentsResponseBodyIntentsList() {}

  explicit ListIntentsResponseBodyIntentsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (intentDescription) {
      res["IntentDescription"] = boost::any(*intentDescription);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (intentName) {
      res["IntentName"] = boost::any(*intentName);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (utterances) {
      res["Utterances"] = boost::any(*utterances);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("IntentDescription") != m.end() && !m["IntentDescription"].empty()) {
      intentDescription = make_shared<string>(boost::any_cast<string>(m["IntentDescription"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
    if (m.find("IntentName") != m.end() && !m["IntentName"].empty()) {
      intentName = make_shared<string>(boost::any_cast<string>(m["IntentName"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywords = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Utterances") != m.end() && !m["Utterances"].empty()) {
      utterances = make_shared<string>(boost::any_cast<string>(m["Utterances"]));
    }
  }


  virtual ~ListIntentsResponseBodyIntentsList() = default;
};
class ListIntentsResponseBodyIntents : public Darabonba::Model {
public:
  shared_ptr<vector<ListIntentsResponseBodyIntentsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListIntentsResponseBodyIntents() {}

  explicit ListIntentsResponseBodyIntents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListIntentsResponseBodyIntentsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntentsResponseBodyIntentsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListIntentsResponseBodyIntentsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListIntentsResponseBodyIntents() = default;
};
class ListIntentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListIntentsResponseBodyIntents> intents{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListIntentsResponseBody() {}

  explicit ListIntentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (intents) {
      res["Intents"] = intents ? boost::any(intents->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Intents") != m.end() && !m["Intents"].empty()) {
      if (typeid(map<string, boost::any>) == m["Intents"].type()) {
        ListIntentsResponseBodyIntents model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Intents"]));
        intents = make_shared<ListIntentsResponseBodyIntents>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListIntentsResponseBody() = default;
};
class ListIntentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntentsResponseBody> body{};

  ListIntentsResponse() {}

  explicit ListIntentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntentsResponse() = default;
};
class ListJobGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> asyncQuery{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupStatusFilter{};
  shared_ptr<bool> onlyMinConcurrencyEnabled{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchText{};
  shared_ptr<long> startTime{};

  ListJobGroupsRequest() {}

  explicit ListJobGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncQuery) {
      res["AsyncQuery"] = boost::any(*asyncQuery);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupStatusFilter) {
      res["JobGroupStatusFilter"] = boost::any(*jobGroupStatusFilter);
    }
    if (onlyMinConcurrencyEnabled) {
      res["OnlyMinConcurrencyEnabled"] = boost::any(*onlyMinConcurrencyEnabled);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchText) {
      res["SearchText"] = boost::any(*searchText);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncQuery") != m.end() && !m["AsyncQuery"].empty()) {
      asyncQuery = make_shared<bool>(boost::any_cast<bool>(m["AsyncQuery"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupStatusFilter") != m.end() && !m["JobGroupStatusFilter"].empty()) {
      jobGroupStatusFilter = make_shared<string>(boost::any_cast<string>(m["JobGroupStatusFilter"]));
    }
    if (m.find("OnlyMinConcurrencyEnabled") != m.end() && !m["OnlyMinConcurrencyEnabled"].empty()) {
      onlyMinConcurrencyEnabled = make_shared<bool>(boost::any_cast<bool>(m["OnlyMinConcurrencyEnabled"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchText") != m.end() && !m["SearchText"].empty()) {
      searchText = make_shared<string>(boost::any_cast<string>(m["SearchText"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListJobGroupsRequest() = default;
};
class ListJobGroupsResponseBodyJobGroupsListExportProgress : public Darabonba::Model {
public:
  shared_ptr<string> fileHttpUrl{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  ListJobGroupsResponseBodyJobGroupsListExportProgress() {}

  explicit ListJobGroupsResponseBodyJobGroupsListExportProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileHttpUrl) {
      res["FileHttpUrl"] = boost::any(*fileHttpUrl);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileHttpUrl") != m.end() && !m["FileHttpUrl"].empty()) {
      fileHttpUrl = make_shared<string>(boost::any_cast<string>(m["FileHttpUrl"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListJobGroupsResponseBodyJobGroupsListExportProgress() = default;
};
class ListJobGroupsResponseBodyJobGroupsListProgress : public Darabonba::Model {
public:
  shared_ptr<long> cancelledNum{};
  shared_ptr<long> duration{};
  shared_ptr<long> executingNum{};
  shared_ptr<long> failedNum{};
  shared_ptr<long> pausedNum{};
  shared_ptr<long> scheduling{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<long> totalCompleted{};
  shared_ptr<long> totalJobs{};
  shared_ptr<long> totalNotAnswered{};

  ListJobGroupsResponseBodyJobGroupsListProgress() {}

  explicit ListJobGroupsResponseBodyJobGroupsListProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelledNum) {
      res["CancelledNum"] = boost::any(*cancelledNum);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (executingNum) {
      res["ExecutingNum"] = boost::any(*executingNum);
    }
    if (failedNum) {
      res["FailedNum"] = boost::any(*failedNum);
    }
    if (pausedNum) {
      res["PausedNum"] = boost::any(*pausedNum);
    }
    if (scheduling) {
      res["Scheduling"] = boost::any(*scheduling);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalCompleted) {
      res["TotalCompleted"] = boost::any(*totalCompleted);
    }
    if (totalJobs) {
      res["TotalJobs"] = boost::any(*totalJobs);
    }
    if (totalNotAnswered) {
      res["TotalNotAnswered"] = boost::any(*totalNotAnswered);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CancelledNum") != m.end() && !m["CancelledNum"].empty()) {
      cancelledNum = make_shared<long>(boost::any_cast<long>(m["CancelledNum"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("ExecutingNum") != m.end() && !m["ExecutingNum"].empty()) {
      executingNum = make_shared<long>(boost::any_cast<long>(m["ExecutingNum"]));
    }
    if (m.find("FailedNum") != m.end() && !m["FailedNum"].empty()) {
      failedNum = make_shared<long>(boost::any_cast<long>(m["FailedNum"]));
    }
    if (m.find("PausedNum") != m.end() && !m["PausedNum"].empty()) {
      pausedNum = make_shared<long>(boost::any_cast<long>(m["PausedNum"]));
    }
    if (m.find("Scheduling") != m.end() && !m["Scheduling"].empty()) {
      scheduling = make_shared<long>(boost::any_cast<long>(m["Scheduling"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalCompleted") != m.end() && !m["TotalCompleted"].empty()) {
      totalCompleted = make_shared<long>(boost::any_cast<long>(m["TotalCompleted"]));
    }
    if (m.find("TotalJobs") != m.end() && !m["TotalJobs"].empty()) {
      totalJobs = make_shared<long>(boost::any_cast<long>(m["TotalJobs"]));
    }
    if (m.find("TotalNotAnswered") != m.end() && !m["TotalNotAnswered"].empty()) {
      totalNotAnswered = make_shared<long>(boost::any_cast<long>(m["TotalNotAnswered"]));
    }
  }


  virtual ~ListJobGroupsResponseBodyJobGroupsListProgress() = default;
};
class ListJobGroupsResponseBodyJobGroupsListStrategy : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  ListJobGroupsResponseBodyJobGroupsListStrategy() {}

  explicit ListJobGroupsResponseBodyJobGroupsListStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListJobGroupsResponseBodyJobGroupsListStrategy() = default;
};
class ListJobGroupsResponseBodyJobGroupsList : public Darabonba::Model {
public:
  shared_ptr<long> creationTime{};
  shared_ptr<ListJobGroupsResponseBodyJobGroupsListExportProgress> exportProgress{};
  shared_ptr<string> jobDataParsingTaskId{};
  shared_ptr<string> jobGroupDescription{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobGroupName{};
  shared_ptr<long> minConcurrency{};
  shared_ptr<string> modifyTime{};
  shared_ptr<ListJobGroupsResponseBodyJobGroupsListProgress> progress{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> scriptVersion{};
  shared_ptr<string> status{};
  shared_ptr<ListJobGroupsResponseBodyJobGroupsListStrategy> strategy{};
  shared_ptr<long> totalCallNum{};

  ListJobGroupsResponseBodyJobGroupsList() {}

  explicit ListJobGroupsResponseBodyJobGroupsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (exportProgress) {
      res["ExportProgress"] = exportProgress ? boost::any(exportProgress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobDataParsingTaskId) {
      res["JobDataParsingTaskId"] = boost::any(*jobDataParsingTaskId);
    }
    if (jobGroupDescription) {
      res["JobGroupDescription"] = boost::any(*jobGroupDescription);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobGroupName) {
      res["JobGroupName"] = boost::any(*jobGroupName);
    }
    if (minConcurrency) {
      res["MinConcurrency"] = boost::any(*minConcurrency);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (progress) {
      res["Progress"] = progress ? boost::any(progress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (scriptVersion) {
      res["ScriptVersion"] = boost::any(*scriptVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCallNum) {
      res["TotalCallNum"] = boost::any(*totalCallNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("ExportProgress") != m.end() && !m["ExportProgress"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExportProgress"].type()) {
        ListJobGroupsResponseBodyJobGroupsListExportProgress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExportProgress"]));
        exportProgress = make_shared<ListJobGroupsResponseBodyJobGroupsListExportProgress>(model1);
      }
    }
    if (m.find("JobDataParsingTaskId") != m.end() && !m["JobDataParsingTaskId"].empty()) {
      jobDataParsingTaskId = make_shared<string>(boost::any_cast<string>(m["JobDataParsingTaskId"]));
    }
    if (m.find("JobGroupDescription") != m.end() && !m["JobGroupDescription"].empty()) {
      jobGroupDescription = make_shared<string>(boost::any_cast<string>(m["JobGroupDescription"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobGroupName") != m.end() && !m["JobGroupName"].empty()) {
      jobGroupName = make_shared<string>(boost::any_cast<string>(m["JobGroupName"]));
    }
    if (m.find("MinConcurrency") != m.end() && !m["MinConcurrency"].empty()) {
      minConcurrency = make_shared<long>(boost::any_cast<long>(m["MinConcurrency"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      if (typeid(map<string, boost::any>) == m["Progress"].type()) {
        ListJobGroupsResponseBodyJobGroupsListProgress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Progress"]));
        progress = make_shared<ListJobGroupsResponseBodyJobGroupsListProgress>(model1);
      }
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("ScriptVersion") != m.end() && !m["ScriptVersion"].empty()) {
      scriptVersion = make_shared<string>(boost::any_cast<string>(m["ScriptVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        ListJobGroupsResponseBodyJobGroupsListStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<ListJobGroupsResponseBodyJobGroupsListStrategy>(model1);
      }
    }
    if (m.find("TotalCallNum") != m.end() && !m["TotalCallNum"].empty()) {
      totalCallNum = make_shared<long>(boost::any_cast<long>(m["TotalCallNum"]));
    }
  }


  virtual ~ListJobGroupsResponseBodyJobGroupsList() = default;
};
class ListJobGroupsResponseBodyJobGroups : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobGroupsResponseBodyJobGroupsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListJobGroupsResponseBodyJobGroups() {}

  explicit ListJobGroupsResponseBodyJobGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListJobGroupsResponseBodyJobGroupsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobGroupsResponseBodyJobGroupsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListJobGroupsResponseBodyJobGroupsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListJobGroupsResponseBodyJobGroups() = default;
};
class ListJobGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> asyncTaskId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListJobGroupsResponseBodyJobGroups> jobGroups{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListJobGroupsResponseBody() {}

  explicit ListJobGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncTaskId) {
      res["AsyncTaskId"] = boost::any(*asyncTaskId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobGroups) {
      res["JobGroups"] = jobGroups ? boost::any(jobGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncTaskId") != m.end() && !m["AsyncTaskId"].empty()) {
      asyncTaskId = make_shared<string>(boost::any_cast<string>(m["AsyncTaskId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("JobGroups") != m.end() && !m["JobGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobGroups"].type()) {
        ListJobGroupsResponseBodyJobGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobGroups"]));
        jobGroups = make_shared<ListJobGroupsResponseBodyJobGroups>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListJobGroupsResponseBody() = default;
};
class ListJobGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListJobGroupsResponseBody> body{};

  ListJobGroupsResponse() {}

  explicit ListJobGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListJobGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListJobGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListJobGroupsResponse() = default;
};
class ListJobGroupsAsyncRequest : public Darabonba::Model {
public:
  shared_ptr<string> asyncTaskId{};

  ListJobGroupsAsyncRequest() {}

  explicit ListJobGroupsAsyncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncTaskId) {
      res["AsyncTaskId"] = boost::any(*asyncTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncTaskId") != m.end() && !m["AsyncTaskId"].empty()) {
      asyncTaskId = make_shared<string>(boost::any_cast<string>(m["AsyncTaskId"]));
    }
  }


  virtual ~ListJobGroupsAsyncRequest() = default;
};
class ListJobGroupsAsyncResponseBodyJobGroupsExportProgress : public Darabonba::Model {
public:
  shared_ptr<string> fileHttpUrl{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  ListJobGroupsAsyncResponseBodyJobGroupsExportProgress() {}

  explicit ListJobGroupsAsyncResponseBodyJobGroupsExportProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileHttpUrl) {
      res["FileHttpUrl"] = boost::any(*fileHttpUrl);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileHttpUrl") != m.end() && !m["FileHttpUrl"].empty()) {
      fileHttpUrl = make_shared<string>(boost::any_cast<string>(m["FileHttpUrl"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListJobGroupsAsyncResponseBodyJobGroupsExportProgress() = default;
};
class ListJobGroupsAsyncResponseBodyJobGroupsProgress : public Darabonba::Model {
public:
  shared_ptr<long> cancelledNum{};
  shared_ptr<long> duration{};
  shared_ptr<long> executingNum{};
  shared_ptr<long> failedNum{};
  shared_ptr<long> pausedNum{};
  shared_ptr<long> scheduling{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<long> totalCompleted{};
  shared_ptr<long> totalJobs{};
  shared_ptr<long> totalNotAnswered{};

  ListJobGroupsAsyncResponseBodyJobGroupsProgress() {}

  explicit ListJobGroupsAsyncResponseBodyJobGroupsProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelledNum) {
      res["CancelledNum"] = boost::any(*cancelledNum);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (executingNum) {
      res["ExecutingNum"] = boost::any(*executingNum);
    }
    if (failedNum) {
      res["FailedNum"] = boost::any(*failedNum);
    }
    if (pausedNum) {
      res["PausedNum"] = boost::any(*pausedNum);
    }
    if (scheduling) {
      res["Scheduling"] = boost::any(*scheduling);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalCompleted) {
      res["TotalCompleted"] = boost::any(*totalCompleted);
    }
    if (totalJobs) {
      res["TotalJobs"] = boost::any(*totalJobs);
    }
    if (totalNotAnswered) {
      res["TotalNotAnswered"] = boost::any(*totalNotAnswered);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CancelledNum") != m.end() && !m["CancelledNum"].empty()) {
      cancelledNum = make_shared<long>(boost::any_cast<long>(m["CancelledNum"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("ExecutingNum") != m.end() && !m["ExecutingNum"].empty()) {
      executingNum = make_shared<long>(boost::any_cast<long>(m["ExecutingNum"]));
    }
    if (m.find("FailedNum") != m.end() && !m["FailedNum"].empty()) {
      failedNum = make_shared<long>(boost::any_cast<long>(m["FailedNum"]));
    }
    if (m.find("PausedNum") != m.end() && !m["PausedNum"].empty()) {
      pausedNum = make_shared<long>(boost::any_cast<long>(m["PausedNum"]));
    }
    if (m.find("Scheduling") != m.end() && !m["Scheduling"].empty()) {
      scheduling = make_shared<long>(boost::any_cast<long>(m["Scheduling"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalCompleted") != m.end() && !m["TotalCompleted"].empty()) {
      totalCompleted = make_shared<long>(boost::any_cast<long>(m["TotalCompleted"]));
    }
    if (m.find("TotalJobs") != m.end() && !m["TotalJobs"].empty()) {
      totalJobs = make_shared<long>(boost::any_cast<long>(m["TotalJobs"]));
    }
    if (m.find("TotalNotAnswered") != m.end() && !m["TotalNotAnswered"].empty()) {
      totalNotAnswered = make_shared<long>(boost::any_cast<long>(m["TotalNotAnswered"]));
    }
  }


  virtual ~ListJobGroupsAsyncResponseBodyJobGroupsProgress() = default;
};
class ListJobGroupsAsyncResponseBodyJobGroupsStrategy : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  ListJobGroupsAsyncResponseBodyJobGroupsStrategy() {}

  explicit ListJobGroupsAsyncResponseBodyJobGroupsStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListJobGroupsAsyncResponseBodyJobGroupsStrategy() = default;
};
class ListJobGroupsAsyncResponseBodyJobGroups : public Darabonba::Model {
public:
  shared_ptr<long> creationTime{};
  shared_ptr<ListJobGroupsAsyncResponseBodyJobGroupsExportProgress> exportProgress{};
  shared_ptr<string> jobDataParsingTaskId{};
  shared_ptr<string> jobGroupDescription{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobGroupName{};
  shared_ptr<long> minConcurrency{};
  shared_ptr<string> modifyTime{};
  shared_ptr<ListJobGroupsAsyncResponseBodyJobGroupsProgress> progress{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> scriptVersion{};
  shared_ptr<string> status{};
  shared_ptr<ListJobGroupsAsyncResponseBodyJobGroupsStrategy> strategy{};
  shared_ptr<long> totalCallNum{};

  ListJobGroupsAsyncResponseBodyJobGroups() {}

  explicit ListJobGroupsAsyncResponseBodyJobGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (exportProgress) {
      res["ExportProgress"] = exportProgress ? boost::any(exportProgress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobDataParsingTaskId) {
      res["JobDataParsingTaskId"] = boost::any(*jobDataParsingTaskId);
    }
    if (jobGroupDescription) {
      res["JobGroupDescription"] = boost::any(*jobGroupDescription);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobGroupName) {
      res["JobGroupName"] = boost::any(*jobGroupName);
    }
    if (minConcurrency) {
      res["MinConcurrency"] = boost::any(*minConcurrency);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (progress) {
      res["Progress"] = progress ? boost::any(progress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (scriptVersion) {
      res["ScriptVersion"] = boost::any(*scriptVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCallNum) {
      res["TotalCallNum"] = boost::any(*totalCallNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("ExportProgress") != m.end() && !m["ExportProgress"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExportProgress"].type()) {
        ListJobGroupsAsyncResponseBodyJobGroupsExportProgress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExportProgress"]));
        exportProgress = make_shared<ListJobGroupsAsyncResponseBodyJobGroupsExportProgress>(model1);
      }
    }
    if (m.find("JobDataParsingTaskId") != m.end() && !m["JobDataParsingTaskId"].empty()) {
      jobDataParsingTaskId = make_shared<string>(boost::any_cast<string>(m["JobDataParsingTaskId"]));
    }
    if (m.find("JobGroupDescription") != m.end() && !m["JobGroupDescription"].empty()) {
      jobGroupDescription = make_shared<string>(boost::any_cast<string>(m["JobGroupDescription"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobGroupName") != m.end() && !m["JobGroupName"].empty()) {
      jobGroupName = make_shared<string>(boost::any_cast<string>(m["JobGroupName"]));
    }
    if (m.find("MinConcurrency") != m.end() && !m["MinConcurrency"].empty()) {
      minConcurrency = make_shared<long>(boost::any_cast<long>(m["MinConcurrency"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      if (typeid(map<string, boost::any>) == m["Progress"].type()) {
        ListJobGroupsAsyncResponseBodyJobGroupsProgress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Progress"]));
        progress = make_shared<ListJobGroupsAsyncResponseBodyJobGroupsProgress>(model1);
      }
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("ScriptVersion") != m.end() && !m["ScriptVersion"].empty()) {
      scriptVersion = make_shared<string>(boost::any_cast<string>(m["ScriptVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        ListJobGroupsAsyncResponseBodyJobGroupsStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<ListJobGroupsAsyncResponseBodyJobGroupsStrategy>(model1);
      }
    }
    if (m.find("TotalCallNum") != m.end() && !m["TotalCallNum"].empty()) {
      totalCallNum = make_shared<long>(boost::any_cast<long>(m["TotalCallNum"]));
    }
  }


  virtual ~ListJobGroupsAsyncResponseBodyJobGroups() = default;
};
class ListJobGroupsAsyncResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<ListJobGroupsAsyncResponseBodyJobGroups>> jobGroups{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<bool> timeout{};
  shared_ptr<long> totalCount{};
  shared_ptr<bool> vaild{};

  ListJobGroupsAsyncResponseBody() {}

  explicit ListJobGroupsAsyncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobGroups) {
      vector<boost::any> temp1;
      for(auto item1:*jobGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobGroups"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vaild) {
      res["Vaild"] = boost::any(*vaild);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("JobGroups") != m.end() && !m["JobGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["JobGroups"].type()) {
        vector<ListJobGroupsAsyncResponseBodyJobGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobGroupsAsyncResponseBodyJobGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobGroups = make_shared<vector<ListJobGroupsAsyncResponseBodyJobGroups>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<bool>(boost::any_cast<bool>(m["Timeout"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Vaild") != m.end() && !m["Vaild"].empty()) {
      vaild = make_shared<bool>(boost::any_cast<bool>(m["Vaild"]));
    }
  }


  virtual ~ListJobGroupsAsyncResponseBody() = default;
};
class ListJobGroupsAsyncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListJobGroupsAsyncResponseBody> body{};

  ListJobGroupsAsyncResponse() {}

  explicit ListJobGroupsAsyncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListJobGroupsAsyncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListJobGroupsAsyncResponseBody>(model1);
      }
    }
  }


  virtual ~ListJobGroupsAsyncResponse() = default;
};
class ListJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> jobId{};

  ListJobsRequest() {}

  explicit ListJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListJobsRequest() = default;
};
class ListJobsResponseBodyJobsContacts : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> honorific{};
  shared_ptr<string> jobId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> role{};
  shared_ptr<string> state{};

  ListJobsResponseBodyJobsContacts() {}

  explicit ListJobsResponseBodyJobsContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListJobsResponseBodyJobsContacts() = default;
};
class ListJobsResponseBodyJobsExtras : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListJobsResponseBodyJobsExtras() {}

  explicit ListJobsResponseBodyJobsExtras(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListJobsResponseBodyJobsExtras() = default;
};
class ListJobsResponseBodyJobsSummary : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> content{};
  shared_ptr<string> summaryName{};

  ListJobsResponseBodyJobsSummary() {}

  explicit ListJobsResponseBodyJobsSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
  }


  virtual ~ListJobsResponseBodyJobsSummary() = default;
};
class ListJobsResponseBodyJobsTasksContact : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> honorific{};
  shared_ptr<string> jobId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> role{};
  shared_ptr<string> state{};

  ListJobsResponseBodyJobsTasksContact() {}

  explicit ListJobsResponseBodyJobsTasksContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListJobsResponseBodyJobsTasksContact() = default;
};
class ListJobsResponseBodyJobsTasksConversationSummary : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> content{};
  shared_ptr<string> summaryName{};

  ListJobsResponseBodyJobsTasksConversationSummary() {}

  explicit ListJobsResponseBodyJobsTasksConversationSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
  }


  virtual ~ListJobsResponseBodyJobsTasksConversationSummary() = default;
};
class ListJobsResponseBodyJobsTasksConversation : public Darabonba::Model {
public:
  shared_ptr<string> script{};
  shared_ptr<string> speaker{};
  shared_ptr<vector<ListJobsResponseBodyJobsTasksConversationSummary>> summary{};
  shared_ptr<long> timestamp{};

  ListJobsResponseBodyJobsTasksConversation() {}

  explicit ListJobsResponseBodyJobsTasksConversation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (speaker) {
      res["Speaker"] = boost::any(*speaker);
    }
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("Speaker") != m.end() && !m["Speaker"].empty()) {
      speaker = make_shared<string>(boost::any_cast<string>(m["Speaker"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<ListJobsResponseBodyJobsTasksConversationSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsResponseBodyJobsTasksConversationSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<ListJobsResponseBodyJobsTasksConversationSummary>>(expect1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~ListJobsResponseBodyJobsTasksConversation() = default;
};
class ListJobsResponseBodyJobsTasks : public Darabonba::Model {
public:
  shared_ptr<long> actualTime{};
  shared_ptr<string> brief{};
  shared_ptr<string> callId{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> chatbotId{};
  shared_ptr<ListJobsResponseBodyJobsTasksContact> contact{};
  shared_ptr<vector<ListJobsResponseBodyJobsTasksConversation>> conversation{};
  shared_ptr<long> duration{};
  shared_ptr<string> jobId{};
  shared_ptr<long> planedTime{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  ListJobsResponseBodyJobsTasks() {}

  explicit ListJobsResponseBodyJobsTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualTime) {
      res["ActualTime"] = boost::any(*actualTime);
    }
    if (brief) {
      res["Brief"] = boost::any(*brief);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (chatbotId) {
      res["ChatbotId"] = boost::any(*chatbotId);
    }
    if (contact) {
      res["Contact"] = contact ? boost::any(contact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conversation) {
      vector<boost::any> temp1;
      for(auto item1:*conversation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conversation"] = boost::any(temp1);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (planedTime) {
      res["PlanedTime"] = boost::any(*planedTime);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualTime") != m.end() && !m["ActualTime"].empty()) {
      actualTime = make_shared<long>(boost::any_cast<long>(m["ActualTime"]));
    }
    if (m.find("Brief") != m.end() && !m["Brief"].empty()) {
      brief = make_shared<string>(boost::any_cast<string>(m["Brief"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("ChatbotId") != m.end() && !m["ChatbotId"].empty()) {
      chatbotId = make_shared<string>(boost::any_cast<string>(m["ChatbotId"]));
    }
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      if (typeid(map<string, boost::any>) == m["Contact"].type()) {
        ListJobsResponseBodyJobsTasksContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Contact"]));
        contact = make_shared<ListJobsResponseBodyJobsTasksContact>(model1);
      }
    }
    if (m.find("Conversation") != m.end() && !m["Conversation"].empty()) {
      if (typeid(vector<boost::any>) == m["Conversation"].type()) {
        vector<ListJobsResponseBodyJobsTasksConversation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conversation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsResponseBodyJobsTasksConversation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conversation = make_shared<vector<ListJobsResponseBodyJobsTasksConversation>>(expect1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("PlanedTime") != m.end() && !m["PlanedTime"].empty()) {
      planedTime = make_shared<long>(boost::any_cast<long>(m["PlanedTime"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ListJobsResponseBodyJobsTasks() = default;
};
class ListJobsResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<vector<ListJobsResponseBodyJobsContacts>> contacts{};
  shared_ptr<vector<ListJobsResponseBodyJobsExtras>> extras{};
  shared_ptr<string> failureReason{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> priority{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> status{};
  shared_ptr<string> strategyId{};
  shared_ptr<vector<ListJobsResponseBodyJobsSummary>> summary{};
  shared_ptr<long> systemPriority{};
  shared_ptr<vector<ListJobsResponseBodyJobsTasks>> tasks{};

  ListJobsResponseBodyJobs() {}

  explicit ListJobsResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (extras) {
      vector<boost::any> temp1;
      for(auto item1:*extras){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Extras"] = boost::any(temp1);
    }
    if (failureReason) {
      res["FailureReason"] = boost::any(*failureReason);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (systemPriority) {
      res["SystemPriority"] = boost::any(*systemPriority);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<ListJobsResponseBodyJobsContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsResponseBodyJobsContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<ListJobsResponseBodyJobsContacts>>(expect1);
      }
    }
    if (m.find("Extras") != m.end() && !m["Extras"].empty()) {
      if (typeid(vector<boost::any>) == m["Extras"].type()) {
        vector<ListJobsResponseBodyJobsExtras> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Extras"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsResponseBodyJobsExtras model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extras = make_shared<vector<ListJobsResponseBodyJobsExtras>>(expect1);
      }
    }
    if (m.find("FailureReason") != m.end() && !m["FailureReason"].empty()) {
      failureReason = make_shared<string>(boost::any_cast<string>(m["FailureReason"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<ListJobsResponseBodyJobsSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsResponseBodyJobsSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<ListJobsResponseBodyJobsSummary>>(expect1);
      }
    }
    if (m.find("SystemPriority") != m.end() && !m["SystemPriority"].empty()) {
      systemPriority = make_shared<long>(boost::any_cast<long>(m["SystemPriority"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<ListJobsResponseBodyJobsTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsResponseBodyJobsTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<ListJobsResponseBodyJobsTasks>>(expect1);
      }
    }
  }


  virtual ~ListJobsResponseBodyJobs() = default;
};
class ListJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<ListJobsResponseBodyJobs>> jobs{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListJobsResponseBody() {}

  explicit ListJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Jobs"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["Jobs"].type()) {
        vector<ListJobsResponseBodyJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsResponseBodyJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<ListJobsResponseBodyJobs>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListJobsResponseBody() = default;
};
class ListJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListJobsResponseBody> body{};

  ListJobsResponse() {}

  explicit ListJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListJobsResponse() = default;
};
class ListJobsByGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobFailureReason{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobStatus{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListJobsByGroupRequest() {}

  explicit ListJobsByGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobFailureReason) {
      res["JobFailureReason"] = boost::any(*jobFailureReason);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobFailureReason") != m.end() && !m["JobFailureReason"].empty()) {
      jobFailureReason = make_shared<string>(boost::any_cast<string>(m["JobFailureReason"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListJobsByGroupRequest() = default;
};
class ListJobsByGroupResponseBodyJobsListContacts : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> honorific{};
  shared_ptr<string> jobId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> role{};
  shared_ptr<string> state{};

  ListJobsByGroupResponseBodyJobsListContacts() {}

  explicit ListJobsByGroupResponseBodyJobsListContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListJobsByGroupResponseBodyJobsListContacts() = default;
};
class ListJobsByGroupResponseBodyJobsListExtras : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListJobsByGroupResponseBodyJobsListExtras() {}

  explicit ListJobsByGroupResponseBodyJobsListExtras(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListJobsByGroupResponseBodyJobsListExtras() = default;
};
class ListJobsByGroupResponseBodyJobsListSummary : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> content{};
  shared_ptr<string> conversationDetailId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> summaryId{};
  shared_ptr<string> summaryName{};
  shared_ptr<string> taskId{};

  ListJobsByGroupResponseBodyJobsListSummary() {}

  explicit ListJobsByGroupResponseBodyJobsListSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (conversationDetailId) {
      res["ConversationDetailId"] = boost::any(*conversationDetailId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (summaryId) {
      res["SummaryId"] = boost::any(*summaryId);
    }
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ConversationDetailId") != m.end() && !m["ConversationDetailId"].empty()) {
      conversationDetailId = make_shared<string>(boost::any_cast<string>(m["ConversationDetailId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("SummaryId") != m.end() && !m["SummaryId"].empty()) {
      summaryId = make_shared<string>(boost::any_cast<string>(m["SummaryId"]));
    }
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ListJobsByGroupResponseBodyJobsListSummary() = default;
};
class ListJobsByGroupResponseBodyJobsList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<vector<ListJobsByGroupResponseBodyJobsListContacts>> contacts{};
  shared_ptr<vector<ListJobsByGroupResponseBodyJobsListExtras>> extras{};
  shared_ptr<string> failureReason{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> priority{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> status{};
  shared_ptr<string> strategyId{};
  shared_ptr<vector<ListJobsByGroupResponseBodyJobsListSummary>> summary{};
  shared_ptr<long> systemPriority{};

  ListJobsByGroupResponseBodyJobsList() {}

  explicit ListJobsByGroupResponseBodyJobsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (extras) {
      vector<boost::any> temp1;
      for(auto item1:*extras){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Extras"] = boost::any(temp1);
    }
    if (failureReason) {
      res["FailureReason"] = boost::any(*failureReason);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (systemPriority) {
      res["SystemPriority"] = boost::any(*systemPriority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<ListJobsByGroupResponseBodyJobsListContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsByGroupResponseBodyJobsListContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<ListJobsByGroupResponseBodyJobsListContacts>>(expect1);
      }
    }
    if (m.find("Extras") != m.end() && !m["Extras"].empty()) {
      if (typeid(vector<boost::any>) == m["Extras"].type()) {
        vector<ListJobsByGroupResponseBodyJobsListExtras> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Extras"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsByGroupResponseBodyJobsListExtras model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extras = make_shared<vector<ListJobsByGroupResponseBodyJobsListExtras>>(expect1);
      }
    }
    if (m.find("FailureReason") != m.end() && !m["FailureReason"].empty()) {
      failureReason = make_shared<string>(boost::any_cast<string>(m["FailureReason"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<ListJobsByGroupResponseBodyJobsListSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsByGroupResponseBodyJobsListSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<ListJobsByGroupResponseBodyJobsListSummary>>(expect1);
      }
    }
    if (m.find("SystemPriority") != m.end() && !m["SystemPriority"].empty()) {
      systemPriority = make_shared<long>(boost::any_cast<long>(m["SystemPriority"]));
    }
  }


  virtual ~ListJobsByGroupResponseBodyJobsList() = default;
};
class ListJobsByGroupResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobsByGroupResponseBodyJobsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListJobsByGroupResponseBodyJobs() {}

  explicit ListJobsByGroupResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListJobsByGroupResponseBodyJobsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsByGroupResponseBodyJobsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListJobsByGroupResponseBodyJobsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListJobsByGroupResponseBodyJobs() = default;
};
class ListJobsByGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListJobsByGroupResponseBodyJobs> jobs{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListJobsByGroupResponseBody() {}

  explicit ListJobsByGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobs) {
      res["Jobs"] = jobs ? boost::any(jobs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Jobs"].type()) {
        ListJobsByGroupResponseBodyJobs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Jobs"]));
        jobs = make_shared<ListJobsByGroupResponseBodyJobs>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListJobsByGroupResponseBody() = default;
};
class ListJobsByGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListJobsByGroupResponseBody> body{};

  ListJobsByGroupResponse() {}

  explicit ListJobsByGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListJobsByGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListJobsByGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListJobsByGroupResponse() = default;
};
class ListOutboundCallNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListOutboundCallNumbersRequest() {}

  explicit ListOutboundCallNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListOutboundCallNumbersRequest() = default;
};
class ListOutboundCallNumbersResponseBodyOutboundCallNumbersList : public Darabonba::Model {
public:
  shared_ptr<string> number{};
  shared_ptr<string> outboundCallNumberId{};
  shared_ptr<string> rateLimitCount{};
  shared_ptr<string> rateLimitPeriod{};

  ListOutboundCallNumbersResponseBodyOutboundCallNumbersList() {}

  explicit ListOutboundCallNumbersResponseBodyOutboundCallNumbersList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (outboundCallNumberId) {
      res["OutboundCallNumberId"] = boost::any(*outboundCallNumberId);
    }
    if (rateLimitCount) {
      res["RateLimitCount"] = boost::any(*rateLimitCount);
    }
    if (rateLimitPeriod) {
      res["RateLimitPeriod"] = boost::any(*rateLimitPeriod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("OutboundCallNumberId") != m.end() && !m["OutboundCallNumberId"].empty()) {
      outboundCallNumberId = make_shared<string>(boost::any_cast<string>(m["OutboundCallNumberId"]));
    }
    if (m.find("RateLimitCount") != m.end() && !m["RateLimitCount"].empty()) {
      rateLimitCount = make_shared<string>(boost::any_cast<string>(m["RateLimitCount"]));
    }
    if (m.find("RateLimitPeriod") != m.end() && !m["RateLimitPeriod"].empty()) {
      rateLimitPeriod = make_shared<string>(boost::any_cast<string>(m["RateLimitPeriod"]));
    }
  }


  virtual ~ListOutboundCallNumbersResponseBodyOutboundCallNumbersList() = default;
};
class ListOutboundCallNumbersResponseBodyOutboundCallNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<ListOutboundCallNumbersResponseBodyOutboundCallNumbersList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListOutboundCallNumbersResponseBodyOutboundCallNumbers() {}

  explicit ListOutboundCallNumbersResponseBodyOutboundCallNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListOutboundCallNumbersResponseBodyOutboundCallNumbersList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOutboundCallNumbersResponseBodyOutboundCallNumbersList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListOutboundCallNumbersResponseBodyOutboundCallNumbersList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListOutboundCallNumbersResponseBodyOutboundCallNumbers() = default;
};
class ListOutboundCallNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListOutboundCallNumbersResponseBodyOutboundCallNumbers> outboundCallNumbers{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListOutboundCallNumbersResponseBody() {}

  explicit ListOutboundCallNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (outboundCallNumbers) {
      res["OutboundCallNumbers"] = outboundCallNumbers ? boost::any(outboundCallNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OutboundCallNumbers") != m.end() && !m["OutboundCallNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutboundCallNumbers"].type()) {
        ListOutboundCallNumbersResponseBodyOutboundCallNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutboundCallNumbers"]));
        outboundCallNumbers = make_shared<ListOutboundCallNumbersResponseBodyOutboundCallNumbers>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListOutboundCallNumbersResponseBody() = default;
};
class ListOutboundCallNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOutboundCallNumbersResponseBody> body{};

  ListOutboundCallNumbersResponse() {}

  explicit ListOutboundCallNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOutboundCallNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOutboundCallNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~ListOutboundCallNumbersResponse() = default;
};
class ListResourceTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceType{};

  ListResourceTagsRequest() {}

  explicit ListResourceTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListResourceTagsRequest() = default;
};
class ListResourceTagsResponseBodyResourceTagsList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListResourceTagsResponseBodyResourceTagsList() {}

  explicit ListResourceTagsResponseBodyResourceTagsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListResourceTagsResponseBodyResourceTagsList() = default;
};
class ListResourceTagsResponseBodyResourceTags : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourceTagsResponseBodyResourceTagsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListResourceTagsResponseBodyResourceTags() {}

  explicit ListResourceTagsResponseBodyResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListResourceTagsResponseBodyResourceTagsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceTagsResponseBodyResourceTagsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListResourceTagsResponseBodyResourceTagsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListResourceTagsResponseBodyResourceTags() = default;
};
class ListResourceTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListResourceTagsResponseBodyResourceTags> resourceTags{};
  shared_ptr<bool> success{};

  ListResourceTagsResponseBody() {}

  explicit ListResourceTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceTags) {
      res["ResourceTags"] = resourceTags ? boost::any(resourceTags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceTags") != m.end() && !m["ResourceTags"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceTags"].type()) {
        ListResourceTagsResponseBodyResourceTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceTags"]));
        resourceTags = make_shared<ListResourceTagsResponseBodyResourceTags>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListResourceTagsResponseBody() = default;
};
class ListResourceTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourceTagsResponseBody> body{};

  ListResourceTagsResponse() {}

  explicit ListResourceTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourceTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourceTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourceTagsResponse() = default;
};
class ListSchedulerInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceOwnerId{};

  ListSchedulerInstancesRequest() {}

  explicit ListSchedulerInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceOwnerId) {
      res["InstanceOwnerId"] = boost::any(*instanceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceOwnerId") != m.end() && !m["InstanceOwnerId"].empty()) {
      instanceOwnerId = make_shared<long>(boost::any_cast<long>(m["InstanceOwnerId"]));
    }
  }


  virtual ~ListSchedulerInstancesRequest() = default;
};
class ListSchedulerInstancesResponseBodySchedulerInstances : public Darabonba::Model {
public:
  shared_ptr<string> baseStrategy{};
  shared_ptr<string> business{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxConcurrency{};
  shared_ptr<string> ownerId{};

  ListSchedulerInstancesResponseBodySchedulerInstances() {}

  explicit ListSchedulerInstancesResponseBodySchedulerInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseStrategy) {
      res["BaseStrategy"] = boost::any(*baseStrategy);
    }
    if (business) {
      res["Business"] = boost::any(*business);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxConcurrency) {
      res["MaxConcurrency"] = boost::any(*maxConcurrency);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseStrategy") != m.end() && !m["BaseStrategy"].empty()) {
      baseStrategy = make_shared<string>(boost::any_cast<string>(m["BaseStrategy"]));
    }
    if (m.find("Business") != m.end() && !m["Business"].empty()) {
      business = make_shared<string>(boost::any_cast<string>(m["Business"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxConcurrency") != m.end() && !m["MaxConcurrency"].empty()) {
      maxConcurrency = make_shared<long>(boost::any_cast<long>(m["MaxConcurrency"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
  }


  virtual ~ListSchedulerInstancesResponseBodySchedulerInstances() = default;
};
class ListSchedulerInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSchedulerInstancesResponseBodySchedulerInstances>> schedulerInstances{};
  shared_ptr<bool> success{};

  ListSchedulerInstancesResponseBody() {}

  explicit ListSchedulerInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schedulerInstances) {
      vector<boost::any> temp1;
      for(auto item1:*schedulerInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SchedulerInstances"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SchedulerInstances") != m.end() && !m["SchedulerInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["SchedulerInstances"].type()) {
        vector<ListSchedulerInstancesResponseBodySchedulerInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SchedulerInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSchedulerInstancesResponseBodySchedulerInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedulerInstances = make_shared<vector<ListSchedulerInstancesResponseBodySchedulerInstances>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSchedulerInstancesResponseBody() = default;
};
class ListSchedulerInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSchedulerInstancesResponseBody> body{};

  ListSchedulerInstancesResponse() {}

  explicit ListSchedulerInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSchedulerInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSchedulerInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSchedulerInstancesResponse() = default;
};
class ListScriptPublishHistoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scriptId{};

  ListScriptPublishHistoriesRequest() {}

  explicit ListScriptPublishHistoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ListScriptPublishHistoriesRequest() = default;
};
class ListScriptPublishHistoriesResponseBodyScriptPublishHistoriesList : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> publishTime{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptVersion{};

  ListScriptPublishHistoriesResponseBodyScriptPublishHistoriesList() {}

  explicit ListScriptPublishHistoriesResponseBodyScriptPublishHistoriesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (publishTime) {
      res["PublishTime"] = boost::any(*publishTime);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptVersion) {
      res["ScriptVersion"] = boost::any(*scriptVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PublishTime") != m.end() && !m["PublishTime"].empty()) {
      publishTime = make_shared<long>(boost::any_cast<long>(m["PublishTime"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptVersion") != m.end() && !m["ScriptVersion"].empty()) {
      scriptVersion = make_shared<string>(boost::any_cast<string>(m["ScriptVersion"]));
    }
  }


  virtual ~ListScriptPublishHistoriesResponseBodyScriptPublishHistoriesList() = default;
};
class ListScriptPublishHistoriesResponseBodyScriptPublishHistories : public Darabonba::Model {
public:
  shared_ptr<vector<ListScriptPublishHistoriesResponseBodyScriptPublishHistoriesList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListScriptPublishHistoriesResponseBodyScriptPublishHistories() {}

  explicit ListScriptPublishHistoriesResponseBodyScriptPublishHistories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListScriptPublishHistoriesResponseBodyScriptPublishHistoriesList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScriptPublishHistoriesResponseBodyScriptPublishHistoriesList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListScriptPublishHistoriesResponseBodyScriptPublishHistoriesList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListScriptPublishHistoriesResponseBodyScriptPublishHistories() = default;
};
class ListScriptPublishHistoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListScriptPublishHistoriesResponseBodyScriptPublishHistories> scriptPublishHistories{};
  shared_ptr<bool> success{};

  ListScriptPublishHistoriesResponseBody() {}

  explicit ListScriptPublishHistoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scriptPublishHistories) {
      res["ScriptPublishHistories"] = scriptPublishHistories ? boost::any(scriptPublishHistories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScriptPublishHistories") != m.end() && !m["ScriptPublishHistories"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptPublishHistories"].type()) {
        ListScriptPublishHistoriesResponseBodyScriptPublishHistories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptPublishHistories"]));
        scriptPublishHistories = make_shared<ListScriptPublishHistoriesResponseBodyScriptPublishHistories>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListScriptPublishHistoriesResponseBody() = default;
};
class ListScriptPublishHistoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListScriptPublishHistoriesResponseBody> body{};

  ListScriptPublishHistoriesResponse() {}

  explicit ListScriptPublishHistoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScriptPublishHistoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScriptPublishHistoriesResponseBody>(model1);
      }
    }
  }


  virtual ~ListScriptPublishHistoriesResponse() = default;
};
class ListScriptRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> refIdsJson{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> search{};
  shared_ptr<string> statesJson{};
  shared_ptr<string> uuidsJson{};

  ListScriptRecordingRequest() {}

  explicit ListScriptRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (refIdsJson) {
      res["RefIdsJson"] = boost::any(*refIdsJson);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (search) {
      res["Search"] = boost::any(*search);
    }
    if (statesJson) {
      res["StatesJson"] = boost::any(*statesJson);
    }
    if (uuidsJson) {
      res["UuidsJson"] = boost::any(*uuidsJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RefIdsJson") != m.end() && !m["RefIdsJson"].empty()) {
      refIdsJson = make_shared<string>(boost::any_cast<string>(m["RefIdsJson"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("Search") != m.end() && !m["Search"].empty()) {
      search = make_shared<string>(boost::any_cast<string>(m["Search"]));
    }
    if (m.find("StatesJson") != m.end() && !m["StatesJson"].empty()) {
      statesJson = make_shared<string>(boost::any_cast<string>(m["StatesJson"]));
    }
    if (m.find("UuidsJson") != m.end() && !m["UuidsJson"].empty()) {
      uuidsJson = make_shared<string>(boost::any_cast<string>(m["UuidsJson"]));
    }
  }


  virtual ~ListScriptRecordingRequest() = default;
};
class ListScriptRecordingResponseBodyScriptRecordings : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> gmtUpload{};
  shared_ptr<string> innerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> recordingContent{};
  shared_ptr<long> recordingDuration{};
  shared_ptr<string> recordingName{};
  shared_ptr<string> refId{};
  shared_ptr<string> scriptId{};
  shared_ptr<long> state{};
  shared_ptr<string> stateExtend{};
  shared_ptr<string> storageUuid{};
  shared_ptr<string> uuid{};

  ListScriptRecordingResponseBodyScriptRecordings() {}

  explicit ListScriptRecordingResponseBodyScriptRecordings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtUpload) {
      res["GmtUpload"] = boost::any(*gmtUpload);
    }
    if (innerId) {
      res["InnerId"] = boost::any(*innerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (recordingContent) {
      res["RecordingContent"] = boost::any(*recordingContent);
    }
    if (recordingDuration) {
      res["RecordingDuration"] = boost::any(*recordingDuration);
    }
    if (recordingName) {
      res["RecordingName"] = boost::any(*recordingName);
    }
    if (refId) {
      res["RefId"] = boost::any(*refId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (stateExtend) {
      res["StateExtend"] = boost::any(*stateExtend);
    }
    if (storageUuid) {
      res["StorageUuid"] = boost::any(*storageUuid);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("GmtUpload") != m.end() && !m["GmtUpload"].empty()) {
      gmtUpload = make_shared<long>(boost::any_cast<long>(m["GmtUpload"]));
    }
    if (m.find("InnerId") != m.end() && !m["InnerId"].empty()) {
      innerId = make_shared<string>(boost::any_cast<string>(m["InnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RecordingContent") != m.end() && !m["RecordingContent"].empty()) {
      recordingContent = make_shared<string>(boost::any_cast<string>(m["RecordingContent"]));
    }
    if (m.find("RecordingDuration") != m.end() && !m["RecordingDuration"].empty()) {
      recordingDuration = make_shared<long>(boost::any_cast<long>(m["RecordingDuration"]));
    }
    if (m.find("RecordingName") != m.end() && !m["RecordingName"].empty()) {
      recordingName = make_shared<string>(boost::any_cast<string>(m["RecordingName"]));
    }
    if (m.find("RefId") != m.end() && !m["RefId"].empty()) {
      refId = make_shared<string>(boost::any_cast<string>(m["RefId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
    if (m.find("StateExtend") != m.end() && !m["StateExtend"].empty()) {
      stateExtend = make_shared<string>(boost::any_cast<string>(m["StateExtend"]));
    }
    if (m.find("StorageUuid") != m.end() && !m["StorageUuid"].empty()) {
      storageUuid = make_shared<string>(boost::any_cast<string>(m["StorageUuid"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ListScriptRecordingResponseBodyScriptRecordings() = default;
};
class ListScriptRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListScriptRecordingResponseBodyScriptRecordings>> scriptRecordings{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListScriptRecordingResponseBody() {}

  explicit ListScriptRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scriptRecordings) {
      vector<boost::any> temp1;
      for(auto item1:*scriptRecordings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptRecordings"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScriptRecordings") != m.end() && !m["ScriptRecordings"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptRecordings"].type()) {
        vector<ListScriptRecordingResponseBodyScriptRecordings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptRecordings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScriptRecordingResponseBodyScriptRecordings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptRecordings = make_shared<vector<ListScriptRecordingResponseBodyScriptRecordings>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListScriptRecordingResponseBody() = default;
};
class ListScriptRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListScriptRecordingResponseBody> body{};

  ListScriptRecordingResponse() {}

  explicit ListScriptRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScriptRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScriptRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~ListScriptRecordingResponse() = default;
};
class ListScriptVoiceConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scriptId{};

  ListScriptVoiceConfigsRequest() {}

  explicit ListScriptVoiceConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ListScriptVoiceConfigsRequest() = default;
};
class ListScriptVoiceConfigsResponseBodyScriptVoiceConfigsList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptContent{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptVoiceConfigId{};
  shared_ptr<string> scriptWaveformRelation{};
  shared_ptr<string> source{};
  shared_ptr<string> type{};

  ListScriptVoiceConfigsResponseBodyScriptVoiceConfigsList() {}

  explicit ListScriptVoiceConfigsResponseBodyScriptVoiceConfigsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptContent) {
      res["ScriptContent"] = boost::any(*scriptContent);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptVoiceConfigId) {
      res["ScriptVoiceConfigId"] = boost::any(*scriptVoiceConfigId);
    }
    if (scriptWaveformRelation) {
      res["ScriptWaveformRelation"] = boost::any(*scriptWaveformRelation);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptContent") != m.end() && !m["ScriptContent"].empty()) {
      scriptContent = make_shared<string>(boost::any_cast<string>(m["ScriptContent"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptVoiceConfigId") != m.end() && !m["ScriptVoiceConfigId"].empty()) {
      scriptVoiceConfigId = make_shared<string>(boost::any_cast<string>(m["ScriptVoiceConfigId"]));
    }
    if (m.find("ScriptWaveformRelation") != m.end() && !m["ScriptWaveformRelation"].empty()) {
      scriptWaveformRelation = make_shared<string>(boost::any_cast<string>(m["ScriptWaveformRelation"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListScriptVoiceConfigsResponseBodyScriptVoiceConfigsList() = default;
};
class ListScriptVoiceConfigsResponseBodyScriptVoiceConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<ListScriptVoiceConfigsResponseBodyScriptVoiceConfigsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListScriptVoiceConfigsResponseBodyScriptVoiceConfigs() {}

  explicit ListScriptVoiceConfigsResponseBodyScriptVoiceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListScriptVoiceConfigsResponseBodyScriptVoiceConfigsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScriptVoiceConfigsResponseBodyScriptVoiceConfigsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListScriptVoiceConfigsResponseBodyScriptVoiceConfigsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListScriptVoiceConfigsResponseBodyScriptVoiceConfigs() = default;
};
class ListScriptVoiceConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListScriptVoiceConfigsResponseBodyScriptVoiceConfigs> scriptVoiceConfigs{};
  shared_ptr<bool> success{};

  ListScriptVoiceConfigsResponseBody() {}

  explicit ListScriptVoiceConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scriptVoiceConfigs) {
      res["ScriptVoiceConfigs"] = scriptVoiceConfigs ? boost::any(scriptVoiceConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScriptVoiceConfigs") != m.end() && !m["ScriptVoiceConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptVoiceConfigs"].type()) {
        ListScriptVoiceConfigsResponseBodyScriptVoiceConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptVoiceConfigs"]));
        scriptVoiceConfigs = make_shared<ListScriptVoiceConfigsResponseBodyScriptVoiceConfigs>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListScriptVoiceConfigsResponseBody() = default;
};
class ListScriptVoiceConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListScriptVoiceConfigsResponseBody> body{};

  ListScriptVoiceConfigsResponse() {}

  explicit ListScriptVoiceConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScriptVoiceConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScriptVoiceConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~ListScriptVoiceConfigsResponse() = default;
};
class ListScriptsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> nluEngine{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scriptName{};

  ListScriptsRequest() {}

  explicit ListScriptsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nluEngine) {
      res["NluEngine"] = boost::any(*nluEngine);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NluEngine") != m.end() && !m["NluEngine"].empty()) {
      nluEngine = make_shared<string>(boost::any_cast<string>(m["NluEngine"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
  }


  virtual ~ListScriptsRequest() = default;
};
class ListScriptsResponseBodyScriptsListNluProfile : public Darabonba::Model {
public:
  shared_ptr<string> fcFunction{};
  shared_ptr<string> fcHttpTriggerUrl{};
  shared_ptr<string> fcRegion{};

  ListScriptsResponseBodyScriptsListNluProfile() {}

  explicit ListScriptsResponseBodyScriptsListNluProfile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fcFunction) {
      res["FcFunction"] = boost::any(*fcFunction);
    }
    if (fcHttpTriggerUrl) {
      res["FcHttpTriggerUrl"] = boost::any(*fcHttpTriggerUrl);
    }
    if (fcRegion) {
      res["FcRegion"] = boost::any(*fcRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FcFunction") != m.end() && !m["FcFunction"].empty()) {
      fcFunction = make_shared<string>(boost::any_cast<string>(m["FcFunction"]));
    }
    if (m.find("FcHttpTriggerUrl") != m.end() && !m["FcHttpTriggerUrl"].empty()) {
      fcHttpTriggerUrl = make_shared<string>(boost::any_cast<string>(m["FcHttpTriggerUrl"]));
    }
    if (m.find("FcRegion") != m.end() && !m["FcRegion"].empty()) {
      fcRegion = make_shared<string>(boost::any_cast<string>(m["FcRegion"]));
    }
  }


  virtual ~ListScriptsResponseBodyScriptsListNluProfile() = default;
};
class ListScriptsResponseBodyScriptsList : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<bool> agentLlm{};
  shared_ptr<long> createTime{};
  shared_ptr<string> debugStatus{};
  shared_ptr<bool> emotionEnable{};
  shared_ptr<string> industry{};
  shared_ptr<bool> isDebugDrafted{};
  shared_ptr<bool> isDrafted{};
  shared_ptr<bool> isPreset{};
  shared_ptr<bool> longWaitEnable{};
  shared_ptr<bool> miniPlaybackEnable{};
  shared_ptr<bool> newBargeInEnable{};
  shared_ptr<string> nluAccessType{};
  shared_ptr<string> nluEngine{};
  shared_ptr<ListScriptsResponseBodyScriptsListNluProfile> nluProfile{};
  shared_ptr<string> rejectReason{};
  shared_ptr<string> scene{};
  shared_ptr<string> scriptDescription{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> agentId{};

  ListScriptsResponseBodyScriptsList() {}

  explicit ListScriptsResponseBodyScriptsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (agentLlm) {
      res["AgentLlm"] = boost::any(*agentLlm);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (debugStatus) {
      res["DebugStatus"] = boost::any(*debugStatus);
    }
    if (emotionEnable) {
      res["EmotionEnable"] = boost::any(*emotionEnable);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (isDebugDrafted) {
      res["IsDebugDrafted"] = boost::any(*isDebugDrafted);
    }
    if (isDrafted) {
      res["IsDrafted"] = boost::any(*isDrafted);
    }
    if (isPreset) {
      res["IsPreset"] = boost::any(*isPreset);
    }
    if (longWaitEnable) {
      res["LongWaitEnable"] = boost::any(*longWaitEnable);
    }
    if (miniPlaybackEnable) {
      res["MiniPlaybackEnable"] = boost::any(*miniPlaybackEnable);
    }
    if (newBargeInEnable) {
      res["NewBargeInEnable"] = boost::any(*newBargeInEnable);
    }
    if (nluAccessType) {
      res["NluAccessType"] = boost::any(*nluAccessType);
    }
    if (nluEngine) {
      res["NluEngine"] = boost::any(*nluEngine);
    }
    if (nluProfile) {
      res["NluProfile"] = nluProfile ? boost::any(nluProfile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rejectReason) {
      res["RejectReason"] = boost::any(*rejectReason);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (scriptDescription) {
      res["ScriptDescription"] = boost::any(*scriptDescription);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (agentId) {
      res["agentId"] = boost::any(*agentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("AgentLlm") != m.end() && !m["AgentLlm"].empty()) {
      agentLlm = make_shared<bool>(boost::any_cast<bool>(m["AgentLlm"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DebugStatus") != m.end() && !m["DebugStatus"].empty()) {
      debugStatus = make_shared<string>(boost::any_cast<string>(m["DebugStatus"]));
    }
    if (m.find("EmotionEnable") != m.end() && !m["EmotionEnable"].empty()) {
      emotionEnable = make_shared<bool>(boost::any_cast<bool>(m["EmotionEnable"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("IsDebugDrafted") != m.end() && !m["IsDebugDrafted"].empty()) {
      isDebugDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDebugDrafted"]));
    }
    if (m.find("IsDrafted") != m.end() && !m["IsDrafted"].empty()) {
      isDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDrafted"]));
    }
    if (m.find("IsPreset") != m.end() && !m["IsPreset"].empty()) {
      isPreset = make_shared<bool>(boost::any_cast<bool>(m["IsPreset"]));
    }
    if (m.find("LongWaitEnable") != m.end() && !m["LongWaitEnable"].empty()) {
      longWaitEnable = make_shared<bool>(boost::any_cast<bool>(m["LongWaitEnable"]));
    }
    if (m.find("MiniPlaybackEnable") != m.end() && !m["MiniPlaybackEnable"].empty()) {
      miniPlaybackEnable = make_shared<bool>(boost::any_cast<bool>(m["MiniPlaybackEnable"]));
    }
    if (m.find("NewBargeInEnable") != m.end() && !m["NewBargeInEnable"].empty()) {
      newBargeInEnable = make_shared<bool>(boost::any_cast<bool>(m["NewBargeInEnable"]));
    }
    if (m.find("NluAccessType") != m.end() && !m["NluAccessType"].empty()) {
      nluAccessType = make_shared<string>(boost::any_cast<string>(m["NluAccessType"]));
    }
    if (m.find("NluEngine") != m.end() && !m["NluEngine"].empty()) {
      nluEngine = make_shared<string>(boost::any_cast<string>(m["NluEngine"]));
    }
    if (m.find("NluProfile") != m.end() && !m["NluProfile"].empty()) {
      if (typeid(map<string, boost::any>) == m["NluProfile"].type()) {
        ListScriptsResponseBodyScriptsListNluProfile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NluProfile"]));
        nluProfile = make_shared<ListScriptsResponseBodyScriptsListNluProfile>(model1);
      }
    }
    if (m.find("RejectReason") != m.end() && !m["RejectReason"].empty()) {
      rejectReason = make_shared<string>(boost::any_cast<string>(m["RejectReason"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("ScriptDescription") != m.end() && !m["ScriptDescription"].empty()) {
      scriptDescription = make_shared<string>(boost::any_cast<string>(m["ScriptDescription"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("agentId") != m.end() && !m["agentId"].empty()) {
      agentId = make_shared<long>(boost::any_cast<long>(m["agentId"]));
    }
  }


  virtual ~ListScriptsResponseBodyScriptsList() = default;
};
class ListScriptsResponseBodyScripts : public Darabonba::Model {
public:
  shared_ptr<vector<ListScriptsResponseBodyScriptsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListScriptsResponseBodyScripts() {}

  explicit ListScriptsResponseBodyScripts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListScriptsResponseBodyScriptsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScriptsResponseBodyScriptsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListScriptsResponseBodyScriptsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListScriptsResponseBodyScripts() = default;
};
class ListScriptsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListScriptsResponseBodyScripts> scripts{};
  shared_ptr<bool> success{};

  ListScriptsResponseBody() {}

  explicit ListScriptsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scripts) {
      res["Scripts"] = scripts ? boost::any(scripts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Scripts") != m.end() && !m["Scripts"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scripts"].type()) {
        ListScriptsResponseBodyScripts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scripts"]));
        scripts = make_shared<ListScriptsResponseBodyScripts>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListScriptsResponseBody() = default;
};
class ListScriptsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListScriptsResponseBody> body{};

  ListScriptsResponse() {}

  explicit ListScriptsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScriptsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScriptsResponseBody>(model1);
      }
    }
  }


  virtual ~ListScriptsResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListTagResourcesResponseBodyTagResources>> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<ListTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<ListTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  ListTagsRequest() {}

  explicit ListTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ListTagsRequest() = default;
};
class ListTagsResponseBodyTagGroups : public Darabonba::Model {
public:
  shared_ptr<string> scriptId{};
  shared_ptr<string> tagGroup{};
  shared_ptr<string> tagGroupId{};
  shared_ptr<long> tagGroupIndex{};

  ListTagsResponseBodyTagGroups() {}

  explicit ListTagsResponseBodyTagGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (tagGroup) {
      res["TagGroup"] = boost::any(*tagGroup);
    }
    if (tagGroupId) {
      res["TagGroupId"] = boost::any(*tagGroupId);
    }
    if (tagGroupIndex) {
      res["TagGroupIndex"] = boost::any(*tagGroupIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("TagGroup") != m.end() && !m["TagGroup"].empty()) {
      tagGroup = make_shared<string>(boost::any_cast<string>(m["TagGroup"]));
    }
    if (m.find("TagGroupId") != m.end() && !m["TagGroupId"].empty()) {
      tagGroupId = make_shared<string>(boost::any_cast<string>(m["TagGroupId"]));
    }
    if (m.find("TagGroupIndex") != m.end() && !m["TagGroupIndex"].empty()) {
      tagGroupIndex = make_shared<long>(boost::any_cast<long>(m["TagGroupIndex"]));
    }
  }


  virtual ~ListTagsResponseBodyTagGroups() = default;
};
class ListTagsResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> scriptId{};
  shared_ptr<string> tagGroup{};
  shared_ptr<string> tagId{};
  shared_ptr<long> tagIndex{};
  shared_ptr<string> tagName{};

  ListTagsResponseBodyTags() {}

  explicit ListTagsResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (tagGroup) {
      res["TagGroup"] = boost::any(*tagGroup);
    }
    if (tagId) {
      res["TagId"] = boost::any(*tagId);
    }
    if (tagIndex) {
      res["TagIndex"] = boost::any(*tagIndex);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("TagGroup") != m.end() && !m["TagGroup"].empty()) {
      tagGroup = make_shared<string>(boost::any_cast<string>(m["TagGroup"]));
    }
    if (m.find("TagId") != m.end() && !m["TagId"].empty()) {
      tagId = make_shared<string>(boost::any_cast<string>(m["TagId"]));
    }
    if (m.find("TagIndex") != m.end() && !m["TagIndex"].empty()) {
      tagIndex = make_shared<long>(boost::any_cast<long>(m["TagIndex"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~ListTagsResponseBodyTags() = default;
};
class ListTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListTagsResponseBodyTagGroups>> tagGroups{};
  shared_ptr<vector<ListTagsResponseBodyTags>> tags{};

  ListTagsResponseBody() {}

  explicit ListTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tagGroups) {
      vector<boost::any> temp1;
      for(auto item1:*tagGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagGroups"] = boost::any(temp1);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TagGroups") != m.end() && !m["TagGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["TagGroups"].type()) {
        vector<ListTagsResponseBodyTagGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagsResponseBodyTagGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagGroups = make_shared<vector<ListTagsResponseBodyTagGroups>>(expect1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListTagsResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagsResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListTagsResponseBodyTags>>(expect1);
      }
    }
  }


  virtual ~ListTagsResponseBody() = default;
};
class ListTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagsResponseBody> body{};

  ListTagsResponse() {}

  explicit ListTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagsResponse() = default;
};
class ModifyAgentProfileRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentProfileId{};
  shared_ptr<string> apiPluginJson{};
  shared_ptr<string> description{};
  shared_ptr<vector<long>> faqCategoryIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instructionJson{};
  shared_ptr<string> labelsJson{};
  shared_ptr<string> model{};
  shared_ptr<string> modelConfig{};
  shared_ptr<string> prompt{};
  shared_ptr<string> promptJson{};
  shared_ptr<string> scenario{};
  shared_ptr<string> variablesJson{};

  ModifyAgentProfileRequest() {}

  explicit ModifyAgentProfileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentProfileId) {
      res["AgentProfileId"] = boost::any(*agentProfileId);
    }
    if (apiPluginJson) {
      res["ApiPluginJson"] = boost::any(*apiPluginJson);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (faqCategoryIds) {
      res["FaqCategoryIds"] = boost::any(*faqCategoryIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instructionJson) {
      res["InstructionJson"] = boost::any(*instructionJson);
    }
    if (labelsJson) {
      res["LabelsJson"] = boost::any(*labelsJson);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (modelConfig) {
      res["ModelConfig"] = boost::any(*modelConfig);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (promptJson) {
      res["PromptJson"] = boost::any(*promptJson);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (variablesJson) {
      res["VariablesJson"] = boost::any(*variablesJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentProfileId") != m.end() && !m["AgentProfileId"].empty()) {
      agentProfileId = make_shared<string>(boost::any_cast<string>(m["AgentProfileId"]));
    }
    if (m.find("ApiPluginJson") != m.end() && !m["ApiPluginJson"].empty()) {
      apiPluginJson = make_shared<string>(boost::any_cast<string>(m["ApiPluginJson"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FaqCategoryIds") != m.end() && !m["FaqCategoryIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["FaqCategoryIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FaqCategoryIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      faqCategoryIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstructionJson") != m.end() && !m["InstructionJson"].empty()) {
      instructionJson = make_shared<string>(boost::any_cast<string>(m["InstructionJson"]));
    }
    if (m.find("LabelsJson") != m.end() && !m["LabelsJson"].empty()) {
      labelsJson = make_shared<string>(boost::any_cast<string>(m["LabelsJson"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("ModelConfig") != m.end() && !m["ModelConfig"].empty()) {
      modelConfig = make_shared<string>(boost::any_cast<string>(m["ModelConfig"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("PromptJson") != m.end() && !m["PromptJson"].empty()) {
      promptJson = make_shared<string>(boost::any_cast<string>(m["PromptJson"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("VariablesJson") != m.end() && !m["VariablesJson"].empty()) {
      variablesJson = make_shared<string>(boost::any_cast<string>(m["VariablesJson"]));
    }
  }


  virtual ~ModifyAgentProfileRequest() = default;
};
class ModifyAgentProfileShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentProfileId{};
  shared_ptr<string> apiPluginJson{};
  shared_ptr<string> description{};
  shared_ptr<string> faqCategoryIdsShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instructionJson{};
  shared_ptr<string> labelsJson{};
  shared_ptr<string> model{};
  shared_ptr<string> modelConfig{};
  shared_ptr<string> prompt{};
  shared_ptr<string> promptJson{};
  shared_ptr<string> scenario{};
  shared_ptr<string> variablesJson{};

  ModifyAgentProfileShrinkRequest() {}

  explicit ModifyAgentProfileShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentProfileId) {
      res["AgentProfileId"] = boost::any(*agentProfileId);
    }
    if (apiPluginJson) {
      res["ApiPluginJson"] = boost::any(*apiPluginJson);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (faqCategoryIdsShrink) {
      res["FaqCategoryIds"] = boost::any(*faqCategoryIdsShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instructionJson) {
      res["InstructionJson"] = boost::any(*instructionJson);
    }
    if (labelsJson) {
      res["LabelsJson"] = boost::any(*labelsJson);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (modelConfig) {
      res["ModelConfig"] = boost::any(*modelConfig);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (promptJson) {
      res["PromptJson"] = boost::any(*promptJson);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (variablesJson) {
      res["VariablesJson"] = boost::any(*variablesJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentProfileId") != m.end() && !m["AgentProfileId"].empty()) {
      agentProfileId = make_shared<string>(boost::any_cast<string>(m["AgentProfileId"]));
    }
    if (m.find("ApiPluginJson") != m.end() && !m["ApiPluginJson"].empty()) {
      apiPluginJson = make_shared<string>(boost::any_cast<string>(m["ApiPluginJson"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FaqCategoryIds") != m.end() && !m["FaqCategoryIds"].empty()) {
      faqCategoryIdsShrink = make_shared<string>(boost::any_cast<string>(m["FaqCategoryIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstructionJson") != m.end() && !m["InstructionJson"].empty()) {
      instructionJson = make_shared<string>(boost::any_cast<string>(m["InstructionJson"]));
    }
    if (m.find("LabelsJson") != m.end() && !m["LabelsJson"].empty()) {
      labelsJson = make_shared<string>(boost::any_cast<string>(m["LabelsJson"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("ModelConfig") != m.end() && !m["ModelConfig"].empty()) {
      modelConfig = make_shared<string>(boost::any_cast<string>(m["ModelConfig"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("PromptJson") != m.end() && !m["PromptJson"].empty()) {
      promptJson = make_shared<string>(boost::any_cast<string>(m["PromptJson"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("VariablesJson") != m.end() && !m["VariablesJson"].empty()) {
      variablesJson = make_shared<string>(boost::any_cast<string>(m["VariablesJson"]));
    }
  }


  virtual ~ModifyAgentProfileShrinkRequest() = default;
};
class ModifyAgentProfileResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> agentProfileId{};
  shared_ptr<string> agentProfileTemplateId{};
  shared_ptr<string> agentType{};
  shared_ptr<string> apiPluginJson{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instructionJson{};
  shared_ptr<string> labelsJson{};
  shared_ptr<string> model{};
  shared_ptr<string> modelConfig{};
  shared_ptr<string> nluConfigJson{};
  shared_ptr<string> prompt{};
  shared_ptr<string> promptJson{};
  shared_ptr<string> scenario{};
  shared_ptr<string> scriptId{};
  shared_ptr<bool> system{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> variablesJson{};

  ModifyAgentProfileResponseBodyData() {}

  explicit ModifyAgentProfileResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentProfileId) {
      res["AgentProfileId"] = boost::any(*agentProfileId);
    }
    if (agentProfileTemplateId) {
      res["AgentProfileTemplateId"] = boost::any(*agentProfileTemplateId);
    }
    if (agentType) {
      res["AgentType"] = boost::any(*agentType);
    }
    if (apiPluginJson) {
      res["ApiPluginJson"] = boost::any(*apiPluginJson);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instructionJson) {
      res["InstructionJson"] = boost::any(*instructionJson);
    }
    if (labelsJson) {
      res["LabelsJson"] = boost::any(*labelsJson);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (modelConfig) {
      res["ModelConfig"] = boost::any(*modelConfig);
    }
    if (nluConfigJson) {
      res["NluConfigJson"] = boost::any(*nluConfigJson);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (promptJson) {
      res["PromptJson"] = boost::any(*promptJson);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (system) {
      res["System"] = boost::any(*system);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (variablesJson) {
      res["VariablesJson"] = boost::any(*variablesJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentProfileId") != m.end() && !m["AgentProfileId"].empty()) {
      agentProfileId = make_shared<string>(boost::any_cast<string>(m["AgentProfileId"]));
    }
    if (m.find("AgentProfileTemplateId") != m.end() && !m["AgentProfileTemplateId"].empty()) {
      agentProfileTemplateId = make_shared<string>(boost::any_cast<string>(m["AgentProfileTemplateId"]));
    }
    if (m.find("AgentType") != m.end() && !m["AgentType"].empty()) {
      agentType = make_shared<string>(boost::any_cast<string>(m["AgentType"]));
    }
    if (m.find("ApiPluginJson") != m.end() && !m["ApiPluginJson"].empty()) {
      apiPluginJson = make_shared<string>(boost::any_cast<string>(m["ApiPluginJson"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstructionJson") != m.end() && !m["InstructionJson"].empty()) {
      instructionJson = make_shared<string>(boost::any_cast<string>(m["InstructionJson"]));
    }
    if (m.find("LabelsJson") != m.end() && !m["LabelsJson"].empty()) {
      labelsJson = make_shared<string>(boost::any_cast<string>(m["LabelsJson"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("ModelConfig") != m.end() && !m["ModelConfig"].empty()) {
      modelConfig = make_shared<string>(boost::any_cast<string>(m["ModelConfig"]));
    }
    if (m.find("NluConfigJson") != m.end() && !m["NluConfigJson"].empty()) {
      nluConfigJson = make_shared<string>(boost::any_cast<string>(m["NluConfigJson"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("PromptJson") != m.end() && !m["PromptJson"].empty()) {
      promptJson = make_shared<string>(boost::any_cast<string>(m["PromptJson"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("System") != m.end() && !m["System"].empty()) {
      system = make_shared<bool>(boost::any_cast<bool>(m["System"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VariablesJson") != m.end() && !m["VariablesJson"].empty()) {
      variablesJson = make_shared<string>(boost::any_cast<string>(m["VariablesJson"]));
    }
  }


  virtual ~ModifyAgentProfileResponseBodyData() = default;
};
class ModifyAgentProfileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ModifyAgentProfileResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyAgentProfileResponseBody() {}

  explicit ModifyAgentProfileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ModifyAgentProfileResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ModifyAgentProfileResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyAgentProfileResponseBody() = default;
};
class ModifyAgentProfileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAgentProfileResponseBody> body{};

  ModifyAgentProfileResponse() {}

  explicit ModifyAgentProfileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAgentProfileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAgentProfileResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAgentProfileResponse() = default;
};
class ModifyAnnotationMissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionName{};
  shared_ptr<long> annotationStatus{};
  shared_ptr<bool> delete_{};

  ModifyAnnotationMissionRequest() {}

  explicit ModifyAnnotationMissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionName) {
      res["AnnotationMissionName"] = boost::any(*annotationMissionName);
    }
    if (annotationStatus) {
      res["AnnotationStatus"] = boost::any(*annotationStatus);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionName") != m.end() && !m["AnnotationMissionName"].empty()) {
      annotationMissionName = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionName"]));
    }
    if (m.find("AnnotationStatus") != m.end() && !m["AnnotationStatus"].empty()) {
      annotationStatus = make_shared<long>(boost::any_cast<long>(m["AnnotationStatus"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<bool>(boost::any_cast<bool>(m["Delete"]));
    }
  }


  virtual ~ModifyAnnotationMissionRequest() = default;
};
class ModifyAnnotationMissionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  ModifyAnnotationMissionResponseBodyData() {}

  explicit ModifyAnnotationMissionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyAnnotationMissionResponseBodyData() = default;
};
class ModifyAnnotationMissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ModifyAnnotationMissionResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyAnnotationMissionResponseBody() {}

  explicit ModifyAnnotationMissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ModifyAnnotationMissionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ModifyAnnotationMissionResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyAnnotationMissionResponseBody() = default;
};
class ModifyAnnotationMissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAnnotationMissionResponseBody> body{};

  ModifyAnnotationMissionResponse() {}

  explicit ModifyAnnotationMissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAnnotationMissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAnnotationMissionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAnnotationMissionResponse() = default;
};
class ModifyBatchJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> batchJobName{};
  shared_ptr<vector<string>> callingNumber{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobFilePath{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> strategyJson{};
  shared_ptr<bool> submitted{};

  ModifyBatchJobsRequest() {}

  explicit ModifyBatchJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchJobName) {
      res["BatchJobName"] = boost::any(*batchJobName);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobFilePath) {
      res["JobFilePath"] = boost::any(*jobFilePath);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (strategyJson) {
      res["StrategyJson"] = boost::any(*strategyJson);
    }
    if (submitted) {
      res["Submitted"] = boost::any(*submitted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchJobName") != m.end() && !m["BatchJobName"].empty()) {
      batchJobName = make_shared<string>(boost::any_cast<string>(m["BatchJobName"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumber = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobFilePath") != m.end() && !m["JobFilePath"].empty()) {
      jobFilePath = make_shared<string>(boost::any_cast<string>(m["JobFilePath"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("StrategyJson") != m.end() && !m["StrategyJson"].empty()) {
      strategyJson = make_shared<string>(boost::any_cast<string>(m["StrategyJson"]));
    }
    if (m.find("Submitted") != m.end() && !m["Submitted"].empty()) {
      submitted = make_shared<bool>(boost::any_cast<bool>(m["Submitted"]));
    }
  }


  virtual ~ModifyBatchJobsRequest() = default;
};
class ModifyBatchJobsResponseBodyJobGroupStrategyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> beginTime{};
  shared_ptr<string> endTime{};

  ModifyBatchJobsResponseBodyJobGroupStrategyWorkingTime() {}

  explicit ModifyBatchJobsResponseBodyJobGroupStrategyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~ModifyBatchJobsResponseBodyJobGroupStrategyWorkingTime() = default;
};
class ModifyBatchJobsResponseBodyJobGroupStrategy : public Darabonba::Model {
public:
  shared_ptr<string> customized{};
  shared_ptr<long> endTime{};
  shared_ptr<string> followUpStrategy{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> repeatBy{};
  shared_ptr<vector<string>> repeatDays{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<long> startTime{};
  shared_ptr<string> strategyDescription{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> strategyName{};
  shared_ptr<string> type{};
  shared_ptr<vector<ModifyBatchJobsResponseBodyJobGroupStrategyWorkingTime>> workingTime{};

  ModifyBatchJobsResponseBodyJobGroupStrategy() {}

  explicit ModifyBatchJobsResponseBodyJobGroupStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (followUpStrategy) {
      res["FollowUpStrategy"] = boost::any(*followUpStrategy);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (repeatBy) {
      res["RepeatBy"] = boost::any(*repeatBy);
    }
    if (repeatDays) {
      res["RepeatDays"] = boost::any(*repeatDays);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (strategyDescription) {
      res["StrategyDescription"] = boost::any(*strategyDescription);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<string>(boost::any_cast<string>(m["Customized"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FollowUpStrategy") != m.end() && !m["FollowUpStrategy"].empty()) {
      followUpStrategy = make_shared<string>(boost::any_cast<string>(m["FollowUpStrategy"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("RepeatBy") != m.end() && !m["RepeatBy"].empty()) {
      repeatBy = make_shared<string>(boost::any_cast<string>(m["RepeatBy"]));
    }
    if (m.find("RepeatDays") != m.end() && !m["RepeatDays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StrategyDescription") != m.end() && !m["StrategyDescription"].empty()) {
      strategyDescription = make_shared<string>(boost::any_cast<string>(m["StrategyDescription"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<ModifyBatchJobsResponseBodyJobGroupStrategyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyBatchJobsResponseBodyJobGroupStrategyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<ModifyBatchJobsResponseBodyJobGroupStrategyWorkingTime>>(expect1);
      }
    }
  }


  virtual ~ModifyBatchJobsResponseBodyJobGroupStrategy() = default;
};
class ModifyBatchJobsResponseBodyJobGroup : public Darabonba::Model {
public:
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<long> creationTime{};
  shared_ptr<string> jobFilePath{};
  shared_ptr<string> jobGroupDescription{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobGroupName{};
  shared_ptr<string> scenarioId{};
  shared_ptr<ModifyBatchJobsResponseBodyJobGroupStrategy> strategy{};

  ModifyBatchJobsResponseBodyJobGroup() {}

  explicit ModifyBatchJobsResponseBodyJobGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (jobFilePath) {
      res["JobFilePath"] = boost::any(*jobFilePath);
    }
    if (jobGroupDescription) {
      res["JobGroupDescription"] = boost::any(*jobGroupDescription);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobGroupName) {
      res["JobGroupName"] = boost::any(*jobGroupName);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("JobFilePath") != m.end() && !m["JobFilePath"].empty()) {
      jobFilePath = make_shared<string>(boost::any_cast<string>(m["JobFilePath"]));
    }
    if (m.find("JobGroupDescription") != m.end() && !m["JobGroupDescription"].empty()) {
      jobGroupDescription = make_shared<string>(boost::any_cast<string>(m["JobGroupDescription"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobGroupName") != m.end() && !m["JobGroupName"].empty()) {
      jobGroupName = make_shared<string>(boost::any_cast<string>(m["JobGroupName"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        ModifyBatchJobsResponseBodyJobGroupStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<ModifyBatchJobsResponseBodyJobGroupStrategy>(model1);
      }
    }
  }


  virtual ~ModifyBatchJobsResponseBodyJobGroup() = default;
};
class ModifyBatchJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ModifyBatchJobsResponseBodyJobGroup> jobGroup{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyBatchJobsResponseBody() {}

  explicit ModifyBatchJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobGroup) {
      res["JobGroup"] = jobGroup ? boost::any(jobGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("JobGroup") != m.end() && !m["JobGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobGroup"].type()) {
        ModifyBatchJobsResponseBodyJobGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobGroup"]));
        jobGroup = make_shared<ModifyBatchJobsResponseBodyJobGroup>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyBatchJobsResponseBody() = default;
};
class ModifyBatchJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBatchJobsResponseBody> body{};

  ModifyBatchJobsResponse() {}

  explicit ModifyBatchJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBatchJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBatchJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBatchJobsResponse() = default;
};
class ModifyBeebotIntentRequestIntentDefinition : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> intentName{};

  ModifyBeebotIntentRequestIntentDefinition() {}

  explicit ModifyBeebotIntentRequestIntentDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (intentName) {
      res["IntentName"] = boost::any(*intentName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("IntentName") != m.end() && !m["IntentName"].empty()) {
      intentName = make_shared<string>(boost::any_cast<string>(m["IntentName"]));
    }
  }


  virtual ~ModifyBeebotIntentRequestIntentDefinition() = default;
};
class ModifyBeebotIntentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<ModifyBeebotIntentRequestIntentDefinition> intentDefinition{};
  shared_ptr<long> intentId{};
  shared_ptr<string> scriptId{};

  ModifyBeebotIntentRequest() {}

  explicit ModifyBeebotIntentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentDefinition) {
      res["IntentDefinition"] = intentDefinition ? boost::any(intentDefinition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentDefinition") != m.end() && !m["IntentDefinition"].empty()) {
      if (typeid(map<string, boost::any>) == m["IntentDefinition"].type()) {
        ModifyBeebotIntentRequestIntentDefinition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IntentDefinition"]));
        intentDefinition = make_shared<ModifyBeebotIntentRequestIntentDefinition>(model1);
      }
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ModifyBeebotIntentRequest() = default;
};
class ModifyBeebotIntentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> intentDefinitionShrink{};
  shared_ptr<long> intentId{};
  shared_ptr<string> scriptId{};

  ModifyBeebotIntentShrinkRequest() {}

  explicit ModifyBeebotIntentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentDefinitionShrink) {
      res["IntentDefinition"] = boost::any(*intentDefinitionShrink);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentDefinition") != m.end() && !m["IntentDefinition"].empty()) {
      intentDefinitionShrink = make_shared<string>(boost::any_cast<string>(m["IntentDefinition"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ModifyBeebotIntentShrinkRequest() = default;
};
class ModifyBeebotIntentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beebotRequestId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> intentId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyBeebotIntentResponseBody() {}

  explicit ModifyBeebotIntentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beebotRequestId) {
      res["BeebotRequestId"] = boost::any(*beebotRequestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeebotRequestId") != m.end() && !m["BeebotRequestId"].empty()) {
      beebotRequestId = make_shared<string>(boost::any_cast<string>(m["BeebotRequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyBeebotIntentResponseBody() = default;
};
class ModifyBeebotIntentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBeebotIntentResponseBody> body{};

  ModifyBeebotIntentResponse() {}

  explicit ModifyBeebotIntentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBeebotIntentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBeebotIntentResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBeebotIntentResponse() = default;
};
class ModifyBeebotIntentLgfRequestLgfDefinition : public Darabonba::Model {
public:
  shared_ptr<long> intentId{};
  shared_ptr<string> ruleText{};

  ModifyBeebotIntentLgfRequestLgfDefinition() {}

  explicit ModifyBeebotIntentLgfRequestLgfDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (ruleText) {
      res["RuleText"] = boost::any(*ruleText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("RuleText") != m.end() && !m["RuleText"].empty()) {
      ruleText = make_shared<string>(boost::any_cast<string>(m["RuleText"]));
    }
  }


  virtual ~ModifyBeebotIntentLgfRequestLgfDefinition() = default;
};
class ModifyBeebotIntentLgfRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<ModifyBeebotIntentLgfRequestLgfDefinition> lgfDefinition{};
  shared_ptr<long> lgfId{};
  shared_ptr<string> scriptId{};

  ModifyBeebotIntentLgfRequest() {}

  explicit ModifyBeebotIntentLgfRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lgfDefinition) {
      res["LgfDefinition"] = lgfDefinition ? boost::any(lgfDefinition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lgfId) {
      res["LgfId"] = boost::any(*lgfId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LgfDefinition") != m.end() && !m["LgfDefinition"].empty()) {
      if (typeid(map<string, boost::any>) == m["LgfDefinition"].type()) {
        ModifyBeebotIntentLgfRequestLgfDefinition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LgfDefinition"]));
        lgfDefinition = make_shared<ModifyBeebotIntentLgfRequestLgfDefinition>(model1);
      }
    }
    if (m.find("LgfId") != m.end() && !m["LgfId"].empty()) {
      lgfId = make_shared<long>(boost::any_cast<long>(m["LgfId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ModifyBeebotIntentLgfRequest() = default;
};
class ModifyBeebotIntentLgfShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lgfDefinitionShrink{};
  shared_ptr<long> lgfId{};
  shared_ptr<string> scriptId{};

  ModifyBeebotIntentLgfShrinkRequest() {}

  explicit ModifyBeebotIntentLgfShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lgfDefinitionShrink) {
      res["LgfDefinition"] = boost::any(*lgfDefinitionShrink);
    }
    if (lgfId) {
      res["LgfId"] = boost::any(*lgfId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LgfDefinition") != m.end() && !m["LgfDefinition"].empty()) {
      lgfDefinitionShrink = make_shared<string>(boost::any_cast<string>(m["LgfDefinition"]));
    }
    if (m.find("LgfId") != m.end() && !m["LgfId"].empty()) {
      lgfId = make_shared<long>(boost::any_cast<long>(m["LgfId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ModifyBeebotIntentLgfShrinkRequest() = default;
};
class ModifyBeebotIntentLgfResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beebotRequestId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> lgfId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyBeebotIntentLgfResponseBody() {}

  explicit ModifyBeebotIntentLgfResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beebotRequestId) {
      res["BeebotRequestId"] = boost::any(*beebotRequestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (lgfId) {
      res["LgfId"] = boost::any(*lgfId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeebotRequestId") != m.end() && !m["BeebotRequestId"].empty()) {
      beebotRequestId = make_shared<string>(boost::any_cast<string>(m["BeebotRequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("LgfId") != m.end() && !m["LgfId"].empty()) {
      lgfId = make_shared<long>(boost::any_cast<long>(m["LgfId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyBeebotIntentLgfResponseBody() = default;
};
class ModifyBeebotIntentLgfResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBeebotIntentLgfResponseBody> body{};

  ModifyBeebotIntentLgfResponse() {}

  explicit ModifyBeebotIntentLgfResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBeebotIntentLgfResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBeebotIntentLgfResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBeebotIntentLgfResponse() = default;
};
class ModifyBeebotIntentUserSayRequestUserSayDefinition : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> intentId{};

  ModifyBeebotIntentUserSayRequestUserSayDefinition() {}

  explicit ModifyBeebotIntentUserSayRequestUserSayDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
  }


  virtual ~ModifyBeebotIntentUserSayRequestUserSayDefinition() = default;
};
class ModifyBeebotIntentUserSayRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};
  shared_ptr<ModifyBeebotIntentUserSayRequestUserSayDefinition> userSayDefinition{};
  shared_ptr<string> userSayId{};

  ModifyBeebotIntentUserSayRequest() {}

  explicit ModifyBeebotIntentUserSayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (userSayDefinition) {
      res["UserSayDefinition"] = userSayDefinition ? boost::any(userSayDefinition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userSayId) {
      res["UserSayId"] = boost::any(*userSayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("UserSayDefinition") != m.end() && !m["UserSayDefinition"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserSayDefinition"].type()) {
        ModifyBeebotIntentUserSayRequestUserSayDefinition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserSayDefinition"]));
        userSayDefinition = make_shared<ModifyBeebotIntentUserSayRequestUserSayDefinition>(model1);
      }
    }
    if (m.find("UserSayId") != m.end() && !m["UserSayId"].empty()) {
      userSayId = make_shared<string>(boost::any_cast<string>(m["UserSayId"]));
    }
  }


  virtual ~ModifyBeebotIntentUserSayRequest() = default;
};
class ModifyBeebotIntentUserSayShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> userSayDefinitionShrink{};
  shared_ptr<string> userSayId{};

  ModifyBeebotIntentUserSayShrinkRequest() {}

  explicit ModifyBeebotIntentUserSayShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (userSayDefinitionShrink) {
      res["UserSayDefinition"] = boost::any(*userSayDefinitionShrink);
    }
    if (userSayId) {
      res["UserSayId"] = boost::any(*userSayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("UserSayDefinition") != m.end() && !m["UserSayDefinition"].empty()) {
      userSayDefinitionShrink = make_shared<string>(boost::any_cast<string>(m["UserSayDefinition"]));
    }
    if (m.find("UserSayId") != m.end() && !m["UserSayId"].empty()) {
      userSayId = make_shared<string>(boost::any_cast<string>(m["UserSayId"]));
    }
  }


  virtual ~ModifyBeebotIntentUserSayShrinkRequest() = default;
};
class ModifyBeebotIntentUserSayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beebotRequestId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> userSayId{};

  ModifyBeebotIntentUserSayResponseBody() {}

  explicit ModifyBeebotIntentUserSayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beebotRequestId) {
      res["BeebotRequestId"] = boost::any(*beebotRequestId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (userSayId) {
      res["UserSayId"] = boost::any(*userSayId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeebotRequestId") != m.end() && !m["BeebotRequestId"].empty()) {
      beebotRequestId = make_shared<string>(boost::any_cast<string>(m["BeebotRequestId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("UserSayId") != m.end() && !m["UserSayId"].empty()) {
      userSayId = make_shared<long>(boost::any_cast<long>(m["UserSayId"]));
    }
  }


  virtual ~ModifyBeebotIntentUserSayResponseBody() = default;
};
class ModifyBeebotIntentUserSayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBeebotIntentUserSayResponseBody> body{};

  ModifyBeebotIntentUserSayResponse() {}

  explicit ModifyBeebotIntentUserSayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBeebotIntentUserSayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBeebotIntentUserSayResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBeebotIntentUserSayResponse() = default;
};
class ModifyDialogueFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> dialogueFlowDefinition{};
  shared_ptr<string> dialogueFlowId{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isDrafted{};
  shared_ptr<string> scriptId{};

  ModifyDialogueFlowRequest() {}

  explicit ModifyDialogueFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dialogueFlowDefinition) {
      res["DialogueFlowDefinition"] = boost::any(*dialogueFlowDefinition);
    }
    if (dialogueFlowId) {
      res["DialogueFlowId"] = boost::any(*dialogueFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isDrafted) {
      res["IsDrafted"] = boost::any(*isDrafted);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DialogueFlowDefinition") != m.end() && !m["DialogueFlowDefinition"].empty()) {
      dialogueFlowDefinition = make_shared<string>(boost::any_cast<string>(m["DialogueFlowDefinition"]));
    }
    if (m.find("DialogueFlowId") != m.end() && !m["DialogueFlowId"].empty()) {
      dialogueFlowId = make_shared<string>(boost::any_cast<string>(m["DialogueFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsDrafted") != m.end() && !m["IsDrafted"].empty()) {
      isDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDrafted"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ModifyDialogueFlowRequest() = default;
};
class ModifyDialogueFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dialogueFlowDefinition{};
  shared_ptr<string> dialogueFlowId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyDialogueFlowResponseBody() {}

  explicit ModifyDialogueFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dialogueFlowDefinition) {
      res["DialogueFlowDefinition"] = boost::any(*dialogueFlowDefinition);
    }
    if (dialogueFlowId) {
      res["DialogueFlowId"] = boost::any(*dialogueFlowId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DialogueFlowDefinition") != m.end() && !m["DialogueFlowDefinition"].empty()) {
      dialogueFlowDefinition = make_shared<string>(boost::any_cast<string>(m["DialogueFlowDefinition"]));
    }
    if (m.find("DialogueFlowId") != m.end() && !m["DialogueFlowId"].empty()) {
      dialogueFlowId = make_shared<string>(boost::any_cast<string>(m["DialogueFlowId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyDialogueFlowResponseBody() = default;
};
class ModifyDialogueFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDialogueFlowResponseBody> body{};

  ModifyDialogueFlowResponse() {}

  explicit ModifyDialogueFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDialogueFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDialogueFlowResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDialogueFlowResponse() = default;
};
class ModifyEmptyNumberNoMoreCallsInfoRequest : public Darabonba::Model {
public:
  shared_ptr<bool> emptyNumberNoMoreCalls{};
  shared_ptr<string> entryId{};
  shared_ptr<long> strategyLevel{};

  ModifyEmptyNumberNoMoreCallsInfoRequest() {}

  explicit ModifyEmptyNumberNoMoreCallsInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emptyNumberNoMoreCalls) {
      res["EmptyNumberNoMoreCalls"] = boost::any(*emptyNumberNoMoreCalls);
    }
    if (entryId) {
      res["EntryId"] = boost::any(*entryId);
    }
    if (strategyLevel) {
      res["StrategyLevel"] = boost::any(*strategyLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmptyNumberNoMoreCalls") != m.end() && !m["EmptyNumberNoMoreCalls"].empty()) {
      emptyNumberNoMoreCalls = make_shared<bool>(boost::any_cast<bool>(m["EmptyNumberNoMoreCalls"]));
    }
    if (m.find("EntryId") != m.end() && !m["EntryId"].empty()) {
      entryId = make_shared<string>(boost::any_cast<string>(m["EntryId"]));
    }
    if (m.find("StrategyLevel") != m.end() && !m["StrategyLevel"].empty()) {
      strategyLevel = make_shared<long>(boost::any_cast<long>(m["StrategyLevel"]));
    }
  }


  virtual ~ModifyEmptyNumberNoMoreCallsInfoRequest() = default;
};
class ModifyEmptyNumberNoMoreCallsInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyEmptyNumberNoMoreCallsInfoResponseBody() {}

  explicit ModifyEmptyNumberNoMoreCallsInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyEmptyNumberNoMoreCallsInfoResponseBody() = default;
};
class ModifyEmptyNumberNoMoreCallsInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyEmptyNumberNoMoreCallsInfoResponseBody> body{};

  ModifyEmptyNumberNoMoreCallsInfoResponse() {}

  explicit ModifyEmptyNumberNoMoreCallsInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEmptyNumberNoMoreCallsInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEmptyNumberNoMoreCallsInfoResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEmptyNumberNoMoreCallsInfoResponse() = default;
};
class ModifyGlobalQuestionRequest : public Darabonba::Model {
public:
  shared_ptr<string> answers{};
  shared_ptr<string> globalQuestionId{};
  shared_ptr<string> globalQuestionName{};
  shared_ptr<string> globalQuestionType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> questions{};
  shared_ptr<string> scriptId{};

  ModifyGlobalQuestionRequest() {}

  explicit ModifyGlobalQuestionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answers) {
      res["Answers"] = boost::any(*answers);
    }
    if (globalQuestionId) {
      res["GlobalQuestionId"] = boost::any(*globalQuestionId);
    }
    if (globalQuestionName) {
      res["GlobalQuestionName"] = boost::any(*globalQuestionName);
    }
    if (globalQuestionType) {
      res["GlobalQuestionType"] = boost::any(*globalQuestionType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (questions) {
      res["Questions"] = boost::any(*questions);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Answers") != m.end() && !m["Answers"].empty()) {
      answers = make_shared<string>(boost::any_cast<string>(m["Answers"]));
    }
    if (m.find("GlobalQuestionId") != m.end() && !m["GlobalQuestionId"].empty()) {
      globalQuestionId = make_shared<string>(boost::any_cast<string>(m["GlobalQuestionId"]));
    }
    if (m.find("GlobalQuestionName") != m.end() && !m["GlobalQuestionName"].empty()) {
      globalQuestionName = make_shared<string>(boost::any_cast<string>(m["GlobalQuestionName"]));
    }
    if (m.find("GlobalQuestionType") != m.end() && !m["GlobalQuestionType"].empty()) {
      globalQuestionType = make_shared<string>(boost::any_cast<string>(m["GlobalQuestionType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Questions") != m.end() && !m["Questions"].empty()) {
      questions = make_shared<string>(boost::any_cast<string>(m["Questions"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~ModifyGlobalQuestionRequest() = default;
};
class ModifyGlobalQuestionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dialogueQuestionId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyGlobalQuestionResponseBody() {}

  explicit ModifyGlobalQuestionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dialogueQuestionId) {
      res["DialogueQuestionId"] = boost::any(*dialogueQuestionId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DialogueQuestionId") != m.end() && !m["DialogueQuestionId"].empty()) {
      dialogueQuestionId = make_shared<string>(boost::any_cast<string>(m["DialogueQuestionId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyGlobalQuestionResponseBody() = default;
};
class ModifyGlobalQuestionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyGlobalQuestionResponseBody> body{};

  ModifyGlobalQuestionResponse() {}

  explicit ModifyGlobalQuestionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyGlobalQuestionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyGlobalQuestionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyGlobalQuestionResponse() = default;
};
class ModifyInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> callingNumber{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> maxConcurrentConversation{};

  ModifyInstanceRequest() {}

  explicit ModifyInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (maxConcurrentConversation) {
      res["MaxConcurrentConversation"] = boost::any(*maxConcurrentConversation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumber = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("MaxConcurrentConversation") != m.end() && !m["MaxConcurrentConversation"].empty()) {
      maxConcurrentConversation = make_shared<long>(boost::any_cast<long>(m["MaxConcurrentConversation"]));
    }
  }


  virtual ~ModifyInstanceRequest() = default;
};
class ModifyInstanceResponseBodyInstance : public Darabonba::Model {
public:
  shared_ptr<long> creationTime{};
  shared_ptr<long> creatorId{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> maxConcurrentConversation{};
  shared_ptr<string> ownerName{};

  ModifyInstanceResponseBodyInstance() {}

  explicit ModifyInstanceResponseBodyInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (maxConcurrentConversation) {
      res["MaxConcurrentConversation"] = boost::any(*maxConcurrentConversation);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<long>(boost::any_cast<long>(m["CreatorId"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("MaxConcurrentConversation") != m.end() && !m["MaxConcurrentConversation"].empty()) {
      maxConcurrentConversation = make_shared<long>(boost::any_cast<long>(m["MaxConcurrentConversation"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
  }


  virtual ~ModifyInstanceResponseBodyInstance() = default;
};
class ModifyInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ModifyInstanceResponseBodyInstance> instance{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyInstanceResponseBody() {}

  explicit ModifyInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        ModifyInstanceResponseBodyInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<ModifyInstanceResponseBodyInstance>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyInstanceResponseBody() = default;
};
class ModifyInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceResponseBody> body{};

  ModifyInstanceResponse() {}

  explicit ModifyInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceResponse() = default;
};
class ModifyIntentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> intentDescription{};
  shared_ptr<string> intentId{};
  shared_ptr<string> intentName{};
  shared_ptr<string> keywords{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> utterances{};

  ModifyIntentRequest() {}

  explicit ModifyIntentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentDescription) {
      res["IntentDescription"] = boost::any(*intentDescription);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (intentName) {
      res["IntentName"] = boost::any(*intentName);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (utterances) {
      res["Utterances"] = boost::any(*utterances);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentDescription") != m.end() && !m["IntentDescription"].empty()) {
      intentDescription = make_shared<string>(boost::any_cast<string>(m["IntentDescription"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
    if (m.find("IntentName") != m.end() && !m["IntentName"].empty()) {
      intentName = make_shared<string>(boost::any_cast<string>(m["IntentName"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywords = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("Utterances") != m.end() && !m["Utterances"].empty()) {
      utterances = make_shared<string>(boost::any_cast<string>(m["Utterances"]));
    }
  }


  virtual ~ModifyIntentRequest() = default;
};
class ModifyIntentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> intentId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyIntentResponseBody() {}

  explicit ModifyIntentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyIntentResponseBody() = default;
};
class ModifyIntentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyIntentResponseBody> body{};

  ModifyIntentResponse() {}

  explicit ModifyIntentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIntentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIntentResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIntentResponse() = default;
};
class ModifyJobGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> callingNumber{};
  shared_ptr<string> description{};
  shared_ptr<string> flashSmsExtras{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobGroupStatus{};
  shared_ptr<long> minConcurrency{};
  shared_ptr<string> name{};
  shared_ptr<string> priority{};
  shared_ptr<vector<string>> recallCallingNumber{};
  shared_ptr<string> recallStrategyJson{};
  shared_ptr<long> ringingDuration{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> strategyJson{};

  ModifyJobGroupRequest() {}

  explicit ModifyJobGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (flashSmsExtras) {
      res["FlashSmsExtras"] = boost::any(*flashSmsExtras);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobGroupStatus) {
      res["JobGroupStatus"] = boost::any(*jobGroupStatus);
    }
    if (minConcurrency) {
      res["MinConcurrency"] = boost::any(*minConcurrency);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (recallCallingNumber) {
      res["RecallCallingNumber"] = boost::any(*recallCallingNumber);
    }
    if (recallStrategyJson) {
      res["RecallStrategyJson"] = boost::any(*recallStrategyJson);
    }
    if (ringingDuration) {
      res["RingingDuration"] = boost::any(*ringingDuration);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (strategyJson) {
      res["StrategyJson"] = boost::any(*strategyJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumber = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FlashSmsExtras") != m.end() && !m["FlashSmsExtras"].empty()) {
      flashSmsExtras = make_shared<string>(boost::any_cast<string>(m["FlashSmsExtras"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobGroupStatus") != m.end() && !m["JobGroupStatus"].empty()) {
      jobGroupStatus = make_shared<string>(boost::any_cast<string>(m["JobGroupStatus"]));
    }
    if (m.find("MinConcurrency") != m.end() && !m["MinConcurrency"].empty()) {
      minConcurrency = make_shared<long>(boost::any_cast<long>(m["MinConcurrency"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("RecallCallingNumber") != m.end() && !m["RecallCallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecallCallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecallCallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recallCallingNumber = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RecallStrategyJson") != m.end() && !m["RecallStrategyJson"].empty()) {
      recallStrategyJson = make_shared<string>(boost::any_cast<string>(m["RecallStrategyJson"]));
    }
    if (m.find("RingingDuration") != m.end() && !m["RingingDuration"].empty()) {
      ringingDuration = make_shared<long>(boost::any_cast<long>(m["RingingDuration"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("StrategyJson") != m.end() && !m["StrategyJson"].empty()) {
      strategyJson = make_shared<string>(boost::any_cast<string>(m["StrategyJson"]));
    }
  }


  virtual ~ModifyJobGroupRequest() = default;
};
class ModifyJobGroupResponseBodyJobGroupExportProgress : public Darabonba::Model {
public:
  shared_ptr<string> fileHttpUrl{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  ModifyJobGroupResponseBodyJobGroupExportProgress() {}

  explicit ModifyJobGroupResponseBodyJobGroupExportProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileHttpUrl) {
      res["FileHttpUrl"] = boost::any(*fileHttpUrl);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileHttpUrl") != m.end() && !m["FileHttpUrl"].empty()) {
      fileHttpUrl = make_shared<string>(boost::any_cast<string>(m["FileHttpUrl"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ModifyJobGroupResponseBodyJobGroupExportProgress() = default;
};
class ModifyJobGroupResponseBodyJobGroupRecallStrategy : public Darabonba::Model {
public:
  shared_ptr<bool> emptyNumberIgnore{};
  shared_ptr<bool> inArrearsIgnore{};
  shared_ptr<bool> outOfServiceIgnore{};

  ModifyJobGroupResponseBodyJobGroupRecallStrategy() {}

  explicit ModifyJobGroupResponseBodyJobGroupRecallStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emptyNumberIgnore) {
      res["EmptyNumberIgnore"] = boost::any(*emptyNumberIgnore);
    }
    if (inArrearsIgnore) {
      res["InArrearsIgnore"] = boost::any(*inArrearsIgnore);
    }
    if (outOfServiceIgnore) {
      res["OutOfServiceIgnore"] = boost::any(*outOfServiceIgnore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmptyNumberIgnore") != m.end() && !m["EmptyNumberIgnore"].empty()) {
      emptyNumberIgnore = make_shared<bool>(boost::any_cast<bool>(m["EmptyNumberIgnore"]));
    }
    if (m.find("InArrearsIgnore") != m.end() && !m["InArrearsIgnore"].empty()) {
      inArrearsIgnore = make_shared<bool>(boost::any_cast<bool>(m["InArrearsIgnore"]));
    }
    if (m.find("OutOfServiceIgnore") != m.end() && !m["OutOfServiceIgnore"].empty()) {
      outOfServiceIgnore = make_shared<bool>(boost::any_cast<bool>(m["OutOfServiceIgnore"]));
    }
  }


  virtual ~ModifyJobGroupResponseBodyJobGroupRecallStrategy() = default;
};
class ModifyJobGroupResponseBodyJobGroupStrategyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> beginTime{};
  shared_ptr<string> endTime{};

  ModifyJobGroupResponseBodyJobGroupStrategyWorkingTime() {}

  explicit ModifyJobGroupResponseBodyJobGroupStrategyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~ModifyJobGroupResponseBodyJobGroupStrategyWorkingTime() = default;
};
class ModifyJobGroupResponseBodyJobGroupStrategy : public Darabonba::Model {
public:
  shared_ptr<string> customized{};
  shared_ptr<long> endTime{};
  shared_ptr<string> followUpStrategy{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> repeatBy{};
  shared_ptr<vector<string>> repeatDays{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<long> startTime{};
  shared_ptr<string> strategyDescription{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> strategyName{};
  shared_ptr<string> type{};
  shared_ptr<vector<ModifyJobGroupResponseBodyJobGroupStrategyWorkingTime>> workingTime{};

  ModifyJobGroupResponseBodyJobGroupStrategy() {}

  explicit ModifyJobGroupResponseBodyJobGroupStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (followUpStrategy) {
      res["FollowUpStrategy"] = boost::any(*followUpStrategy);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (repeatBy) {
      res["RepeatBy"] = boost::any(*repeatBy);
    }
    if (repeatDays) {
      res["RepeatDays"] = boost::any(*repeatDays);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (strategyDescription) {
      res["StrategyDescription"] = boost::any(*strategyDescription);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<string>(boost::any_cast<string>(m["Customized"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FollowUpStrategy") != m.end() && !m["FollowUpStrategy"].empty()) {
      followUpStrategy = make_shared<string>(boost::any_cast<string>(m["FollowUpStrategy"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("RepeatBy") != m.end() && !m["RepeatBy"].empty()) {
      repeatBy = make_shared<string>(boost::any_cast<string>(m["RepeatBy"]));
    }
    if (m.find("RepeatDays") != m.end() && !m["RepeatDays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StrategyDescription") != m.end() && !m["StrategyDescription"].empty()) {
      strategyDescription = make_shared<string>(boost::any_cast<string>(m["StrategyDescription"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<ModifyJobGroupResponseBodyJobGroupStrategyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyJobGroupResponseBodyJobGroupStrategyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<ModifyJobGroupResponseBodyJobGroupStrategyWorkingTime>>(expect1);
      }
    }
  }


  virtual ~ModifyJobGroupResponseBodyJobGroupStrategy() = default;
};
class ModifyJobGroupResponseBodyJobGroup : public Darabonba::Model {
public:
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<long> creationTime{};
  shared_ptr<ModifyJobGroupResponseBodyJobGroupExportProgress> exportProgress{};
  shared_ptr<string> flashSmsExtras{};
  shared_ptr<string> jobDataParsingTaskId{};
  shared_ptr<string> jobFilePath{};
  shared_ptr<string> jobGroupDescription{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobGroupName{};
  shared_ptr<long> minConcurrency{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> priority{};
  shared_ptr<ModifyJobGroupResponseBodyJobGroupRecallStrategy> recallStrategy{};
  shared_ptr<long> ringingDuration{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> scriptVersion{};
  shared_ptr<string> status{};
  shared_ptr<ModifyJobGroupResponseBodyJobGroupStrategy> strategy{};

  ModifyJobGroupResponseBodyJobGroup() {}

  explicit ModifyJobGroupResponseBodyJobGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (exportProgress) {
      res["ExportProgress"] = exportProgress ? boost::any(exportProgress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flashSmsExtras) {
      res["FlashSmsExtras"] = boost::any(*flashSmsExtras);
    }
    if (jobDataParsingTaskId) {
      res["JobDataParsingTaskId"] = boost::any(*jobDataParsingTaskId);
    }
    if (jobFilePath) {
      res["JobFilePath"] = boost::any(*jobFilePath);
    }
    if (jobGroupDescription) {
      res["JobGroupDescription"] = boost::any(*jobGroupDescription);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobGroupName) {
      res["JobGroupName"] = boost::any(*jobGroupName);
    }
    if (minConcurrency) {
      res["MinConcurrency"] = boost::any(*minConcurrency);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (recallStrategy) {
      res["RecallStrategy"] = recallStrategy ? boost::any(recallStrategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ringingDuration) {
      res["RingingDuration"] = boost::any(*ringingDuration);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (scriptVersion) {
      res["ScriptVersion"] = boost::any(*scriptVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("ExportProgress") != m.end() && !m["ExportProgress"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExportProgress"].type()) {
        ModifyJobGroupResponseBodyJobGroupExportProgress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExportProgress"]));
        exportProgress = make_shared<ModifyJobGroupResponseBodyJobGroupExportProgress>(model1);
      }
    }
    if (m.find("FlashSmsExtras") != m.end() && !m["FlashSmsExtras"].empty()) {
      flashSmsExtras = make_shared<string>(boost::any_cast<string>(m["FlashSmsExtras"]));
    }
    if (m.find("JobDataParsingTaskId") != m.end() && !m["JobDataParsingTaskId"].empty()) {
      jobDataParsingTaskId = make_shared<string>(boost::any_cast<string>(m["JobDataParsingTaskId"]));
    }
    if (m.find("JobFilePath") != m.end() && !m["JobFilePath"].empty()) {
      jobFilePath = make_shared<string>(boost::any_cast<string>(m["JobFilePath"]));
    }
    if (m.find("JobGroupDescription") != m.end() && !m["JobGroupDescription"].empty()) {
      jobGroupDescription = make_shared<string>(boost::any_cast<string>(m["JobGroupDescription"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobGroupName") != m.end() && !m["JobGroupName"].empty()) {
      jobGroupName = make_shared<string>(boost::any_cast<string>(m["JobGroupName"]));
    }
    if (m.find("MinConcurrency") != m.end() && !m["MinConcurrency"].empty()) {
      minConcurrency = make_shared<long>(boost::any_cast<long>(m["MinConcurrency"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("RecallStrategy") != m.end() && !m["RecallStrategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecallStrategy"].type()) {
        ModifyJobGroupResponseBodyJobGroupRecallStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecallStrategy"]));
        recallStrategy = make_shared<ModifyJobGroupResponseBodyJobGroupRecallStrategy>(model1);
      }
    }
    if (m.find("RingingDuration") != m.end() && !m["RingingDuration"].empty()) {
      ringingDuration = make_shared<long>(boost::any_cast<long>(m["RingingDuration"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("ScriptVersion") != m.end() && !m["ScriptVersion"].empty()) {
      scriptVersion = make_shared<string>(boost::any_cast<string>(m["ScriptVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        ModifyJobGroupResponseBodyJobGroupStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<ModifyJobGroupResponseBodyJobGroupStrategy>(model1);
      }
    }
  }


  virtual ~ModifyJobGroupResponseBodyJobGroup() = default;
};
class ModifyJobGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ModifyJobGroupResponseBodyJobGroup> jobGroup{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyJobGroupResponseBody() {}

  explicit ModifyJobGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobGroup) {
      res["JobGroup"] = jobGroup ? boost::any(jobGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("JobGroup") != m.end() && !m["JobGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobGroup"].type()) {
        ModifyJobGroupResponseBodyJobGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobGroup"]));
        jobGroup = make_shared<ModifyJobGroupResponseBodyJobGroup>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyJobGroupResponseBody() = default;
};
class ModifyJobGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyJobGroupResponseBody> body{};

  ModifyJobGroupResponse() {}

  explicit ModifyJobGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyJobGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyJobGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyJobGroupResponse() = default;
};
class ModifyOutboundCallNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> outboundCallNumberId{};
  shared_ptr<long> rateLimitCount{};
  shared_ptr<long> rateLimitPeriod{};

  ModifyOutboundCallNumberRequest() {}

  explicit ModifyOutboundCallNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (outboundCallNumberId) {
      res["OutboundCallNumberId"] = boost::any(*outboundCallNumberId);
    }
    if (rateLimitCount) {
      res["RateLimitCount"] = boost::any(*rateLimitCount);
    }
    if (rateLimitPeriod) {
      res["RateLimitPeriod"] = boost::any(*rateLimitPeriod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("OutboundCallNumberId") != m.end() && !m["OutboundCallNumberId"].empty()) {
      outboundCallNumberId = make_shared<string>(boost::any_cast<string>(m["OutboundCallNumberId"]));
    }
    if (m.find("RateLimitCount") != m.end() && !m["RateLimitCount"].empty()) {
      rateLimitCount = make_shared<long>(boost::any_cast<long>(m["RateLimitCount"]));
    }
    if (m.find("RateLimitPeriod") != m.end() && !m["RateLimitPeriod"].empty()) {
      rateLimitPeriod = make_shared<long>(boost::any_cast<long>(m["RateLimitPeriod"]));
    }
  }


  virtual ~ModifyOutboundCallNumberRequest() = default;
};
class ModifyOutboundCallNumberResponseBodyOutboundCallNumber : public Darabonba::Model {
public:
  shared_ptr<string> number{};
  shared_ptr<string> outboundCallNumberId{};
  shared_ptr<string> rateLimitCount{};
  shared_ptr<string> rateLimitPeriod{};

  ModifyOutboundCallNumberResponseBodyOutboundCallNumber() {}

  explicit ModifyOutboundCallNumberResponseBodyOutboundCallNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (outboundCallNumberId) {
      res["OutboundCallNumberId"] = boost::any(*outboundCallNumberId);
    }
    if (rateLimitCount) {
      res["RateLimitCount"] = boost::any(*rateLimitCount);
    }
    if (rateLimitPeriod) {
      res["RateLimitPeriod"] = boost::any(*rateLimitPeriod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("OutboundCallNumberId") != m.end() && !m["OutboundCallNumberId"].empty()) {
      outboundCallNumberId = make_shared<string>(boost::any_cast<string>(m["OutboundCallNumberId"]));
    }
    if (m.find("RateLimitCount") != m.end() && !m["RateLimitCount"].empty()) {
      rateLimitCount = make_shared<string>(boost::any_cast<string>(m["RateLimitCount"]));
    }
    if (m.find("RateLimitPeriod") != m.end() && !m["RateLimitPeriod"].empty()) {
      rateLimitPeriod = make_shared<string>(boost::any_cast<string>(m["RateLimitPeriod"]));
    }
  }


  virtual ~ModifyOutboundCallNumberResponseBodyOutboundCallNumber() = default;
};
class ModifyOutboundCallNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ModifyOutboundCallNumberResponseBodyOutboundCallNumber> outboundCallNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyOutboundCallNumberResponseBody() {}

  explicit ModifyOutboundCallNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (outboundCallNumber) {
      res["OutboundCallNumber"] = outboundCallNumber ? boost::any(outboundCallNumber->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OutboundCallNumber") != m.end() && !m["OutboundCallNumber"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutboundCallNumber"].type()) {
        ModifyOutboundCallNumberResponseBodyOutboundCallNumber model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutboundCallNumber"]));
        outboundCallNumber = make_shared<ModifyOutboundCallNumberResponseBodyOutboundCallNumber>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyOutboundCallNumberResponseBody() = default;
};
class ModifyOutboundCallNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyOutboundCallNumberResponseBody> body{};

  ModifyOutboundCallNumberResponse() {}

  explicit ModifyOutboundCallNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyOutboundCallNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyOutboundCallNumberResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyOutboundCallNumberResponse() = default;
};
class ModifyScriptRequest : public Darabonba::Model {
public:
  shared_ptr<long> agentId{};
  shared_ptr<string> agentKey{};
  shared_ptr<bool> agentLlm{};
  shared_ptr<string> asrConfig{};
  shared_ptr<string> chatConfig{};
  shared_ptr<string> chatbotId{};
  shared_ptr<bool> emotionEnable{};
  shared_ptr<string> industry{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> labelConfig{};
  shared_ptr<bool> longWaitEnable{};
  shared_ptr<string> miniPlaybackConfigListJsonString{};
  shared_ptr<bool> miniPlaybackEnable{};
  shared_ptr<bool> newBargeInEnable{};
  shared_ptr<string> nlsConfig{};
  shared_ptr<string> nluAccessType{};
  shared_ptr<string> nluEngine{};
  shared_ptr<string> scene{};
  shared_ptr<vector<string>> scriptContent{};
  shared_ptr<string> scriptDescription{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptName{};
  shared_ptr<vector<string>> scriptWaveform{};
  shared_ptr<string> ttsConfig{};

  ModifyScriptRequest() {}

  explicit ModifyScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (agentLlm) {
      res["AgentLlm"] = boost::any(*agentLlm);
    }
    if (asrConfig) {
      res["AsrConfig"] = boost::any(*asrConfig);
    }
    if (chatConfig) {
      res["ChatConfig"] = boost::any(*chatConfig);
    }
    if (chatbotId) {
      res["ChatbotId"] = boost::any(*chatbotId);
    }
    if (emotionEnable) {
      res["EmotionEnable"] = boost::any(*emotionEnable);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (labelConfig) {
      res["LabelConfig"] = boost::any(*labelConfig);
    }
    if (longWaitEnable) {
      res["LongWaitEnable"] = boost::any(*longWaitEnable);
    }
    if (miniPlaybackConfigListJsonString) {
      res["MiniPlaybackConfigListJsonString"] = boost::any(*miniPlaybackConfigListJsonString);
    }
    if (miniPlaybackEnable) {
      res["MiniPlaybackEnable"] = boost::any(*miniPlaybackEnable);
    }
    if (newBargeInEnable) {
      res["NewBargeInEnable"] = boost::any(*newBargeInEnable);
    }
    if (nlsConfig) {
      res["NlsConfig"] = boost::any(*nlsConfig);
    }
    if (nluAccessType) {
      res["NluAccessType"] = boost::any(*nluAccessType);
    }
    if (nluEngine) {
      res["NluEngine"] = boost::any(*nluEngine);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (scriptContent) {
      res["ScriptContent"] = boost::any(*scriptContent);
    }
    if (scriptDescription) {
      res["ScriptDescription"] = boost::any(*scriptDescription);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (scriptWaveform) {
      res["ScriptWaveform"] = boost::any(*scriptWaveform);
    }
    if (ttsConfig) {
      res["TtsConfig"] = boost::any(*ttsConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<long>(boost::any_cast<long>(m["AgentId"]));
    }
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("AgentLlm") != m.end() && !m["AgentLlm"].empty()) {
      agentLlm = make_shared<bool>(boost::any_cast<bool>(m["AgentLlm"]));
    }
    if (m.find("AsrConfig") != m.end() && !m["AsrConfig"].empty()) {
      asrConfig = make_shared<string>(boost::any_cast<string>(m["AsrConfig"]));
    }
    if (m.find("ChatConfig") != m.end() && !m["ChatConfig"].empty()) {
      chatConfig = make_shared<string>(boost::any_cast<string>(m["ChatConfig"]));
    }
    if (m.find("ChatbotId") != m.end() && !m["ChatbotId"].empty()) {
      chatbotId = make_shared<string>(boost::any_cast<string>(m["ChatbotId"]));
    }
    if (m.find("EmotionEnable") != m.end() && !m["EmotionEnable"].empty()) {
      emotionEnable = make_shared<bool>(boost::any_cast<bool>(m["EmotionEnable"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LabelConfig") != m.end() && !m["LabelConfig"].empty()) {
      labelConfig = make_shared<string>(boost::any_cast<string>(m["LabelConfig"]));
    }
    if (m.find("LongWaitEnable") != m.end() && !m["LongWaitEnable"].empty()) {
      longWaitEnable = make_shared<bool>(boost::any_cast<bool>(m["LongWaitEnable"]));
    }
    if (m.find("MiniPlaybackConfigListJsonString") != m.end() && !m["MiniPlaybackConfigListJsonString"].empty()) {
      miniPlaybackConfigListJsonString = make_shared<string>(boost::any_cast<string>(m["MiniPlaybackConfigListJsonString"]));
    }
    if (m.find("MiniPlaybackEnable") != m.end() && !m["MiniPlaybackEnable"].empty()) {
      miniPlaybackEnable = make_shared<bool>(boost::any_cast<bool>(m["MiniPlaybackEnable"]));
    }
    if (m.find("NewBargeInEnable") != m.end() && !m["NewBargeInEnable"].empty()) {
      newBargeInEnable = make_shared<bool>(boost::any_cast<bool>(m["NewBargeInEnable"]));
    }
    if (m.find("NlsConfig") != m.end() && !m["NlsConfig"].empty()) {
      nlsConfig = make_shared<string>(boost::any_cast<string>(m["NlsConfig"]));
    }
    if (m.find("NluAccessType") != m.end() && !m["NluAccessType"].empty()) {
      nluAccessType = make_shared<string>(boost::any_cast<string>(m["NluAccessType"]));
    }
    if (m.find("NluEngine") != m.end() && !m["NluEngine"].empty()) {
      nluEngine = make_shared<string>(boost::any_cast<string>(m["NluEngine"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("ScriptContent") != m.end() && !m["ScriptContent"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScriptContent"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScriptContent"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scriptContent = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScriptDescription") != m.end() && !m["ScriptDescription"].empty()) {
      scriptDescription = make_shared<string>(boost::any_cast<string>(m["ScriptDescription"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("ScriptWaveform") != m.end() && !m["ScriptWaveform"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScriptWaveform"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScriptWaveform"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scriptWaveform = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TtsConfig") != m.end() && !m["TtsConfig"].empty()) {
      ttsConfig = make_shared<string>(boost::any_cast<string>(m["TtsConfig"]));
    }
  }


  virtual ~ModifyScriptRequest() = default;
};
class ModifyScriptResponseBodyScript : public Darabonba::Model {
public:
  shared_ptr<string> debugStatus{};
  shared_ptr<string> industry{};
  shared_ptr<bool> isDebugDrafted{};
  shared_ptr<bool> isDrafted{};
  shared_ptr<string> scene{};
  shared_ptr<string> scriptDescription{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};

  ModifyScriptResponseBodyScript() {}

  explicit ModifyScriptResponseBodyScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (debugStatus) {
      res["DebugStatus"] = boost::any(*debugStatus);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (isDebugDrafted) {
      res["IsDebugDrafted"] = boost::any(*isDebugDrafted);
    }
    if (isDrafted) {
      res["IsDrafted"] = boost::any(*isDrafted);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (scriptDescription) {
      res["ScriptDescription"] = boost::any(*scriptDescription);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DebugStatus") != m.end() && !m["DebugStatus"].empty()) {
      debugStatus = make_shared<string>(boost::any_cast<string>(m["DebugStatus"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("IsDebugDrafted") != m.end() && !m["IsDebugDrafted"].empty()) {
      isDebugDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDebugDrafted"]));
    }
    if (m.find("IsDrafted") != m.end() && !m["IsDrafted"].empty()) {
      isDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDrafted"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("ScriptDescription") != m.end() && !m["ScriptDescription"].empty()) {
      scriptDescription = make_shared<string>(boost::any_cast<string>(m["ScriptDescription"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ModifyScriptResponseBodyScript() = default;
};
class ModifyScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ModifyScriptResponseBodyScript> script{};
  shared_ptr<bool> success{};

  ModifyScriptResponseBody() {}

  explicit ModifyScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        ModifyScriptResponseBodyScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<ModifyScriptResponseBodyScript>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyScriptResponseBody() = default;
};
class ModifyScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyScriptResponseBody> body{};

  ModifyScriptResponse() {}

  explicit ModifyScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyScriptResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyScriptResponse() = default;
};
class ModifyScriptVoiceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptVoiceConfigId{};
  shared_ptr<string> scriptWaveformRelation{};
  shared_ptr<string> type{};

  ModifyScriptVoiceConfigRequest() {}

  explicit ModifyScriptVoiceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptVoiceConfigId) {
      res["ScriptVoiceConfigId"] = boost::any(*scriptVoiceConfigId);
    }
    if (scriptWaveformRelation) {
      res["ScriptWaveformRelation"] = boost::any(*scriptWaveformRelation);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptVoiceConfigId") != m.end() && !m["ScriptVoiceConfigId"].empty()) {
      scriptVoiceConfigId = make_shared<string>(boost::any_cast<string>(m["ScriptVoiceConfigId"]));
    }
    if (m.find("ScriptWaveformRelation") != m.end() && !m["ScriptWaveformRelation"].empty()) {
      scriptWaveformRelation = make_shared<string>(boost::any_cast<string>(m["ScriptWaveformRelation"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyScriptVoiceConfigRequest() = default;
};
class ModifyScriptVoiceConfigResponseBodyScriptVoiceConfig : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptContent{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptVoiceConfigId{};
  shared_ptr<string> scriptWaveformRelation{};
  shared_ptr<string> source{};
  shared_ptr<string> type{};

  ModifyScriptVoiceConfigResponseBodyScriptVoiceConfig() {}

  explicit ModifyScriptVoiceConfigResponseBodyScriptVoiceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptContent) {
      res["ScriptContent"] = boost::any(*scriptContent);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptVoiceConfigId) {
      res["ScriptVoiceConfigId"] = boost::any(*scriptVoiceConfigId);
    }
    if (scriptWaveformRelation) {
      res["ScriptWaveformRelation"] = boost::any(*scriptWaveformRelation);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptContent") != m.end() && !m["ScriptContent"].empty()) {
      scriptContent = make_shared<string>(boost::any_cast<string>(m["ScriptContent"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptVoiceConfigId") != m.end() && !m["ScriptVoiceConfigId"].empty()) {
      scriptVoiceConfigId = make_shared<string>(boost::any_cast<string>(m["ScriptVoiceConfigId"]));
    }
    if (m.find("ScriptWaveformRelation") != m.end() && !m["ScriptWaveformRelation"].empty()) {
      scriptWaveformRelation = make_shared<string>(boost::any_cast<string>(m["ScriptWaveformRelation"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyScriptVoiceConfigResponseBodyScriptVoiceConfig() = default;
};
class ModifyScriptVoiceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ModifyScriptVoiceConfigResponseBodyScriptVoiceConfig> scriptVoiceConfig{};
  shared_ptr<bool> success{};

  ModifyScriptVoiceConfigResponseBody() {}

  explicit ModifyScriptVoiceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scriptVoiceConfig) {
      res["ScriptVoiceConfig"] = scriptVoiceConfig ? boost::any(scriptVoiceConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScriptVoiceConfig") != m.end() && !m["ScriptVoiceConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptVoiceConfig"].type()) {
        ModifyScriptVoiceConfigResponseBodyScriptVoiceConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptVoiceConfig"]));
        scriptVoiceConfig = make_shared<ModifyScriptVoiceConfigResponseBodyScriptVoiceConfig>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyScriptVoiceConfigResponseBody() = default;
};
class ModifyScriptVoiceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyScriptVoiceConfigResponseBody> body{};

  ModifyScriptVoiceConfigResponse() {}

  explicit ModifyScriptVoiceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyScriptVoiceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyScriptVoiceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyScriptVoiceConfigResponse() = default;
};
class ModifyTTSConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nlsServiceType{};
  shared_ptr<string> pitchRate{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> speechRate{};
  shared_ptr<string> voice{};
  shared_ptr<string> volume{};

  ModifyTTSConfigRequest() {}

  explicit ModifyTTSConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nlsServiceType) {
      res["NlsServiceType"] = boost::any(*nlsServiceType);
    }
    if (pitchRate) {
      res["PitchRate"] = boost::any(*pitchRate);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NlsServiceType") != m.end() && !m["NlsServiceType"].empty()) {
      nlsServiceType = make_shared<string>(boost::any_cast<string>(m["NlsServiceType"]));
    }
    if (m.find("PitchRate") != m.end() && !m["PitchRate"].empty()) {
      pitchRate = make_shared<string>(boost::any_cast<string>(m["PitchRate"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<string>(boost::any_cast<string>(m["SpeechRate"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<string>(boost::any_cast<string>(m["Volume"]));
    }
  }


  virtual ~ModifyTTSConfigRequest() = default;
};
class ModifyTTSConfigResponseBodyTTSConfig : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> pitchRate{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> speechRate{};
  shared_ptr<string> TTSConfigId{};
  shared_ptr<string> voice{};
  shared_ptr<string> volume{};

  ModifyTTSConfigResponseBodyTTSConfig() {}

  explicit ModifyTTSConfigResponseBodyTTSConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pitchRate) {
      res["PitchRate"] = boost::any(*pitchRate);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (TTSConfigId) {
      res["TTSConfigId"] = boost::any(*TTSConfigId);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PitchRate") != m.end() && !m["PitchRate"].empty()) {
      pitchRate = make_shared<string>(boost::any_cast<string>(m["PitchRate"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<string>(boost::any_cast<string>(m["SpeechRate"]));
    }
    if (m.find("TTSConfigId") != m.end() && !m["TTSConfigId"].empty()) {
      TTSConfigId = make_shared<string>(boost::any_cast<string>(m["TTSConfigId"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<string>(boost::any_cast<string>(m["Volume"]));
    }
  }


  virtual ~ModifyTTSConfigResponseBodyTTSConfig() = default;
};
class ModifyTTSConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ModifyTTSConfigResponseBodyTTSConfig> TTSConfig{};

  ModifyTTSConfigResponseBody() {}

  explicit ModifyTTSConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (TTSConfig) {
      res["TTSConfig"] = TTSConfig ? boost::any(TTSConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TTSConfig") != m.end() && !m["TTSConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TTSConfig"].type()) {
        ModifyTTSConfigResponseBodyTTSConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TTSConfig"]));
        TTSConfig = make_shared<ModifyTTSConfigResponseBodyTTSConfig>(model1);
      }
    }
  }


  virtual ~ModifyTTSConfigResponseBody() = default;
};
class ModifyTTSConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTTSConfigResponseBody> body{};

  ModifyTTSConfigResponse() {}

  explicit ModifyTTSConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTTSConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTTSConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTTSConfigResponse() = default;
};
class ModifyTagGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> tagGroups{};
  shared_ptr<string> tags{};

  ModifyTagGroupsRequest() {}

  explicit ModifyTagGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (tagGroups) {
      res["TagGroups"] = boost::any(*tagGroups);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("TagGroups") != m.end() && !m["TagGroups"].empty()) {
      tagGroups = make_shared<string>(boost::any_cast<string>(m["TagGroups"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~ModifyTagGroupsRequest() = default;
};
class ModifyTagGroupsResponseBodyTagGroups : public Darabonba::Model {
public:
  shared_ptr<string> scriptId{};
  shared_ptr<string> tagGroup{};
  shared_ptr<string> tagGroupId{};
  shared_ptr<long> tagGroupIndex{};

  ModifyTagGroupsResponseBodyTagGroups() {}

  explicit ModifyTagGroupsResponseBodyTagGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (tagGroup) {
      res["TagGroup"] = boost::any(*tagGroup);
    }
    if (tagGroupId) {
      res["TagGroupId"] = boost::any(*tagGroupId);
    }
    if (tagGroupIndex) {
      res["TagGroupIndex"] = boost::any(*tagGroupIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("TagGroup") != m.end() && !m["TagGroup"].empty()) {
      tagGroup = make_shared<string>(boost::any_cast<string>(m["TagGroup"]));
    }
    if (m.find("TagGroupId") != m.end() && !m["TagGroupId"].empty()) {
      tagGroupId = make_shared<string>(boost::any_cast<string>(m["TagGroupId"]));
    }
    if (m.find("TagGroupIndex") != m.end() && !m["TagGroupIndex"].empty()) {
      tagGroupIndex = make_shared<long>(boost::any_cast<long>(m["TagGroupIndex"]));
    }
  }


  virtual ~ModifyTagGroupsResponseBodyTagGroups() = default;
};
class ModifyTagGroupsResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> scriptId{};
  shared_ptr<string> tagGroup{};
  shared_ptr<string> tagId{};
  shared_ptr<long> tagIndex{};
  shared_ptr<string> tagName{};

  ModifyTagGroupsResponseBodyTags() {}

  explicit ModifyTagGroupsResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (tagGroup) {
      res["TagGroup"] = boost::any(*tagGroup);
    }
    if (tagId) {
      res["TagId"] = boost::any(*tagId);
    }
    if (tagIndex) {
      res["TagIndex"] = boost::any(*tagIndex);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("TagGroup") != m.end() && !m["TagGroup"].empty()) {
      tagGroup = make_shared<string>(boost::any_cast<string>(m["TagGroup"]));
    }
    if (m.find("TagId") != m.end() && !m["TagId"].empty()) {
      tagId = make_shared<string>(boost::any_cast<string>(m["TagId"]));
    }
    if (m.find("TagIndex") != m.end() && !m["TagIndex"].empty()) {
      tagIndex = make_shared<long>(boost::any_cast<long>(m["TagIndex"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~ModifyTagGroupsResponseBodyTags() = default;
};
class ModifyTagGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ModifyTagGroupsResponseBodyTagGroups>> tagGroups{};
  shared_ptr<vector<ModifyTagGroupsResponseBodyTags>> tags{};

  ModifyTagGroupsResponseBody() {}

  explicit ModifyTagGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tagGroups) {
      vector<boost::any> temp1;
      for(auto item1:*tagGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagGroups"] = boost::any(temp1);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TagGroups") != m.end() && !m["TagGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["TagGroups"].type()) {
        vector<ModifyTagGroupsResponseBodyTagGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyTagGroupsResponseBodyTagGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagGroups = make_shared<vector<ModifyTagGroupsResponseBodyTagGroups>>(expect1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ModifyTagGroupsResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyTagGroupsResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ModifyTagGroupsResponseBodyTags>>(expect1);
      }
    }
  }


  virtual ~ModifyTagGroupsResponseBody() = default;
};
class ModifyTagGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTagGroupsResponseBody> body{};

  ModifyTagGroupsResponse() {}

  explicit ModifyTagGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTagGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTagGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTagGroupsResponse() = default;
};
class PublishScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  PublishScriptRequest() {}

  explicit PublishScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~PublishScriptRequest() = default;
};
class PublishScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PublishScriptResponseBody() {}

  explicit PublishScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PublishScriptResponseBody() = default;
};
class PublishScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishScriptResponseBody> body{};

  PublishScriptResponse() {}

  explicit PublishScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishScriptResponseBody>(model1);
      }
    }
  }


  virtual ~PublishScriptResponse() = default;
};
class PublishScriptForDebugRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  PublishScriptForDebugRequest() {}

  explicit PublishScriptForDebugRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~PublishScriptForDebugRequest() = default;
};
class PublishScriptForDebugResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PublishScriptForDebugResponseBody() {}

  explicit PublishScriptForDebugResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PublishScriptForDebugResponseBody() = default;
};
class PublishScriptForDebugResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishScriptForDebugResponseBody> body{};

  PublishScriptForDebugResponse() {}

  explicit PublishScriptForDebugResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishScriptForDebugResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishScriptForDebugResponseBody>(model1);
      }
    }
  }


  virtual ~PublishScriptForDebugResponse() = default;
};
class QueryJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactName{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> scenarioId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> timeAlignment{};

  QueryJobsRequest() {}

  explicit QueryJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timeAlignment) {
      res["TimeAlignment"] = boost::any(*timeAlignment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TimeAlignment") != m.end() && !m["TimeAlignment"].empty()) {
      timeAlignment = make_shared<string>(boost::any_cast<string>(m["TimeAlignment"]));
    }
  }


  virtual ~QueryJobsRequest() = default;
};
class QueryJobsResponseBodyJobsListContacts : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> honorific{};
  shared_ptr<string> jobId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> role{};
  shared_ptr<string> state{};

  QueryJobsResponseBodyJobsListContacts() {}

  explicit QueryJobsResponseBodyJobsListContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~QueryJobsResponseBodyJobsListContacts() = default;
};
class QueryJobsResponseBodyJobsListExtras : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  QueryJobsResponseBodyJobsListExtras() {}

  explicit QueryJobsResponseBodyJobsListExtras(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryJobsResponseBodyJobsListExtras() = default;
};
class QueryJobsResponseBodyJobsListSummary : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> content{};
  shared_ptr<string> conversationDetailId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> summaryId{};
  shared_ptr<string> summaryName{};
  shared_ptr<string> taskId{};

  QueryJobsResponseBodyJobsListSummary() {}

  explicit QueryJobsResponseBodyJobsListSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (conversationDetailId) {
      res["ConversationDetailId"] = boost::any(*conversationDetailId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (summaryId) {
      res["SummaryId"] = boost::any(*summaryId);
    }
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ConversationDetailId") != m.end() && !m["ConversationDetailId"].empty()) {
      conversationDetailId = make_shared<string>(boost::any_cast<string>(m["ConversationDetailId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("SummaryId") != m.end() && !m["SummaryId"].empty()) {
      summaryId = make_shared<string>(boost::any_cast<string>(m["SummaryId"]));
    }
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~QueryJobsResponseBodyJobsListSummary() = default;
};
class QueryJobsResponseBodyJobsListTagHits : public Darabonba::Model {
public:
  shared_ptr<string> tagGroup{};
  shared_ptr<string> tagName{};

  QueryJobsResponseBodyJobsListTagHits() {}

  explicit QueryJobsResponseBodyJobsListTagHits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagGroup) {
      res["TagGroup"] = boost::any(*tagGroup);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagGroup") != m.end() && !m["TagGroup"].empty()) {
      tagGroup = make_shared<string>(boost::any_cast<string>(m["TagGroup"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~QueryJobsResponseBodyJobsListTagHits() = default;
};
class QueryJobsResponseBodyJobsListTasksContact : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> contactName{};
  shared_ptr<string> honorific{};
  shared_ptr<string> jobId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> role{};
  shared_ptr<string> state{};

  QueryJobsResponseBodyJobsListTasksContact() {}

  explicit QueryJobsResponseBodyJobsListTasksContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~QueryJobsResponseBodyJobsListTasksContact() = default;
};
class QueryJobsResponseBodyJobsListTasks : public Darabonba::Model {
public:
  shared_ptr<long> actualTime{};
  shared_ptr<string> brief{};
  shared_ptr<string> callId{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> chatbotId{};
  shared_ptr<QueryJobsResponseBodyJobsListTasksContact> contact{};
  shared_ptr<long> duration{};
  shared_ptr<string> jobId{};
  shared_ptr<long> planedTime{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  QueryJobsResponseBodyJobsListTasks() {}

  explicit QueryJobsResponseBodyJobsListTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualTime) {
      res["ActualTime"] = boost::any(*actualTime);
    }
    if (brief) {
      res["Brief"] = boost::any(*brief);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (chatbotId) {
      res["ChatbotId"] = boost::any(*chatbotId);
    }
    if (contact) {
      res["Contact"] = contact ? boost::any(contact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (planedTime) {
      res["PlanedTime"] = boost::any(*planedTime);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualTime") != m.end() && !m["ActualTime"].empty()) {
      actualTime = make_shared<long>(boost::any_cast<long>(m["ActualTime"]));
    }
    if (m.find("Brief") != m.end() && !m["Brief"].empty()) {
      brief = make_shared<string>(boost::any_cast<string>(m["Brief"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("ChatbotId") != m.end() && !m["ChatbotId"].empty()) {
      chatbotId = make_shared<string>(boost::any_cast<string>(m["ChatbotId"]));
    }
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      if (typeid(map<string, boost::any>) == m["Contact"].type()) {
        QueryJobsResponseBodyJobsListTasksContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Contact"]));
        contact = make_shared<QueryJobsResponseBodyJobsListTasksContact>(model1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("PlanedTime") != m.end() && !m["PlanedTime"].empty()) {
      planedTime = make_shared<long>(boost::any_cast<long>(m["PlanedTime"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~QueryJobsResponseBodyJobsListTasks() = default;
};
class QueryJobsResponseBodyJobsList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<vector<QueryJobsResponseBodyJobsListContacts>> contacts{};
  shared_ptr<vector<QueryJobsResponseBodyJobsListExtras>> extras{};
  shared_ptr<string> failureReason{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> priority{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> status{};
  shared_ptr<string> strategyId{};
  shared_ptr<vector<QueryJobsResponseBodyJobsListSummary>> summary{};
  shared_ptr<vector<QueryJobsResponseBodyJobsListTagHits>> tagHits{};
  shared_ptr<vector<QueryJobsResponseBodyJobsListTasks>> tasks{};

  QueryJobsResponseBodyJobsList() {}

  explicit QueryJobsResponseBodyJobsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (extras) {
      vector<boost::any> temp1;
      for(auto item1:*extras){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Extras"] = boost::any(temp1);
    }
    if (failureReason) {
      res["FailureReason"] = boost::any(*failureReason);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (tagHits) {
      vector<boost::any> temp1;
      for(auto item1:*tagHits){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagHits"] = boost::any(temp1);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<QueryJobsResponseBodyJobsListContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobsResponseBodyJobsListContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<QueryJobsResponseBodyJobsListContacts>>(expect1);
      }
    }
    if (m.find("Extras") != m.end() && !m["Extras"].empty()) {
      if (typeid(vector<boost::any>) == m["Extras"].type()) {
        vector<QueryJobsResponseBodyJobsListExtras> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Extras"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobsResponseBodyJobsListExtras model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extras = make_shared<vector<QueryJobsResponseBodyJobsListExtras>>(expect1);
      }
    }
    if (m.find("FailureReason") != m.end() && !m["FailureReason"].empty()) {
      failureReason = make_shared<string>(boost::any_cast<string>(m["FailureReason"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<QueryJobsResponseBodyJobsListSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobsResponseBodyJobsListSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<QueryJobsResponseBodyJobsListSummary>>(expect1);
      }
    }
    if (m.find("TagHits") != m.end() && !m["TagHits"].empty()) {
      if (typeid(vector<boost::any>) == m["TagHits"].type()) {
        vector<QueryJobsResponseBodyJobsListTagHits> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagHits"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobsResponseBodyJobsListTagHits model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagHits = make_shared<vector<QueryJobsResponseBodyJobsListTagHits>>(expect1);
      }
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<QueryJobsResponseBodyJobsListTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobsResponseBodyJobsListTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<QueryJobsResponseBodyJobsListTasks>>(expect1);
      }
    }
  }


  virtual ~QueryJobsResponseBodyJobsList() = default;
};
class QueryJobsResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobsResponseBodyJobsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  QueryJobsResponseBodyJobs() {}

  explicit QueryJobsResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryJobsResponseBodyJobsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobsResponseBodyJobsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryJobsResponseBodyJobsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryJobsResponseBodyJobs() = default;
};
class QueryJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<QueryJobsResponseBodyJobs> jobs{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryJobsResponseBody() {}

  explicit QueryJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobs) {
      res["Jobs"] = jobs ? boost::any(jobs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Jobs"].type()) {
        QueryJobsResponseBodyJobs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Jobs"]));
        jobs = make_shared<QueryJobsResponseBodyJobs>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryJobsResponseBody() = default;
};
class QueryJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryJobsResponseBody> body{};

  QueryJobsResponse() {}

  explicit QueryJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryJobsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryJobsResponse() = default;
};
class QueryJobsWithResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> endActualTimeFilter{};
  shared_ptr<bool> hasAnsweredFilter{};
  shared_ptr<bool> hasHangUpByRejectionFilter{};
  shared_ptr<bool> hasReachedEndOfFlowFilter{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobFailureReasonsFilter{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobStatusFilter{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryText{};
  shared_ptr<long> startActualTimeFilter{};
  shared_ptr<string> taskStatusFilter{};

  QueryJobsWithResultRequest() {}

  explicit QueryJobsWithResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endActualTimeFilter) {
      res["EndActualTimeFilter"] = boost::any(*endActualTimeFilter);
    }
    if (hasAnsweredFilter) {
      res["HasAnsweredFilter"] = boost::any(*hasAnsweredFilter);
    }
    if (hasHangUpByRejectionFilter) {
      res["HasHangUpByRejectionFilter"] = boost::any(*hasHangUpByRejectionFilter);
    }
    if (hasReachedEndOfFlowFilter) {
      res["HasReachedEndOfFlowFilter"] = boost::any(*hasReachedEndOfFlowFilter);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobFailureReasonsFilter) {
      res["JobFailureReasonsFilter"] = boost::any(*jobFailureReasonsFilter);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobStatusFilter) {
      res["JobStatusFilter"] = boost::any(*jobStatusFilter);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryText) {
      res["QueryText"] = boost::any(*queryText);
    }
    if (startActualTimeFilter) {
      res["StartActualTimeFilter"] = boost::any(*startActualTimeFilter);
    }
    if (taskStatusFilter) {
      res["TaskStatusFilter"] = boost::any(*taskStatusFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndActualTimeFilter") != m.end() && !m["EndActualTimeFilter"].empty()) {
      endActualTimeFilter = make_shared<long>(boost::any_cast<long>(m["EndActualTimeFilter"]));
    }
    if (m.find("HasAnsweredFilter") != m.end() && !m["HasAnsweredFilter"].empty()) {
      hasAnsweredFilter = make_shared<bool>(boost::any_cast<bool>(m["HasAnsweredFilter"]));
    }
    if (m.find("HasHangUpByRejectionFilter") != m.end() && !m["HasHangUpByRejectionFilter"].empty()) {
      hasHangUpByRejectionFilter = make_shared<bool>(boost::any_cast<bool>(m["HasHangUpByRejectionFilter"]));
    }
    if (m.find("HasReachedEndOfFlowFilter") != m.end() && !m["HasReachedEndOfFlowFilter"].empty()) {
      hasReachedEndOfFlowFilter = make_shared<bool>(boost::any_cast<bool>(m["HasReachedEndOfFlowFilter"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobFailureReasonsFilter") != m.end() && !m["JobFailureReasonsFilter"].empty()) {
      jobFailureReasonsFilter = make_shared<string>(boost::any_cast<string>(m["JobFailureReasonsFilter"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobStatusFilter") != m.end() && !m["JobStatusFilter"].empty()) {
      jobStatusFilter = make_shared<string>(boost::any_cast<string>(m["JobStatusFilter"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryText") != m.end() && !m["QueryText"].empty()) {
      queryText = make_shared<string>(boost::any_cast<string>(m["QueryText"]));
    }
    if (m.find("StartActualTimeFilter") != m.end() && !m["StartActualTimeFilter"].empty()) {
      startActualTimeFilter = make_shared<long>(boost::any_cast<long>(m["StartActualTimeFilter"]));
    }
    if (m.find("TaskStatusFilter") != m.end() && !m["TaskStatusFilter"].empty()) {
      taskStatusFilter = make_shared<string>(boost::any_cast<string>(m["TaskStatusFilter"]));
    }
  }


  virtual ~QueryJobsWithResultRequest() = default;
};
class QueryJobsWithResultResponseBodyJobsListLatestTaskContact : public Darabonba::Model {
public:
  shared_ptr<string> honorific{};
  shared_ptr<string> id{};
  shared_ptr<string> jobUuid{};
  shared_ptr<string> name{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> preferredPhoneNumber{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> role{};
  shared_ptr<long> round{};
  shared_ptr<string> state{};

  QueryJobsWithResultResponseBodyJobsListLatestTaskContact() {}

  explicit QueryJobsWithResultResponseBodyJobsListLatestTaskContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobUuid) {
      res["JobUuid"] = boost::any(*jobUuid);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (preferredPhoneNumber) {
      res["PreferredPhoneNumber"] = boost::any(*preferredPhoneNumber);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (round) {
      res["Round"] = boost::any(*round);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JobUuid") != m.end() && !m["JobUuid"].empty()) {
      jobUuid = make_shared<string>(boost::any_cast<string>(m["JobUuid"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("PreferredPhoneNumber") != m.end() && !m["PreferredPhoneNumber"].empty()) {
      preferredPhoneNumber = make_shared<string>(boost::any_cast<string>(m["PreferredPhoneNumber"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Round") != m.end() && !m["Round"].empty()) {
      round = make_shared<long>(boost::any_cast<long>(m["Round"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~QueryJobsWithResultResponseBodyJobsListLatestTaskContact() = default;
};
class QueryJobsWithResultResponseBodyJobsListLatestTaskDialExceptionCodes : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> hint{};

  QueryJobsWithResultResponseBodyJobsListLatestTaskDialExceptionCodes() {}

  explicit QueryJobsWithResultResponseBodyJobsListLatestTaskDialExceptionCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hint) {
      res["Hint"] = boost::any(*hint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Hint") != m.end() && !m["Hint"].empty()) {
      hint = make_shared<string>(boost::any_cast<string>(m["Hint"]));
    }
  }


  virtual ~QueryJobsWithResultResponseBodyJobsListLatestTaskDialExceptionCodes() = default;
};
class QueryJobsWithResultResponseBodyJobsListLatestTaskExtras : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  QueryJobsWithResultResponseBodyJobsListLatestTaskExtras() {}

  explicit QueryJobsWithResultResponseBodyJobsListLatestTaskExtras(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryJobsWithResultResponseBodyJobsListLatestTaskExtras() = default;
};
class QueryJobsWithResultResponseBodyJobsListLatestTaskTagHits : public Darabonba::Model {
public:
  shared_ptr<string> tagGroup{};
  shared_ptr<string> tagName{};

  QueryJobsWithResultResponseBodyJobsListLatestTaskTagHits() {}

  explicit QueryJobsWithResultResponseBodyJobsListLatestTaskTagHits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagGroup) {
      res["TagGroup"] = boost::any(*tagGroup);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagGroup") != m.end() && !m["TagGroup"].empty()) {
      tagGroup = make_shared<string>(boost::any_cast<string>(m["TagGroup"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~QueryJobsWithResultResponseBodyJobsListLatestTaskTagHits() = default;
};
class QueryJobsWithResultResponseBodyJobsListLatestTask : public Darabonba::Model {
public:
  shared_ptr<long> callDuration{};
  shared_ptr<string> callDurationDisplay{};
  shared_ptr<long> callTime{};
  shared_ptr<QueryJobsWithResultResponseBodyJobsListLatestTaskContact> contact{};
  shared_ptr<vector<QueryJobsWithResultResponseBodyJobsListLatestTaskDialExceptionCodes>> dialExceptionCodes{};
  shared_ptr<vector<QueryJobsWithResultResponseBodyJobsListLatestTaskExtras>> extras{};
  shared_ptr<bool> hasAnswered{};
  shared_ptr<bool> hasHangUpByRejection{};
  shared_ptr<bool> hasLastPlaybackCompleted{};
  shared_ptr<bool> hasReachedEndOfFlow{};
  shared_ptr<string> status{};
  shared_ptr<string> statusName{};
  shared_ptr<vector<QueryJobsWithResultResponseBodyJobsListLatestTaskTagHits>> tagHits{};
  shared_ptr<string> taskEndReason{};

  QueryJobsWithResultResponseBodyJobsListLatestTask() {}

  explicit QueryJobsWithResultResponseBodyJobsListLatestTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callDuration) {
      res["CallDuration"] = boost::any(*callDuration);
    }
    if (callDurationDisplay) {
      res["CallDurationDisplay"] = boost::any(*callDurationDisplay);
    }
    if (callTime) {
      res["CallTime"] = boost::any(*callTime);
    }
    if (contact) {
      res["Contact"] = contact ? boost::any(contact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dialExceptionCodes) {
      vector<boost::any> temp1;
      for(auto item1:*dialExceptionCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DialExceptionCodes"] = boost::any(temp1);
    }
    if (extras) {
      vector<boost::any> temp1;
      for(auto item1:*extras){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Extras"] = boost::any(temp1);
    }
    if (hasAnswered) {
      res["HasAnswered"] = boost::any(*hasAnswered);
    }
    if (hasHangUpByRejection) {
      res["HasHangUpByRejection"] = boost::any(*hasHangUpByRejection);
    }
    if (hasLastPlaybackCompleted) {
      res["HasLastPlaybackCompleted"] = boost::any(*hasLastPlaybackCompleted);
    }
    if (hasReachedEndOfFlow) {
      res["HasReachedEndOfFlow"] = boost::any(*hasReachedEndOfFlow);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusName) {
      res["StatusName"] = boost::any(*statusName);
    }
    if (tagHits) {
      vector<boost::any> temp1;
      for(auto item1:*tagHits){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagHits"] = boost::any(temp1);
    }
    if (taskEndReason) {
      res["TaskEndReason"] = boost::any(*taskEndReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallDuration") != m.end() && !m["CallDuration"].empty()) {
      callDuration = make_shared<long>(boost::any_cast<long>(m["CallDuration"]));
    }
    if (m.find("CallDurationDisplay") != m.end() && !m["CallDurationDisplay"].empty()) {
      callDurationDisplay = make_shared<string>(boost::any_cast<string>(m["CallDurationDisplay"]));
    }
    if (m.find("CallTime") != m.end() && !m["CallTime"].empty()) {
      callTime = make_shared<long>(boost::any_cast<long>(m["CallTime"]));
    }
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      if (typeid(map<string, boost::any>) == m["Contact"].type()) {
        QueryJobsWithResultResponseBodyJobsListLatestTaskContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Contact"]));
        contact = make_shared<QueryJobsWithResultResponseBodyJobsListLatestTaskContact>(model1);
      }
    }
    if (m.find("DialExceptionCodes") != m.end() && !m["DialExceptionCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["DialExceptionCodes"].type()) {
        vector<QueryJobsWithResultResponseBodyJobsListLatestTaskDialExceptionCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DialExceptionCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobsWithResultResponseBodyJobsListLatestTaskDialExceptionCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dialExceptionCodes = make_shared<vector<QueryJobsWithResultResponseBodyJobsListLatestTaskDialExceptionCodes>>(expect1);
      }
    }
    if (m.find("Extras") != m.end() && !m["Extras"].empty()) {
      if (typeid(vector<boost::any>) == m["Extras"].type()) {
        vector<QueryJobsWithResultResponseBodyJobsListLatestTaskExtras> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Extras"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobsWithResultResponseBodyJobsListLatestTaskExtras model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extras = make_shared<vector<QueryJobsWithResultResponseBodyJobsListLatestTaskExtras>>(expect1);
      }
    }
    if (m.find("HasAnswered") != m.end() && !m["HasAnswered"].empty()) {
      hasAnswered = make_shared<bool>(boost::any_cast<bool>(m["HasAnswered"]));
    }
    if (m.find("HasHangUpByRejection") != m.end() && !m["HasHangUpByRejection"].empty()) {
      hasHangUpByRejection = make_shared<bool>(boost::any_cast<bool>(m["HasHangUpByRejection"]));
    }
    if (m.find("HasLastPlaybackCompleted") != m.end() && !m["HasLastPlaybackCompleted"].empty()) {
      hasLastPlaybackCompleted = make_shared<bool>(boost::any_cast<bool>(m["HasLastPlaybackCompleted"]));
    }
    if (m.find("HasReachedEndOfFlow") != m.end() && !m["HasReachedEndOfFlow"].empty()) {
      hasReachedEndOfFlow = make_shared<bool>(boost::any_cast<bool>(m["HasReachedEndOfFlow"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusName") != m.end() && !m["StatusName"].empty()) {
      statusName = make_shared<string>(boost::any_cast<string>(m["StatusName"]));
    }
    if (m.find("TagHits") != m.end() && !m["TagHits"].empty()) {
      if (typeid(vector<boost::any>) == m["TagHits"].type()) {
        vector<QueryJobsWithResultResponseBodyJobsListLatestTaskTagHits> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagHits"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobsWithResultResponseBodyJobsListLatestTaskTagHits model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagHits = make_shared<vector<QueryJobsWithResultResponseBodyJobsListLatestTaskTagHits>>(expect1);
      }
    }
    if (m.find("TaskEndReason") != m.end() && !m["TaskEndReason"].empty()) {
      taskEndReason = make_shared<string>(boost::any_cast<string>(m["TaskEndReason"]));
    }
  }


  virtual ~QueryJobsWithResultResponseBodyJobsListLatestTask() = default;
};
class QueryJobsWithResultResponseBodyJobsList : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> jobFailureReason{};
  shared_ptr<QueryJobsWithResultResponseBodyJobsListLatestTask> latestTask{};
  shared_ptr<string> status{};
  shared_ptr<string> statusName{};

  QueryJobsWithResultResponseBodyJobsList() {}

  explicit QueryJobsWithResultResponseBodyJobsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobFailureReason) {
      res["JobFailureReason"] = boost::any(*jobFailureReason);
    }
    if (latestTask) {
      res["LatestTask"] = latestTask ? boost::any(latestTask->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusName) {
      res["StatusName"] = boost::any(*statusName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JobFailureReason") != m.end() && !m["JobFailureReason"].empty()) {
      jobFailureReason = make_shared<string>(boost::any_cast<string>(m["JobFailureReason"]));
    }
    if (m.find("LatestTask") != m.end() && !m["LatestTask"].empty()) {
      if (typeid(map<string, boost::any>) == m["LatestTask"].type()) {
        QueryJobsWithResultResponseBodyJobsListLatestTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LatestTask"]));
        latestTask = make_shared<QueryJobsWithResultResponseBodyJobsListLatestTask>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusName") != m.end() && !m["StatusName"].empty()) {
      statusName = make_shared<string>(boost::any_cast<string>(m["StatusName"]));
    }
  }


  virtual ~QueryJobsWithResultResponseBodyJobsList() = default;
};
class QueryJobsWithResultResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobsWithResultResponseBodyJobsList>> list{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> rowCount{};

  QueryJobsWithResultResponseBodyJobs() {}

  explicit QueryJobsWithResultResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryJobsWithResultResponseBodyJobsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobsWithResultResponseBodyJobsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryJobsWithResultResponseBodyJobsList>>(expect1);
      }
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
  }


  virtual ~QueryJobsWithResultResponseBodyJobs() = default;
};
class QueryJobsWithResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<QueryJobsWithResultResponseBodyJobs> jobs{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<string>> variableNames{};

  QueryJobsWithResultResponseBody() {}

  explicit QueryJobsWithResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobs) {
      res["Jobs"] = jobs ? boost::any(jobs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (variableNames) {
      res["VariableNames"] = boost::any(*variableNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Jobs"].type()) {
        QueryJobsWithResultResponseBodyJobs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Jobs"]));
        jobs = make_shared<QueryJobsWithResultResponseBodyJobs>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("VariableNames") != m.end() && !m["VariableNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VariableNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VariableNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      variableNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryJobsWithResultResponseBody() = default;
};
class QueryJobsWithResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryJobsWithResultResponseBody> body{};

  QueryJobsWithResultResponse() {}

  explicit QueryJobsWithResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryJobsWithResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryJobsWithResultResponseBody>(model1);
      }
    }
  }


  virtual ~QueryJobsWithResultResponse() = default;
};
class QueryScriptWaveformsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptContent{};
  shared_ptr<string> scriptId{};

  QueryScriptWaveformsRequest() {}

  explicit QueryScriptWaveformsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptContent) {
      res["ScriptContent"] = boost::any(*scriptContent);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptContent") != m.end() && !m["ScriptContent"].empty()) {
      scriptContent = make_shared<string>(boost::any_cast<string>(m["ScriptContent"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~QueryScriptWaveformsRequest() = default;
};
class QueryScriptWaveformsResponseBodyScriptWaveforms : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> scriptContent{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptWaveformId{};

  QueryScriptWaveformsResponseBodyScriptWaveforms() {}

  explicit QueryScriptWaveformsResponseBodyScriptWaveforms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (scriptContent) {
      res["ScriptContent"] = boost::any(*scriptContent);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptWaveformId) {
      res["ScriptWaveformId"] = boost::any(*scriptWaveformId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("ScriptContent") != m.end() && !m["ScriptContent"].empty()) {
      scriptContent = make_shared<string>(boost::any_cast<string>(m["ScriptContent"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptWaveformId") != m.end() && !m["ScriptWaveformId"].empty()) {
      scriptWaveformId = make_shared<string>(boost::any_cast<string>(m["ScriptWaveformId"]));
    }
  }


  virtual ~QueryScriptWaveformsResponseBodyScriptWaveforms() = default;
};
class QueryScriptWaveformsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryScriptWaveformsResponseBodyScriptWaveforms>> scriptWaveforms{};
  shared_ptr<bool> success{};

  QueryScriptWaveformsResponseBody() {}

  explicit QueryScriptWaveformsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scriptWaveforms) {
      vector<boost::any> temp1;
      for(auto item1:*scriptWaveforms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptWaveforms"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScriptWaveforms") != m.end() && !m["ScriptWaveforms"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptWaveforms"].type()) {
        vector<QueryScriptWaveformsResponseBodyScriptWaveforms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptWaveforms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryScriptWaveformsResponseBodyScriptWaveforms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptWaveforms = make_shared<vector<QueryScriptWaveformsResponseBodyScriptWaveforms>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryScriptWaveformsResponseBody() = default;
};
class QueryScriptWaveformsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryScriptWaveformsResponseBody> body{};

  QueryScriptWaveformsResponse() {}

  explicit QueryScriptWaveformsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryScriptWaveformsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryScriptWaveformsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryScriptWaveformsResponse() = default;
};
class QueryScriptsByStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> statusList{};

  QueryScriptsByStatusRequest() {}

  explicit QueryScriptsByStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryScriptsByStatusRequest() = default;
};
class QueryScriptsByStatusResponseBodyScriptsList : public Darabonba::Model {
public:
  shared_ptr<string> appliedVersion{};
  shared_ptr<string> debugStatus{};
  shared_ptr<string> debugVersion{};
  shared_ptr<string> industry{};
  shared_ptr<bool> isDebugDrafted{};
  shared_ptr<bool> isDrafted{};
  shared_ptr<string> scene{};
  shared_ptr<string> scriptDescription{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};

  QueryScriptsByStatusResponseBodyScriptsList() {}

  explicit QueryScriptsByStatusResponseBodyScriptsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appliedVersion) {
      res["AppliedVersion"] = boost::any(*appliedVersion);
    }
    if (debugStatus) {
      res["DebugStatus"] = boost::any(*debugStatus);
    }
    if (debugVersion) {
      res["DebugVersion"] = boost::any(*debugVersion);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (isDebugDrafted) {
      res["IsDebugDrafted"] = boost::any(*isDebugDrafted);
    }
    if (isDrafted) {
      res["IsDrafted"] = boost::any(*isDrafted);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (scriptDescription) {
      res["ScriptDescription"] = boost::any(*scriptDescription);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppliedVersion") != m.end() && !m["AppliedVersion"].empty()) {
      appliedVersion = make_shared<string>(boost::any_cast<string>(m["AppliedVersion"]));
    }
    if (m.find("DebugStatus") != m.end() && !m["DebugStatus"].empty()) {
      debugStatus = make_shared<string>(boost::any_cast<string>(m["DebugStatus"]));
    }
    if (m.find("DebugVersion") != m.end() && !m["DebugVersion"].empty()) {
      debugVersion = make_shared<string>(boost::any_cast<string>(m["DebugVersion"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("IsDebugDrafted") != m.end() && !m["IsDebugDrafted"].empty()) {
      isDebugDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDebugDrafted"]));
    }
    if (m.find("IsDrafted") != m.end() && !m["IsDrafted"].empty()) {
      isDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDrafted"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("ScriptDescription") != m.end() && !m["ScriptDescription"].empty()) {
      scriptDescription = make_shared<string>(boost::any_cast<string>(m["ScriptDescription"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~QueryScriptsByStatusResponseBodyScriptsList() = default;
};
class QueryScriptsByStatusResponseBodyScripts : public Darabonba::Model {
public:
  shared_ptr<vector<QueryScriptsByStatusResponseBodyScriptsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  QueryScriptsByStatusResponseBodyScripts() {}

  explicit QueryScriptsByStatusResponseBodyScripts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryScriptsByStatusResponseBodyScriptsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryScriptsByStatusResponseBodyScriptsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryScriptsByStatusResponseBodyScriptsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryScriptsByStatusResponseBodyScripts() = default;
};
class QueryScriptsByStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryScriptsByStatusResponseBodyScripts> scripts{};
  shared_ptr<bool> success{};

  QueryScriptsByStatusResponseBody() {}

  explicit QueryScriptsByStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scripts) {
      res["Scripts"] = scripts ? boost::any(scripts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Scripts") != m.end() && !m["Scripts"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scripts"].type()) {
        QueryScriptsByStatusResponseBodyScripts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scripts"]));
        scripts = make_shared<QueryScriptsByStatusResponseBodyScripts>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryScriptsByStatusResponseBody() = default;
};
class QueryScriptsByStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryScriptsByStatusResponseBody> body{};

  QueryScriptsByStatusResponse() {}

  explicit QueryScriptsByStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryScriptsByStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryScriptsByStatusResponseBody>(model1);
      }
    }
  }


  virtual ~QueryScriptsByStatusResponse() = default;
};
class RecordFailureRequest : public Darabonba::Model {
public:
  shared_ptr<long> actualTime{};
  shared_ptr<string> callId{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> dispositionCode{};
  shared_ptr<string> exceptionCodes{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> taskId{};

  RecordFailureRequest() {}

  explicit RecordFailureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualTime) {
      res["ActualTime"] = boost::any(*actualTime);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (dispositionCode) {
      res["DispositionCode"] = boost::any(*dispositionCode);
    }
    if (exceptionCodes) {
      res["ExceptionCodes"] = boost::any(*exceptionCodes);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualTime") != m.end() && !m["ActualTime"].empty()) {
      actualTime = make_shared<long>(boost::any_cast<long>(m["ActualTime"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("DispositionCode") != m.end() && !m["DispositionCode"].empty()) {
      dispositionCode = make_shared<string>(boost::any_cast<string>(m["DispositionCode"]));
    }
    if (m.find("ExceptionCodes") != m.end() && !m["ExceptionCodes"].empty()) {
      exceptionCodes = make_shared<string>(boost::any_cast<string>(m["ExceptionCodes"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~RecordFailureRequest() = default;
};
class RecordFailureResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RecordFailureResponseBody() {}

  explicit RecordFailureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RecordFailureResponseBody() = default;
};
class RecordFailureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecordFailureResponseBody> body{};

  RecordFailureResponse() {}

  explicit RecordFailureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecordFailureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecordFailureResponseBody>(model1);
      }
    }
  }


  virtual ~RecordFailureResponse() = default;
};
class ResumeJobsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<vector<string>> jobId{};
  shared_ptr<vector<string>> jobReferenceId{};
  shared_ptr<string> scenarioId{};

  ResumeJobsRequest() {}

  explicit ResumeJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobReferenceId) {
      res["JobReferenceId"] = boost::any(*jobReferenceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("JobReferenceId") != m.end() && !m["JobReferenceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobReferenceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobReferenceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobReferenceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
  }


  virtual ~ResumeJobsRequest() = default;
};
class ResumeJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ResumeJobsResponseBody() {}

  explicit ResumeJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ResumeJobsResponseBody() = default;
};
class ResumeJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeJobsResponseBody> body{};

  ResumeJobsResponse() {}

  explicit ResumeJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeJobsResponse() = default;
};
class RollbackScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> rollbackVersion{};
  shared_ptr<string> scriptId{};

  RollbackScriptRequest() {}

  explicit RollbackScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (rollbackVersion) {
      res["RollbackVersion"] = boost::any(*rollbackVersion);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RollbackVersion") != m.end() && !m["RollbackVersion"].empty()) {
      rollbackVersion = make_shared<string>(boost::any_cast<string>(m["RollbackVersion"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~RollbackScriptRequest() = default;
};
class RollbackScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RollbackScriptResponseBody() {}

  explicit RollbackScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RollbackScriptResponseBody() = default;
};
class RollbackScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RollbackScriptResponseBody> body{};

  RollbackScriptResponse() {}

  explicit RollbackScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackScriptResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackScriptResponse() = default;
};
class SaveAfterAnswerDelayPlaybackRequest : public Darabonba::Model {
public:
  shared_ptr<long> afterAnswerDelayPlayback{};
  shared_ptr<string> entryId{};
  shared_ptr<long> strategyLevel{};

  SaveAfterAnswerDelayPlaybackRequest() {}

  explicit SaveAfterAnswerDelayPlaybackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (afterAnswerDelayPlayback) {
      res["AfterAnswerDelayPlayback"] = boost::any(*afterAnswerDelayPlayback);
    }
    if (entryId) {
      res["EntryId"] = boost::any(*entryId);
    }
    if (strategyLevel) {
      res["StrategyLevel"] = boost::any(*strategyLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AfterAnswerDelayPlayback") != m.end() && !m["AfterAnswerDelayPlayback"].empty()) {
      afterAnswerDelayPlayback = make_shared<long>(boost::any_cast<long>(m["AfterAnswerDelayPlayback"]));
    }
    if (m.find("EntryId") != m.end() && !m["EntryId"].empty()) {
      entryId = make_shared<string>(boost::any_cast<string>(m["EntryId"]));
    }
    if (m.find("StrategyLevel") != m.end() && !m["StrategyLevel"].empty()) {
      strategyLevel = make_shared<long>(boost::any_cast<long>(m["StrategyLevel"]));
    }
  }


  virtual ~SaveAfterAnswerDelayPlaybackRequest() = default;
};
class SaveAfterAnswerDelayPlaybackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveAfterAnswerDelayPlaybackResponseBody() {}

  explicit SaveAfterAnswerDelayPlaybackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveAfterAnswerDelayPlaybackResponseBody() = default;
};
class SaveAfterAnswerDelayPlaybackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveAfterAnswerDelayPlaybackResponseBody> body{};

  SaveAfterAnswerDelayPlaybackResponse() {}

  explicit SaveAfterAnswerDelayPlaybackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveAfterAnswerDelayPlaybackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveAfterAnswerDelayPlaybackResponseBody>(model1);
      }
    }
  }


  virtual ~SaveAfterAnswerDelayPlaybackResponse() = default;
};
class SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionChatCustomizationDataInfoId{};
  shared_ptr<string> annotationMissionChatId{};
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionSessionId{};
  shared_ptr<string> content{};
  shared_ptr<bool> create{};
  shared_ptr<long> createTime{};
  shared_ptr<string> customizationDataDescription{};
  shared_ptr<string> customizationDataId{};
  shared_ptr<string> customizationDataName{};
  shared_ptr<long> customizationDataWeight{};
  shared_ptr<bool> delete_{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> modifiedTime{};

  SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList() {}

  explicit SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionChatCustomizationDataInfoId) {
      res["AnnotationMissionChatCustomizationDataInfoId"] = boost::any(*annotationMissionChatCustomizationDataInfoId);
    }
    if (annotationMissionChatId) {
      res["AnnotationMissionChatId"] = boost::any(*annotationMissionChatId);
    }
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionSessionId) {
      res["AnnotationMissionSessionId"] = boost::any(*annotationMissionSessionId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customizationDataDescription) {
      res["CustomizationDataDescription"] = boost::any(*customizationDataDescription);
    }
    if (customizationDataId) {
      res["CustomizationDataId"] = boost::any(*customizationDataId);
    }
    if (customizationDataName) {
      res["CustomizationDataName"] = boost::any(*customizationDataName);
    }
    if (customizationDataWeight) {
      res["CustomizationDataWeight"] = boost::any(*customizationDataWeight);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionChatCustomizationDataInfoId") != m.end() && !m["AnnotationMissionChatCustomizationDataInfoId"].empty()) {
      annotationMissionChatCustomizationDataInfoId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatCustomizationDataInfoId"]));
    }
    if (m.find("AnnotationMissionChatId") != m.end() && !m["AnnotationMissionChatId"].empty()) {
      annotationMissionChatId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatId"]));
    }
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionSessionId") != m.end() && !m["AnnotationMissionSessionId"].empty()) {
      annotationMissionSessionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<bool>(boost::any_cast<bool>(m["Create"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CustomizationDataDescription") != m.end() && !m["CustomizationDataDescription"].empty()) {
      customizationDataDescription = make_shared<string>(boost::any_cast<string>(m["CustomizationDataDescription"]));
    }
    if (m.find("CustomizationDataId") != m.end() && !m["CustomizationDataId"].empty()) {
      customizationDataId = make_shared<string>(boost::any_cast<string>(m["CustomizationDataId"]));
    }
    if (m.find("CustomizationDataName") != m.end() && !m["CustomizationDataName"].empty()) {
      customizationDataName = make_shared<string>(boost::any_cast<string>(m["CustomizationDataName"]));
    }
    if (m.find("CustomizationDataWeight") != m.end() && !m["CustomizationDataWeight"].empty()) {
      customizationDataWeight = make_shared<long>(boost::any_cast<long>(m["CustomizationDataWeight"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<bool>(boost::any_cast<bool>(m["Delete"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
  }


  virtual ~SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList() = default;
};
class SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionChatId{};
  shared_ptr<string> annotationMissionChatIntentUserSayInfoId{};
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionSessionId{};
  shared_ptr<string> botId{};
  shared_ptr<string> content{};
  shared_ptr<bool> create{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> delete_{};
  shared_ptr<long> dialogId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> intentId{};
  shared_ptr<long> modifiedTime{};

  SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList() {}

  explicit SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionChatId) {
      res["AnnotationMissionChatId"] = boost::any(*annotationMissionChatId);
    }
    if (annotationMissionChatIntentUserSayInfoId) {
      res["AnnotationMissionChatIntentUserSayInfoId"] = boost::any(*annotationMissionChatIntentUserSayInfoId);
    }
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionSessionId) {
      res["AnnotationMissionSessionId"] = boost::any(*annotationMissionSessionId);
    }
    if (botId) {
      res["BotId"] = boost::any(*botId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    if (dialogId) {
      res["DialogId"] = boost::any(*dialogId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionChatId") != m.end() && !m["AnnotationMissionChatId"].empty()) {
      annotationMissionChatId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatId"]));
    }
    if (m.find("AnnotationMissionChatIntentUserSayInfoId") != m.end() && !m["AnnotationMissionChatIntentUserSayInfoId"].empty()) {
      annotationMissionChatIntentUserSayInfoId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatIntentUserSayInfoId"]));
    }
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionSessionId") != m.end() && !m["AnnotationMissionSessionId"].empty()) {
      annotationMissionSessionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionId"]));
    }
    if (m.find("BotId") != m.end() && !m["BotId"].empty()) {
      botId = make_shared<string>(boost::any_cast<string>(m["BotId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<bool>(boost::any_cast<bool>(m["Create"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<bool>(boost::any_cast<bool>(m["Delete"]));
    }
    if (m.find("DialogId") != m.end() && !m["DialogId"].empty()) {
      dialogId = make_shared<long>(boost::any_cast<long>(m["DialogId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<long>(boost::any_cast<long>(m["IntentId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
  }


  virtual ~SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList() = default;
};
class SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionChatId{};
  shared_ptr<string> annotationMissionChatTagInfoId{};
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionSessionId{};
  shared_ptr<string> annotationMissionTagInfoId{};
  shared_ptr<string> annotationMissionTagInfoName{};
  shared_ptr<bool> create{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> delete_{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> modifiedTime{};

  SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList() {}

  explicit SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionChatId) {
      res["AnnotationMissionChatId"] = boost::any(*annotationMissionChatId);
    }
    if (annotationMissionChatTagInfoId) {
      res["AnnotationMissionChatTagInfoId"] = boost::any(*annotationMissionChatTagInfoId);
    }
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionSessionId) {
      res["AnnotationMissionSessionId"] = boost::any(*annotationMissionSessionId);
    }
    if (annotationMissionTagInfoId) {
      res["AnnotationMissionTagInfoId"] = boost::any(*annotationMissionTagInfoId);
    }
    if (annotationMissionTagInfoName) {
      res["AnnotationMissionTagInfoName"] = boost::any(*annotationMissionTagInfoName);
    }
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionChatId") != m.end() && !m["AnnotationMissionChatId"].empty()) {
      annotationMissionChatId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatId"]));
    }
    if (m.find("AnnotationMissionChatTagInfoId") != m.end() && !m["AnnotationMissionChatTagInfoId"].empty()) {
      annotationMissionChatTagInfoId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatTagInfoId"]));
    }
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionSessionId") != m.end() && !m["AnnotationMissionSessionId"].empty()) {
      annotationMissionSessionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionId"]));
    }
    if (m.find("AnnotationMissionTagInfoId") != m.end() && !m["AnnotationMissionTagInfoId"].empty()) {
      annotationMissionTagInfoId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionTagInfoId"]));
    }
    if (m.find("AnnotationMissionTagInfoName") != m.end() && !m["AnnotationMissionTagInfoName"].empty()) {
      annotationMissionTagInfoName = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionTagInfoName"]));
    }
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<bool>(boost::any_cast<bool>(m["Create"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<bool>(boost::any_cast<bool>(m["Delete"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
  }


  virtual ~SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList() = default;
};
class SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionChatId{};
  shared_ptr<string> annotationMissionChatVocabularyInfoId{};
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionSessionId{};
  shared_ptr<bool> create{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> delete_{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> vocabulary{};
  shared_ptr<string> vocabularyDescription{};
  shared_ptr<string> vocabularyId{};
  shared_ptr<string> vocabularyName{};
  shared_ptr<long> vocabularyWeight{};

  SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList() {}

  explicit SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionChatId) {
      res["AnnotationMissionChatId"] = boost::any(*annotationMissionChatId);
    }
    if (annotationMissionChatVocabularyInfoId) {
      res["AnnotationMissionChatVocabularyInfoId"] = boost::any(*annotationMissionChatVocabularyInfoId);
    }
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionSessionId) {
      res["AnnotationMissionSessionId"] = boost::any(*annotationMissionSessionId);
    }
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (vocabulary) {
      res["Vocabulary"] = boost::any(*vocabulary);
    }
    if (vocabularyDescription) {
      res["VocabularyDescription"] = boost::any(*vocabularyDescription);
    }
    if (vocabularyId) {
      res["VocabularyId"] = boost::any(*vocabularyId);
    }
    if (vocabularyName) {
      res["VocabularyName"] = boost::any(*vocabularyName);
    }
    if (vocabularyWeight) {
      res["VocabularyWeight"] = boost::any(*vocabularyWeight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionChatId") != m.end() && !m["AnnotationMissionChatId"].empty()) {
      annotationMissionChatId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatId"]));
    }
    if (m.find("AnnotationMissionChatVocabularyInfoId") != m.end() && !m["AnnotationMissionChatVocabularyInfoId"].empty()) {
      annotationMissionChatVocabularyInfoId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatVocabularyInfoId"]));
    }
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionSessionId") != m.end() && !m["AnnotationMissionSessionId"].empty()) {
      annotationMissionSessionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionId"]));
    }
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<bool>(boost::any_cast<bool>(m["Create"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<bool>(boost::any_cast<bool>(m["Delete"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("Vocabulary") != m.end() && !m["Vocabulary"].empty()) {
      vocabulary = make_shared<string>(boost::any_cast<string>(m["Vocabulary"]));
    }
    if (m.find("VocabularyDescription") != m.end() && !m["VocabularyDescription"].empty()) {
      vocabularyDescription = make_shared<string>(boost::any_cast<string>(m["VocabularyDescription"]));
    }
    if (m.find("VocabularyId") != m.end() && !m["VocabularyId"].empty()) {
      vocabularyId = make_shared<string>(boost::any_cast<string>(m["VocabularyId"]));
    }
    if (m.find("VocabularyName") != m.end() && !m["VocabularyName"].empty()) {
      vocabularyName = make_shared<string>(boost::any_cast<string>(m["VocabularyName"]));
    }
    if (m.find("VocabularyWeight") != m.end() && !m["VocabularyWeight"].empty()) {
      vocabularyWeight = make_shared<long>(boost::any_cast<long>(m["VocabularyWeight"]));
    }
  }


  virtual ~SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList() = default;
};
class SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatList : public Darabonba::Model {
public:
  shared_ptr<string> annotationAsrResult{};
  shared_ptr<vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList>> annotationMissionChatCustomizationDataInfoList{};
  shared_ptr<string> annotationMissionChatId{};
  shared_ptr<vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList>> annotationMissionChatIntentUserSayInfoList{};
  shared_ptr<vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList>> annotationMissionChatTagInfoList{};
  shared_ptr<vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList>> annotationMissionChatVocabularyInfoList{};
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionSessionId{};
  shared_ptr<long> annotationStatus{};
  shared_ptr<string> answer{};
  shared_ptr<long> asrAnnotationStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> intentAnnotationStatus{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<long> occurTime{};
  shared_ptr<string> originalAsrResult{};
  shared_ptr<string> sequenceId{};
  shared_ptr<long> subStatus{};
  shared_ptr<long> tagAnnotationStatus{};
  shared_ptr<long> translationError{};

  SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatList() {}

  explicit SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationAsrResult) {
      res["AnnotationAsrResult"] = boost::any(*annotationAsrResult);
    }
    if (annotationMissionChatCustomizationDataInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionChatCustomizationDataInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionChatCustomizationDataInfoList"] = boost::any(temp1);
    }
    if (annotationMissionChatId) {
      res["AnnotationMissionChatId"] = boost::any(*annotationMissionChatId);
    }
    if (annotationMissionChatIntentUserSayInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionChatIntentUserSayInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionChatIntentUserSayInfoList"] = boost::any(temp1);
    }
    if (annotationMissionChatTagInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionChatTagInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionChatTagInfoList"] = boost::any(temp1);
    }
    if (annotationMissionChatVocabularyInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionChatVocabularyInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionChatVocabularyInfoList"] = boost::any(temp1);
    }
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionSessionId) {
      res["AnnotationMissionSessionId"] = boost::any(*annotationMissionSessionId);
    }
    if (annotationStatus) {
      res["AnnotationStatus"] = boost::any(*annotationStatus);
    }
    if (answer) {
      res["Answer"] = boost::any(*answer);
    }
    if (asrAnnotationStatus) {
      res["AsrAnnotationStatus"] = boost::any(*asrAnnotationStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intentAnnotationStatus) {
      res["IntentAnnotationStatus"] = boost::any(*intentAnnotationStatus);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (occurTime) {
      res["OccurTime"] = boost::any(*occurTime);
    }
    if (originalAsrResult) {
      res["OriginalAsrResult"] = boost::any(*originalAsrResult);
    }
    if (sequenceId) {
      res["SequenceId"] = boost::any(*sequenceId);
    }
    if (subStatus) {
      res["SubStatus"] = boost::any(*subStatus);
    }
    if (tagAnnotationStatus) {
      res["TagAnnotationStatus"] = boost::any(*tagAnnotationStatus);
    }
    if (translationError) {
      res["TranslationError"] = boost::any(*translationError);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationAsrResult") != m.end() && !m["AnnotationAsrResult"].empty()) {
      annotationAsrResult = make_shared<string>(boost::any_cast<string>(m["AnnotationAsrResult"]));
    }
    if (m.find("AnnotationMissionChatCustomizationDataInfoList") != m.end() && !m["AnnotationMissionChatCustomizationDataInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionChatCustomizationDataInfoList"].type()) {
        vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionChatCustomizationDataInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionChatCustomizationDataInfoList = make_shared<vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatCustomizationDataInfoList>>(expect1);
      }
    }
    if (m.find("AnnotationMissionChatId") != m.end() && !m["AnnotationMissionChatId"].empty()) {
      annotationMissionChatId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionChatId"]));
    }
    if (m.find("AnnotationMissionChatIntentUserSayInfoList") != m.end() && !m["AnnotationMissionChatIntentUserSayInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionChatIntentUserSayInfoList"].type()) {
        vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionChatIntentUserSayInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionChatIntentUserSayInfoList = make_shared<vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatIntentUserSayInfoList>>(expect1);
      }
    }
    if (m.find("AnnotationMissionChatTagInfoList") != m.end() && !m["AnnotationMissionChatTagInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionChatTagInfoList"].type()) {
        vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionChatTagInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionChatTagInfoList = make_shared<vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatTagInfoList>>(expect1);
      }
    }
    if (m.find("AnnotationMissionChatVocabularyInfoList") != m.end() && !m["AnnotationMissionChatVocabularyInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionChatVocabularyInfoList"].type()) {
        vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionChatVocabularyInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionChatVocabularyInfoList = make_shared<vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatListAnnotationMissionChatVocabularyInfoList>>(expect1);
      }
    }
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionSessionId") != m.end() && !m["AnnotationMissionSessionId"].empty()) {
      annotationMissionSessionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionId"]));
    }
    if (m.find("AnnotationStatus") != m.end() && !m["AnnotationStatus"].empty()) {
      annotationStatus = make_shared<long>(boost::any_cast<long>(m["AnnotationStatus"]));
    }
    if (m.find("Answer") != m.end() && !m["Answer"].empty()) {
      answer = make_shared<string>(boost::any_cast<string>(m["Answer"]));
    }
    if (m.find("AsrAnnotationStatus") != m.end() && !m["AsrAnnotationStatus"].empty()) {
      asrAnnotationStatus = make_shared<long>(boost::any_cast<long>(m["AsrAnnotationStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntentAnnotationStatus") != m.end() && !m["IntentAnnotationStatus"].empty()) {
      intentAnnotationStatus = make_shared<long>(boost::any_cast<long>(m["IntentAnnotationStatus"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("OccurTime") != m.end() && !m["OccurTime"].empty()) {
      occurTime = make_shared<long>(boost::any_cast<long>(m["OccurTime"]));
    }
    if (m.find("OriginalAsrResult") != m.end() && !m["OriginalAsrResult"].empty()) {
      originalAsrResult = make_shared<string>(boost::any_cast<string>(m["OriginalAsrResult"]));
    }
    if (m.find("SequenceId") != m.end() && !m["SequenceId"].empty()) {
      sequenceId = make_shared<string>(boost::any_cast<string>(m["SequenceId"]));
    }
    if (m.find("SubStatus") != m.end() && !m["SubStatus"].empty()) {
      subStatus = make_shared<long>(boost::any_cast<long>(m["SubStatus"]));
    }
    if (m.find("TagAnnotationStatus") != m.end() && !m["TagAnnotationStatus"].empty()) {
      tagAnnotationStatus = make_shared<long>(boost::any_cast<long>(m["TagAnnotationStatus"]));
    }
    if (m.find("TranslationError") != m.end() && !m["TranslationError"].empty()) {
      translationError = make_shared<long>(boost::any_cast<long>(m["TranslationError"]));
    }
  }


  virtual ~SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatList() = default;
};
class SaveAnnotationMissionSessionListRequestAnnotationMissionSessionList : public Darabonba::Model {
public:
  shared_ptr<vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatList>> annotationMissionChatList{};
  shared_ptr<string> annotationMissionId{};
  shared_ptr<string> annotationMissionSessionId{};
  shared_ptr<long> annotationStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> sessionId{};

  SaveAnnotationMissionSessionListRequestAnnotationMissionSessionList() {}

  explicit SaveAnnotationMissionSessionListRequestAnnotationMissionSessionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionChatList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionChatList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionChatList"] = boost::any(temp1);
    }
    if (annotationMissionId) {
      res["AnnotationMissionId"] = boost::any(*annotationMissionId);
    }
    if (annotationMissionSessionId) {
      res["AnnotationMissionSessionId"] = boost::any(*annotationMissionSessionId);
    }
    if (annotationStatus) {
      res["AnnotationStatus"] = boost::any(*annotationStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionChatList") != m.end() && !m["AnnotationMissionChatList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionChatList"].type()) {
        vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionChatList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionChatList = make_shared<vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionListAnnotationMissionChatList>>(expect1);
      }
    }
    if (m.find("AnnotationMissionId") != m.end() && !m["AnnotationMissionId"].empty()) {
      annotationMissionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionId"]));
    }
    if (m.find("AnnotationMissionSessionId") != m.end() && !m["AnnotationMissionSessionId"].empty()) {
      annotationMissionSessionId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionId"]));
    }
    if (m.find("AnnotationStatus") != m.end() && !m["AnnotationStatus"].empty()) {
      annotationStatus = make_shared<long>(boost::any_cast<long>(m["AnnotationStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
  }


  virtual ~SaveAnnotationMissionSessionListRequestAnnotationMissionSessionList() = default;
};
class SaveAnnotationMissionSessionListRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentKey{};
  shared_ptr<long> annotationMissionDataSourceType{};
  shared_ptr<vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionList>> annotationMissionSessionList{};
  shared_ptr<string> annotationMissionSessionListJsonString{};
  shared_ptr<long> environment{};
  shared_ptr<string> userNick{};

  SaveAnnotationMissionSessionListRequest() {}

  explicit SaveAnnotationMissionSessionListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (annotationMissionDataSourceType) {
      res["AnnotationMissionDataSourceType"] = boost::any(*annotationMissionDataSourceType);
    }
    if (annotationMissionSessionList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionSessionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionSessionList"] = boost::any(temp1);
    }
    if (annotationMissionSessionListJsonString) {
      res["AnnotationMissionSessionListJsonString"] = boost::any(*annotationMissionSessionListJsonString);
    }
    if (environment) {
      res["Environment"] = boost::any(*environment);
    }
    if (userNick) {
      res["UserNick"] = boost::any(*userNick);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("AnnotationMissionDataSourceType") != m.end() && !m["AnnotationMissionDataSourceType"].empty()) {
      annotationMissionDataSourceType = make_shared<long>(boost::any_cast<long>(m["AnnotationMissionDataSourceType"]));
    }
    if (m.find("AnnotationMissionSessionList") != m.end() && !m["AnnotationMissionSessionList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionSessionList"].type()) {
        vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionSessionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SaveAnnotationMissionSessionListRequestAnnotationMissionSessionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionSessionList = make_shared<vector<SaveAnnotationMissionSessionListRequestAnnotationMissionSessionList>>(expect1);
      }
    }
    if (m.find("AnnotationMissionSessionListJsonString") != m.end() && !m["AnnotationMissionSessionListJsonString"].empty()) {
      annotationMissionSessionListJsonString = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionListJsonString"]));
    }
    if (m.find("Environment") != m.end() && !m["Environment"].empty()) {
      environment = make_shared<long>(boost::any_cast<long>(m["Environment"]));
    }
    if (m.find("UserNick") != m.end() && !m["UserNick"].empty()) {
      userNick = make_shared<string>(boost::any_cast<string>(m["UserNick"]));
    }
  }


  virtual ~SaveAnnotationMissionSessionListRequest() = default;
};
class SaveAnnotationMissionSessionListResponseBodyDataSaveAnnotationMissionSessionListRequest : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionSessionListJsonString{};

  SaveAnnotationMissionSessionListResponseBodyDataSaveAnnotationMissionSessionListRequest() {}

  explicit SaveAnnotationMissionSessionListResponseBodyDataSaveAnnotationMissionSessionListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionSessionListJsonString) {
      res["AnnotationMissionSessionListJsonString"] = boost::any(*annotationMissionSessionListJsonString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionSessionListJsonString") != m.end() && !m["AnnotationMissionSessionListJsonString"].empty()) {
      annotationMissionSessionListJsonString = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionSessionListJsonString"]));
    }
  }


  virtual ~SaveAnnotationMissionSessionListResponseBodyDataSaveAnnotationMissionSessionListRequest() = default;
};
class SaveAnnotationMissionSessionListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<vector<string>> messageList{};
  shared_ptr<SaveAnnotationMissionSessionListResponseBodyDataSaveAnnotationMissionSessionListRequest> saveAnnotationMissionSessionListRequest{};
  shared_ptr<bool> success{};

  SaveAnnotationMissionSessionListResponseBodyData() {}

  explicit SaveAnnotationMissionSessionListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageList) {
      res["MessageList"] = boost::any(*messageList);
    }
    if (saveAnnotationMissionSessionListRequest) {
      res["SaveAnnotationMissionSessionListRequest"] = saveAnnotationMissionSessionListRequest ? boost::any(saveAnnotationMissionSessionListRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageList") != m.end() && !m["MessageList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MessageList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MessageList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      messageList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SaveAnnotationMissionSessionListRequest") != m.end() && !m["SaveAnnotationMissionSessionListRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["SaveAnnotationMissionSessionListRequest"].type()) {
        SaveAnnotationMissionSessionListResponseBodyDataSaveAnnotationMissionSessionListRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SaveAnnotationMissionSessionListRequest"]));
        saveAnnotationMissionSessionListRequest = make_shared<SaveAnnotationMissionSessionListResponseBodyDataSaveAnnotationMissionSessionListRequest>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveAnnotationMissionSessionListResponseBodyData() = default;
};
class SaveAnnotationMissionSessionListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SaveAnnotationMissionSessionListResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveAnnotationMissionSessionListResponseBody() {}

  explicit SaveAnnotationMissionSessionListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SaveAnnotationMissionSessionListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SaveAnnotationMissionSessionListResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveAnnotationMissionSessionListResponseBody() = default;
};
class SaveAnnotationMissionSessionListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveAnnotationMissionSessionListResponseBody> body{};

  SaveAnnotationMissionSessionListResponse() {}

  explicit SaveAnnotationMissionSessionListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveAnnotationMissionSessionListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveAnnotationMissionSessionListResponseBody>(model1);
      }
    }
  }


  virtual ~SaveAnnotationMissionSessionListResponse() = default;
};
class SaveAnnotationMissionTagInfoListRequestAnnotationMissionTagInfoList : public Darabonba::Model {
public:
  shared_ptr<string> annotationMissionTagInfoDescription{};
  shared_ptr<string> annotationMissionTagInfoId{};
  shared_ptr<string> annotationMissionTagInfoName{};
  shared_ptr<bool> delete_{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};

  SaveAnnotationMissionTagInfoListRequestAnnotationMissionTagInfoList() {}

  explicit SaveAnnotationMissionTagInfoListRequestAnnotationMissionTagInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionTagInfoDescription) {
      res["AnnotationMissionTagInfoDescription"] = boost::any(*annotationMissionTagInfoDescription);
    }
    if (annotationMissionTagInfoId) {
      res["AnnotationMissionTagInfoId"] = boost::any(*annotationMissionTagInfoId);
    }
    if (annotationMissionTagInfoName) {
      res["AnnotationMissionTagInfoName"] = boost::any(*annotationMissionTagInfoName);
    }
    if (delete_) {
      res["Delete"] = boost::any(*delete_);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionTagInfoDescription") != m.end() && !m["AnnotationMissionTagInfoDescription"].empty()) {
      annotationMissionTagInfoDescription = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionTagInfoDescription"]));
    }
    if (m.find("AnnotationMissionTagInfoId") != m.end() && !m["AnnotationMissionTagInfoId"].empty()) {
      annotationMissionTagInfoId = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionTagInfoId"]));
    }
    if (m.find("AnnotationMissionTagInfoName") != m.end() && !m["AnnotationMissionTagInfoName"].empty()) {
      annotationMissionTagInfoName = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionTagInfoName"]));
    }
    if (m.find("Delete") != m.end() && !m["Delete"].empty()) {
      delete_ = make_shared<bool>(boost::any_cast<bool>(m["Delete"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~SaveAnnotationMissionTagInfoListRequestAnnotationMissionTagInfoList() = default;
};
class SaveAnnotationMissionTagInfoListRequest : public Darabonba::Model {
public:
  shared_ptr<vector<SaveAnnotationMissionTagInfoListRequestAnnotationMissionTagInfoList>> annotationMissionTagInfoList{};
  shared_ptr<string> annotationMissionTagInfoListJsonString{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> reset{};

  SaveAnnotationMissionTagInfoListRequest() {}

  explicit SaveAnnotationMissionTagInfoListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotationMissionTagInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*annotationMissionTagInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnnotationMissionTagInfoList"] = boost::any(temp1);
    }
    if (annotationMissionTagInfoListJsonString) {
      res["AnnotationMissionTagInfoListJsonString"] = boost::any(*annotationMissionTagInfoListJsonString);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (reset) {
      res["Reset"] = boost::any(*reset);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnnotationMissionTagInfoList") != m.end() && !m["AnnotationMissionTagInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnnotationMissionTagInfoList"].type()) {
        vector<SaveAnnotationMissionTagInfoListRequestAnnotationMissionTagInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnnotationMissionTagInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SaveAnnotationMissionTagInfoListRequestAnnotationMissionTagInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotationMissionTagInfoList = make_shared<vector<SaveAnnotationMissionTagInfoListRequestAnnotationMissionTagInfoList>>(expect1);
      }
    }
    if (m.find("AnnotationMissionTagInfoListJsonString") != m.end() && !m["AnnotationMissionTagInfoListJsonString"].empty()) {
      annotationMissionTagInfoListJsonString = make_shared<string>(boost::any_cast<string>(m["AnnotationMissionTagInfoListJsonString"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Reset") != m.end() && !m["Reset"].empty()) {
      reset = make_shared<bool>(boost::any_cast<bool>(m["Reset"]));
    }
  }


  virtual ~SaveAnnotationMissionTagInfoListRequest() = default;
};
class SaveAnnotationMissionTagInfoListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> execCount{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  SaveAnnotationMissionTagInfoListResponseBodyData() {}

  explicit SaveAnnotationMissionTagInfoListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (execCount) {
      res["ExecCount"] = boost::any(*execCount);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecCount") != m.end() && !m["ExecCount"].empty()) {
      execCount = make_shared<long>(boost::any_cast<long>(m["ExecCount"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveAnnotationMissionTagInfoListResponseBodyData() = default;
};
class SaveAnnotationMissionTagInfoListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SaveAnnotationMissionTagInfoListResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveAnnotationMissionTagInfoListResponseBody() {}

  explicit SaveAnnotationMissionTagInfoListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SaveAnnotationMissionTagInfoListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SaveAnnotationMissionTagInfoListResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveAnnotationMissionTagInfoListResponseBody() = default;
};
class SaveAnnotationMissionTagInfoListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveAnnotationMissionTagInfoListResponseBody> body{};

  SaveAnnotationMissionTagInfoListResponse() {}

  explicit SaveAnnotationMissionTagInfoListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveAnnotationMissionTagInfoListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveAnnotationMissionTagInfoListResponseBody>(model1);
      }
    }
  }


  virtual ~SaveAnnotationMissionTagInfoListResponse() = default;
};
class SaveBaseStrategyPeriodRequest : public Darabonba::Model {
public:
  shared_ptr<string> entryId{};
  shared_ptr<bool> onlyWeekdays{};
  shared_ptr<bool> onlyWorkdays{};
  shared_ptr<long> strategyLevel{};
  shared_ptr<vector<string>> workingTime{};
  shared_ptr<string> workingTimeFramesJson{};

  SaveBaseStrategyPeriodRequest() {}

  explicit SaveBaseStrategyPeriodRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entryId) {
      res["EntryId"] = boost::any(*entryId);
    }
    if (onlyWeekdays) {
      res["OnlyWeekdays"] = boost::any(*onlyWeekdays);
    }
    if (onlyWorkdays) {
      res["OnlyWorkdays"] = boost::any(*onlyWorkdays);
    }
    if (strategyLevel) {
      res["StrategyLevel"] = boost::any(*strategyLevel);
    }
    if (workingTime) {
      res["WorkingTime"] = boost::any(*workingTime);
    }
    if (workingTimeFramesJson) {
      res["WorkingTimeFramesJson"] = boost::any(*workingTimeFramesJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntryId") != m.end() && !m["EntryId"].empty()) {
      entryId = make_shared<string>(boost::any_cast<string>(m["EntryId"]));
    }
    if (m.find("OnlyWeekdays") != m.end() && !m["OnlyWeekdays"].empty()) {
      onlyWeekdays = make_shared<bool>(boost::any_cast<bool>(m["OnlyWeekdays"]));
    }
    if (m.find("OnlyWorkdays") != m.end() && !m["OnlyWorkdays"].empty()) {
      onlyWorkdays = make_shared<bool>(boost::any_cast<bool>(m["OnlyWorkdays"]));
    }
    if (m.find("StrategyLevel") != m.end() && !m["StrategyLevel"].empty()) {
      strategyLevel = make_shared<long>(boost::any_cast<long>(m["StrategyLevel"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WorkingTime"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      workingTime = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WorkingTimeFramesJson") != m.end() && !m["WorkingTimeFramesJson"].empty()) {
      workingTimeFramesJson = make_shared<string>(boost::any_cast<string>(m["WorkingTimeFramesJson"]));
    }
  }


  virtual ~SaveBaseStrategyPeriodRequest() = default;
};
class SaveBaseStrategyPeriodResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveBaseStrategyPeriodResponseBody() {}

  explicit SaveBaseStrategyPeriodResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveBaseStrategyPeriodResponseBody() = default;
};
class SaveBaseStrategyPeriodResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveBaseStrategyPeriodResponseBody> body{};

  SaveBaseStrategyPeriodResponse() {}

  explicit SaveBaseStrategyPeriodResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveBaseStrategyPeriodResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveBaseStrategyPeriodResponseBody>(model1);
      }
    }
  }


  virtual ~SaveBaseStrategyPeriodResponse() = default;
};
class SaveContactBlockListRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contactBlockListList{};
  shared_ptr<string> contactBlockListsJson{};
  shared_ptr<string> instanceId{};

  SaveContactBlockListRequest() {}

  explicit SaveContactBlockListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactBlockListList) {
      res["ContactBlockListList"] = boost::any(*contactBlockListList);
    }
    if (contactBlockListsJson) {
      res["ContactBlockListsJson"] = boost::any(*contactBlockListsJson);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactBlockListList") != m.end() && !m["ContactBlockListList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactBlockListList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactBlockListList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactBlockListList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ContactBlockListsJson") != m.end() && !m["ContactBlockListsJson"].empty()) {
      contactBlockListsJson = make_shared<string>(boost::any_cast<string>(m["ContactBlockListsJson"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~SaveContactBlockListRequest() = default;
};
class SaveContactBlockListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> affectedRows{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveContactBlockListResponseBody() {}

  explicit SaveContactBlockListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectedRows) {
      res["AffectedRows"] = boost::any(*affectedRows);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectedRows") != m.end() && !m["AffectedRows"].empty()) {
      affectedRows = make_shared<long>(boost::any_cast<long>(m["AffectedRows"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveContactBlockListResponseBody() = default;
};
class SaveContactBlockListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveContactBlockListResponseBody> body{};

  SaveContactBlockListResponse() {}

  explicit SaveContactBlockListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveContactBlockListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveContactBlockListResponseBody>(model1);
      }
    }
  }


  virtual ~SaveContactBlockListResponse() = default;
};
class SaveContactWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contactWhiteListList{};
  shared_ptr<string> contactWhiteListsJson{};
  shared_ptr<string> instanceId{};

  SaveContactWhiteListRequest() {}

  explicit SaveContactWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactWhiteListList) {
      res["ContactWhiteListList"] = boost::any(*contactWhiteListList);
    }
    if (contactWhiteListsJson) {
      res["ContactWhiteListsJson"] = boost::any(*contactWhiteListsJson);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactWhiteListList") != m.end() && !m["ContactWhiteListList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactWhiteListList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactWhiteListList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactWhiteListList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ContactWhiteListsJson") != m.end() && !m["ContactWhiteListsJson"].empty()) {
      contactWhiteListsJson = make_shared<string>(boost::any_cast<string>(m["ContactWhiteListsJson"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~SaveContactWhiteListRequest() = default;
};
class SaveContactWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> affectedRows{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveContactWhiteListResponseBody() {}

  explicit SaveContactWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectedRows) {
      res["AffectedRows"] = boost::any(*affectedRows);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectedRows") != m.end() && !m["AffectedRows"].empty()) {
      affectedRows = make_shared<long>(boost::any_cast<long>(m["AffectedRows"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveContactWhiteListResponseBody() = default;
};
class SaveContactWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveContactWhiteListResponseBody> body{};

  SaveContactWhiteListResponse() {}

  explicit SaveContactWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveContactWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveContactWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~SaveContactWhiteListResponse() = default;
};
class SaveEffectiveDaysRequest : public Darabonba::Model {
public:
  shared_ptr<long> effectiveDays{};
  shared_ptr<string> entryId{};
  shared_ptr<long> strategyLevel{};

  SaveEffectiveDaysRequest() {}

  explicit SaveEffectiveDaysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectiveDays) {
      res["EffectiveDays"] = boost::any(*effectiveDays);
    }
    if (entryId) {
      res["EntryId"] = boost::any(*entryId);
    }
    if (strategyLevel) {
      res["StrategyLevel"] = boost::any(*strategyLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectiveDays") != m.end() && !m["EffectiveDays"].empty()) {
      effectiveDays = make_shared<long>(boost::any_cast<long>(m["EffectiveDays"]));
    }
    if (m.find("EntryId") != m.end() && !m["EntryId"].empty()) {
      entryId = make_shared<string>(boost::any_cast<string>(m["EntryId"]));
    }
    if (m.find("StrategyLevel") != m.end() && !m["StrategyLevel"].empty()) {
      strategyLevel = make_shared<long>(boost::any_cast<long>(m["StrategyLevel"]));
    }
  }


  virtual ~SaveEffectiveDaysRequest() = default;
};
class SaveEffectiveDaysResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveEffectiveDaysResponseBody() {}

  explicit SaveEffectiveDaysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveEffectiveDaysResponseBody() = default;
};
class SaveEffectiveDaysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveEffectiveDaysResponseBody> body{};

  SaveEffectiveDaysResponse() {}

  explicit SaveEffectiveDaysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveEffectiveDaysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveEffectiveDaysResponseBody>(model1);
      }
    }
  }


  virtual ~SaveEffectiveDaysResponse() = default;
};
class SaveMaxAttemptsPerDayRequest : public Darabonba::Model {
public:
  shared_ptr<string> entryId{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<long> strategyLevel{};

  SaveMaxAttemptsPerDayRequest() {}

  explicit SaveMaxAttemptsPerDayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entryId) {
      res["EntryId"] = boost::any(*entryId);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (strategyLevel) {
      res["StrategyLevel"] = boost::any(*strategyLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntryId") != m.end() && !m["EntryId"].empty()) {
      entryId = make_shared<string>(boost::any_cast<string>(m["EntryId"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("StrategyLevel") != m.end() && !m["StrategyLevel"].empty()) {
      strategyLevel = make_shared<long>(boost::any_cast<long>(m["StrategyLevel"]));
    }
  }


  virtual ~SaveMaxAttemptsPerDayRequest() = default;
};
class SaveMaxAttemptsPerDayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveMaxAttemptsPerDayResponseBody() {}

  explicit SaveMaxAttemptsPerDayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveMaxAttemptsPerDayResponseBody() = default;
};
class SaveMaxAttemptsPerDayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveMaxAttemptsPerDayResponseBody> body{};

  SaveMaxAttemptsPerDayResponse() {}

  explicit SaveMaxAttemptsPerDayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveMaxAttemptsPerDayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveMaxAttemptsPerDayResponseBody>(model1);
      }
    }
  }


  virtual ~SaveMaxAttemptsPerDayResponse() = default;
};
class SearchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> actualTimeGte{};
  shared_ptr<long> actualTimeLte{};
  shared_ptr<long> callDurationGte{};
  shared_ptr<long> callDurationLte{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobGroupNameQuery{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobStatusStringList{};
  shared_ptr<string> otherId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> recordingDurationGte{};
  shared_ptr<long> recordingDurationLte{};
  shared_ptr<string> scriptNameQuery{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortOrder{};
  shared_ptr<long> taskCreateTimeGte{};
  shared_ptr<long> taskCreateTimeLte{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskStatusStringList{};
  shared_ptr<string> userIdMatch{};

  SearchTaskRequest() {}

  explicit SearchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualTimeGte) {
      res["ActualTimeGte"] = boost::any(*actualTimeGte);
    }
    if (actualTimeLte) {
      res["ActualTimeLte"] = boost::any(*actualTimeLte);
    }
    if (callDurationGte) {
      res["CallDurationGte"] = boost::any(*callDurationGte);
    }
    if (callDurationLte) {
      res["CallDurationLte"] = boost::any(*callDurationLte);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobGroupNameQuery) {
      res["JobGroupNameQuery"] = boost::any(*jobGroupNameQuery);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobStatusStringList) {
      res["JobStatusStringList"] = boost::any(*jobStatusStringList);
    }
    if (otherId) {
      res["OtherId"] = boost::any(*otherId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recordingDurationGte) {
      res["RecordingDurationGte"] = boost::any(*recordingDurationGte);
    }
    if (recordingDurationLte) {
      res["RecordingDurationLte"] = boost::any(*recordingDurationLte);
    }
    if (scriptNameQuery) {
      res["ScriptNameQuery"] = boost::any(*scriptNameQuery);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (taskCreateTimeGte) {
      res["TaskCreateTimeGte"] = boost::any(*taskCreateTimeGte);
    }
    if (taskCreateTimeLte) {
      res["TaskCreateTimeLte"] = boost::any(*taskCreateTimeLte);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatusStringList) {
      res["TaskStatusStringList"] = boost::any(*taskStatusStringList);
    }
    if (userIdMatch) {
      res["UserIdMatch"] = boost::any(*userIdMatch);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualTimeGte") != m.end() && !m["ActualTimeGte"].empty()) {
      actualTimeGte = make_shared<long>(boost::any_cast<long>(m["ActualTimeGte"]));
    }
    if (m.find("ActualTimeLte") != m.end() && !m["ActualTimeLte"].empty()) {
      actualTimeLte = make_shared<long>(boost::any_cast<long>(m["ActualTimeLte"]));
    }
    if (m.find("CallDurationGte") != m.end() && !m["CallDurationGte"].empty()) {
      callDurationGte = make_shared<long>(boost::any_cast<long>(m["CallDurationGte"]));
    }
    if (m.find("CallDurationLte") != m.end() && !m["CallDurationLte"].empty()) {
      callDurationLte = make_shared<long>(boost::any_cast<long>(m["CallDurationLte"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobGroupNameQuery") != m.end() && !m["JobGroupNameQuery"].empty()) {
      jobGroupNameQuery = make_shared<string>(boost::any_cast<string>(m["JobGroupNameQuery"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobStatusStringList") != m.end() && !m["JobStatusStringList"].empty()) {
      jobStatusStringList = make_shared<string>(boost::any_cast<string>(m["JobStatusStringList"]));
    }
    if (m.find("OtherId") != m.end() && !m["OtherId"].empty()) {
      otherId = make_shared<string>(boost::any_cast<string>(m["OtherId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecordingDurationGte") != m.end() && !m["RecordingDurationGte"].empty()) {
      recordingDurationGte = make_shared<long>(boost::any_cast<long>(m["RecordingDurationGte"]));
    }
    if (m.find("RecordingDurationLte") != m.end() && !m["RecordingDurationLte"].empty()) {
      recordingDurationLte = make_shared<long>(boost::any_cast<long>(m["RecordingDurationLte"]));
    }
    if (m.find("ScriptNameQuery") != m.end() && !m["ScriptNameQuery"].empty()) {
      scriptNameQuery = make_shared<string>(boost::any_cast<string>(m["ScriptNameQuery"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("TaskCreateTimeGte") != m.end() && !m["TaskCreateTimeGte"].empty()) {
      taskCreateTimeGte = make_shared<long>(boost::any_cast<long>(m["TaskCreateTimeGte"]));
    }
    if (m.find("TaskCreateTimeLte") != m.end() && !m["TaskCreateTimeLte"].empty()) {
      taskCreateTimeLte = make_shared<long>(boost::any_cast<long>(m["TaskCreateTimeLte"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatusStringList") != m.end() && !m["TaskStatusStringList"].empty()) {
      taskStatusStringList = make_shared<string>(boost::any_cast<string>(m["TaskStatusStringList"]));
    }
    if (m.find("UserIdMatch") != m.end() && !m["UserIdMatch"].empty()) {
      userIdMatch = make_shared<string>(boost::any_cast<string>(m["UserIdMatch"]));
    }
  }


  virtual ~SearchTaskRequest() = default;
};
class SearchTaskResponseBodySearchTaskInfoList : public Darabonba::Model {
public:
  shared_ptr<long> actualTime{};
  shared_ptr<long> callDuration{};
  shared_ptr<string> callDurationDisplay{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> dialException{};
  shared_ptr<vector<string>> dialExceptionCodes{};
  shared_ptr<string> dialExceptionOld{};
  shared_ptr<bool> hasAnswered{};
  shared_ptr<bool> hasHangUpByRejection{};
  shared_ptr<bool> hasLastPlaybackCompleted{};
  shared_ptr<bool> hasReachedEndOfFlow{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobGroupName{};
  shared_ptr<string> jobId{};
  shared_ptr<long> jobStatus{};
  shared_ptr<string> jobStatusName{};
  shared_ptr<string> jobStatusString{};
  shared_ptr<long> recordingDuration{};
  shared_ptr<string> scriptName{};
  shared_ptr<long> taskCreateTime{};
  shared_ptr<long> taskEndReason{};
  shared_ptr<string> taskId{};
  shared_ptr<long> taskStatus{};
  shared_ptr<string> taskStatusName{};
  shared_ptr<string> taskStatusString{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  SearchTaskResponseBodySearchTaskInfoList() {}

  explicit SearchTaskResponseBodySearchTaskInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualTime) {
      res["ActualTime"] = boost::any(*actualTime);
    }
    if (callDuration) {
      res["CallDuration"] = boost::any(*callDuration);
    }
    if (callDurationDisplay) {
      res["CallDurationDisplay"] = boost::any(*callDurationDisplay);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (dialException) {
      res["DialException"] = boost::any(*dialException);
    }
    if (dialExceptionCodes) {
      res["DialExceptionCodes"] = boost::any(*dialExceptionCodes);
    }
    if (dialExceptionOld) {
      res["DialExceptionOld"] = boost::any(*dialExceptionOld);
    }
    if (hasAnswered) {
      res["HasAnswered"] = boost::any(*hasAnswered);
    }
    if (hasHangUpByRejection) {
      res["HasHangUpByRejection"] = boost::any(*hasHangUpByRejection);
    }
    if (hasLastPlaybackCompleted) {
      res["HasLastPlaybackCompleted"] = boost::any(*hasLastPlaybackCompleted);
    }
    if (hasReachedEndOfFlow) {
      res["HasReachedEndOfFlow"] = boost::any(*hasReachedEndOfFlow);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobGroupName) {
      res["JobGroupName"] = boost::any(*jobGroupName);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (jobStatusName) {
      res["JobStatusName"] = boost::any(*jobStatusName);
    }
    if (jobStatusString) {
      res["JobStatusString"] = boost::any(*jobStatusString);
    }
    if (recordingDuration) {
      res["RecordingDuration"] = boost::any(*recordingDuration);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (taskCreateTime) {
      res["TaskCreateTime"] = boost::any(*taskCreateTime);
    }
    if (taskEndReason) {
      res["TaskEndReason"] = boost::any(*taskEndReason);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskStatusName) {
      res["TaskStatusName"] = boost::any(*taskStatusName);
    }
    if (taskStatusString) {
      res["TaskStatusString"] = boost::any(*taskStatusString);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualTime") != m.end() && !m["ActualTime"].empty()) {
      actualTime = make_shared<long>(boost::any_cast<long>(m["ActualTime"]));
    }
    if (m.find("CallDuration") != m.end() && !m["CallDuration"].empty()) {
      callDuration = make_shared<long>(boost::any_cast<long>(m["CallDuration"]));
    }
    if (m.find("CallDurationDisplay") != m.end() && !m["CallDurationDisplay"].empty()) {
      callDurationDisplay = make_shared<string>(boost::any_cast<string>(m["CallDurationDisplay"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("DialException") != m.end() && !m["DialException"].empty()) {
      dialException = make_shared<string>(boost::any_cast<string>(m["DialException"]));
    }
    if (m.find("DialExceptionCodes") != m.end() && !m["DialExceptionCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DialExceptionCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DialExceptionCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dialExceptionCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DialExceptionOld") != m.end() && !m["DialExceptionOld"].empty()) {
      dialExceptionOld = make_shared<string>(boost::any_cast<string>(m["DialExceptionOld"]));
    }
    if (m.find("HasAnswered") != m.end() && !m["HasAnswered"].empty()) {
      hasAnswered = make_shared<bool>(boost::any_cast<bool>(m["HasAnswered"]));
    }
    if (m.find("HasHangUpByRejection") != m.end() && !m["HasHangUpByRejection"].empty()) {
      hasHangUpByRejection = make_shared<bool>(boost::any_cast<bool>(m["HasHangUpByRejection"]));
    }
    if (m.find("HasLastPlaybackCompleted") != m.end() && !m["HasLastPlaybackCompleted"].empty()) {
      hasLastPlaybackCompleted = make_shared<bool>(boost::any_cast<bool>(m["HasLastPlaybackCompleted"]));
    }
    if (m.find("HasReachedEndOfFlow") != m.end() && !m["HasReachedEndOfFlow"].empty()) {
      hasReachedEndOfFlow = make_shared<bool>(boost::any_cast<bool>(m["HasReachedEndOfFlow"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobGroupName") != m.end() && !m["JobGroupName"].empty()) {
      jobGroupName = make_shared<string>(boost::any_cast<string>(m["JobGroupName"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<long>(boost::any_cast<long>(m["JobStatus"]));
    }
    if (m.find("JobStatusName") != m.end() && !m["JobStatusName"].empty()) {
      jobStatusName = make_shared<string>(boost::any_cast<string>(m["JobStatusName"]));
    }
    if (m.find("JobStatusString") != m.end() && !m["JobStatusString"].empty()) {
      jobStatusString = make_shared<string>(boost::any_cast<string>(m["JobStatusString"]));
    }
    if (m.find("RecordingDuration") != m.end() && !m["RecordingDuration"].empty()) {
      recordingDuration = make_shared<long>(boost::any_cast<long>(m["RecordingDuration"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("TaskCreateTime") != m.end() && !m["TaskCreateTime"].empty()) {
      taskCreateTime = make_shared<long>(boost::any_cast<long>(m["TaskCreateTime"]));
    }
    if (m.find("TaskEndReason") != m.end() && !m["TaskEndReason"].empty()) {
      taskEndReason = make_shared<long>(boost::any_cast<long>(m["TaskEndReason"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("TaskStatusName") != m.end() && !m["TaskStatusName"].empty()) {
      taskStatusName = make_shared<string>(boost::any_cast<string>(m["TaskStatusName"]));
    }
    if (m.find("TaskStatusString") != m.end() && !m["TaskStatusString"].empty()) {
      taskStatusString = make_shared<string>(boost::any_cast<string>(m["TaskStatusString"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~SearchTaskResponseBodySearchTaskInfoList() = default;
};
class SearchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<SearchTaskResponseBodySearchTaskInfoList>> searchTaskInfoList{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  SearchTaskResponseBody() {}

  explicit SearchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (searchTaskInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*searchTaskInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchTaskInfoList"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SearchTaskInfoList") != m.end() && !m["SearchTaskInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchTaskInfoList"].type()) {
        vector<SearchTaskResponseBodySearchTaskInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchTaskInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTaskResponseBodySearchTaskInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchTaskInfoList = make_shared<vector<SearchTaskResponseBodySearchTaskInfoList>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~SearchTaskResponseBody() = default;
};
class SearchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchTaskResponseBody> body{};

  SearchTaskResponse() {}

  explicit SearchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~SearchTaskResponse() = default;
};
class StartJobRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> callingNumber{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobJson{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> scriptId{};

  StartJobRequest() {}

  explicit StartJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobJson) {
      res["JobJson"] = boost::any(*jobJson);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumber = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobJson") != m.end() && !m["JobJson"].empty()) {
      jobJson = make_shared<string>(boost::any_cast<string>(m["JobJson"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~StartJobRequest() = default;
};
class StartJobResponseBodyCallIds : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  StartJobResponseBodyCallIds() {}

  explicit StartJobResponseBodyCallIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~StartJobResponseBodyCallIds() = default;
};
class StartJobResponseBodyTaskIds : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  StartJobResponseBodyTaskIds() {}

  explicit StartJobResponseBodyTaskIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~StartJobResponseBodyTaskIds() = default;
};
class StartJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<StartJobResponseBodyCallIds>> callIds{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<StartJobResponseBodyTaskIds>> taskIds{};

  StartJobResponseBody() {}

  explicit StartJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callIds) {
      vector<boost::any> temp1;
      for(auto item1:*callIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CallIds"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskIds) {
      vector<boost::any> temp1;
      for(auto item1:*taskIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskIds"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallIds") != m.end() && !m["CallIds"].empty()) {
      if (typeid(vector<boost::any>) == m["CallIds"].type()) {
        vector<StartJobResponseBodyCallIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CallIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartJobResponseBodyCallIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        callIds = make_shared<vector<StartJobResponseBodyCallIds>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<StartJobResponseBodyTaskIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartJobResponseBodyTaskIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskIds = make_shared<vector<StartJobResponseBodyTaskIds>>(expect1);
      }
    }
  }


  virtual ~StartJobResponseBody() = default;
};
class StartJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartJobResponseBody> body{};

  StartJobResponse() {}

  explicit StartJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartJobResponseBody>(model1);
      }
    }
  }


  virtual ~StartJobResponse() = default;
};
class SubmitBatchJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};

  SubmitBatchJobsRequest() {}

  explicit SubmitBatchJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
  }


  virtual ~SubmitBatchJobsRequest() = default;
};
class SubmitBatchJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitBatchJobsResponseBody() {}

  explicit SubmitBatchJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitBatchJobsResponseBody() = default;
};
class SubmitBatchJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitBatchJobsResponseBody> body{};

  SubmitBatchJobsResponse() {}

  explicit SubmitBatchJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitBatchJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitBatchJobsResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitBatchJobsResponse() = default;
};
class SubmitRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> mergedRecording{};
  shared_ptr<string> resourceRecording{};
  shared_ptr<string> taskId{};

  SubmitRecordingRequest() {}

  explicit SubmitRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mergedRecording) {
      res["MergedRecording"] = boost::any(*mergedRecording);
    }
    if (resourceRecording) {
      res["ResourceRecording"] = boost::any(*resourceRecording);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MergedRecording") != m.end() && !m["MergedRecording"].empty()) {
      mergedRecording = make_shared<string>(boost::any_cast<string>(m["MergedRecording"]));
    }
    if (m.find("ResourceRecording") != m.end() && !m["ResourceRecording"].empty()) {
      resourceRecording = make_shared<string>(boost::any_cast<string>(m["ResourceRecording"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~SubmitRecordingRequest() = default;
};
class SubmitRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitRecordingResponseBody() {}

  explicit SubmitRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitRecordingResponseBody() = default;
};
class SubmitRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitRecordingResponseBody> body{};

  SubmitRecordingResponse() {}

  explicit SubmitRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitRecordingResponse() = default;
};
class SubmitScriptReviewRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> from{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  SubmitScriptReviewRequest() {}

  explicit SubmitScriptReviewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~SubmitScriptReviewRequest() = default;
};
class SubmitScriptReviewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitScriptReviewResponseBody() {}

  explicit SubmitScriptReviewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitScriptReviewResponseBody() = default;
};
class SubmitScriptReviewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitScriptReviewResponseBody> body{};

  SubmitScriptReviewResponse() {}

  explicit SubmitScriptReviewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitScriptReviewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitScriptReviewResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitScriptReviewResponse() = default;
};
class SuspendCallRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> calledNumbers{};
  shared_ptr<string> groupId{};
  shared_ptr<string> instanceId{};

  SuspendCallRequest() {}

  explicit SuspendCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calledNumbers) {
      res["CalledNumbers"] = boost::any(*calledNumbers);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalledNumbers") != m.end() && !m["CalledNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CalledNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CalledNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      calledNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~SuspendCallRequest() = default;
};
class SuspendCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SuspendCallResponseBody() {}

  explicit SuspendCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SuspendCallResponseBody() = default;
};
class SuspendCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendCallResponseBody> body{};

  SuspendCallResponse() {}

  explicit SuspendCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendCallResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendCallResponse() = default;
};
class SuspendCallWithFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> filePath{};
  shared_ptr<string> groupId{};
  shared_ptr<string> instanceId{};

  SuspendCallWithFileRequest() {}

  explicit SuspendCallWithFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~SuspendCallWithFileRequest() = default;
};
class SuspendCallWithFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SuspendCallWithFileResponseBody() {}

  explicit SuspendCallWithFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SuspendCallWithFileResponseBody() = default;
};
class SuspendCallWithFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendCallWithFileResponseBody> body{};

  SuspendCallWithFileResponse() {}

  explicit SuspendCallWithFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendCallWithFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendCallWithFileResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendCallWithFileResponse() = default;
};
class SuspendJobsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<vector<string>> jobId{};
  shared_ptr<vector<string>> jobReferenceId{};
  shared_ptr<string> scenarioId{};

  SuspendJobsRequest() {}

  explicit SuspendJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobReferenceId) {
      res["JobReferenceId"] = boost::any(*jobReferenceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("JobReferenceId") != m.end() && !m["JobReferenceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobReferenceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobReferenceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobReferenceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
  }


  virtual ~SuspendJobsRequest() = default;
};
class SuspendJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SuspendJobsResponseBody() {}

  explicit SuspendJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SuspendJobsResponseBody() = default;
};
class SuspendJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendJobsResponseBody> body{};

  SuspendJobsResponse() {}

  explicit SuspendJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendJobsResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendJobsResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class TaskPreparingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> instanceOwnerId{};
  shared_ptr<string> jobId{};

  TaskPreparingRequest() {}

  explicit TaskPreparingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceOwnerId) {
      res["InstanceOwnerId"] = boost::any(*instanceOwnerId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceOwnerId") != m.end() && !m["InstanceOwnerId"].empty()) {
      instanceOwnerId = make_shared<long>(boost::any_cast<long>(m["InstanceOwnerId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~TaskPreparingRequest() = default;
};
class TaskPreparingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> taskId{};

  TaskPreparingResponseBody() {}

  explicit TaskPreparingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~TaskPreparingResponseBody() = default;
};
class TaskPreparingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TaskPreparingResponseBody> body{};

  TaskPreparingResponse() {}

  explicit TaskPreparingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TaskPreparingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TaskPreparingResponseBody>(model1);
      }
    }
  }


  virtual ~TaskPreparingResponse() = default;
};
class TerminateCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> callId{};
  shared_ptr<string> instanceId{};

  TerminateCallRequest() {}

  explicit TerminateCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~TerminateCallRequest() = default;
};
class TerminateCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  TerminateCallResponseBody() {}

  explicit TerminateCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TerminateCallResponseBody() = default;
};
class TerminateCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TerminateCallResponseBody> body{};

  TerminateCallResponse() {}

  explicit TerminateCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TerminateCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TerminateCallResponseBody>(model1);
      }
    }
  }


  virtual ~TerminateCallResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UploadScriptRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  UploadScriptRecordingRequest() {}

  explicit UploadScriptRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~UploadScriptRecordingRequest() = default;
};
class UploadScriptRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> uuid{};

  UploadScriptRecordingResponseBody() {}

  explicit UploadScriptRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~UploadScriptRecordingResponseBody() = default;
};
class UploadScriptRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadScriptRecordingResponseBody> body{};

  UploadScriptRecordingResponse() {}

  explicit UploadScriptRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadScriptRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadScriptRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~UploadScriptRecordingResponse() = default;
};
class WithdrawScriptReviewRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scriptId{};

  WithdrawScriptReviewRequest() {}

  explicit WithdrawScriptReviewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
  }


  virtual ~WithdrawScriptReviewRequest() = default;
};
class WithdrawScriptReviewResponseBodyScript : public Darabonba::Model {
public:
  shared_ptr<string> debugStatus{};
  shared_ptr<string> industry{};
  shared_ptr<bool> isDebugDrafted{};
  shared_ptr<bool> isDrafted{};
  shared_ptr<string> scene{};
  shared_ptr<string> scriptDescription{};
  shared_ptr<string> scriptId{};
  shared_ptr<string> scriptName{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};

  WithdrawScriptReviewResponseBodyScript() {}

  explicit WithdrawScriptReviewResponseBodyScript(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (debugStatus) {
      res["DebugStatus"] = boost::any(*debugStatus);
    }
    if (industry) {
      res["Industry"] = boost::any(*industry);
    }
    if (isDebugDrafted) {
      res["IsDebugDrafted"] = boost::any(*isDebugDrafted);
    }
    if (isDrafted) {
      res["IsDrafted"] = boost::any(*isDrafted);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (scriptDescription) {
      res["ScriptDescription"] = boost::any(*scriptDescription);
    }
    if (scriptId) {
      res["ScriptId"] = boost::any(*scriptId);
    }
    if (scriptName) {
      res["ScriptName"] = boost::any(*scriptName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DebugStatus") != m.end() && !m["DebugStatus"].empty()) {
      debugStatus = make_shared<string>(boost::any_cast<string>(m["DebugStatus"]));
    }
    if (m.find("Industry") != m.end() && !m["Industry"].empty()) {
      industry = make_shared<string>(boost::any_cast<string>(m["Industry"]));
    }
    if (m.find("IsDebugDrafted") != m.end() && !m["IsDebugDrafted"].empty()) {
      isDebugDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDebugDrafted"]));
    }
    if (m.find("IsDrafted") != m.end() && !m["IsDrafted"].empty()) {
      isDrafted = make_shared<bool>(boost::any_cast<bool>(m["IsDrafted"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("ScriptDescription") != m.end() && !m["ScriptDescription"].empty()) {
      scriptDescription = make_shared<string>(boost::any_cast<string>(m["ScriptDescription"]));
    }
    if (m.find("ScriptId") != m.end() && !m["ScriptId"].empty()) {
      scriptId = make_shared<string>(boost::any_cast<string>(m["ScriptId"]));
    }
    if (m.find("ScriptName") != m.end() && !m["ScriptName"].empty()) {
      scriptName = make_shared<string>(boost::any_cast<string>(m["ScriptName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~WithdrawScriptReviewResponseBodyScript() = default;
};
class WithdrawScriptReviewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<WithdrawScriptReviewResponseBodyScript> script{};
  shared_ptr<bool> success{};

  WithdrawScriptReviewResponseBody() {}

  explicit WithdrawScriptReviewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (script) {
      res["Script"] = script ? boost::any(script->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      if (typeid(map<string, boost::any>) == m["Script"].type()) {
        WithdrawScriptReviewResponseBodyScript model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Script"]));
        script = make_shared<WithdrawScriptReviewResponseBodyScript>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~WithdrawScriptReviewResponseBody() = default;
};
class WithdrawScriptReviewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WithdrawScriptReviewResponseBody> body{};

  WithdrawScriptReviewResponse() {}

  explicit WithdrawScriptReviewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WithdrawScriptReviewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WithdrawScriptReviewResponseBody>(model1);
      }
    }
  }


  virtual ~WithdrawScriptReviewResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  ApplyNumberDistrictInfoParsingResultResponse applyNumberDistrictInfoParsingResultWithOptions(shared_ptr<ApplyNumberDistrictInfoParsingResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyNumberDistrictInfoParsingResultResponse applyNumberDistrictInfoParsingResult(shared_ptr<ApplyNumberDistrictInfoParsingResultRequest> request);
  AssignJobsResponse assignJobsWithOptions(shared_ptr<AssignJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssignJobsResponse assignJobs(shared_ptr<AssignJobsRequest> request);
  CancelJobsResponse cancelJobsWithOptions(shared_ptr<CancelJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelJobsResponse cancelJobs(shared_ptr<CancelJobsRequest> request);
  ChangeResourceGroupResponse changeResourceGroupWithOptions(shared_ptr<ChangeResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeResourceGroupResponse changeResourceGroup(shared_ptr<ChangeResourceGroupRequest> request);
  CreateAgentProfileResponse createAgentProfileWithOptions(shared_ptr<CreateAgentProfileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAgentProfileResponse createAgentProfile(shared_ptr<CreateAgentProfileRequest> request);
  CreateAnnotationMissionResponse createAnnotationMissionWithOptions(shared_ptr<CreateAnnotationMissionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAnnotationMissionResponse createAnnotationMission(shared_ptr<CreateAnnotationMissionRequest> request);
  CreateBatchJobsResponse createBatchJobsWithOptions(shared_ptr<CreateBatchJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBatchJobsResponse createBatchJobs(shared_ptr<CreateBatchJobsRequest> request);
  CreateBatchRepeatJobResponse createBatchRepeatJobWithOptions(shared_ptr<CreateBatchRepeatJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBatchRepeatJobResponse createBatchRepeatJob(shared_ptr<CreateBatchRepeatJobRequest> request);
  CreateBeebotIntentResponse createBeebotIntentWithOptions(shared_ptr<CreateBeebotIntentRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBeebotIntentResponse createBeebotIntent(shared_ptr<CreateBeebotIntentRequest> request);
  CreateBeebotIntentLgfResponse createBeebotIntentLgfWithOptions(shared_ptr<CreateBeebotIntentLgfRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBeebotIntentLgfResponse createBeebotIntentLgf(shared_ptr<CreateBeebotIntentLgfRequest> request);
  CreateBeebotIntentUserSayResponse createBeebotIntentUserSayWithOptions(shared_ptr<CreateBeebotIntentUserSayRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBeebotIntentUserSayResponse createBeebotIntentUserSay(shared_ptr<CreateBeebotIntentUserSayRequest> request);
  CreateDialogueFlowResponse createDialogueFlowWithOptions(shared_ptr<CreateDialogueFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDialogueFlowResponse createDialogueFlow(shared_ptr<CreateDialogueFlowRequest> request);
  CreateDownloadUrlResponse createDownloadUrlWithOptions(shared_ptr<CreateDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDownloadUrlResponse createDownloadUrl(shared_ptr<CreateDownloadUrlRequest> request);
  CreateGlobalQuestionResponse createGlobalQuestionWithOptions(shared_ptr<CreateGlobalQuestionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateGlobalQuestionResponse createGlobalQuestion(shared_ptr<CreateGlobalQuestionRequest> request);
  CreateInstanceResponse createInstanceWithOptions(shared_ptr<CreateInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceResponse createInstance(shared_ptr<CreateInstanceRequest> request);
  CreateInstanceBindNumberResponse createInstanceBindNumberWithOptions(shared_ptr<CreateInstanceBindNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceBindNumberResponse createInstanceBindNumber(shared_ptr<CreateInstanceBindNumberRequest> request);
  CreateIntentResponse createIntentWithOptions(shared_ptr<CreateIntentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIntentResponse createIntent(shared_ptr<CreateIntentRequest> request);
  CreateJobDataParsingTaskResponse createJobDataParsingTaskWithOptions(shared_ptr<CreateJobDataParsingTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateJobDataParsingTaskResponse createJobDataParsingTask(shared_ptr<CreateJobDataParsingTaskRequest> request);
  CreateJobGroupResponse createJobGroupWithOptions(shared_ptr<CreateJobGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateJobGroupResponse createJobGroup(shared_ptr<CreateJobGroupRequest> request);
  CreateJobGroupExportTaskResponse createJobGroupExportTaskWithOptions(shared_ptr<CreateJobGroupExportTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateJobGroupExportTaskResponse createJobGroupExportTask(shared_ptr<CreateJobGroupExportTaskRequest> request);
  CreateNumberDistrictInfoDownloadUrlResponse createNumberDistrictInfoDownloadUrlWithOptions(shared_ptr<CreateNumberDistrictInfoDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNumberDistrictInfoDownloadUrlResponse createNumberDistrictInfoDownloadUrl(shared_ptr<CreateNumberDistrictInfoDownloadUrlRequest> request);
  CreateNumberDistrictInfoParsingTaskResponse createNumberDistrictInfoParsingTaskWithOptions(shared_ptr<CreateNumberDistrictInfoParsingTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNumberDistrictInfoParsingTaskResponse createNumberDistrictInfoParsingTask(shared_ptr<CreateNumberDistrictInfoParsingTaskRequest> request);
  CreateOutboundCallNumberResponse createOutboundCallNumberWithOptions(shared_ptr<CreateOutboundCallNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOutboundCallNumberResponse createOutboundCallNumber(shared_ptr<CreateOutboundCallNumberRequest> request);
  CreateScriptResponse createScriptWithOptions(shared_ptr<CreateScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScriptResponse createScript(shared_ptr<CreateScriptRequest> request);
  CreateScriptWaveformResponse createScriptWaveformWithOptions(shared_ptr<CreateScriptWaveformRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScriptWaveformResponse createScriptWaveform(shared_ptr<CreateScriptWaveformRequest> request);
  CreateTagResponse createTagWithOptions(shared_ptr<CreateTagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTagResponse createTag(shared_ptr<CreateTagRequest> request);
  CreateTaskExportTaskResponse createTaskExportTaskWithOptions(shared_ptr<CreateTaskExportTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTaskExportTaskResponse createTaskExportTask(shared_ptr<CreateTaskExportTaskRequest> request);
  DeleteAgentProfilesResponse deleteAgentProfilesWithOptions(shared_ptr<DeleteAgentProfilesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAgentProfilesResponse deleteAgentProfiles(shared_ptr<DeleteAgentProfilesRequest> request);
  DeleteAllNumberDistrictInfoResponse deleteAllNumberDistrictInfoWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAllNumberDistrictInfoResponse deleteAllNumberDistrictInfo();
  DeleteBeebotIntentResponse deleteBeebotIntentWithOptions(shared_ptr<DeleteBeebotIntentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBeebotIntentResponse deleteBeebotIntent(shared_ptr<DeleteBeebotIntentRequest> request);
  DeleteBeebotIntentLgfResponse deleteBeebotIntentLgfWithOptions(shared_ptr<DeleteBeebotIntentLgfRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBeebotIntentLgfResponse deleteBeebotIntentLgf(shared_ptr<DeleteBeebotIntentLgfRequest> request);
  DeleteBeebotIntentUserSayResponse deleteBeebotIntentUserSayWithOptions(shared_ptr<DeleteBeebotIntentUserSayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBeebotIntentUserSayResponse deleteBeebotIntentUserSay(shared_ptr<DeleteBeebotIntentUserSayRequest> request);
  DeleteContactBlockListResponse deleteContactBlockListWithOptions(shared_ptr<DeleteContactBlockListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteContactBlockListResponse deleteContactBlockList(shared_ptr<DeleteContactBlockListRequest> request);
  DeleteContactWhiteListResponse deleteContactWhiteListWithOptions(shared_ptr<DeleteContactWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteContactWhiteListResponse deleteContactWhiteList(shared_ptr<DeleteContactWhiteListRequest> request);
  DeleteDialogueFlowResponse deleteDialogueFlowWithOptions(shared_ptr<DeleteDialogueFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDialogueFlowResponse deleteDialogueFlow(shared_ptr<DeleteDialogueFlowRequest> request);
  DeleteGlobalQuestionResponse deleteGlobalQuestionWithOptions(shared_ptr<DeleteGlobalQuestionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGlobalQuestionResponse deleteGlobalQuestion(shared_ptr<DeleteGlobalQuestionRequest> request);
  DeleteInstanceResponse deleteInstanceWithOptions(shared_ptr<DeleteInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInstanceResponse deleteInstance(shared_ptr<DeleteInstanceRequest> request);
  DeleteIntentResponse deleteIntentWithOptions(shared_ptr<DeleteIntentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIntentResponse deleteIntent(shared_ptr<DeleteIntentRequest> request);
  DeleteJobGroupResponse deleteJobGroupWithOptions(shared_ptr<DeleteJobGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteJobGroupResponse deleteJobGroup(shared_ptr<DeleteJobGroupRequest> request);
  DeleteOutboundCallNumberResponse deleteOutboundCallNumberWithOptions(shared_ptr<DeleteOutboundCallNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOutboundCallNumberResponse deleteOutboundCallNumber(shared_ptr<DeleteOutboundCallNumberRequest> request);
  DeleteScriptResponse deleteScriptWithOptions(shared_ptr<DeleteScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteScriptResponse deleteScript(shared_ptr<DeleteScriptRequest> request);
  DeleteScriptRecordingResponse deleteScriptRecordingWithOptions(shared_ptr<DeleteScriptRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteScriptRecordingResponse deleteScriptRecording(shared_ptr<DeleteScriptRecordingRequest> request);
  DeleteScriptWaveformResponse deleteScriptWaveformWithOptions(shared_ptr<DeleteScriptWaveformRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteScriptWaveformResponse deleteScriptWaveform(shared_ptr<DeleteScriptWaveformRequest> request);
  DescribeBeebotIntentResponse describeBeebotIntentWithOptions(shared_ptr<DescribeBeebotIntentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBeebotIntentResponse describeBeebotIntent(shared_ptr<DescribeBeebotIntentRequest> request);
  DescribeDialogueNodeStatisticsResponse describeDialogueNodeStatisticsWithOptions(shared_ptr<DescribeDialogueNodeStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDialogueNodeStatisticsResponse describeDialogueNodeStatistics(shared_ptr<DescribeDialogueNodeStatisticsRequest> request);
  DescribeDsReportsResponse describeDsReportsWithOptions(shared_ptr<DescribeDsReportsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDsReportsResponse describeDsReports(shared_ptr<DescribeDsReportsRequest> request);
  DescribeGlobalQuestionResponse describeGlobalQuestionWithOptions(shared_ptr<DescribeGlobalQuestionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGlobalQuestionResponse describeGlobalQuestion(shared_ptr<DescribeGlobalQuestionRequest> request);
  DescribeGroupExecutingInfoResponse describeGroupExecutingInfoWithOptions(shared_ptr<DescribeGroupExecutingInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupExecutingInfoResponse describeGroupExecutingInfo(shared_ptr<DescribeGroupExecutingInfoRequest> request);
  DescribeInstanceResponse describeInstanceWithOptions(shared_ptr<DescribeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceResponse describeInstance(shared_ptr<DescribeInstanceRequest> request);
  DescribeIntentResponse describeIntentWithOptions(shared_ptr<DescribeIntentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIntentResponse describeIntent(shared_ptr<DescribeIntentRequest> request);
  DescribeIntentStatisticsResponse describeIntentStatisticsWithOptions(shared_ptr<DescribeIntentStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIntentStatisticsResponse describeIntentStatistics(shared_ptr<DescribeIntentStatisticsRequest> request);
  DescribeJobResponse describeJobWithOptions(shared_ptr<DescribeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeJobResponse describeJob(shared_ptr<DescribeJobRequest> request);
  DescribeJobDataParsingTaskProgressResponse describeJobDataParsingTaskProgressWithOptions(shared_ptr<DescribeJobDataParsingTaskProgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeJobDataParsingTaskProgressResponse describeJobDataParsingTaskProgress(shared_ptr<DescribeJobDataParsingTaskProgressRequest> request);
  DescribeJobGroupResponse describeJobGroupWithOptions(shared_ptr<DescribeJobGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeJobGroupResponse describeJobGroup(shared_ptr<DescribeJobGroupRequest> request);
  DescribeJobGroupExportTaskProgressResponse describeJobGroupExportTaskProgressWithOptions(shared_ptr<DescribeJobGroupExportTaskProgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeJobGroupExportTaskProgressResponse describeJobGroupExportTaskProgress(shared_ptr<DescribeJobGroupExportTaskProgressRequest> request);
  DescribeNumberDistrictInfoStatusResponse describeNumberDistrictInfoStatusWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNumberDistrictInfoStatusResponse describeNumberDistrictInfoStatus();
  DescribeScriptResponse describeScriptWithOptions(shared_ptr<DescribeScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScriptResponse describeScript(shared_ptr<DescribeScriptRequest> request);
  DescribeScriptVoiceConfigResponse describeScriptVoiceConfigWithOptions(shared_ptr<DescribeScriptVoiceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScriptVoiceConfigResponse describeScriptVoiceConfig(shared_ptr<DescribeScriptVoiceConfigRequest> request);
  DescribeTTSConfigResponse describeTTSConfigWithOptions(shared_ptr<DescribeTTSConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTTSConfigResponse describeTTSConfig(shared_ptr<DescribeTTSConfigRequest> request);
  DescribeTTSDemoResponse describeTTSDemoWithOptions(shared_ptr<DescribeTTSDemoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTTSDemoResponse describeTTSDemo(shared_ptr<DescribeTTSDemoRequest> request);
  DescribeTagHitsSummaryResponse describeTagHitsSummaryWithOptions(shared_ptr<DescribeTagHitsSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagHitsSummaryResponse describeTagHitsSummary(shared_ptr<DescribeTagHitsSummaryRequest> request);
  DescribeTenantBindNumberResponse describeTenantBindNumberWithOptions(shared_ptr<DescribeTenantBindNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTenantBindNumberResponse describeTenantBindNumber(shared_ptr<DescribeTenantBindNumberRequest> request);
  DialogueResponse dialogueWithOptions(shared_ptr<DialogueRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DialogueResponse dialogue(shared_ptr<DialogueRequest> request);
  DismissNumberDistrictInfoParsingResultResponse dismissNumberDistrictInfoParsingResultWithOptions(shared_ptr<DismissNumberDistrictInfoParsingResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DismissNumberDistrictInfoParsingResultResponse dismissNumberDistrictInfoParsingResult(shared_ptr<DismissNumberDistrictInfoParsingResultRequest> request);
  DownloadRecordingResponse downloadRecordingWithOptions(shared_ptr<DownloadRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadRecordingResponse downloadRecording(shared_ptr<DownloadRecordingRequest> request);
  DownloadScriptRecordingResponse downloadScriptRecordingWithOptions(shared_ptr<DownloadScriptRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadScriptRecordingResponse downloadScriptRecording(shared_ptr<DownloadScriptRecordingRequest> request);
  DuplicateScriptResponse duplicateScriptWithOptions(shared_ptr<DuplicateScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DuplicateScriptResponse duplicateScript(shared_ptr<DuplicateScriptRequest> request);
  ExportScriptResponse exportScriptWithOptions(shared_ptr<ExportScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportScriptResponse exportScript(shared_ptr<ExportScriptRequest> request);
  GenerateUploadUrlResponse generateUploadUrlWithOptions(shared_ptr<GenerateUploadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateUploadUrlResponse generateUploadUrl(shared_ptr<GenerateUploadUrlRequest> request);
  GetAfterAnswerDelayPlaybackResponse getAfterAnswerDelayPlaybackWithOptions(shared_ptr<GetAfterAnswerDelayPlaybackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAfterAnswerDelayPlaybackResponse getAfterAnswerDelayPlayback(shared_ptr<GetAfterAnswerDelayPlaybackRequest> request);
  GetAgentProfileResponse getAgentProfileWithOptions(shared_ptr<GetAgentProfileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAgentProfileResponse getAgentProfile(shared_ptr<GetAgentProfileRequest> request);
  GetAgentProfileTemplateResponse getAgentProfileTemplateWithOptions(shared_ptr<GetAgentProfileTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAgentProfileTemplateResponse getAgentProfileTemplate(shared_ptr<GetAgentProfileTemplateRequest> request);
  GetAnnotationMissionSummaryResponse getAnnotationMissionSummaryWithOptions(shared_ptr<GetAnnotationMissionSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAnnotationMissionSummaryResponse getAnnotationMissionSummary(shared_ptr<GetAnnotationMissionSummaryRequest> request);
  GetAnnotationMissionTagInfoListResponse getAnnotationMissionTagInfoListWithOptions(shared_ptr<GetAnnotationMissionTagInfoListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAnnotationMissionTagInfoListResponse getAnnotationMissionTagInfoList(shared_ptr<GetAnnotationMissionTagInfoListRequest> request);
  GetAsrServerInfoResponse getAsrServerInfoWithOptions(shared_ptr<GetAsrServerInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAsrServerInfoResponse getAsrServerInfo(shared_ptr<GetAsrServerInfoRequest> request);
  GetBaseStrategyPeriodResponse getBaseStrategyPeriodWithOptions(shared_ptr<GetBaseStrategyPeriodRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBaseStrategyPeriodResponse getBaseStrategyPeriod(shared_ptr<GetBaseStrategyPeriodRequest> request);
  GetConcurrentConversationQuotaResponse getConcurrentConversationQuotaWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConcurrentConversationQuotaResponse getConcurrentConversationQuota();
  GetContactBlockListResponse getContactBlockListWithOptions(shared_ptr<GetContactBlockListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetContactBlockListResponse getContactBlockList(shared_ptr<GetContactBlockListRequest> request);
  GetContactWhiteListResponse getContactWhiteListWithOptions(shared_ptr<GetContactWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetContactWhiteListResponse getContactWhiteList(shared_ptr<GetContactWhiteListRequest> request);
  GetCurrentConcurrencyResponse getCurrentConcurrencyWithOptions(shared_ptr<GetCurrentConcurrencyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCurrentConcurrencyResponse getCurrentConcurrency(shared_ptr<GetCurrentConcurrencyRequest> request);
  GetEffectiveDaysResponse getEffectiveDaysWithOptions(shared_ptr<GetEffectiveDaysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEffectiveDaysResponse getEffectiveDays(shared_ptr<GetEffectiveDaysRequest> request);
  GetEmptyNumberNoMoreCallsInfoResponse getEmptyNumberNoMoreCallsInfoWithOptions(shared_ptr<GetEmptyNumberNoMoreCallsInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEmptyNumberNoMoreCallsInfoResponse getEmptyNumberNoMoreCallsInfo(shared_ptr<GetEmptyNumberNoMoreCallsInfoRequest> request);
  GetJobDataUploadParamsResponse getJobDataUploadParamsWithOptions(shared_ptr<GetJobDataUploadParamsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetJobDataUploadParamsResponse getJobDataUploadParams(shared_ptr<GetJobDataUploadParamsRequest> request);
  GetMaxAttemptsPerDayResponse getMaxAttemptsPerDayWithOptions(shared_ptr<GetMaxAttemptsPerDayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMaxAttemptsPerDayResponse getMaxAttemptsPerDay(shared_ptr<GetMaxAttemptsPerDayRequest> request);
  GetNumberDistrictInfoTemplateDownloadUrlResponse getNumberDistrictInfoTemplateDownloadUrlWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNumberDistrictInfoTemplateDownloadUrlResponse getNumberDistrictInfoTemplateDownloadUrl();
  GetRealtimeConcurrencyReportResponse getRealtimeConcurrencyReportWithOptions(shared_ptr<GetRealtimeConcurrencyReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRealtimeConcurrencyReportResponse getRealtimeConcurrencyReport(shared_ptr<GetRealtimeConcurrencyReportRequest> request);
  GetSummaryInfoResponse getSummaryInfoWithOptions(shared_ptr<GetSummaryInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSummaryInfoResponse getSummaryInfo(shared_ptr<GetSummaryInfoRequest> request);
  GetTaskByUuidResponse getTaskByUuidWithOptions(shared_ptr<GetTaskByUuidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskByUuidResponse getTaskByUuid(shared_ptr<GetTaskByUuidRequest> request);
  GetVersionResponse getVersionWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVersionResponse getVersion();
  ImportScriptResponse importScriptWithOptions(shared_ptr<ImportScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportScriptResponse importScript(shared_ptr<ImportScriptRequest> request);
  InflightTaskTimeoutResponse inflightTaskTimeoutWithOptions(shared_ptr<InflightTaskTimeoutRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InflightTaskTimeoutResponse inflightTaskTimeout(shared_ptr<InflightTaskTimeoutRequest> request);
  ListAgentProfilesResponse listAgentProfilesWithOptions(shared_ptr<ListAgentProfilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAgentProfilesResponse listAgentProfiles(shared_ptr<ListAgentProfilesRequest> request);
  ListAllTenantBindNumberBindingResponse listAllTenantBindNumberBindingWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAllTenantBindNumberBindingResponse listAllTenantBindNumberBinding();
  ListAnnotationMissionResponse listAnnotationMissionWithOptions(shared_ptr<ListAnnotationMissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAnnotationMissionResponse listAnnotationMission(shared_ptr<ListAnnotationMissionRequest> request);
  ListAnnotationMissionSessionResponse listAnnotationMissionSessionWithOptions(shared_ptr<ListAnnotationMissionSessionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAnnotationMissionSessionResponse listAnnotationMissionSession(shared_ptr<ListAnnotationMissionSessionRequest> request);
  ListApiPluginsResponse listApiPluginsWithOptions(shared_ptr<ListApiPluginsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApiPluginsResponse listApiPlugins(shared_ptr<ListApiPluginsRequest> request);
  ListBeebotIntentResponse listBeebotIntentWithOptions(shared_ptr<ListBeebotIntentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBeebotIntentResponse listBeebotIntent(shared_ptr<ListBeebotIntentRequest> request);
  ListBeebotIntentLgfResponse listBeebotIntentLgfWithOptions(shared_ptr<ListBeebotIntentLgfRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBeebotIntentLgfResponse listBeebotIntentLgf(shared_ptr<ListBeebotIntentLgfRequest> request);
  ListBeebotIntentUserSayResponse listBeebotIntentUserSayWithOptions(shared_ptr<ListBeebotIntentUserSayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBeebotIntentUserSayResponse listBeebotIntentUserSay(shared_ptr<ListBeebotIntentUserSayRequest> request);
  ListChatbotInstancesResponse listChatbotInstancesWithOptions(shared_ptr<ListChatbotInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListChatbotInstancesResponse listChatbotInstances(shared_ptr<ListChatbotInstancesRequest> request);
  ListDialogueFlowsResponse listDialogueFlowsWithOptions(shared_ptr<ListDialogueFlowsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDialogueFlowsResponse listDialogueFlows(shared_ptr<ListDialogueFlowsRequest> request);
  ListDownloadTasksResponse listDownloadTasksWithOptions(shared_ptr<ListDownloadTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDownloadTasksResponse listDownloadTasks(shared_ptr<ListDownloadTasksRequest> request);
  ListFlashSmsTemplatesResponse listFlashSmsTemplatesWithOptions(shared_ptr<ListFlashSmsTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlashSmsTemplatesResponse listFlashSmsTemplates(shared_ptr<ListFlashSmsTemplatesRequest> request);
  ListGlobalQuestionsResponse listGlobalQuestionsWithOptions(shared_ptr<ListGlobalQuestionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGlobalQuestionsResponse listGlobalQuestions(shared_ptr<ListGlobalQuestionsRequest> request);
  ListInstancesResponse listInstancesWithOptions(shared_ptr<ListInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstancesResponse listInstances(shared_ptr<ListInstancesRequest> request);
  ListIntentionsResponse listIntentionsWithOptions(shared_ptr<ListIntentionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntentionsResponse listIntentions(shared_ptr<ListIntentionsRequest> request);
  ListIntentsResponse listIntentsWithOptions(shared_ptr<ListIntentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntentsResponse listIntents(shared_ptr<ListIntentsRequest> request);
  ListJobGroupsResponse listJobGroupsWithOptions(shared_ptr<ListJobGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJobGroupsResponse listJobGroups(shared_ptr<ListJobGroupsRequest> request);
  ListJobGroupsAsyncResponse listJobGroupsAsyncWithOptions(shared_ptr<ListJobGroupsAsyncRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJobGroupsAsyncResponse listJobGroupsAsync(shared_ptr<ListJobGroupsAsyncRequest> request);
  ListJobsResponse listJobsWithOptions(shared_ptr<ListJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJobsResponse listJobs(shared_ptr<ListJobsRequest> request);
  ListJobsByGroupResponse listJobsByGroupWithOptions(shared_ptr<ListJobsByGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJobsByGroupResponse listJobsByGroup(shared_ptr<ListJobsByGroupRequest> request);
  ListOutboundCallNumbersResponse listOutboundCallNumbersWithOptions(shared_ptr<ListOutboundCallNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOutboundCallNumbersResponse listOutboundCallNumbers(shared_ptr<ListOutboundCallNumbersRequest> request);
  ListResourceTagsResponse listResourceTagsWithOptions(shared_ptr<ListResourceTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourceTagsResponse listResourceTags(shared_ptr<ListResourceTagsRequest> request);
  ListSchedulerInstancesResponse listSchedulerInstancesWithOptions(shared_ptr<ListSchedulerInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSchedulerInstancesResponse listSchedulerInstances(shared_ptr<ListSchedulerInstancesRequest> request);
  ListScriptPublishHistoriesResponse listScriptPublishHistoriesWithOptions(shared_ptr<ListScriptPublishHistoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScriptPublishHistoriesResponse listScriptPublishHistories(shared_ptr<ListScriptPublishHistoriesRequest> request);
  ListScriptRecordingResponse listScriptRecordingWithOptions(shared_ptr<ListScriptRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScriptRecordingResponse listScriptRecording(shared_ptr<ListScriptRecordingRequest> request);
  ListScriptVoiceConfigsResponse listScriptVoiceConfigsWithOptions(shared_ptr<ListScriptVoiceConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScriptVoiceConfigsResponse listScriptVoiceConfigs(shared_ptr<ListScriptVoiceConfigsRequest> request);
  ListScriptsResponse listScriptsWithOptions(shared_ptr<ListScriptsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScriptsResponse listScripts(shared_ptr<ListScriptsRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListTagsResponse listTagsWithOptions(shared_ptr<ListTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagsResponse listTags(shared_ptr<ListTagsRequest> request);
  ModifyAgentProfileResponse modifyAgentProfileWithOptions(shared_ptr<ModifyAgentProfileRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAgentProfileResponse modifyAgentProfile(shared_ptr<ModifyAgentProfileRequest> request);
  ModifyAnnotationMissionResponse modifyAnnotationMissionWithOptions(shared_ptr<ModifyAnnotationMissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAnnotationMissionResponse modifyAnnotationMission(shared_ptr<ModifyAnnotationMissionRequest> request);
  ModifyBatchJobsResponse modifyBatchJobsWithOptions(shared_ptr<ModifyBatchJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBatchJobsResponse modifyBatchJobs(shared_ptr<ModifyBatchJobsRequest> request);
  ModifyBeebotIntentResponse modifyBeebotIntentWithOptions(shared_ptr<ModifyBeebotIntentRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBeebotIntentResponse modifyBeebotIntent(shared_ptr<ModifyBeebotIntentRequest> request);
  ModifyBeebotIntentLgfResponse modifyBeebotIntentLgfWithOptions(shared_ptr<ModifyBeebotIntentLgfRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBeebotIntentLgfResponse modifyBeebotIntentLgf(shared_ptr<ModifyBeebotIntentLgfRequest> request);
  ModifyBeebotIntentUserSayResponse modifyBeebotIntentUserSayWithOptions(shared_ptr<ModifyBeebotIntentUserSayRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBeebotIntentUserSayResponse modifyBeebotIntentUserSay(shared_ptr<ModifyBeebotIntentUserSayRequest> request);
  ModifyDialogueFlowResponse modifyDialogueFlowWithOptions(shared_ptr<ModifyDialogueFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDialogueFlowResponse modifyDialogueFlow(shared_ptr<ModifyDialogueFlowRequest> request);
  ModifyEmptyNumberNoMoreCallsInfoResponse modifyEmptyNumberNoMoreCallsInfoWithOptions(shared_ptr<ModifyEmptyNumberNoMoreCallsInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEmptyNumberNoMoreCallsInfoResponse modifyEmptyNumberNoMoreCallsInfo(shared_ptr<ModifyEmptyNumberNoMoreCallsInfoRequest> request);
  ModifyGlobalQuestionResponse modifyGlobalQuestionWithOptions(shared_ptr<ModifyGlobalQuestionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyGlobalQuestionResponse modifyGlobalQuestion(shared_ptr<ModifyGlobalQuestionRequest> request);
  ModifyInstanceResponse modifyInstanceWithOptions(shared_ptr<ModifyInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceResponse modifyInstance(shared_ptr<ModifyInstanceRequest> request);
  ModifyIntentResponse modifyIntentWithOptions(shared_ptr<ModifyIntentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIntentResponse modifyIntent(shared_ptr<ModifyIntentRequest> request);
  ModifyJobGroupResponse modifyJobGroupWithOptions(shared_ptr<ModifyJobGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyJobGroupResponse modifyJobGroup(shared_ptr<ModifyJobGroupRequest> request);
  ModifyOutboundCallNumberResponse modifyOutboundCallNumberWithOptions(shared_ptr<ModifyOutboundCallNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyOutboundCallNumberResponse modifyOutboundCallNumber(shared_ptr<ModifyOutboundCallNumberRequest> request);
  ModifyScriptResponse modifyScriptWithOptions(shared_ptr<ModifyScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyScriptResponse modifyScript(shared_ptr<ModifyScriptRequest> request);
  ModifyScriptVoiceConfigResponse modifyScriptVoiceConfigWithOptions(shared_ptr<ModifyScriptVoiceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyScriptVoiceConfigResponse modifyScriptVoiceConfig(shared_ptr<ModifyScriptVoiceConfigRequest> request);
  ModifyTTSConfigResponse modifyTTSConfigWithOptions(shared_ptr<ModifyTTSConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTTSConfigResponse modifyTTSConfig(shared_ptr<ModifyTTSConfigRequest> request);
  ModifyTagGroupsResponse modifyTagGroupsWithOptions(shared_ptr<ModifyTagGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTagGroupsResponse modifyTagGroups(shared_ptr<ModifyTagGroupsRequest> request);
  PublishScriptResponse publishScriptWithOptions(shared_ptr<PublishScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishScriptResponse publishScript(shared_ptr<PublishScriptRequest> request);
  PublishScriptForDebugResponse publishScriptForDebugWithOptions(shared_ptr<PublishScriptForDebugRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishScriptForDebugResponse publishScriptForDebug(shared_ptr<PublishScriptForDebugRequest> request);
  QueryJobsResponse queryJobsWithOptions(shared_ptr<QueryJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryJobsResponse queryJobs(shared_ptr<QueryJobsRequest> request);
  QueryJobsWithResultResponse queryJobsWithResultWithOptions(shared_ptr<QueryJobsWithResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryJobsWithResultResponse queryJobsWithResult(shared_ptr<QueryJobsWithResultRequest> request);
  QueryScriptWaveformsResponse queryScriptWaveformsWithOptions(shared_ptr<QueryScriptWaveformsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryScriptWaveformsResponse queryScriptWaveforms(shared_ptr<QueryScriptWaveformsRequest> request);
  QueryScriptsByStatusResponse queryScriptsByStatusWithOptions(shared_ptr<QueryScriptsByStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryScriptsByStatusResponse queryScriptsByStatus(shared_ptr<QueryScriptsByStatusRequest> request);
  RecordFailureResponse recordFailureWithOptions(shared_ptr<RecordFailureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecordFailureResponse recordFailure(shared_ptr<RecordFailureRequest> request);
  ResumeJobsResponse resumeJobsWithOptions(shared_ptr<ResumeJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeJobsResponse resumeJobs(shared_ptr<ResumeJobsRequest> request);
  RollbackScriptResponse rollbackScriptWithOptions(shared_ptr<RollbackScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackScriptResponse rollbackScript(shared_ptr<RollbackScriptRequest> request);
  SaveAfterAnswerDelayPlaybackResponse saveAfterAnswerDelayPlaybackWithOptions(shared_ptr<SaveAfterAnswerDelayPlaybackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveAfterAnswerDelayPlaybackResponse saveAfterAnswerDelayPlayback(shared_ptr<SaveAfterAnswerDelayPlaybackRequest> request);
  SaveAnnotationMissionSessionListResponse saveAnnotationMissionSessionListWithOptions(shared_ptr<SaveAnnotationMissionSessionListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveAnnotationMissionSessionListResponse saveAnnotationMissionSessionList(shared_ptr<SaveAnnotationMissionSessionListRequest> request);
  SaveAnnotationMissionTagInfoListResponse saveAnnotationMissionTagInfoListWithOptions(shared_ptr<SaveAnnotationMissionTagInfoListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveAnnotationMissionTagInfoListResponse saveAnnotationMissionTagInfoList(shared_ptr<SaveAnnotationMissionTagInfoListRequest> request);
  SaveBaseStrategyPeriodResponse saveBaseStrategyPeriodWithOptions(shared_ptr<SaveBaseStrategyPeriodRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveBaseStrategyPeriodResponse saveBaseStrategyPeriod(shared_ptr<SaveBaseStrategyPeriodRequest> request);
  SaveContactBlockListResponse saveContactBlockListWithOptions(shared_ptr<SaveContactBlockListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveContactBlockListResponse saveContactBlockList(shared_ptr<SaveContactBlockListRequest> request);
  SaveContactWhiteListResponse saveContactWhiteListWithOptions(shared_ptr<SaveContactWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveContactWhiteListResponse saveContactWhiteList(shared_ptr<SaveContactWhiteListRequest> request);
  SaveEffectiveDaysResponse saveEffectiveDaysWithOptions(shared_ptr<SaveEffectiveDaysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveEffectiveDaysResponse saveEffectiveDays(shared_ptr<SaveEffectiveDaysRequest> request);
  SaveMaxAttemptsPerDayResponse saveMaxAttemptsPerDayWithOptions(shared_ptr<SaveMaxAttemptsPerDayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveMaxAttemptsPerDayResponse saveMaxAttemptsPerDay(shared_ptr<SaveMaxAttemptsPerDayRequest> request);
  SearchTaskResponse searchTaskWithOptions(shared_ptr<SearchTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchTaskResponse searchTask(shared_ptr<SearchTaskRequest> request);
  StartJobResponse startJobWithOptions(shared_ptr<StartJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartJobResponse startJob(shared_ptr<StartJobRequest> request);
  SubmitBatchJobsResponse submitBatchJobsWithOptions(shared_ptr<SubmitBatchJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitBatchJobsResponse submitBatchJobs(shared_ptr<SubmitBatchJobsRequest> request);
  SubmitRecordingResponse submitRecordingWithOptions(shared_ptr<SubmitRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitRecordingResponse submitRecording(shared_ptr<SubmitRecordingRequest> request);
  SubmitScriptReviewResponse submitScriptReviewWithOptions(shared_ptr<SubmitScriptReviewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitScriptReviewResponse submitScriptReview(shared_ptr<SubmitScriptReviewRequest> request);
  SuspendCallResponse suspendCallWithOptions(shared_ptr<SuspendCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendCallResponse suspendCall(shared_ptr<SuspendCallRequest> request);
  SuspendCallWithFileResponse suspendCallWithFileWithOptions(shared_ptr<SuspendCallWithFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendCallWithFileResponse suspendCallWithFile(shared_ptr<SuspendCallWithFileRequest> request);
  SuspendJobsResponse suspendJobsWithOptions(shared_ptr<SuspendJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendJobsResponse suspendJobs(shared_ptr<SuspendJobsRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  TaskPreparingResponse taskPreparingWithOptions(shared_ptr<TaskPreparingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TaskPreparingResponse taskPreparing(shared_ptr<TaskPreparingRequest> request);
  TerminateCallResponse terminateCallWithOptions(shared_ptr<TerminateCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TerminateCallResponse terminateCall(shared_ptr<TerminateCallRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UploadScriptRecordingResponse uploadScriptRecordingWithOptions(shared_ptr<UploadScriptRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadScriptRecordingResponse uploadScriptRecording(shared_ptr<UploadScriptRecordingRequest> request);
  WithdrawScriptReviewResponse withdrawScriptReviewWithOptions(shared_ptr<WithdrawScriptReviewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  WithdrawScriptReviewResponse withdrawScriptReview(shared_ptr<WithdrawScriptReviewRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_OutboundBot20191226

#endif
