// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_MTS20180528_H_
#define ALIBABACLOUD_MTS20180528_H_

#include <alibabacloud/open_api.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Mts20180528 {
class ActivateMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ActivateMediaWorkflowRequest() {}

  explicit ActivateMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ActivateMediaWorkflowRequest() = default;
};
class ActivateMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};

  ActivateMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit ActivateMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~ActivateMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class ActivateMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<ActivateMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};
  shared_ptr<string> requestId{};

  ActivateMediaWorkflowResponseBody() {}

  explicit ActivateMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        ActivateMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<ActivateMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ActivateMediaWorkflowResponseBody() = default;
};
class ActivateMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ActivateMediaWorkflowResponseBody> body{};

  ActivateMediaWorkflowResponse() {}

  explicit ActivateMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ActivateMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ActivateMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~ActivateMediaWorkflowResponse() = default;
};
class AddCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> cateName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> parentId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AddCategoryRequest() {}

  explicit AddCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AddCategoryRequest() = default;
};
class AddCategoryResponseBodyCategory : public Darabonba::Model {
public:
  shared_ptr<string> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> level{};
  shared_ptr<string> parentId{};

  AddCategoryResponseBodyCategory() {}

  explicit AddCategoryResponseBodyCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<string>(boost::any_cast<string>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
  }


  virtual ~AddCategoryResponseBodyCategory() = default;
};
class AddCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddCategoryResponseBodyCategory> category{};
  shared_ptr<string> requestId{};

  AddCategoryResponseBody() {}

  explicit AddCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = category ? boost::any(category->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(map<string, boost::any>) == m["Category"].type()) {
        AddCategoryResponseBodyCategory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Category"]));
        category = make_shared<AddCategoryResponseBodyCategory>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCategoryResponseBody() = default;
};
class AddCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCategoryResponseBody> body{};

  AddCategoryResponse() {}

  explicit AddCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~AddCategoryResponse() = default;
};
class AddMediaRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> fileURL{};
  shared_ptr<bool> inputUnbind{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowUserData{};
  shared_ptr<string> overrideParams{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};

  AddMediaRequest() {}

  explicit AddMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (inputUnbind) {
      res["InputUnbind"] = boost::any(*inputUnbind);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowUserData) {
      res["MediaWorkflowUserData"] = boost::any(*mediaWorkflowUserData);
    }
    if (overrideParams) {
      res["OverrideParams"] = boost::any(*overrideParams);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("InputUnbind") != m.end() && !m["InputUnbind"].empty()) {
      inputUnbind = make_shared<bool>(boost::any_cast<bool>(m["InputUnbind"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowUserData") != m.end() && !m["MediaWorkflowUserData"].empty()) {
      mediaWorkflowUserData = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowUserData"]));
    }
    if (m.find("OverrideParams") != m.end() && !m["OverrideParams"].empty()) {
      overrideParams = make_shared<string>(boost::any_cast<string>(m["OverrideParams"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~AddMediaRequest() = default;
};
class AddMediaResponseBodyMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  AddMediaResponseBodyMediaFile() {}

  explicit AddMediaResponseBodyMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~AddMediaResponseBodyMediaFile() = default;
};
class AddMediaResponseBodyMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  AddMediaResponseBodyMediaRunIdList() {}

  explicit AddMediaResponseBodyMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddMediaResponseBodyMediaRunIdList() = default;
};
class AddMediaResponseBodyMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  AddMediaResponseBodyMediaTags() {}

  explicit AddMediaResponseBodyMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddMediaResponseBodyMediaTags() = default;
};
class AddMediaResponseBodyMedia : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<long> cateId{};
  shared_ptr<string> censorState{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> duration{};
  shared_ptr<AddMediaResponseBodyMediaFile> file{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> publishState{};
  shared_ptr<AddMediaResponseBodyMediaRunIdList> runIdList{};
  shared_ptr<string> size{};
  shared_ptr<AddMediaResponseBodyMediaTags> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> width{};

  AddMediaResponseBodyMedia() {}

  explicit AddMediaResponseBodyMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (censorState) {
      res["CensorState"] = boost::any(*censorState);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CensorState") != m.end() && !m["CensorState"].empty()) {
      censorState = make_shared<string>(boost::any_cast<string>(m["CensorState"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        AddMediaResponseBodyMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<AddMediaResponseBodyMediaFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        AddMediaResponseBodyMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<AddMediaResponseBodyMediaRunIdList>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        AddMediaResponseBodyMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<AddMediaResponseBodyMediaTags>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~AddMediaResponseBodyMedia() = default;
};
class AddMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddMediaResponseBodyMedia> media{};
  shared_ptr<string> requestId{};

  AddMediaResponseBody() {}

  explicit AddMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = media ? boost::any(media->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(map<string, boost::any>) == m["Media"].type()) {
        AddMediaResponseBodyMedia model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Media"]));
        media = make_shared<AddMediaResponseBodyMedia>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddMediaResponseBody() = default;
};
class AddMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMediaResponseBody> body{};

  AddMediaResponse() {}

  explicit AddMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMediaResponseBody>(model1);
      }
    }
  }


  virtual ~AddMediaResponse() = default;
};
class AddMediaTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> tag{};

  AddMediaTagRequest() {}

  explicit AddMediaTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~AddMediaTagRequest() = default;
};
class AddMediaTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddMediaTagResponseBody() {}

  explicit AddMediaTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddMediaTagResponseBody() = default;
};
class AddMediaTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMediaTagResponseBody> body{};

  AddMediaTagResponse() {}

  explicit AddMediaTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMediaTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMediaTagResponseBody>(model1);
      }
    }
  }


  virtual ~AddMediaTagResponse() = default;
};
class AddMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> topology{};
  shared_ptr<string> triggerMode{};

  AddMediaWorkflowRequest() {}

  explicit AddMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~AddMediaWorkflowRequest() = default;
};
class AddMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};
  shared_ptr<string> triggerMode{};

  AddMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit AddMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~AddMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class AddMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};
  shared_ptr<string> requestId{};

  AddMediaWorkflowResponseBody() {}

  explicit AddMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        AddMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<AddMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddMediaWorkflowResponseBody() = default;
};
class AddMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMediaWorkflowResponseBody> body{};

  AddMediaWorkflowResponse() {}

  explicit AddMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~AddMediaWorkflowResponse() = default;
};
class AddPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> role{};
  shared_ptr<string> speed{};
  shared_ptr<long> speedLevel{};

  AddPipelineRequest() {}

  explicit AddPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (speedLevel) {
      res["SpeedLevel"] = boost::any(*speedLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("SpeedLevel") != m.end() && !m["SpeedLevel"].empty()) {
      speedLevel = make_shared<long>(boost::any_cast<long>(m["SpeedLevel"]));
    }
  }


  virtual ~AddPipelineRequest() = default;
};
class AddPipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> queueName{};
  shared_ptr<string> topic{};

  AddPipelineResponseBodyPipelineNotifyConfig() {}

  explicit AddPipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~AddPipelineResponseBodyPipelineNotifyConfig() = default;
};
class AddPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<AddPipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> role{};
  shared_ptr<string> speed{};
  shared_ptr<long> speedLevel{};
  shared_ptr<string> state{};

  AddPipelineResponseBodyPipeline() {}

  explicit AddPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (speedLevel) {
      res["SpeedLevel"] = boost::any(*speedLevel);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        AddPipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<AddPipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("SpeedLevel") != m.end() && !m["SpeedLevel"].empty()) {
      speedLevel = make_shared<long>(boost::any_cast<long>(m["SpeedLevel"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~AddPipelineResponseBodyPipeline() = default;
};
class AddPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddPipelineResponseBodyPipeline> pipeline{};
  shared_ptr<string> requestId{};

  AddPipelineResponseBody() {}

  explicit AddPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        AddPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<AddPipelineResponseBodyPipeline>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPipelineResponseBody() = default;
};
class AddPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPipelineResponseBody> body{};

  AddPipelineResponse() {}

  explicit AddPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~AddPipelineResponse() = default;
};
class AddTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> audio{};
  shared_ptr<string> container{};
  shared_ptr<string> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> transConfig{};
  shared_ptr<string> video{};

  AddTemplateRequest() {}

  explicit AddTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = boost::any(*audio);
    }
    if (container) {
      res["Container"] = boost::any(*container);
    }
    if (muxConfig) {
      res["MuxConfig"] = boost::any(*muxConfig);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (transConfig) {
      res["TransConfig"] = boost::any(*transConfig);
    }
    if (video) {
      res["Video"] = boost::any(*video);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      audio = make_shared<string>(boost::any_cast<string>(m["Audio"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      container = make_shared<string>(boost::any_cast<string>(m["Container"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      muxConfig = make_shared<string>(boost::any_cast<string>(m["MuxConfig"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      transConfig = make_shared<string>(boost::any_cast<string>(m["TransConfig"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      video = make_shared<string>(boost::any_cast<string>(m["Video"]));
    }
  }


  virtual ~AddTemplateRequest() = default;
};
class AddTemplateResponseBodyTemplateAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> method{};

  AddTemplateResponseBodyTemplateAudioVolume() {}

  explicit AddTemplateResponseBodyTemplateAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateAudioVolume() = default;
};
class AddTemplateResponseBodyTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<AddTemplateResponseBodyTemplateAudioVolume> volume{};

  AddTemplateResponseBodyTemplateAudio() {}

  explicit AddTemplateResponseBodyTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        AddTemplateResponseBodyTemplateAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<AddTemplateResponseBodyTemplateAudioVolume>(model1);
      }
    }
  }


  virtual ~AddTemplateResponseBodyTemplateAudio() = default;
};
class AddTemplateResponseBodyTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  AddTemplateResponseBodyTemplateContainer() {}

  explicit AddTemplateResponseBodyTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateContainer() = default;
};
class AddTemplateResponseBodyTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  AddTemplateResponseBodyTemplateMuxConfigGif() {}

  explicit AddTemplateResponseBodyTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateMuxConfigGif() = default;
};
class AddTemplateResponseBodyTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  AddTemplateResponseBodyTemplateMuxConfigSegment() {}

  explicit AddTemplateResponseBodyTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateMuxConfigSegment() = default;
};
class AddTemplateResponseBodyTemplateMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  AddTemplateResponseBodyTemplateMuxConfigWebp() {}

  explicit AddTemplateResponseBodyTemplateMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateMuxConfigWebp() = default;
};
class AddTemplateResponseBodyTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<AddTemplateResponseBodyTemplateMuxConfigGif> gif{};
  shared_ptr<AddTemplateResponseBodyTemplateMuxConfigSegment> segment{};
  shared_ptr<AddTemplateResponseBodyTemplateMuxConfigWebp> webp{};

  AddTemplateResponseBodyTemplateMuxConfig() {}

  explicit AddTemplateResponseBodyTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        AddTemplateResponseBodyTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<AddTemplateResponseBodyTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        AddTemplateResponseBodyTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<AddTemplateResponseBodyTemplateMuxConfigSegment>(model1);
      }
    }
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        AddTemplateResponseBodyTemplateMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<AddTemplateResponseBodyTemplateMuxConfigWebp>(model1);
      }
    }
  }


  virtual ~AddTemplateResponseBodyTemplateMuxConfig() = default;
};
class AddTemplateResponseBodyTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  AddTemplateResponseBodyTemplateTransConfig() {}

  explicit AddTemplateResponseBodyTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateTransConfig() = default;
};
class AddTemplateResponseBodyTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  AddTemplateResponseBodyTemplateVideoBitrateBnd() {}

  explicit AddTemplateResponseBodyTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateVideoBitrateBnd() = default;
};
class AddTemplateResponseBodyTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<AddTemplateResponseBodyTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> resoPriority{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  AddTemplateResponseBodyTemplateVideo() {}

  explicit AddTemplateResponseBodyTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        AddTemplateResponseBodyTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<AddTemplateResponseBodyTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplateVideo() = default;
};
class AddTemplateResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<AddTemplateResponseBodyTemplateAudio> audio{};
  shared_ptr<AddTemplateResponseBodyTemplateContainer> container{};
  shared_ptr<string> id{};
  shared_ptr<AddTemplateResponseBodyTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<AddTemplateResponseBodyTemplateTransConfig> transConfig{};
  shared_ptr<AddTemplateResponseBodyTemplateVideo> video{};

  AddTemplateResponseBodyTemplate() {}

  explicit AddTemplateResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        AddTemplateResponseBodyTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<AddTemplateResponseBodyTemplateAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        AddTemplateResponseBodyTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<AddTemplateResponseBodyTemplateContainer>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        AddTemplateResponseBodyTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<AddTemplateResponseBodyTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        AddTemplateResponseBodyTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<AddTemplateResponseBodyTemplateTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        AddTemplateResponseBodyTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<AddTemplateResponseBodyTemplateVideo>(model1);
      }
    }
  }


  virtual ~AddTemplateResponseBodyTemplate() = default;
};
class AddTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddTemplateResponseBodyTemplate> template_{};

  AddTemplateResponseBody() {}

  explicit AddTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(map<string, boost::any>) == m["Template"].type()) {
        AddTemplateResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Template"]));
        template_ = make_shared<AddTemplateResponseBodyTemplate>(model1);
      }
    }
  }


  virtual ~AddTemplateResponseBody() = default;
};
class AddTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTemplateResponseBody> body{};

  AddTemplateResponse() {}

  explicit AddTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~AddTemplateResponse() = default;
};
class AddWaterMarkTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  AddWaterMarkTemplateRequest() {}

  explicit AddWaterMarkTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AddWaterMarkTemplateRequest() = default;
};
class AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> width{};

  AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer() {}

  explicit AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer() = default;
};
class AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline() {}

  explicit AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline() = default;
};
class AddWaterMarkTemplateResponseBodyWaterMarkTemplate : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer> ratioRefer{};
  shared_ptr<string> referPos{};
  shared_ptr<string> state{};
  shared_ptr<AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline> timeline{};
  shared_ptr<string> type{};
  shared_ptr<string> width{};

  AddWaterMarkTemplateResponseBodyWaterMarkTemplate() {}

  explicit AddWaterMarkTemplateResponseBodyWaterMarkTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ratioRefer) {
      res["RatioRefer"] = ratioRefer ? boost::any(ratioRefer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RatioRefer") != m.end() && !m["RatioRefer"].empty()) {
      if (typeid(map<string, boost::any>) == m["RatioRefer"].type()) {
        AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RatioRefer"]));
        ratioRefer = make_shared<AddWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<AddWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~AddWaterMarkTemplateResponseBodyWaterMarkTemplate() = default;
};
class AddWaterMarkTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddWaterMarkTemplateResponseBodyWaterMarkTemplate> waterMarkTemplate{};

  AddWaterMarkTemplateResponseBody() {}

  explicit AddWaterMarkTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (waterMarkTemplate) {
      res["WaterMarkTemplate"] = waterMarkTemplate ? boost::any(waterMarkTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WaterMarkTemplate") != m.end() && !m["WaterMarkTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkTemplate"].type()) {
        AddWaterMarkTemplateResponseBodyWaterMarkTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkTemplate"]));
        waterMarkTemplate = make_shared<AddWaterMarkTemplateResponseBodyWaterMarkTemplate>(model1);
      }
    }
  }


  virtual ~AddWaterMarkTemplateResponseBody() = default;
};
class AddWaterMarkTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddWaterMarkTemplateResponseBody> body{};

  AddWaterMarkTemplateResponse() {}

  explicit AddWaterMarkTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddWaterMarkTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddWaterMarkTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~AddWaterMarkTemplateResponse() = default;
};
class BindInputBucketRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> roleArn{};

  BindInputBucketRequest() {}

  explicit BindInputBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~BindInputBucketRequest() = default;
};
class BindInputBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BindInputBucketResponseBody() {}

  explicit BindInputBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindInputBucketResponseBody() = default;
};
class BindInputBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindInputBucketResponseBody> body{};

  BindInputBucketResponse() {}

  explicit BindInputBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindInputBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindInputBucketResponseBody>(model1);
      }
    }
  }


  virtual ~BindInputBucketResponse() = default;
};
class BindOutputBucketRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> roleArn{};

  BindOutputBucketRequest() {}

  explicit BindOutputBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~BindOutputBucketRequest() = default;
};
class BindOutputBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BindOutputBucketResponseBody() {}

  explicit BindOutputBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindOutputBucketResponseBody() = default;
};
class BindOutputBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindOutputBucketResponseBody> body{};

  BindOutputBucketResponse() {}

  explicit BindOutputBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindOutputBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindOutputBucketResponseBody>(model1);
      }
    }
  }


  virtual ~BindOutputBucketResponse() = default;
};
class CancelJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CancelJobRequest() {}

  explicit CancelJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CancelJobRequest() = default;
};
class CancelJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  CancelJobResponseBody() {}

  explicit CancelJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelJobResponseBody() = default;
};
class CancelJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelJobResponseBody> body{};

  CancelJobResponse() {}

  explicit CancelJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelJobResponseBody>(model1);
      }
    }
  }


  virtual ~CancelJobResponse() = default;
};
class CategoryTreeRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CategoryTreeRequest() {}

  explicit CategoryTreeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CategoryTreeRequest() = default;
};
class CategoryTreeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> categoryTree{};
  shared_ptr<string> requestId{};

  CategoryTreeResponseBody() {}

  explicit CategoryTreeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryTree) {
      res["CategoryTree"] = boost::any(*categoryTree);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryTree") != m.end() && !m["CategoryTree"].empty()) {
      categoryTree = make_shared<string>(boost::any_cast<string>(m["CategoryTree"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CategoryTreeResponseBody() = default;
};
class CategoryTreeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CategoryTreeResponseBody> body{};

  CategoryTreeResponse() {}

  explicit CategoryTreeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CategoryTreeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CategoryTreeResponseBody>(model1);
      }
    }
  }


  virtual ~CategoryTreeResponse() = default;
};
class DeactivateMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeactivateMediaWorkflowRequest() {}

  explicit DeactivateMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeactivateMediaWorkflowRequest() = default;
};
class DeactivateMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};

  DeactivateMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit DeactivateMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~DeactivateMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class DeactivateMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeactivateMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};
  shared_ptr<string> requestId{};

  DeactivateMediaWorkflowResponseBody() {}

  explicit DeactivateMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        DeactivateMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<DeactivateMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeactivateMediaWorkflowResponseBody() = default;
};
class DeactivateMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeactivateMediaWorkflowResponseBody> body{};

  DeactivateMediaWorkflowResponse() {}

  explicit DeactivateMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeactivateMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeactivateMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~DeactivateMediaWorkflowResponse() = default;
};
class DeleteCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteCategoryRequest() {}

  explicit DeleteCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteCategoryRequest() = default;
};
class DeleteCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCategoryResponseBody() {}

  explicit DeleteCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCategoryResponseBody() = default;
};
class DeleteCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCategoryResponseBody> body{};

  DeleteCategoryResponse() {}

  explicit DeleteCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCategoryResponse() = default;
};
class DeleteMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteMediaRequest() {}

  explicit DeleteMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteMediaRequest() = default;
};
class DeleteMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMediaResponseBody() {}

  explicit DeleteMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMediaResponseBody() = default;
};
class DeleteMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaResponseBody> body{};

  DeleteMediaResponse() {}

  explicit DeleteMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaResponse() = default;
};
class DeleteMediaTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> tag{};

  DeleteMediaTagRequest() {}

  explicit DeleteMediaTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~DeleteMediaTagRequest() = default;
};
class DeleteMediaTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMediaTagResponseBody() {}

  explicit DeleteMediaTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMediaTagResponseBody() = default;
};
class DeleteMediaTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaTagResponseBody> body{};

  DeleteMediaTagResponse() {}

  explicit DeleteMediaTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaTagResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaTagResponse() = default;
};
class DeleteMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteMediaWorkflowRequest() {}

  explicit DeleteMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteMediaWorkflowRequest() = default;
};
class DeleteMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};

  DeleteMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit DeleteMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~DeleteMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class DeleteMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};
  shared_ptr<string> requestId{};

  DeleteMediaWorkflowResponseBody() {}

  explicit DeleteMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        DeleteMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<DeleteMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMediaWorkflowResponseBody() = default;
};
class DeleteMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaWorkflowResponseBody> body{};

  DeleteMediaWorkflowResponse() {}

  explicit DeleteMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaWorkflowResponse() = default;
};
class DeletePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeletePipelineRequest() {}

  explicit DeletePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeletePipelineRequest() = default;
};
class DeletePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<string> requestId{};

  DeletePipelineResponseBody() {}

  explicit DeletePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePipelineResponseBody() = default;
};
class DeletePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePipelineResponseBody> body{};

  DeletePipelineResponse() {}

  explicit DeletePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePipelineResponse() = default;
};
class DeleteTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateId{};

  DeleteTemplateRequest() {}

  explicit DeleteTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteTemplateRequest() = default;
};
class DeleteTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  DeleteTemplateResponseBody() {}

  explicit DeleteTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteTemplateResponseBody() = default;
};
class DeleteTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTemplateResponseBody> body{};

  DeleteTemplateResponse() {}

  explicit DeleteTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTemplateResponse() = default;
};
class DeleteWaterMarkTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> waterMarkTemplateId{};

  DeleteWaterMarkTemplateRequest() {}

  explicit DeleteWaterMarkTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
  }


  virtual ~DeleteWaterMarkTemplateRequest() = default;
};
class DeleteWaterMarkTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> waterMarkTemplateId{};

  DeleteWaterMarkTemplateResponseBody() {}

  explicit DeleteWaterMarkTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
  }


  virtual ~DeleteWaterMarkTemplateResponseBody() = default;
};
class DeleteWaterMarkTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWaterMarkTemplateResponseBody> body{};

  DeleteWaterMarkTemplateResponse() {}

  explicit DeleteWaterMarkTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWaterMarkTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWaterMarkTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWaterMarkTemplateResponse() = default;
};
class DescribeMtsUserResourcePackageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeMtsUserResourcePackageRequest() {}

  explicit DescribeMtsUserResourcePackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeMtsUserResourcePackageRequest() = default;
};
class DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> currCapacity{};
  shared_ptr<string> displayName{};
  shared_ptr<string> initCapacity{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> status{};

  DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo() {}

  explicit DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (currCapacity) {
      res["CurrCapacity"] = boost::any(*currCapacity);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (initCapacity) {
      res["InitCapacity"] = boost::any(*initCapacity);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CurrCapacity") != m.end() && !m["CurrCapacity"].empty()) {
      currCapacity = make_shared<string>(boost::any_cast<string>(m["CurrCapacity"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InitCapacity") != m.end() && !m["InitCapacity"].empty()) {
      initCapacity = make_shared<string>(boost::any_cast<string>(m["InitCapacity"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo() = default;
};
class DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo>> resourcePackageInfo{};

  DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos() {}

  explicit DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourcePackageInfo) {
      vector<boost::any> temp1;
      for(auto item1:*resourcePackageInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcePackageInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourcePackageInfo") != m.end() && !m["ResourcePackageInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcePackageInfo"].type()) {
        vector<DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcePackageInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcePackageInfo = make_shared<vector<DescribeMtsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos() = default;
};
class DescribeMtsUserResourcePackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos> resourcePackageInfos{};

  DescribeMtsUserResourcePackageResponseBody() {}

  explicit DescribeMtsUserResourcePackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourcePackageInfos) {
      res["ResourcePackageInfos"] = resourcePackageInfos ? boost::any(resourcePackageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourcePackageInfos") != m.end() && !m["ResourcePackageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourcePackageInfos"].type()) {
        DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourcePackageInfos"]));
        resourcePackageInfos = make_shared<DescribeMtsUserResourcePackageResponseBodyResourcePackageInfos>(model1);
      }
    }
  }


  virtual ~DescribeMtsUserResourcePackageResponseBody() = default;
};
class DescribeMtsUserResourcePackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMtsUserResourcePackageResponseBody> body{};

  DescribeMtsUserResourcePackageResponse() {}

  explicit DescribeMtsUserResourcePackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMtsUserResourcePackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMtsUserResourcePackageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMtsUserResourcePackageResponse() = default;
};
class ListAllCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListAllCategoryRequest() {}

  explicit ListAllCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListAllCategoryRequest() = default;
};
class ListAllCategoryResponseBodyCategoryListCategory : public Darabonba::Model {
public:
  shared_ptr<string> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> level{};
  shared_ptr<string> parentId{};

  ListAllCategoryResponseBodyCategoryListCategory() {}

  explicit ListAllCategoryResponseBodyCategoryListCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<string>(boost::any_cast<string>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
  }


  virtual ~ListAllCategoryResponseBodyCategoryListCategory() = default;
};
class ListAllCategoryResponseBodyCategoryList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAllCategoryResponseBodyCategoryListCategory>> category{};

  ListAllCategoryResponseBodyCategoryList() {}

  explicit ListAllCategoryResponseBodyCategoryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      vector<boost::any> temp1;
      for(auto item1:*category){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Category"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(vector<boost::any>) == m["Category"].type()) {
        vector<ListAllCategoryResponseBodyCategoryListCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Category"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllCategoryResponseBodyCategoryListCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        category = make_shared<vector<ListAllCategoryResponseBodyCategoryListCategory>>(expect1);
      }
    }
  }


  virtual ~ListAllCategoryResponseBodyCategoryList() = default;
};
class ListAllCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAllCategoryResponseBodyCategoryList> categoryList{};
  shared_ptr<string> requestId{};

  ListAllCategoryResponseBody() {}

  explicit ListAllCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryList) {
      res["CategoryList"] = categoryList ? boost::any(categoryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryList") != m.end() && !m["CategoryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CategoryList"].type()) {
        ListAllCategoryResponseBodyCategoryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CategoryList"]));
        categoryList = make_shared<ListAllCategoryResponseBodyCategoryList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAllCategoryResponseBody() = default;
};
class ListAllCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAllCategoryResponseBody> body{};

  ListAllCategoryResponse() {}

  explicit ListAllCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAllCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAllCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~ListAllCategoryResponse() = default;
};
class ListAllMediaBucketRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListAllMediaBucketRequest() {}

  explicit ListAllMediaBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListAllMediaBucketRequest() = default;
};
class ListAllMediaBucketResponseBodyMediaBucketListMediaBucket : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> type{};

  ListAllMediaBucketResponseBodyMediaBucketListMediaBucket() {}

  explicit ListAllMediaBucketResponseBodyMediaBucketListMediaBucket(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAllMediaBucketResponseBodyMediaBucketListMediaBucket() = default;
};
class ListAllMediaBucketResponseBodyMediaBucketList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAllMediaBucketResponseBodyMediaBucketListMediaBucket>> mediaBucket{};

  ListAllMediaBucketResponseBodyMediaBucketList() {}

  explicit ListAllMediaBucketResponseBodyMediaBucketList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaBucket) {
      vector<boost::any> temp1;
      for(auto item1:*mediaBucket){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaBucket"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaBucket") != m.end() && !m["MediaBucket"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaBucket"].type()) {
        vector<ListAllMediaBucketResponseBodyMediaBucketListMediaBucket> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaBucket"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllMediaBucketResponseBodyMediaBucketListMediaBucket model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaBucket = make_shared<vector<ListAllMediaBucketResponseBodyMediaBucketListMediaBucket>>(expect1);
      }
    }
  }


  virtual ~ListAllMediaBucketResponseBodyMediaBucketList() = default;
};
class ListAllMediaBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAllMediaBucketResponseBodyMediaBucketList> mediaBucketList{};
  shared_ptr<string> requestId{};

  ListAllMediaBucketResponseBody() {}

  explicit ListAllMediaBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaBucketList) {
      res["MediaBucketList"] = mediaBucketList ? boost::any(mediaBucketList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaBucketList") != m.end() && !m["MediaBucketList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBucketList"].type()) {
        ListAllMediaBucketResponseBodyMediaBucketList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBucketList"]));
        mediaBucketList = make_shared<ListAllMediaBucketResponseBodyMediaBucketList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAllMediaBucketResponseBody() = default;
};
class ListAllMediaBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAllMediaBucketResponseBody> body{};

  ListAllMediaBucketResponse() {}

  explicit ListAllMediaBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAllMediaBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAllMediaBucketResponseBody>(model1);
      }
    }
  }


  virtual ~ListAllMediaBucketResponse() = default;
};
class ListJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfJobCreatedTimeRange{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> startOfJobCreatedTimeRange{};
  shared_ptr<string> state{};

  ListJobRequest() {}

  explicit ListJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfJobCreatedTimeRange) {
      res["EndOfJobCreatedTimeRange"] = boost::any(*endOfJobCreatedTimeRange);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (startOfJobCreatedTimeRange) {
      res["StartOfJobCreatedTimeRange"] = boost::any(*startOfJobCreatedTimeRange);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfJobCreatedTimeRange") != m.end() && !m["EndOfJobCreatedTimeRange"].empty()) {
      endOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["EndOfJobCreatedTimeRange"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StartOfJobCreatedTimeRange") != m.end() && !m["StartOfJobCreatedTimeRange"].empty()) {
      startOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["StartOfJobCreatedTimeRange"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListJobRequest() = default;
};
class ListJobResponseBodyJobListJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  ListJobResponseBodyJobListJobInput() {}

  explicit ListJobResponseBodyJobListJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobInput() = default;
};
class ListJobResponseBodyJobListJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  ListJobResponseBodyJobListJobMNSMessageResult() {}

  explicit ListJobResponseBodyJobListJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobMNSMessageResult() = default;
};
class ListJobResponseBodyJobListJobOutputAmixListAmix : public Darabonba::Model {
public:
  shared_ptr<string> amixURL{};
  shared_ptr<string> duration{};
  shared_ptr<string> map{};
  shared_ptr<string> mixDurMode{};
  shared_ptr<string> start{};

  ListJobResponseBodyJobListJobOutputAmixListAmix() {}

  explicit ListJobResponseBodyJobListJobOutputAmixListAmix(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amixURL) {
      res["AmixURL"] = boost::any(*amixURL);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (map) {
      res["Map"] = boost::any(*map);
    }
    if (mixDurMode) {
      res["MixDurMode"] = boost::any(*mixDurMode);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AmixURL") != m.end() && !m["AmixURL"].empty()) {
      amixURL = make_shared<string>(boost::any_cast<string>(m["AmixURL"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
    if (m.find("MixDurMode") != m.end() && !m["MixDurMode"].empty()) {
      mixDurMode = make_shared<string>(boost::any_cast<string>(m["MixDurMode"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputAmixListAmix() = default;
};
class ListJobResponseBodyJobListJobOutputAmixList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputAmixListAmix>> amix{};

  ListJobResponseBodyJobListJobOutputAmixList() {}

  explicit ListJobResponseBodyJobListJobOutputAmixList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amix) {
      vector<boost::any> temp1;
      for(auto item1:*amix){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Amix"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amix") != m.end() && !m["Amix"].empty()) {
      if (typeid(vector<boost::any>) == m["Amix"].type()) {
        vector<ListJobResponseBodyJobListJobOutputAmixListAmix> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Amix"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputAmixListAmix model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        amix = make_shared<vector<ListJobResponseBodyJobListJobOutputAmixListAmix>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputAmixList() = default;
};
class ListJobResponseBodyJobListJobOutputAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> method{};

  ListJobResponseBodyJobListJobOutputAudioVolume() {}

  explicit ListJobResponseBodyJobListJobOutputAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputAudioVolume() = default;
};
class ListJobResponseBodyJobListJobOutputAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> samplerate{};
  shared_ptr<ListJobResponseBodyJobListJobOutputAudioVolume> volume{};

  ListJobResponseBodyJobListJobOutputAudio() {}

  explicit ListJobResponseBodyJobListJobOutputAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        ListJobResponseBodyJobListJobOutputAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<ListJobResponseBodyJobListJobOutputAudioVolume>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputAudio() = default;
};
class ListJobResponseBodyJobListJobOutputClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> seek{};

  ListJobResponseBodyJobListJobOutputClipTimeSpan() {}

  explicit ListJobResponseBodyJobListJobOutputClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputClipTimeSpan() = default;
};
class ListJobResponseBodyJobListJobOutputClip : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputClipTimeSpan> timeSpan{};

  ListJobResponseBodyJobListJobOutputClip() {}

  explicit ListJobResponseBodyJobListJobOutputClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        ListJobResponseBodyJobListJobOutputClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<ListJobResponseBodyJobListJobOutputClipTimeSpan>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputClip() = default;
};
class ListJobResponseBodyJobListJobOutputContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  ListJobResponseBodyJobListJobOutputContainer() {}

  explicit ListJobResponseBodyJobListJobOutputContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputContainer() = default;
};
class ListJobResponseBodyJobListJobOutputEncryption : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};
  shared_ptr<string> type{};

  ListJobResponseBodyJobListJobOutputEncryption() {}

  explicit ListJobResponseBodyJobListJobOutputEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputEncryption() = default;
};
class ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> md5Support{};
  shared_ptr<bool> sizeSupport{};

  ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS() {}

  explicit ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS() = default;
};
class ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS> TS{};

  ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport() {}

  explicit ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<ListJobResponseBodyJobListJobOutputM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport() = default;
};
class ListJobResponseBodyJobListJobOutputMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> start{};

  ListJobResponseBodyJobListJobOutputMergeListMerge() {}

  explicit ListJobResponseBodyJobListJobOutputMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMergeListMerge() = default;
};
class ListJobResponseBodyJobListJobOutputMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputMergeListMerge>> merge{};

  ListJobResponseBodyJobListJobOutputMergeList() {}

  explicit ListJobResponseBodyJobListJobOutputMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<ListJobResponseBodyJobListJobOutputMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<ListJobResponseBodyJobListJobOutputMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMergeList() = default;
};
class ListJobResponseBodyJobListJobOutputMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  ListJobResponseBodyJobListJobOutputMuxConfigGif() {}

  explicit ListJobResponseBodyJobListJobOutputMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMuxConfigGif() = default;
};
class ListJobResponseBodyJobListJobOutputMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  ListJobResponseBodyJobListJobOutputMuxConfigSegment() {}

  explicit ListJobResponseBodyJobListJobOutputMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMuxConfigSegment() = default;
};
class ListJobResponseBodyJobListJobOutputMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  ListJobResponseBodyJobListJobOutputMuxConfigWebp() {}

  explicit ListJobResponseBodyJobListJobOutputMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMuxConfigWebp() = default;
};
class ListJobResponseBodyJobListJobOutputMuxConfig : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputMuxConfigGif> gif{};
  shared_ptr<ListJobResponseBodyJobListJobOutputMuxConfigSegment> segment{};
  shared_ptr<ListJobResponseBodyJobListJobOutputMuxConfigWebp> webp{};

  ListJobResponseBodyJobListJobOutputMuxConfig() {}

  explicit ListJobResponseBodyJobListJobOutputMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        ListJobResponseBodyJobListJobOutputMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<ListJobResponseBodyJobListJobOutputMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        ListJobResponseBodyJobListJobOutputMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<ListJobResponseBodyJobListJobOutputMuxConfigSegment>(model1);
      }
    }
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        ListJobResponseBodyJobListJobOutputMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<ListJobResponseBodyJobListJobOutputMuxConfigWebp>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputMuxConfig() = default;
};
class ListJobResponseBodyJobListJobOutputOpeningListOpening : public Darabonba::Model {
public:
  shared_ptr<string> height{};
  shared_ptr<string> start{};
  shared_ptr<string> width{};
  shared_ptr<string> openUrl{};

  ListJobResponseBodyJobListJobOutputOpeningListOpening() {}

  explicit ListJobResponseBodyJobListJobOutputOpeningListOpening(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (openUrl) {
      res["openUrl"] = boost::any(*openUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("openUrl") != m.end() && !m["openUrl"].empty()) {
      openUrl = make_shared<string>(boost::any_cast<string>(m["openUrl"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOpeningListOpening() = default;
};
class ListJobResponseBodyJobListJobOutputOpeningList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputOpeningListOpening>> opening{};

  ListJobResponseBodyJobListJobOutputOpeningList() {}

  explicit ListJobResponseBodyJobListJobOutputOpeningList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opening) {
      vector<boost::any> temp1;
      for(auto item1:*opening){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Opening"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Opening") != m.end() && !m["Opening"].empty()) {
      if (typeid(vector<boost::any>) == m["Opening"].type()) {
        vector<ListJobResponseBodyJobListJobOutputOpeningListOpening> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Opening"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputOpeningListOpening model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        opening = make_shared<vector<ListJobResponseBodyJobListJobOutputOpeningListOpening>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOpeningList() = default;
};
class ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() {}

  explicit ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() = default;
};
class ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};
  shared_ptr<string> message{};
  shared_ptr<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile> outSubtitleFile{};
  shared_ptr<bool> success{};

  ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle() {}

  explicit ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (outSubtitleFile) {
      res["OutSubtitleFile"] = outSubtitleFile ? boost::any(outSubtitleFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OutSubtitleFile") != m.end() && !m["OutSubtitleFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleFile"].type()) {
        ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleFile"]));
        outSubtitleFile = make_shared<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle() = default;
};
class ListJobResponseBodyJobListJobOutputOutSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle>> outSubtitle{};

  ListJobResponseBodyJobListJobOutputOutSubtitleList() {}

  explicit ListJobResponseBodyJobListJobOutputOutSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*outSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutSubtitle") != m.end() && !m["OutSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["OutSubtitle"].type()) {
        vector<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outSubtitle = make_shared<vector<ListJobResponseBodyJobListJobOutputOutSubtitleListOutSubtitle>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOutSubtitleList() = default;
};
class ListJobResponseBodyJobListJobOutputOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  ListJobResponseBodyJobListJobOutputOutputFile() {}

  explicit ListJobResponseBodyJobListJobOutputOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputOutputFile() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  ListJobResponseBodyJobListJobOutputPropertiesFormat() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesFormat() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList() = default;
};
class ListJobResponseBodyJobListJobOutputPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList> videoStreamList{};

  ListJobResponseBodyJobListJobOutputPropertiesStreams() {}

  explicit ListJobResponseBodyJobListJobOutputPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputPropertiesStreams() = default;
};
class ListJobResponseBodyJobListJobOutputProperties : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> fileSize{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesFormat> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<ListJobResponseBodyJobListJobOutputPropertiesStreams> streams{};
  shared_ptr<string> width{};

  ListJobResponseBodyJobListJobOutputProperties() {}

  explicit ListJobResponseBodyJobListJobOutputProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<ListJobResponseBodyJobListJobOutputPropertiesFormat>(model1);
      }
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        ListJobResponseBodyJobListJobOutputPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<ListJobResponseBodyJobListJobOutputPropertiesStreams>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputProperties() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle>> subtitle{};

  ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList() = default;
};
class ListJobResponseBodyJobListJobOutputSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList> subtitleList{};

  ListJobResponseBodyJobListJobOutputSubtitleConfig() {}

  explicit ListJobResponseBodyJobListJobOutputSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<ListJobResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<ListJobResponseBodyJobListJobOutputSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSubtitleConfig() = default;
};
class ListJobResponseBodyJobListJobOutputSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  ListJobResponseBodyJobListJobOutputSuperReso() {}

  explicit ListJobResponseBodyJobListJobOutputSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputSuperReso() = default;
};
class ListJobResponseBodyJobListJobOutputTailSlateListTailSlate : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<string> blendDuration{};
  shared_ptr<string> height{};
  shared_ptr<bool> isMergeAudio{};
  shared_ptr<string> start{};
  shared_ptr<string> tailUrl{};
  shared_ptr<string> width{};

  ListJobResponseBodyJobListJobOutputTailSlateListTailSlate() {}

  explicit ListJobResponseBodyJobListJobOutputTailSlateListTailSlate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (blendDuration) {
      res["BlendDuration"] = boost::any(*blendDuration);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (isMergeAudio) {
      res["IsMergeAudio"] = boost::any(*isMergeAudio);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (tailUrl) {
      res["TailUrl"] = boost::any(*tailUrl);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("BlendDuration") != m.end() && !m["BlendDuration"].empty()) {
      blendDuration = make_shared<string>(boost::any_cast<string>(m["BlendDuration"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("IsMergeAudio") != m.end() && !m["IsMergeAudio"].empty()) {
      isMergeAudio = make_shared<bool>(boost::any_cast<bool>(m["IsMergeAudio"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("TailUrl") != m.end() && !m["TailUrl"].empty()) {
      tailUrl = make_shared<string>(boost::any_cast<string>(m["TailUrl"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputTailSlateListTailSlate() = default;
};
class ListJobResponseBodyJobListJobOutputTailSlateList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputTailSlateListTailSlate>> tailSlate{};

  ListJobResponseBodyJobListJobOutputTailSlateList() {}

  explicit ListJobResponseBodyJobListJobOutputTailSlateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tailSlate) {
      vector<boost::any> temp1;
      for(auto item1:*tailSlate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TailSlate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TailSlate") != m.end() && !m["TailSlate"].empty()) {
      if (typeid(vector<boost::any>) == m["TailSlate"].type()) {
        vector<ListJobResponseBodyJobListJobOutputTailSlateListTailSlate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TailSlate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputTailSlateListTailSlate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tailSlate = make_shared<vector<ListJobResponseBodyJobListJobOutputTailSlateListTailSlate>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputTailSlateList() = default;
};
class ListJobResponseBodyJobListJobOutputTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  ListJobResponseBodyJobListJobOutputTransConfig() {}

  explicit ListJobResponseBodyJobListJobOutputTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputTransConfig() = default;
};
class ListJobResponseBodyJobListJobOutputVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  ListJobResponseBodyJobListJobOutputVideoBitrateBnd() {}

  explicit ListJobResponseBodyJobListJobOutputVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputVideoBitrateBnd() = default;
};
class ListJobResponseBodyJobListJobOutputVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<ListJobResponseBodyJobListJobOutputVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> resoPriority{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  ListJobResponseBodyJobListJobOutputVideo() {}

  explicit ListJobResponseBodyJobListJobOutputVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        ListJobResponseBodyJobListJobOutputVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<ListJobResponseBodyJobListJobOutputVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputVideo() = default;
};
class ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile() {}

  explicit ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile() = default;
};
class ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> referPos{};
  shared_ptr<string> type{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> width{};

  ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark() {}

  explicit ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark() = default;
};
class ListJobResponseBodyJobListJobOutputWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark>> waterMark{};

  ListJobResponseBodyJobListJobOutputWaterMarkList() {}

  explicit ListJobResponseBodyJobListJobOutputWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<ListJobResponseBodyJobListJobOutputWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutputWaterMarkList() = default;
};
class ListJobResponseBodyJobListJobOutput : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobListJobOutputAmixList> amixList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<ListJobResponseBodyJobListJobOutputClip> clip{};
  shared_ptr<ListJobResponseBodyJobListJobOutputContainer> container{};
  shared_ptr<string> deWatermark{};
  shared_ptr<ListJobResponseBodyJobListJobOutputEncryption> encryption{};
  shared_ptr<ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<ListJobResponseBodyJobListJobOutputMergeList> mergeList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputMuxConfig> muxConfig{};
  shared_ptr<ListJobResponseBodyJobListJobOutputOpeningList> openingList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputOutSubtitleList> outSubtitleList{};
  shared_ptr<ListJobResponseBodyJobListJobOutputOutputFile> outputFile{};
  shared_ptr<string> priority{};
  shared_ptr<ListJobResponseBodyJobListJobOutputProperties> properties{};
  shared_ptr<string> rotate{};
  shared_ptr<ListJobResponseBodyJobListJobOutputSubtitleConfig> subtitleConfig{};
  shared_ptr<ListJobResponseBodyJobListJobOutputSuperReso> superReso{};
  shared_ptr<ListJobResponseBodyJobListJobOutputTailSlateList> tailSlateList{};
  shared_ptr<string> templateId{};
  shared_ptr<ListJobResponseBodyJobListJobOutputTransConfig> transConfig{};
  shared_ptr<string> userData{};
  shared_ptr<ListJobResponseBodyJobListJobOutputVideo> video{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<ListJobResponseBodyJobListJobOutputWaterMarkList> waterMarkList{};

  ListJobResponseBodyJobListJobOutput() {}

  explicit ListJobResponseBodyJobListJobOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amixList) {
      res["AmixList"] = amixList ? boost::any(amixList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (openingList) {
      res["OpeningList"] = openingList ? boost::any(openingList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outSubtitleList) {
      res["OutSubtitleList"] = outSubtitleList ? boost::any(outSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tailSlateList) {
      res["TailSlateList"] = tailSlateList ? boost::any(tailSlateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AmixList") != m.end() && !m["AmixList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AmixList"].type()) {
        ListJobResponseBodyJobListJobOutputAmixList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AmixList"]));
        amixList = make_shared<ListJobResponseBodyJobListJobOutputAmixList>(model1);
      }
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        ListJobResponseBodyJobListJobOutputAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<ListJobResponseBodyJobListJobOutputAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        ListJobResponseBodyJobListJobOutputClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<ListJobResponseBodyJobListJobOutputClip>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        ListJobResponseBodyJobListJobOutputContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<ListJobResponseBodyJobListJobOutputContainer>(model1);
      }
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        ListJobResponseBodyJobListJobOutputEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<ListJobResponseBodyJobListJobOutputEncryption>(model1);
      }
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<ListJobResponseBodyJobListJobOutputM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        ListJobResponseBodyJobListJobOutputMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<ListJobResponseBodyJobListJobOutputMergeList>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        ListJobResponseBodyJobListJobOutputMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<ListJobResponseBodyJobListJobOutputMuxConfig>(model1);
      }
    }
    if (m.find("OpeningList") != m.end() && !m["OpeningList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpeningList"].type()) {
        ListJobResponseBodyJobListJobOutputOpeningList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpeningList"]));
        openingList = make_shared<ListJobResponseBodyJobListJobOutputOpeningList>(model1);
      }
    }
    if (m.find("OutSubtitleList") != m.end() && !m["OutSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleList"].type()) {
        ListJobResponseBodyJobListJobOutputOutSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleList"]));
        outSubtitleList = make_shared<ListJobResponseBodyJobListJobOutputOutSubtitleList>(model1);
      }
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        ListJobResponseBodyJobListJobOutputOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<ListJobResponseBodyJobListJobOutputOutputFile>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        ListJobResponseBodyJobListJobOutputProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<ListJobResponseBodyJobListJobOutputProperties>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        ListJobResponseBodyJobListJobOutputSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<ListJobResponseBodyJobListJobOutputSubtitleConfig>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        ListJobResponseBodyJobListJobOutputSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<ListJobResponseBodyJobListJobOutputSuperReso>(model1);
      }
    }
    if (m.find("TailSlateList") != m.end() && !m["TailSlateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TailSlateList"].type()) {
        ListJobResponseBodyJobListJobOutputTailSlateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TailSlateList"]));
        tailSlateList = make_shared<ListJobResponseBodyJobListJobOutputTailSlateList>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        ListJobResponseBodyJobListJobOutputTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<ListJobResponseBodyJobListJobOutputTransConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        ListJobResponseBodyJobListJobOutputVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<ListJobResponseBodyJobListJobOutputVideo>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        ListJobResponseBodyJobListJobOutputWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<ListJobResponseBodyJobListJobOutputWaterMarkList>(model1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobListJobOutput() = default;
};
class ListJobResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<ListJobResponseBodyJobListJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<ListJobResponseBodyJobListJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<ListJobResponseBodyJobListJobOutput> output{};
  shared_ptr<long> percent{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> state{};

  ListJobResponseBodyJobListJob() {}

  explicit ListJobResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListJobResponseBodyJobListJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListJobResponseBodyJobListJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        ListJobResponseBodyJobListJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<ListJobResponseBodyJobListJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        ListJobResponseBodyJobListJobOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<ListJobResponseBodyJobListJobOutput>(model1);
      }
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListJobResponseBodyJobListJob() = default;
};
class ListJobResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobResponseBodyJobListJob>> job{};

  ListJobResponseBodyJobList() {}

  explicit ListJobResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<ListJobResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<ListJobResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~ListJobResponseBodyJobList() = default;
};
class ListJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListJobResponseBodyJobList> jobList{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListJobResponseBody() {}

  explicit ListJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        ListJobResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<ListJobResponseBodyJobList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListJobResponseBody() = default;
};
class ListJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListJobResponseBody> body{};

  ListJobResponse() {}

  explicit ListJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListJobResponse() = default;
};
class ListMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> to{};

  ListMediaRequest() {}

  explicit ListMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["To"]));
    }
  }


  virtual ~ListMediaRequest() = default;
};
class ListMediaResponseBodyMediaListMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  ListMediaResponseBodyMediaListMediaFile() {}

  explicit ListMediaResponseBodyMediaListMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~ListMediaResponseBodyMediaListMediaFile() = default;
};
class ListMediaResponseBodyMediaListMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  ListMediaResponseBodyMediaListMediaRunIdList() {}

  explicit ListMediaResponseBodyMediaListMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListMediaResponseBodyMediaListMediaRunIdList() = default;
};
class ListMediaResponseBodyMediaListMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  ListMediaResponseBodyMediaListMediaTags() {}

  explicit ListMediaResponseBodyMediaListMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListMediaResponseBodyMediaListMediaTags() = default;
};
class ListMediaResponseBodyMediaListMedia : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<long> cateId{};
  shared_ptr<string> censorState{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> duration{};
  shared_ptr<ListMediaResponseBodyMediaListMediaFile> file{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> publishState{};
  shared_ptr<ListMediaResponseBodyMediaListMediaRunIdList> runIdList{};
  shared_ptr<string> size{};
  shared_ptr<ListMediaResponseBodyMediaListMediaTags> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> width{};

  ListMediaResponseBodyMediaListMedia() {}

  explicit ListMediaResponseBodyMediaListMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (censorState) {
      res["CensorState"] = boost::any(*censorState);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CensorState") != m.end() && !m["CensorState"].empty()) {
      censorState = make_shared<string>(boost::any_cast<string>(m["CensorState"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        ListMediaResponseBodyMediaListMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<ListMediaResponseBodyMediaListMediaFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        ListMediaResponseBodyMediaListMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<ListMediaResponseBodyMediaListMediaRunIdList>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        ListMediaResponseBodyMediaListMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<ListMediaResponseBodyMediaListMediaTags>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListMediaResponseBodyMediaListMedia() = default;
};
class ListMediaResponseBodyMediaList : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaResponseBodyMediaListMedia>> media{};

  ListMediaResponseBodyMediaList() {}

  explicit ListMediaResponseBodyMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      vector<boost::any> temp1;
      for(auto item1:*media){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Media"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(vector<boost::any>) == m["Media"].type()) {
        vector<ListMediaResponseBodyMediaListMedia> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Media"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaResponseBodyMediaListMedia model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        media = make_shared<vector<ListMediaResponseBodyMediaListMedia>>(expect1);
      }
    }
  }


  virtual ~ListMediaResponseBodyMediaList() = default;
};
class ListMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMediaResponseBodyMediaList> mediaList{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListMediaResponseBody() {}

  explicit ListMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaList) {
      res["MediaList"] = mediaList ? boost::any(mediaList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaList") != m.end() && !m["MediaList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaList"].type()) {
        ListMediaResponseBodyMediaList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaList"]));
        mediaList = make_shared<ListMediaResponseBodyMediaList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMediaResponseBody() = default;
};
class ListMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMediaResponseBody> body{};

  ListMediaResponse() {}

  explicit ListMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaResponse() = default;
};
class ListMediaWorkflowExecutionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputFileURL{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListMediaWorkflowExecutionsRequest() {}

  explicit ListMediaWorkflowExecutionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFileURL) {
      res["InputFileURL"] = boost::any(*inputFileURL);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFileURL") != m.end() && !m["InputFileURL"].empty()) {
      inputFileURL = make_shared<string>(boost::any_cast<string>(m["InputFileURL"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsRequest() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> endTime{};
  shared_ptr<string> jobId{};
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> type{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity>> activity{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activity) {
      vector<boost::any> temp1;
      for(auto item1:*activity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Activity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Activity") != m.end() && !m["Activity"].empty()) {
      if (typeid(vector<boost::any>) == m["Activity"].type()) {
        vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Activity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activity = make_shared<vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity>>(expect1);
      }
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput : public Darabonba::Model {
public:
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile> inputFile{};
  shared_ptr<string> userData{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution : public Darabonba::Model {
public:
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList> activityList{};
  shared_ptr<string> creationTime{};
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput> input{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> runId{};
  shared_ptr<string> state{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityList) {
      res["ActivityList"] = activityList ? boost::any(activityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityList") != m.end() && !m["ActivityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActivityList"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActivityList"]));
        activityList = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      runId = make_shared<string>(boost::any_cast<string>(m["RunId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution() = default;
};
class ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution>> mediaWorkflowExecution{};

  ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList() {}

  explicit ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowExecution) {
      vector<boost::any> temp1;
      for(auto item1:*mediaWorkflowExecution){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaWorkflowExecution"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowExecution") != m.end() && !m["MediaWorkflowExecution"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaWorkflowExecution"].type()) {
        vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaWorkflowExecution"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaWorkflowExecution = make_shared<vector<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution>>(expect1);
      }
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList() = default;
};
class ListMediaWorkflowExecutionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList> mediaWorkflowExecutionList{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListMediaWorkflowExecutionsResponseBody() {}

  explicit ListMediaWorkflowExecutionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowExecutionList) {
      res["MediaWorkflowExecutionList"] = mediaWorkflowExecutionList ? boost::any(mediaWorkflowExecutionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowExecutionList") != m.end() && !m["MediaWorkflowExecutionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflowExecutionList"].type()) {
        ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflowExecutionList"]));
        mediaWorkflowExecutionList = make_shared<ListMediaWorkflowExecutionsResponseBodyMediaWorkflowExecutionList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponseBody() = default;
};
class ListMediaWorkflowExecutionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMediaWorkflowExecutionsResponseBody> body{};

  ListMediaWorkflowExecutionsResponse() {}

  explicit ListMediaWorkflowExecutionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaWorkflowExecutionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaWorkflowExecutionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaWorkflowExecutionsResponse() = default;
};
class QueryAnalysisJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> analysisJobIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryAnalysisJobListRequest() {}

  explicit QueryAnalysisJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisJobIds) {
      res["AnalysisJobIds"] = boost::any(*analysisJobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisJobIds") != m.end() && !m["AnalysisJobIds"].empty()) {
      analysisJobIds = make_shared<string>(boost::any_cast<string>(m["AnalysisJobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryAnalysisJobListRequest() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop : public Darabonba::Model {
public:
  shared_ptr<string> height{};
  shared_ptr<string> left{};
  shared_ptr<string> mode{};
  shared_ptr<string> top{};
  shared_ptr<string> width{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop> crop{};
  shared_ptr<string> deinterlace{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (crop) {
      res["Crop"] = crop ? boost::any(crop->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deinterlace) {
      res["Deinterlace"] = boost::any(*deinterlace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      if (typeid(map<string, boost::any>) == m["Crop"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Crop"]));
        crop = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControlCrop>(model1);
      }
    }
    if (m.find("Deinterlace") != m.end() && !m["Deinterlace"].empty()) {
      deinterlace = make_shared<string>(boost::any_cast<string>(m["Deinterlace"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl : public Darabonba::Model {
public:
  shared_ptr<string> methodStreaming{};
  shared_ptr<string> rateQuality{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methodStreaming) {
      res["MethodStreaming"] = boost::any(*methodStreaming);
    }
    if (rateQuality) {
      res["RateQuality"] = boost::any(*rateQuality);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MethodStreaming") != m.end() && !m["MethodStreaming"].empty()) {
      methodStreaming = make_shared<string>(boost::any_cast<string>(m["MethodStreaming"]));
    }
    if (m.find("RateQuality") != m.end() && !m["RateQuality"].empty()) {
      rateQuality = make_shared<string>(boost::any_cast<string>(m["RateQuality"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl> propertiesControl{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl> qualityControl{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertiesControl) {
      res["PropertiesControl"] = propertiesControl ? boost::any(propertiesControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (qualityControl) {
      res["QualityControl"] = qualityControl ? boost::any(qualityControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertiesControl") != m.end() && !m["PropertiesControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertiesControl"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertiesControl"]));
        propertiesControl = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigPropertiesControl>(model1);
      }
    }
    if (m.find("QualityControl") != m.end() && !m["QualityControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["QualityControl"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QualityControl"]));
        qualityControl = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfigQualityControl>(model1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> samplerate{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> loop{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif> gif{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment> segment{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> transMode{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio> audio{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer> container{};
  shared_ptr<string> id{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig> transConfig{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo> video{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateContainer>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplateVideo>(model1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate>> template_{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateListTemplate>>(expect1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig> analysisConfig{};
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> id{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile> inputFile{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<long> percent{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> priority{};
  shared_ptr<string> state{};
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList> templateList{};
  shared_ptr<string> userData{};

  QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisConfig) {
      res["AnalysisConfig"] = analysisConfig ? boost::any(analysisConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (templateList) {
      res["TemplateList"] = templateList ? boost::any(templateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisConfig") != m.end() && !m["AnalysisConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AnalysisConfig"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AnalysisConfig"]));
        analysisConfig = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobAnalysisConfig>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobInputFile>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateList"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateList"]));
        templateList = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJobTemplateList>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob() = default;
};
class QueryAnalysisJobListResponseBodyAnalysisJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob>> analysisJob{};

  QueryAnalysisJobListResponseBodyAnalysisJobList() {}

  explicit QueryAnalysisJobListResponseBodyAnalysisJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisJob) {
      vector<boost::any> temp1;
      for(auto item1:*analysisJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnalysisJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisJob") != m.end() && !m["AnalysisJob"].empty()) {
      if (typeid(vector<boost::any>) == m["AnalysisJob"].type()) {
        vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnalysisJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        analysisJob = make_shared<vector<QueryAnalysisJobListResponseBodyAnalysisJobListAnalysisJob>>(expect1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyAnalysisJobList() = default;
};
class QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds() {}

  explicit QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds() = default;
};
class QueryAnalysisJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryAnalysisJobListResponseBodyAnalysisJobList> analysisJobList{};
  shared_ptr<QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds> nonExistAnalysisJobIds{};
  shared_ptr<string> requestId{};

  QueryAnalysisJobListResponseBody() {}

  explicit QueryAnalysisJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisJobList) {
      res["AnalysisJobList"] = analysisJobList ? boost::any(analysisJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistAnalysisJobIds) {
      res["NonExistAnalysisJobIds"] = nonExistAnalysisJobIds ? boost::any(nonExistAnalysisJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisJobList") != m.end() && !m["AnalysisJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AnalysisJobList"].type()) {
        QueryAnalysisJobListResponseBodyAnalysisJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AnalysisJobList"]));
        analysisJobList = make_shared<QueryAnalysisJobListResponseBodyAnalysisJobList>(model1);
      }
    }
    if (m.find("NonExistAnalysisJobIds") != m.end() && !m["NonExistAnalysisJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistAnalysisJobIds"].type()) {
        QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistAnalysisJobIds"]));
        nonExistAnalysisJobIds = make_shared<QueryAnalysisJobListResponseBodyNonExistAnalysisJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryAnalysisJobListResponseBody() = default;
};
class QueryAnalysisJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAnalysisJobListResponseBody> body{};

  QueryAnalysisJobListResponse() {}

  explicit QueryAnalysisJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAnalysisJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAnalysisJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAnalysisJobListResponse() = default;
};
class QueryEditingJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryEditingJobListRequest() {}

  explicit QueryEditingJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryEditingJobListRequest() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> method{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> samplerate{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume> volume{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigAudio() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigAudioVolume>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigAudio() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> seek{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigClip : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan> timeSpan{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigClip() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigClipTimeSpan>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigClip() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigContainer() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigContainer() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> alpha{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile> inputFile{};
  shared_ptr<string> type{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alpha) {
      res["Alpha"] = boost::any(*alpha);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alpha") != m.end() && !m["Alpha"].empty()) {
      alpha = make_shared<string>(boost::any_cast<string>(m["Alpha"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMarkInputFile>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect : public Darabonba::Model {
public:
  shared_ptr<string> effect{};
  shared_ptr<string> effectConfig{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (effectConfig) {
      res["EffectConfig"] = boost::any(*effectConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("EffectConfig") != m.end() && !m["EffectConfig"].empty()) {
      effectConfig = make_shared<string>(boost::any_cast<string>(m["EffectConfig"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect>> effect{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      vector<boost::any> temp1;
      for(auto item1:*effect){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Effect"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      if (typeid(vector<boost::any>) == m["Effect"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Effect"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        effect = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffectsEffect>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects> effects{};
  shared_ptr<string> id{};
  shared_ptr<string> in{};
  shared_ptr<string> out{};
  shared_ptr<string> sourceID{};
  shared_ptr<string> sourceStrmMap{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effects) {
      res["Effects"] = effects ? boost::any(effects->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (sourceID) {
      res["SourceID"] = boost::any(*sourceID);
    }
    if (sourceStrmMap) {
      res["SourceStrmMap"] = boost::any(*sourceStrmMap);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effects") != m.end() && !m["Effects"].empty()) {
      if (typeid(map<string, boost::any>) == m["Effects"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Effects"]));
        effects = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClipEffects>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<string>(boost::any_cast<string>(m["In"]));
    }
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<string>(boost::any_cast<string>(m["Out"]));
    }
    if (m.find("SourceID") != m.end() && !m["SourceID"].empty()) {
      sourceID = make_shared<string>(boost::any_cast<string>(m["SourceID"]));
    }
    if (m.find("SourceStrmMap") != m.end() && !m["SourceStrmMap"].empty()) {
      sourceStrmMap = make_shared<string>(boost::any_cast<string>(m["SourceStrmMap"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip>> clip{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clip) {
      vector<boost::any> temp1;
      for(auto item1:*clip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(vector<boost::any>) == m["Clip"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clip = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipListClip>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio : public Darabonba::Model {
public:
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> samplerate{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> isGpuData{};
  shared_ptr<string> isOneTrackData{};
  shared_ptr<string> reclosePrec{};
  shared_ptr<string> renderRatio{};
  shared_ptr<string> width{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (isGpuData) {
      res["IsGpuData"] = boost::any(*isGpuData);
    }
    if (isOneTrackData) {
      res["IsOneTrackData"] = boost::any(*isOneTrackData);
    }
    if (reclosePrec) {
      res["ReclosePrec"] = boost::any(*reclosePrec);
    }
    if (renderRatio) {
      res["RenderRatio"] = boost::any(*renderRatio);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("IsGpuData") != m.end() && !m["IsGpuData"].empty()) {
      isGpuData = make_shared<string>(boost::any_cast<string>(m["IsGpuData"]));
    }
    if (m.find("IsOneTrackData") != m.end() && !m["IsOneTrackData"].empty()) {
      isOneTrackData = make_shared<string>(boost::any_cast<string>(m["IsOneTrackData"]));
    }
    if (m.find("ReclosePrec") != m.end() && !m["ReclosePrec"].empty()) {
      reclosePrec = make_shared<string>(boost::any_cast<string>(m["ReclosePrec"]));
    }
    if (m.find("RenderRatio") != m.end() && !m["RenderRatio"].empty()) {
      renderRatio = make_shared<string>(boost::any_cast<string>(m["RenderRatio"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio> timelineConfigAudio{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo> timelineConfigVideo{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timelineConfigAudio) {
      res["TimelineConfigAudio"] = timelineConfigAudio ? boost::any(timelineConfigAudio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timelineConfigVideo) {
      res["TimelineConfigVideo"] = timelineConfigVideo ? boost::any(timelineConfigVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimelineConfigAudio") != m.end() && !m["TimelineConfigAudio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfigAudio"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfigAudio"]));
        timelineConfigAudio = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio>(model1);
      }
    }
    if (m.find("TimelineConfigVideo") != m.end() && !m["TimelineConfigVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfigVideo"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfigVideo"]));
        timelineConfigVideo = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> l{};
  shared_ptr<string> t{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (l) {
      res["L"] = boost::any(*l);
    }
    if (t) {
      res["T"] = boost::any(*t);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("L") != m.end() && !m["L"].empty()) {
      l = make_shared<string>(boost::any_cast<string>(m["L"]));
    }
    if (m.find("T") != m.end() && !m["T"].empty()) {
      t = make_shared<string>(boost::any_cast<string>(m["T"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo> clipsConfigVideo{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsConfigVideo) {
      res["ClipsConfigVideo"] = clipsConfigVideo ? boost::any(clipsConfigVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsConfigVideo") != m.end() && !m["ClipsConfigVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipsConfigVideo"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipsConfigVideo"]));
        clipsConfigVideo = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig> clipsConfig{};
  shared_ptr<string> in{};
  shared_ptr<string> out{};
  shared_ptr<string> clipID{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsConfig) {
      res["ClipsConfig"] = clipsConfig ? boost::any(clipsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (clipID) {
      res["clipID"] = boost::any(*clipID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsConfig") != m.end() && !m["ClipsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipsConfig"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipsConfig"]));
        clipsConfig = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig>(model1);
      }
    }
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<string>(boost::any_cast<string>(m["In"]));
    }
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<string>(boost::any_cast<string>(m["Out"]));
    }
    if (m.find("clipID") != m.end() && !m["clipID"].empty()) {
      clipID = make_shared<string>(boost::any_cast<string>(m["clipID"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip>> clip{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clip) {
      vector<boost::any> temp1;
      for(auto item1:*clip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(vector<boost::any>) == m["Clip"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clip = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClipsClip>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips> clips{};
  shared_ptr<string> id{};
  shared_ptr<string> order{};
  shared_ptr<string> type{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clips) {
      res["Clips"] = clips ? boost::any(clips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clips") != m.end() && !m["Clips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clips"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clips"]));
        clips = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrackClips>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack>> track{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (track) {
      vector<boost::any> temp1;
      for(auto item1:*track){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Track"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Track") != m.end() && !m["Track"].empty()) {
      if (typeid(vector<boost::any>) == m["Track"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Track"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        track = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackListTrack>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig> timelineConfig{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList> trackList{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timelineConfig) {
      res["TimelineConfig"] = timelineConfig ? boost::any(timelineConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trackList) {
      res["TrackList"] = trackList ? boost::any(trackList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimelineConfig") != m.end() && !m["TimelineConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfig"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfig"]));
        timelineConfig = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTimelineConfig>(model1);
      }
    }
    if (m.find("TrackList") != m.end() && !m["TrackList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrackList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrackList"]));
        trackList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimelineTrackList>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEditing : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList> clipList{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline> timeline{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEditing() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEditing(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipList) {
      res["ClipList"] = clipList ? boost::any(clipList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipList") != m.end() && !m["ClipList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipList"]));
        clipList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingClipList>(model1);
      }
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditingTimeline>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEditing() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};
  shared_ptr<string> type{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> md5Support{};
  shared_ptr<bool> sizeSupport{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS> TS{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> start{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge>> merge{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif> gif{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment> segment{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList> videoStreamList{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigProperties : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> fileSize{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams> streams{};
  shared_ptr<string> width{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigProperties() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesFormat>(model1);
      }
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigPropertiesStreams>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigProperties() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle>> subtitle{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList> subtitleList{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> duration{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigVideo() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigVideo() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> referPos{};
  shared_ptr<string> type{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> width{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark>> waterMark{};

  QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingConfig : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigClip> clip{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigContainer> container{};
  shared_ptr<string> deWatermark{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark> digiWaterMark{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEditing> editing{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption> encryption{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList> mergeList{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig> muxConfig{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile> outputFile{};
  shared_ptr<string> priority{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigProperties> properties{};
  shared_ptr<string> rotate{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig> subtitleConfig{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso> superReso{};
  shared_ptr<string> templateId{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig> transConfig{};
  shared_ptr<string> userData{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigVideo> video{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList> waterMarkList{};

  QueryEditingJobListResponseBodyJobListJobEditingConfig() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (digiWaterMark) {
      res["DigiWaterMark"] = digiWaterMark ? boost::any(digiWaterMark->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (editing) {
      res["Editing"] = editing ? boost::any(editing->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigClip>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigContainer>(model1);
      }
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("DigiWaterMark") != m.end() && !m["DigiWaterMark"].empty()) {
      if (typeid(map<string, boost::any>) == m["DigiWaterMark"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DigiWaterMark"]));
        digiWaterMark = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigDigiWaterMark>(model1);
      }
    }
    if (m.find("Editing") != m.end() && !m["Editing"].empty()) {
      if (typeid(map<string, boost::any>) == m["Editing"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEditing model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Editing"]));
        editing = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEditing>(model1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigEncryption>(model1);
      }
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigMergeList>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigMuxConfig>(model1);
      }
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigOutputFile>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigProperties>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigSubtitleConfig>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigSuperReso>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigTransConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigVideo>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfigWaterMarkList>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingConfig() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig : public Darabonba::Model {
public:
  shared_ptr<string> deinterlaceMethod{};
  shared_ptr<string> isNormalSar{};

  QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deinterlaceMethod) {
      res["DeinterlaceMethod"] = boost::any(*deinterlaceMethod);
    }
    if (isNormalSar) {
      res["IsNormalSar"] = boost::any(*isNormalSar);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeinterlaceMethod") != m.end() && !m["DeinterlaceMethod"].empty()) {
      deinterlaceMethod = make_shared<string>(boost::any_cast<string>(m["DeinterlaceMethod"]));
    }
    if (m.find("IsNormalSar") != m.end() && !m["IsNormalSar"].empty()) {
      isNormalSar = make_shared<string>(boost::any_cast<string>(m["IsNormalSar"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig> inputConfig{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile> inputFile{};

  QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputConfig) {
      res["InputConfig"] = inputConfig ? boost::any(inputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputConfig"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputConfig"]));
        inputConfig = make_shared<QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputConfig>(model1);
      }
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInputInputFile>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput() = default;
};
class QueryEditingJobListResponseBodyJobListJobEditingInputs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput>> editingInput{};

  QueryEditingJobListResponseBodyJobListJobEditingInputs() {}

  explicit QueryEditingJobListResponseBodyJobListJobEditingInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingInput) {
      vector<boost::any> temp1;
      for(auto item1:*editingInput){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EditingInput"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingInput") != m.end() && !m["EditingInput"].empty()) {
      if (typeid(vector<boost::any>) == m["EditingInput"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EditingInput"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        editingInput = make_shared<vector<QueryEditingJobListResponseBodyJobListJobEditingInputsEditingInput>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobEditingInputs() = default;
};
class QueryEditingJobListResponseBodyJobListJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  QueryEditingJobListResponseBodyJobListJobMNSMessageResult() {}

  explicit QueryEditingJobListResponseBodyJobListJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJobMNSMessageResult() = default;
};
class QueryEditingJobListResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingConfig> editingConfig{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobEditingInputs> editingInputs{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> jobId{};
  shared_ptr<QueryEditingJobListResponseBodyJobListJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<long> percent{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> state{};

  QueryEditingJobListResponseBodyJobListJob() {}

  explicit QueryEditingJobListResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (editingConfig) {
      res["EditingConfig"] = editingConfig ? boost::any(editingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (editingInputs) {
      res["EditingInputs"] = editingInputs ? boost::any(editingInputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["EditingConfig"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EditingConfig"]));
        editingConfig = make_shared<QueryEditingJobListResponseBodyJobListJobEditingConfig>(model1);
      }
    }
    if (m.find("EditingInputs") != m.end() && !m["EditingInputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["EditingInputs"].type()) {
        QueryEditingJobListResponseBodyJobListJobEditingInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EditingInputs"]));
        editingInputs = make_shared<QueryEditingJobListResponseBodyJobListJobEditingInputs>(model1);
      }
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryEditingJobListResponseBodyJobListJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryEditingJobListResponseBodyJobListJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobListJob() = default;
};
class QueryEditingJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryEditingJobListResponseBodyJobListJob>> job{};

  QueryEditingJobListResponseBodyJobList() {}

  explicit QueryEditingJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryEditingJobListResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryEditingJobListResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryEditingJobListResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~QueryEditingJobListResponseBodyJobList() = default;
};
class QueryEditingJobListResponseBodyNonExistJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryEditingJobListResponseBodyNonExistJobIds() {}

  explicit QueryEditingJobListResponseBodyNonExistJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryEditingJobListResponseBodyNonExistJobIds() = default;
};
class QueryEditingJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryEditingJobListResponseBodyJobList> jobList{};
  shared_ptr<QueryEditingJobListResponseBodyNonExistJobIds> nonExistJobIds{};
  shared_ptr<string> requestId{};

  QueryEditingJobListResponseBody() {}

  explicit QueryEditingJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistJobIds) {
      res["NonExistJobIds"] = nonExistJobIds ? boost::any(nonExistJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        QueryEditingJobListResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<QueryEditingJobListResponseBodyJobList>(model1);
      }
    }
    if (m.find("NonExistJobIds") != m.end() && !m["NonExistJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistJobIds"].type()) {
        QueryEditingJobListResponseBodyNonExistJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistJobIds"]));
        nonExistJobIds = make_shared<QueryEditingJobListResponseBodyNonExistJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryEditingJobListResponseBody() = default;
};
class QueryEditingJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEditingJobListResponseBody> body{};

  QueryEditingJobListResponse() {}

  explicit QueryEditingJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEditingJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEditingJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEditingJobListResponse() = default;
};
class QueryJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryJobListRequest() {}

  explicit QueryJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryJobListRequest() = default;
};
class QueryJobListResponseBodyJobListJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryJobListResponseBodyJobListJobInput() {}

  explicit QueryJobListResponseBodyJobListJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobInput() = default;
};
class QueryJobListResponseBodyJobListJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  QueryJobListResponseBodyJobListJobMNSMessageResult() {}

  explicit QueryJobListResponseBodyJobListJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobMNSMessageResult() = default;
};
class QueryJobListResponseBodyJobListJobOutputAmixListAmix : public Darabonba::Model {
public:
  shared_ptr<string> amixURL{};
  shared_ptr<string> duration{};
  shared_ptr<string> map{};
  shared_ptr<string> mixDurMode{};
  shared_ptr<string> start{};

  QueryJobListResponseBodyJobListJobOutputAmixListAmix() {}

  explicit QueryJobListResponseBodyJobListJobOutputAmixListAmix(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amixURL) {
      res["AmixURL"] = boost::any(*amixURL);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (map) {
      res["Map"] = boost::any(*map);
    }
    if (mixDurMode) {
      res["MixDurMode"] = boost::any(*mixDurMode);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AmixURL") != m.end() && !m["AmixURL"].empty()) {
      amixURL = make_shared<string>(boost::any_cast<string>(m["AmixURL"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
    if (m.find("MixDurMode") != m.end() && !m["MixDurMode"].empty()) {
      mixDurMode = make_shared<string>(boost::any_cast<string>(m["MixDurMode"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputAmixListAmix() = default;
};
class QueryJobListResponseBodyJobListJobOutputAmixList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputAmixListAmix>> amix{};

  QueryJobListResponseBodyJobListJobOutputAmixList() {}

  explicit QueryJobListResponseBodyJobListJobOutputAmixList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amix) {
      vector<boost::any> temp1;
      for(auto item1:*amix){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Amix"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amix") != m.end() && !m["Amix"].empty()) {
      if (typeid(vector<boost::any>) == m["Amix"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputAmixListAmix> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Amix"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputAmixListAmix model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        amix = make_shared<vector<QueryJobListResponseBodyJobListJobOutputAmixListAmix>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputAmixList() = default;
};
class QueryJobListResponseBodyJobListJobOutputAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> method{};

  QueryJobListResponseBodyJobListJobOutputAudioVolume() {}

  explicit QueryJobListResponseBodyJobListJobOutputAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputAudioVolume() = default;
};
class QueryJobListResponseBodyJobListJobOutputAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> samplerate{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputAudioVolume> volume{};

  QueryJobListResponseBodyJobListJobOutputAudio() {}

  explicit QueryJobListResponseBodyJobListJobOutputAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        QueryJobListResponseBodyJobListJobOutputAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<QueryJobListResponseBodyJobListJobOutputAudioVolume>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputAudio() = default;
};
class QueryJobListResponseBodyJobListJobOutputClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> seek{};

  QueryJobListResponseBodyJobListJobOutputClipTimeSpan() {}

  explicit QueryJobListResponseBodyJobListJobOutputClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputClipTimeSpan() = default;
};
class QueryJobListResponseBodyJobListJobOutputClip : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputClipTimeSpan> timeSpan{};

  QueryJobListResponseBodyJobListJobOutputClip() {}

  explicit QueryJobListResponseBodyJobListJobOutputClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        QueryJobListResponseBodyJobListJobOutputClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<QueryJobListResponseBodyJobListJobOutputClipTimeSpan>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputClip() = default;
};
class QueryJobListResponseBodyJobListJobOutputContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  QueryJobListResponseBodyJobListJobOutputContainer() {}

  explicit QueryJobListResponseBodyJobListJobOutputContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputContainer() = default;
};
class QueryJobListResponseBodyJobListJobOutputEncryption : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};
  shared_ptr<string> type{};

  QueryJobListResponseBodyJobListJobOutputEncryption() {}

  explicit QueryJobListResponseBodyJobListJobOutputEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputEncryption() = default;
};
class QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> md5Support{};
  shared_ptr<bool> sizeSupport{};

  QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS() {}

  explicit QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS() = default;
};
class QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS> TS{};

  QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport() {}

  explicit QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport() = default;
};
class QueryJobListResponseBodyJobListJobOutputMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> start{};

  QueryJobListResponseBodyJobListJobOutputMergeListMerge() {}

  explicit QueryJobListResponseBodyJobListJobOutputMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMergeListMerge() = default;
};
class QueryJobListResponseBodyJobListJobOutputMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputMergeListMerge>> merge{};

  QueryJobListResponseBodyJobListJobOutputMergeList() {}

  explicit QueryJobListResponseBodyJobListJobOutputMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<QueryJobListResponseBodyJobListJobOutputMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMergeList() = default;
};
class QueryJobListResponseBodyJobListJobOutputMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  QueryJobListResponseBodyJobListJobOutputMuxConfigGif() {}

  explicit QueryJobListResponseBodyJobListJobOutputMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMuxConfigGif() = default;
};
class QueryJobListResponseBodyJobListJobOutputMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  QueryJobListResponseBodyJobListJobOutputMuxConfigSegment() {}

  explicit QueryJobListResponseBodyJobListJobOutputMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMuxConfigSegment() = default;
};
class QueryJobListResponseBodyJobListJobOutputMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  QueryJobListResponseBodyJobListJobOutputMuxConfigWebp() {}

  explicit QueryJobListResponseBodyJobListJobOutputMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMuxConfigWebp() = default;
};
class QueryJobListResponseBodyJobListJobOutputMuxConfig : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMuxConfigGif> gif{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMuxConfigSegment> segment{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMuxConfigWebp> webp{};

  QueryJobListResponseBodyJobListJobOutputMuxConfig() {}

  explicit QueryJobListResponseBodyJobListJobOutputMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        QueryJobListResponseBodyJobListJobOutputMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<QueryJobListResponseBodyJobListJobOutputMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        QueryJobListResponseBodyJobListJobOutputMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<QueryJobListResponseBodyJobListJobOutputMuxConfigSegment>(model1);
      }
    }
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        QueryJobListResponseBodyJobListJobOutputMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<QueryJobListResponseBodyJobListJobOutputMuxConfigWebp>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputMuxConfig() = default;
};
class QueryJobListResponseBodyJobListJobOutputOpeningListOpening : public Darabonba::Model {
public:
  shared_ptr<string> height{};
  shared_ptr<string> start{};
  shared_ptr<string> width{};
  shared_ptr<string> openUrl{};

  QueryJobListResponseBodyJobListJobOutputOpeningListOpening() {}

  explicit QueryJobListResponseBodyJobListJobOutputOpeningListOpening(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (openUrl) {
      res["openUrl"] = boost::any(*openUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("openUrl") != m.end() && !m["openUrl"].empty()) {
      openUrl = make_shared<string>(boost::any_cast<string>(m["openUrl"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOpeningListOpening() = default;
};
class QueryJobListResponseBodyJobListJobOutputOpeningList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputOpeningListOpening>> opening{};

  QueryJobListResponseBodyJobListJobOutputOpeningList() {}

  explicit QueryJobListResponseBodyJobListJobOutputOpeningList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opening) {
      vector<boost::any> temp1;
      for(auto item1:*opening){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Opening"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Opening") != m.end() && !m["Opening"].empty()) {
      if (typeid(vector<boost::any>) == m["Opening"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputOpeningListOpening> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Opening"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputOpeningListOpening model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        opening = make_shared<vector<QueryJobListResponseBodyJobListJobOutputOpeningListOpening>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOpeningList() = default;
};
class QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() {}

  explicit QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() = default;
};
class QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};
  shared_ptr<string> message{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile> outSubtitleFile{};
  shared_ptr<bool> success{};

  QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle() {}

  explicit QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (outSubtitleFile) {
      res["OutSubtitleFile"] = outSubtitleFile ? boost::any(outSubtitleFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OutSubtitleFile") != m.end() && !m["OutSubtitleFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleFile"].type()) {
        QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleFile"]));
        outSubtitleFile = make_shared<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitleOutSubtitleFile>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle() = default;
};
class QueryJobListResponseBodyJobListJobOutputOutSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle>> outSubtitle{};

  QueryJobListResponseBodyJobListJobOutputOutSubtitleList() {}

  explicit QueryJobListResponseBodyJobListJobOutputOutSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*outSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutSubtitle") != m.end() && !m["OutSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["OutSubtitle"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outSubtitle = make_shared<vector<QueryJobListResponseBodyJobListJobOutputOutSubtitleListOutSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOutSubtitleList() = default;
};
class QueryJobListResponseBodyJobListJobOutputOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  QueryJobListResponseBodyJobListJobOutputOutputFile() {}

  explicit QueryJobListResponseBodyJobListJobOutputOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputOutputFile() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  QueryJobListResponseBodyJobListJobOutputPropertiesFormat() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesFormat() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo : public Darabonba::Model {
public:
  shared_ptr<string> source{};

  QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo>> sourceLogo{};

  QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceLogo) {
      vector<boost::any> temp1;
      for(auto item1:*sourceLogo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceLogo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceLogo") != m.end() && !m["SourceLogo"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceLogo"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceLogo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceLogo = make_shared<vector<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogosSourceLogo>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList() = default;
};
class QueryJobListResponseBodyJobListJobOutputPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList> videoStreamList{};

  QueryJobListResponseBodyJobListJobOutputPropertiesStreams() {}

  explicit QueryJobListResponseBodyJobListJobOutputPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputPropertiesStreams() = default;
};
class QueryJobListResponseBodyJobListJobOutputProperties : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> fileSize{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesFormat> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos> sourceLogos{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputPropertiesStreams> streams{};
  shared_ptr<string> width{};

  QueryJobListResponseBodyJobListJobOutputProperties() {}

  explicit QueryJobListResponseBodyJobListJobOutputProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (sourceLogos) {
      res["SourceLogos"] = sourceLogos ? boost::any(sourceLogos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesFormat>(model1);
      }
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("SourceLogos") != m.end() && !m["SourceLogos"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceLogos"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceLogos"]));
        sourceLogos = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesSourceLogos>(model1);
      }
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryJobListResponseBodyJobListJobOutputPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryJobListResponseBodyJobListJobOutputPropertiesStreams>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputProperties() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle>> subtitle{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList() = default;
};
class QueryJobListResponseBodyJobListJobOutputSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList> subtitleList{};

  QueryJobListResponseBodyJobListJobOutputSubtitleConfig() {}

  explicit QueryJobListResponseBodyJobListJobOutputSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<QueryJobListResponseBodyJobListJobOutputSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<QueryJobListResponseBodyJobListJobOutputSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSubtitleConfig() = default;
};
class QueryJobListResponseBodyJobListJobOutputSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  QueryJobListResponseBodyJobListJobOutputSuperReso() {}

  explicit QueryJobListResponseBodyJobListJobOutputSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputSuperReso() = default;
};
class QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<string> blendDuration{};
  shared_ptr<string> height{};
  shared_ptr<bool> isMergeAudio{};
  shared_ptr<string> start{};
  shared_ptr<string> tailUrl{};
  shared_ptr<string> width{};

  QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate() {}

  explicit QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (blendDuration) {
      res["BlendDuration"] = boost::any(*blendDuration);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (isMergeAudio) {
      res["IsMergeAudio"] = boost::any(*isMergeAudio);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (tailUrl) {
      res["TailUrl"] = boost::any(*tailUrl);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("BlendDuration") != m.end() && !m["BlendDuration"].empty()) {
      blendDuration = make_shared<string>(boost::any_cast<string>(m["BlendDuration"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("IsMergeAudio") != m.end() && !m["IsMergeAudio"].empty()) {
      isMergeAudio = make_shared<bool>(boost::any_cast<bool>(m["IsMergeAudio"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("TailUrl") != m.end() && !m["TailUrl"].empty()) {
      tailUrl = make_shared<string>(boost::any_cast<string>(m["TailUrl"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate() = default;
};
class QueryJobListResponseBodyJobListJobOutputTailSlateList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate>> tailSlate{};

  QueryJobListResponseBodyJobListJobOutputTailSlateList() {}

  explicit QueryJobListResponseBodyJobListJobOutputTailSlateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tailSlate) {
      vector<boost::any> temp1;
      for(auto item1:*tailSlate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TailSlate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TailSlate") != m.end() && !m["TailSlate"].empty()) {
      if (typeid(vector<boost::any>) == m["TailSlate"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TailSlate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tailSlate = make_shared<vector<QueryJobListResponseBodyJobListJobOutputTailSlateListTailSlate>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputTailSlateList() = default;
};
class QueryJobListResponseBodyJobListJobOutputTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  QueryJobListResponseBodyJobListJobOutputTransConfig() {}

  explicit QueryJobListResponseBodyJobListJobOutputTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputTransConfig() = default;
};
class QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd() {}

  explicit QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd() = default;
};
class QueryJobListResponseBodyJobListJobOutputVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> resoPriority{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  QueryJobListResponseBodyJobListJobOutputVideo() {}

  explicit QueryJobListResponseBodyJobListJobOutputVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<QueryJobListResponseBodyJobListJobOutputVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputVideo() = default;
};
class QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile() {}

  explicit QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile() = default;
};
class QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> referPos{};
  shared_ptr<string> type{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> width{};

  QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark() {}

  explicit QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark() = default;
};
class QueryJobListResponseBodyJobListJobOutputWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark>> waterMark{};

  QueryJobListResponseBodyJobListJobOutputWaterMarkList() {}

  explicit QueryJobListResponseBodyJobListJobOutputWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<QueryJobListResponseBodyJobListJobOutputWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutputWaterMarkList() = default;
};
class QueryJobListResponseBodyJobListJobOutput : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobListJobOutputAmixList> amixList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputClip> clip{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputContainer> container{};
  shared_ptr<string> deWatermark{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputEncryption> encryption{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMergeList> mergeList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputMuxConfig> muxConfig{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputOpeningList> openingList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputOutSubtitleList> outSubtitleList{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputOutputFile> outputFile{};
  shared_ptr<string> priority{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputProperties> properties{};
  shared_ptr<string> rotate{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSubtitleConfig> subtitleConfig{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputSuperReso> superReso{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputTailSlateList> tailSlateList{};
  shared_ptr<string> templateId{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputTransConfig> transConfig{};
  shared_ptr<string> userData{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputVideo> video{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutputWaterMarkList> waterMarkList{};

  QueryJobListResponseBodyJobListJobOutput() {}

  explicit QueryJobListResponseBodyJobListJobOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amixList) {
      res["AmixList"] = amixList ? boost::any(amixList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (openingList) {
      res["OpeningList"] = openingList ? boost::any(openingList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outSubtitleList) {
      res["OutSubtitleList"] = outSubtitleList ? boost::any(outSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tailSlateList) {
      res["TailSlateList"] = tailSlateList ? boost::any(tailSlateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AmixList") != m.end() && !m["AmixList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AmixList"].type()) {
        QueryJobListResponseBodyJobListJobOutputAmixList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AmixList"]));
        amixList = make_shared<QueryJobListResponseBodyJobListJobOutputAmixList>(model1);
      }
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        QueryJobListResponseBodyJobListJobOutputAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<QueryJobListResponseBodyJobListJobOutputAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        QueryJobListResponseBodyJobListJobOutputClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<QueryJobListResponseBodyJobListJobOutputClip>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        QueryJobListResponseBodyJobListJobOutputContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<QueryJobListResponseBodyJobListJobOutputContainer>(model1);
      }
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        QueryJobListResponseBodyJobListJobOutputEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<QueryJobListResponseBodyJobListJobOutputEncryption>(model1);
      }
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<QueryJobListResponseBodyJobListJobOutputM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        QueryJobListResponseBodyJobListJobOutputMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<QueryJobListResponseBodyJobListJobOutputMergeList>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        QueryJobListResponseBodyJobListJobOutputMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<QueryJobListResponseBodyJobListJobOutputMuxConfig>(model1);
      }
    }
    if (m.find("OpeningList") != m.end() && !m["OpeningList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpeningList"].type()) {
        QueryJobListResponseBodyJobListJobOutputOpeningList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpeningList"]));
        openingList = make_shared<QueryJobListResponseBodyJobListJobOutputOpeningList>(model1);
      }
    }
    if (m.find("OutSubtitleList") != m.end() && !m["OutSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleList"].type()) {
        QueryJobListResponseBodyJobListJobOutputOutSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleList"]));
        outSubtitleList = make_shared<QueryJobListResponseBodyJobListJobOutputOutSubtitleList>(model1);
      }
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryJobListResponseBodyJobListJobOutputOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryJobListResponseBodyJobListJobOutputOutputFile>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        QueryJobListResponseBodyJobListJobOutputProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<QueryJobListResponseBodyJobListJobOutputProperties>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        QueryJobListResponseBodyJobListJobOutputSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<QueryJobListResponseBodyJobListJobOutputSubtitleConfig>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        QueryJobListResponseBodyJobListJobOutputSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<QueryJobListResponseBodyJobListJobOutputSuperReso>(model1);
      }
    }
    if (m.find("TailSlateList") != m.end() && !m["TailSlateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TailSlateList"].type()) {
        QueryJobListResponseBodyJobListJobOutputTailSlateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TailSlateList"]));
        tailSlateList = make_shared<QueryJobListResponseBodyJobListJobOutputTailSlateList>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        QueryJobListResponseBodyJobListJobOutputTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<QueryJobListResponseBodyJobListJobOutputTransConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        QueryJobListResponseBodyJobListJobOutputVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<QueryJobListResponseBodyJobListJobOutputVideo>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        QueryJobListResponseBodyJobListJobOutputWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<QueryJobListResponseBodyJobListJobOutputWaterMarkList>(model1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobListJobOutput() = default;
};
class QueryJobListResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<QueryJobListResponseBodyJobListJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<QueryJobListResponseBodyJobListJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<QueryJobListResponseBodyJobListJobOutput> output{};
  shared_ptr<long> percent{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> state{};

  QueryJobListResponseBodyJobListJob() {}

  explicit QueryJobListResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryJobListResponseBodyJobListJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryJobListResponseBodyJobListJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryJobListResponseBodyJobListJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryJobListResponseBodyJobListJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        QueryJobListResponseBodyJobListJobOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<QueryJobListResponseBodyJobListJobOutput>(model1);
      }
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~QueryJobListResponseBodyJobListJob() = default;
};
class QueryJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryJobListResponseBodyJobListJob>> job{};

  QueryJobListResponseBodyJobList() {}

  explicit QueryJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<QueryJobListResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryJobListResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<QueryJobListResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~QueryJobListResponseBodyJobList() = default;
};
class QueryJobListResponseBodyNonExistJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryJobListResponseBodyNonExistJobIds() {}

  explicit QueryJobListResponseBodyNonExistJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryJobListResponseBodyNonExistJobIds() = default;
};
class QueryJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryJobListResponseBodyJobList> jobList{};
  shared_ptr<QueryJobListResponseBodyNonExistJobIds> nonExistJobIds{};
  shared_ptr<string> requestId{};

  QueryJobListResponseBody() {}

  explicit QueryJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistJobIds) {
      res["NonExistJobIds"] = nonExistJobIds ? boost::any(nonExistJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        QueryJobListResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<QueryJobListResponseBodyJobList>(model1);
      }
    }
    if (m.find("NonExistJobIds") != m.end() && !m["NonExistJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistJobIds"].type()) {
        QueryJobListResponseBodyNonExistJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistJobIds"]));
        nonExistJobIds = make_shared<QueryJobListResponseBodyNonExistJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryJobListResponseBody() = default;
};
class QueryJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryJobListResponseBody> body{};

  QueryJobListResponse() {}

  explicit QueryJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryJobListResponse() = default;
};
class QueryMediaInfoJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaInfoJobIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMediaInfoJobListRequest() {}

  explicit QueryMediaInfoJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJobIds) {
      res["MediaInfoJobIds"] = boost::any(*mediaInfoJobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJobIds") != m.end() && !m["MediaInfoJobIds"].empty()) {
      mediaInfoJobIds = make_shared<string>(boost::any_cast<string>(m["MediaInfoJobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMediaInfoJobListRequest() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList> videoStreamList{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> fileSize{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams> streams{};
  shared_ptr<string> width{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesFormat>(model1);
      }
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobPropertiesStreams>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties> properties{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJobProperties>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob() = default;
};
class QueryMediaInfoJobListResponseBodyMediaInfoJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob>> mediaInfoJob{};

  QueryMediaInfoJobListResponseBodyMediaInfoJobList() {}

  explicit QueryMediaInfoJobListResponseBodyMediaInfoJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJob) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfoJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfoJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJob") != m.end() && !m["MediaInfoJob"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfoJob"].type()) {
        vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfoJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfoJob = make_shared<vector<QueryMediaInfoJobListResponseBodyMediaInfoJobListMediaInfoJob>>(expect1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyMediaInfoJobList() = default;
};
class QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds() {}

  explicit QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds() = default;
};
class QueryMediaInfoJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaInfoJobListResponseBodyMediaInfoJobList> mediaInfoJobList{};
  shared_ptr<QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds> nonExistMediaInfoJobIds{};
  shared_ptr<string> requestId{};

  QueryMediaInfoJobListResponseBody() {}

  explicit QueryMediaInfoJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJobList) {
      res["MediaInfoJobList"] = mediaInfoJobList ? boost::any(mediaInfoJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistMediaInfoJobIds) {
      res["NonExistMediaInfoJobIds"] = nonExistMediaInfoJobIds ? boost::any(nonExistMediaInfoJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJobList") != m.end() && !m["MediaInfoJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoJobList"].type()) {
        QueryMediaInfoJobListResponseBodyMediaInfoJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoJobList"]));
        mediaInfoJobList = make_shared<QueryMediaInfoJobListResponseBodyMediaInfoJobList>(model1);
      }
    }
    if (m.find("NonExistMediaInfoJobIds") != m.end() && !m["NonExistMediaInfoJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistMediaInfoJobIds"].type()) {
        QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistMediaInfoJobIds"]));
        nonExistMediaInfoJobIds = make_shared<QueryMediaInfoJobListResponseBodyNonExistMediaInfoJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaInfoJobListResponseBody() = default;
};
class QueryMediaInfoJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaInfoJobListResponseBody> body{};

  QueryMediaInfoJobListResponse() {}

  explicit QueryMediaInfoJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaInfoJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaInfoJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaInfoJobListResponse() = default;
};
class QueryMediaListRequest : public Darabonba::Model {
public:
  shared_ptr<bool> includeMediaInfo{};
  shared_ptr<bool> includePlayList{};
  shared_ptr<bool> includeSnapshotList{};
  shared_ptr<bool> includeSummaryList{};
  shared_ptr<string> mediaIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMediaListRequest() {}

  explicit QueryMediaListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (includeMediaInfo) {
      res["IncludeMediaInfo"] = boost::any(*includeMediaInfo);
    }
    if (includePlayList) {
      res["IncludePlayList"] = boost::any(*includePlayList);
    }
    if (includeSnapshotList) {
      res["IncludeSnapshotList"] = boost::any(*includeSnapshotList);
    }
    if (includeSummaryList) {
      res["IncludeSummaryList"] = boost::any(*includeSummaryList);
    }
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IncludeMediaInfo") != m.end() && !m["IncludeMediaInfo"].empty()) {
      includeMediaInfo = make_shared<bool>(boost::any_cast<bool>(m["IncludeMediaInfo"]));
    }
    if (m.find("IncludePlayList") != m.end() && !m["IncludePlayList"].empty()) {
      includePlayList = make_shared<bool>(boost::any_cast<bool>(m["IncludePlayList"]));
    }
    if (m.find("IncludeSnapshotList") != m.end() && !m["IncludeSnapshotList"].empty()) {
      includeSnapshotList = make_shared<bool>(boost::any_cast<bool>(m["IncludeSnapshotList"]));
    }
    if (m.find("IncludeSummaryList") != m.end() && !m["IncludeSummaryList"].empty()) {
      includeSummaryList = make_shared<bool>(boost::any_cast<bool>(m["IncludeSummaryList"]));
    }
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMediaListRequest() = default;
};
class QueryMediaListResponseBodyMediaListMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListResponseBodyMediaListMediaFile() {}

  explicit QueryMediaListResponseBodyMediaListMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaFile() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoFormat() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoFormat() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream>> audioStream{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream>> videoStream{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfoStreams : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList> videoStreamList{};

  QueryMediaListResponseBodyMediaListMediaMediaInfoStreams() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfoStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfoStreams() = default;
};
class QueryMediaListResponseBodyMediaListMediaMediaInfo : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoFormat> format{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfoStreams> streams{};

  QueryMediaListResponseBodyMediaListMediaMediaInfo() {}

  explicit QueryMediaListResponseBodyMediaListMediaMediaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoFormat>(model1);
      }
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfoStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfoStreams>(model1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaMediaInfo() = default;
};
class QueryMediaListResponseBodyMediaListMediaPlayListPlayFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListResponseBodyMediaListMediaPlayListPlayFile() {}

  explicit QueryMediaListResponseBodyMediaListMediaPlayListPlayFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaPlayListPlayFile() = default;
};
class QueryMediaListResponseBodyMediaListMediaPlayListPlay : public Darabonba::Model {
public:
  shared_ptr<string> activityName{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> encryption{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaPlayListPlayFile> file{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> size{};
  shared_ptr<string> width{};

  QueryMediaListResponseBodyMediaListMediaPlayListPlay() {}

  explicit QueryMediaListResponseBodyMediaListMediaPlayListPlay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (encryption) {
      res["Encryption"] = boost::any(*encryption);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      encryption = make_shared<string>(boost::any_cast<string>(m["Encryption"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListResponseBodyMediaListMediaPlayListPlayFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListResponseBodyMediaListMediaPlayListPlayFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaPlayListPlay() = default;
};
class QueryMediaListResponseBodyMediaListMediaPlayList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaPlayListPlay>> play{};

  QueryMediaListResponseBodyMediaListMediaPlayList() {}

  explicit QueryMediaListResponseBodyMediaListMediaPlayList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (play) {
      vector<boost::any> temp1;
      for(auto item1:*play){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Play"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Play") != m.end() && !m["Play"].empty()) {
      if (typeid(vector<boost::any>) == m["Play"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaPlayListPlay> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Play"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaPlayListPlay model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        play = make_shared<vector<QueryMediaListResponseBodyMediaListMediaPlayListPlay>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaPlayList() = default;
};
class QueryMediaListResponseBodyMediaListMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  QueryMediaListResponseBodyMediaListMediaRunIdList() {}

  explicit QueryMediaListResponseBodyMediaListMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaRunIdList() = default;
};
class QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile() {}

  explicit QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile() = default;
};
class QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot : public Darabonba::Model {
public:
  shared_ptr<string> activityName{};
  shared_ptr<string> count{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile> file{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> type{};

  QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot() {}

  explicit QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshotFile>(model1);
      }
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot() = default;
};
class QueryMediaListResponseBodyMediaListMediaSnapshotList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot>> snapshot{};

  QueryMediaListResponseBodyMediaListMediaSnapshotList() {}

  explicit QueryMediaListResponseBodyMediaListMediaSnapshotList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshot) {
      vector<boost::any> temp1;
      for(auto item1:*snapshot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Snapshot"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Snapshot") != m.end() && !m["Snapshot"].empty()) {
      if (typeid(vector<boost::any>) == m["Snapshot"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Snapshot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshot = make_shared<vector<QueryMediaListResponseBodyMediaListMediaSnapshotListSnapshot>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSnapshotList() = default;
};
class QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile() {}

  explicit QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile() = default;
};
class QueryMediaListResponseBodyMediaListMediaSummaryListSummary : public Darabonba::Model {
public:
  shared_ptr<string> activityName{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile> file{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> type{};

  QueryMediaListResponseBodyMediaListMediaSummaryListSummary() {}

  explicit QueryMediaListResponseBodyMediaListMediaSummaryListSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListResponseBodyMediaListMediaSummaryListSummaryFile>(model1);
      }
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSummaryListSummary() = default;
};
class QueryMediaListResponseBodyMediaListMediaSummaryList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMediaSummaryListSummary>> summary{};

  QueryMediaListResponseBodyMediaListMediaSummaryList() {}

  explicit QueryMediaListResponseBodyMediaListMediaSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<QueryMediaListResponseBodyMediaListMediaSummaryListSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMediaSummaryListSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<QueryMediaListResponseBodyMediaListMediaSummaryListSummary>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaSummaryList() = default;
};
class QueryMediaListResponseBodyMediaListMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  QueryMediaListResponseBodyMediaListMediaTags() {}

  explicit QueryMediaListResponseBodyMediaListMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMediaTags() = default;
};
class QueryMediaListResponseBodyMediaListMedia : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<long> cateId{};
  shared_ptr<string> censorState{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> duration{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaFile> file{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaMediaInfo> mediaInfo{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaPlayList> playList{};
  shared_ptr<string> publishState{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaRunIdList> runIdList{};
  shared_ptr<string> size{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaSnapshotList> snapshotList{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaSummaryList> summaryList{};
  shared_ptr<QueryMediaListResponseBodyMediaListMediaTags> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> width{};

  QueryMediaListResponseBodyMediaListMedia() {}

  explicit QueryMediaListResponseBodyMediaListMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (censorState) {
      res["CensorState"] = boost::any(*censorState);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaInfo) {
      res["MediaInfo"] = mediaInfo ? boost::any(mediaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (playList) {
      res["PlayList"] = playList ? boost::any(playList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotList) {
      res["SnapshotList"] = snapshotList ? boost::any(snapshotList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summaryList) {
      res["SummaryList"] = summaryList ? boost::any(summaryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CensorState") != m.end() && !m["CensorState"].empty()) {
      censorState = make_shared<string>(boost::any_cast<string>(m["CensorState"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListResponseBodyMediaListMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListResponseBodyMediaListMediaFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaInfo") != m.end() && !m["MediaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfo"].type()) {
        QueryMediaListResponseBodyMediaListMediaMediaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfo"]));
        mediaInfo = make_shared<QueryMediaListResponseBodyMediaListMediaMediaInfo>(model1);
      }
    }
    if (m.find("PlayList") != m.end() && !m["PlayList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PlayList"].type()) {
        QueryMediaListResponseBodyMediaListMediaPlayList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PlayList"]));
        playList = make_shared<QueryMediaListResponseBodyMediaListMediaPlayList>(model1);
      }
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        QueryMediaListResponseBodyMediaListMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<QueryMediaListResponseBodyMediaListMediaRunIdList>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("SnapshotList") != m.end() && !m["SnapshotList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotList"].type()) {
        QueryMediaListResponseBodyMediaListMediaSnapshotList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotList"]));
        snapshotList = make_shared<QueryMediaListResponseBodyMediaListMediaSnapshotList>(model1);
      }
    }
    if (m.find("SummaryList") != m.end() && !m["SummaryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SummaryList"].type()) {
        QueryMediaListResponseBodyMediaListMediaSummaryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SummaryList"]));
        summaryList = make_shared<QueryMediaListResponseBodyMediaListMediaSummaryList>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QueryMediaListResponseBodyMediaListMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QueryMediaListResponseBodyMediaListMediaTags>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaListResponseBodyMediaListMedia() = default;
};
class QueryMediaListResponseBodyMediaList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListResponseBodyMediaListMedia>> media{};

  QueryMediaListResponseBodyMediaList() {}

  explicit QueryMediaListResponseBodyMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      vector<boost::any> temp1;
      for(auto item1:*media){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Media"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(vector<boost::any>) == m["Media"].type()) {
        vector<QueryMediaListResponseBodyMediaListMedia> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Media"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListResponseBodyMediaListMedia model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        media = make_shared<vector<QueryMediaListResponseBodyMediaListMedia>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListResponseBodyMediaList() = default;
};
class QueryMediaListResponseBodyNonExistMediaIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> mediaId{};

  QueryMediaListResponseBodyNonExistMediaIds() {}

  explicit QueryMediaListResponseBodyNonExistMediaIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MediaId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MediaId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mediaId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListResponseBodyNonExistMediaIds() = default;
};
class QueryMediaListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListResponseBodyMediaList> mediaList{};
  shared_ptr<QueryMediaListResponseBodyNonExistMediaIds> nonExistMediaIds{};
  shared_ptr<string> requestId{};

  QueryMediaListResponseBody() {}

  explicit QueryMediaListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaList) {
      res["MediaList"] = mediaList ? boost::any(mediaList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistMediaIds) {
      res["NonExistMediaIds"] = nonExistMediaIds ? boost::any(nonExistMediaIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaList") != m.end() && !m["MediaList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaList"].type()) {
        QueryMediaListResponseBodyMediaList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaList"]));
        mediaList = make_shared<QueryMediaListResponseBodyMediaList>(model1);
      }
    }
    if (m.find("NonExistMediaIds") != m.end() && !m["NonExistMediaIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistMediaIds"].type()) {
        QueryMediaListResponseBodyNonExistMediaIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistMediaIds"]));
        nonExistMediaIds = make_shared<QueryMediaListResponseBodyNonExistMediaIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaListResponseBody() = default;
};
class QueryMediaListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaListResponseBody> body{};

  QueryMediaListResponse() {}

  explicit QueryMediaListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaListResponse() = default;
};
class QueryMediaListByURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileURLs{};
  shared_ptr<bool> includeMediaInfo{};
  shared_ptr<bool> includePlayList{};
  shared_ptr<bool> includeSnapshotList{};
  shared_ptr<bool> includeSummaryList{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMediaListByURLRequest() {}

  explicit QueryMediaListByURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURLs) {
      res["FileURLs"] = boost::any(*fileURLs);
    }
    if (includeMediaInfo) {
      res["IncludeMediaInfo"] = boost::any(*includeMediaInfo);
    }
    if (includePlayList) {
      res["IncludePlayList"] = boost::any(*includePlayList);
    }
    if (includeSnapshotList) {
      res["IncludeSnapshotList"] = boost::any(*includeSnapshotList);
    }
    if (includeSummaryList) {
      res["IncludeSummaryList"] = boost::any(*includeSummaryList);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURLs") != m.end() && !m["FileURLs"].empty()) {
      fileURLs = make_shared<string>(boost::any_cast<string>(m["FileURLs"]));
    }
    if (m.find("IncludeMediaInfo") != m.end() && !m["IncludeMediaInfo"].empty()) {
      includeMediaInfo = make_shared<bool>(boost::any_cast<bool>(m["IncludeMediaInfo"]));
    }
    if (m.find("IncludePlayList") != m.end() && !m["IncludePlayList"].empty()) {
      includePlayList = make_shared<bool>(boost::any_cast<bool>(m["IncludePlayList"]));
    }
    if (m.find("IncludeSnapshotList") != m.end() && !m["IncludeSnapshotList"].empty()) {
      includeSnapshotList = make_shared<bool>(boost::any_cast<bool>(m["IncludeSnapshotList"]));
    }
    if (m.find("IncludeSummaryList") != m.end() && !m["IncludeSummaryList"].empty()) {
      includeSummaryList = make_shared<bool>(boost::any_cast<bool>(m["IncludeSummaryList"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMediaListByURLRequest() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListByURLResponseBodyMediaListMediaFile() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaFile() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream>> audioStream{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream>> videoStream{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList> audioStreamList{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList> videoStreamList{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaMediaInfo : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat> format{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams> streams{};

  QueryMediaListByURLResponseBodyMediaListMediaMediaInfo() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaMediaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoFormat>(model1);
      }
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfoStreams>(model1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaMediaInfo() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay : public Darabonba::Model {
public:
  shared_ptr<string> activityName{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> encryption{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile> file{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> size{};
  shared_ptr<string> width{};

  QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (encryption) {
      res["Encryption"] = boost::any(*encryption);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      encryption = make_shared<string>(boost::any_cast<string>(m["Encryption"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlayFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaPlayList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay>> play{};

  QueryMediaListByURLResponseBodyMediaListMediaPlayList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaPlayList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (play) {
      vector<boost::any> temp1;
      for(auto item1:*play){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Play"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Play") != m.end() && !m["Play"].empty()) {
      if (typeid(vector<boost::any>) == m["Play"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Play"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        play = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaPlayListPlay>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaPlayList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  QueryMediaListByURLResponseBodyMediaListMediaRunIdList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaRunIdList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot : public Darabonba::Model {
public:
  shared_ptr<string> activityName{};
  shared_ptr<string> count{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile> file{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> type{};

  QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshotFile>(model1);
      }
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSnapshotList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot>> snapshot{};

  QueryMediaListByURLResponseBodyMediaListMediaSnapshotList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSnapshotList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshot) {
      vector<boost::any> temp1;
      for(auto item1:*snapshot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Snapshot"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Snapshot") != m.end() && !m["Snapshot"].empty()) {
      if (typeid(vector<boost::any>) == m["Snapshot"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Snapshot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshot = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaSnapshotListSnapshot>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSnapshotList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary : public Darabonba::Model {
public:
  shared_ptr<string> activityName{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile> file{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> mediaWorkflowName{};
  shared_ptr<string> type{};

  QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (mediaWorkflowName) {
      res["MediaWorkflowName"] = boost::any(*mediaWorkflowName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummaryFile>(model1);
      }
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("MediaWorkflowName") != m.end() && !m["MediaWorkflowName"].empty()) {
      mediaWorkflowName = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaSummaryList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary>> summary{};

  QueryMediaListByURLResponseBodyMediaListMediaSummaryList() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMediaSummaryListSummary>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaSummaryList() = default;
};
class QueryMediaListByURLResponseBodyMediaListMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  QueryMediaListByURLResponseBodyMediaListMediaTags() {}

  explicit QueryMediaListByURLResponseBodyMediaListMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMediaTags() = default;
};
class QueryMediaListByURLResponseBodyMediaListMedia : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<long> cateId{};
  shared_ptr<string> censorState{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> duration{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaFile> file{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaMediaInfo> mediaInfo{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaPlayList> playList{};
  shared_ptr<string> publishState{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaRunIdList> runIdList{};
  shared_ptr<string> size{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaSnapshotList> snapshotList{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaSummaryList> summaryList{};
  shared_ptr<QueryMediaListByURLResponseBodyMediaListMediaTags> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> width{};

  QueryMediaListByURLResponseBodyMediaListMedia() {}

  explicit QueryMediaListByURLResponseBodyMediaListMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (censorState) {
      res["CensorState"] = boost::any(*censorState);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaInfo) {
      res["MediaInfo"] = mediaInfo ? boost::any(mediaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (playList) {
      res["PlayList"] = playList ? boost::any(playList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshotList) {
      res["SnapshotList"] = snapshotList ? boost::any(snapshotList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summaryList) {
      res["SummaryList"] = summaryList ? boost::any(summaryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CensorState") != m.end() && !m["CensorState"].empty()) {
      censorState = make_shared<string>(boost::any_cast<string>(m["CensorState"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<QueryMediaListByURLResponseBodyMediaListMediaFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaInfo") != m.end() && !m["MediaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfo"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaMediaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfo"]));
        mediaInfo = make_shared<QueryMediaListByURLResponseBodyMediaListMediaMediaInfo>(model1);
      }
    }
    if (m.find("PlayList") != m.end() && !m["PlayList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PlayList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaPlayList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PlayList"]));
        playList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaPlayList>(model1);
      }
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaRunIdList>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("SnapshotList") != m.end() && !m["SnapshotList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaSnapshotList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotList"]));
        snapshotList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaSnapshotList>(model1);
      }
    }
    if (m.find("SummaryList") != m.end() && !m["SummaryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SummaryList"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaSummaryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SummaryList"]));
        summaryList = make_shared<QueryMediaListByURLResponseBodyMediaListMediaSummaryList>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        QueryMediaListByURLResponseBodyMediaListMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<QueryMediaListByURLResponseBodyMediaListMediaTags>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaListMedia() = default;
};
class QueryMediaListByURLResponseBodyMediaList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaListByURLResponseBodyMediaListMedia>> media{};

  QueryMediaListByURLResponseBodyMediaList() {}

  explicit QueryMediaListByURLResponseBodyMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      vector<boost::any> temp1;
      for(auto item1:*media){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Media"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(vector<boost::any>) == m["Media"].type()) {
        vector<QueryMediaListByURLResponseBodyMediaListMedia> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Media"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaListByURLResponseBodyMediaListMedia model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        media = make_shared<vector<QueryMediaListByURLResponseBodyMediaListMedia>>(expect1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponseBodyMediaList() = default;
};
class QueryMediaListByURLResponseBodyNonExistFileURLs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fileURL{};

  QueryMediaListByURLResponseBodyNonExistFileURLs() {}

  explicit QueryMediaListByURLResponseBodyNonExistFileURLs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FileURL"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FileURL"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fileURL = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaListByURLResponseBodyNonExistFileURLs() = default;
};
class QueryMediaListByURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaListByURLResponseBodyMediaList> mediaList{};
  shared_ptr<QueryMediaListByURLResponseBodyNonExistFileURLs> nonExistFileURLs{};
  shared_ptr<string> requestId{};

  QueryMediaListByURLResponseBody() {}

  explicit QueryMediaListByURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaList) {
      res["MediaList"] = mediaList ? boost::any(mediaList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistFileURLs) {
      res["NonExistFileURLs"] = nonExistFileURLs ? boost::any(nonExistFileURLs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaList") != m.end() && !m["MediaList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaList"].type()) {
        QueryMediaListByURLResponseBodyMediaList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaList"]));
        mediaList = make_shared<QueryMediaListByURLResponseBodyMediaList>(model1);
      }
    }
    if (m.find("NonExistFileURLs") != m.end() && !m["NonExistFileURLs"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistFileURLs"].type()) {
        QueryMediaListByURLResponseBodyNonExistFileURLs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistFileURLs"]));
        nonExistFileURLs = make_shared<QueryMediaListByURLResponseBodyNonExistFileURLs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaListByURLResponseBody() = default;
};
class QueryMediaListByURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaListByURLResponseBody> body{};

  QueryMediaListByURLResponse() {}

  explicit QueryMediaListByURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaListByURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaListByURLResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaListByURLResponse() = default;
};
class QueryMediaWorkflowExecutionListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> runIds{};

  QueryMediaWorkflowExecutionListRequest() {}

  explicit QueryMediaWorkflowExecutionListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (runIds) {
      res["RunIds"] = boost::any(*runIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RunIds") != m.end() && !m["RunIds"].empty()) {
      runIds = make_shared<string>(boost::any_cast<string>(m["RunIds"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListRequest() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> endTime{};
  shared_ptr<string> jobId{};
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> type{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivityMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity>> activity{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activity) {
      vector<boost::any> temp1;
      for(auto item1:*activity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Activity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Activity") != m.end() && !m["Activity"].empty()) {
      if (typeid(vector<boost::any>) == m["Activity"].type()) {
        vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Activity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activity = make_shared<vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityListActivity>>(expect1);
      }
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput : public Darabonba::Model {
public:
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile> inputFile{};
  shared_ptr<string> userData{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInputInputFile>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution : public Darabonba::Model {
public:
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList> activityList{};
  shared_ptr<string> creationTime{};
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput> input{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> runId{};
  shared_ptr<string> state{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityList) {
      res["ActivityList"] = activityList ? boost::any(activityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityList") != m.end() && !m["ActivityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActivityList"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActivityList"]));
        activityList = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionActivityList>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecutionInput>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      runId = make_shared<string>(boost::any_cast<string>(m["RunId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution>> mediaWorkflowExecution{};

  QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowExecution) {
      vector<boost::any> temp1;
      for(auto item1:*mediaWorkflowExecution){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaWorkflowExecution"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowExecution") != m.end() && !m["MediaWorkflowExecution"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaWorkflowExecution"].type()) {
        vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaWorkflowExecution"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaWorkflowExecution = make_shared<vector<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionListMediaWorkflowExecution>>(expect1);
      }
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList() = default;
};
class QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds() {}

  explicit QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds() = default;
};
class QueryMediaWorkflowExecutionListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList> mediaWorkflowExecutionList{};
  shared_ptr<QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds> nonExistRunIds{};
  shared_ptr<string> requestId{};

  QueryMediaWorkflowExecutionListResponseBody() {}

  explicit QueryMediaWorkflowExecutionListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowExecutionList) {
      res["MediaWorkflowExecutionList"] = mediaWorkflowExecutionList ? boost::any(mediaWorkflowExecutionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistRunIds) {
      res["NonExistRunIds"] = nonExistRunIds ? boost::any(nonExistRunIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowExecutionList") != m.end() && !m["MediaWorkflowExecutionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflowExecutionList"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflowExecutionList"]));
        mediaWorkflowExecutionList = make_shared<QueryMediaWorkflowExecutionListResponseBodyMediaWorkflowExecutionList>(model1);
      }
    }
    if (m.find("NonExistRunIds") != m.end() && !m["NonExistRunIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistRunIds"].type()) {
        QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistRunIds"]));
        nonExistRunIds = make_shared<QueryMediaWorkflowExecutionListResponseBodyNonExistRunIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponseBody() = default;
};
class QueryMediaWorkflowExecutionListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaWorkflowExecutionListResponseBody> body{};

  QueryMediaWorkflowExecutionListResponse() {}

  explicit QueryMediaWorkflowExecutionListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaWorkflowExecutionListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaWorkflowExecutionListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaWorkflowExecutionListResponse() = default;
};
class QueryMediaWorkflowListRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaWorkflowIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMediaWorkflowListRequest() {}

  explicit QueryMediaWorkflowListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowIds) {
      res["MediaWorkflowIds"] = boost::any(*mediaWorkflowIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowIds") != m.end() && !m["MediaWorkflowIds"].empty()) {
      mediaWorkflowIds = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMediaWorkflowListRequest() = default;
};
class QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};
  shared_ptr<string> triggerMode{};

  QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow() {}

  explicit QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow() = default;
};
class QueryMediaWorkflowListResponseBodyMediaWorkflowList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow>> mediaWorkflow{};

  QueryMediaWorkflowListResponseBodyMediaWorkflowList() {}

  explicit QueryMediaWorkflowListResponseBodyMediaWorkflowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      vector<boost::any> temp1;
      for(auto item1:*mediaWorkflow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaWorkflow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaWorkflow"].type()) {
        vector<QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaWorkflow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaWorkflow = make_shared<vector<QueryMediaWorkflowListResponseBodyMediaWorkflowListMediaWorkflow>>(expect1);
      }
    }
  }


  virtual ~QueryMediaWorkflowListResponseBodyMediaWorkflowList() = default;
};
class QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> mediaWorkflowId{};

  QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds() {}

  explicit QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MediaWorkflowId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MediaWorkflowId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mediaWorkflowId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds() = default;
};
class QueryMediaWorkflowListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaWorkflowListResponseBodyMediaWorkflowList> mediaWorkflowList{};
  shared_ptr<QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds> nonExistMediaWorkflowIds{};
  shared_ptr<string> requestId{};

  QueryMediaWorkflowListResponseBody() {}

  explicit QueryMediaWorkflowListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowList) {
      res["MediaWorkflowList"] = mediaWorkflowList ? boost::any(mediaWorkflowList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistMediaWorkflowIds) {
      res["NonExistMediaWorkflowIds"] = nonExistMediaWorkflowIds ? boost::any(nonExistMediaWorkflowIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowList") != m.end() && !m["MediaWorkflowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflowList"].type()) {
        QueryMediaWorkflowListResponseBodyMediaWorkflowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflowList"]));
        mediaWorkflowList = make_shared<QueryMediaWorkflowListResponseBodyMediaWorkflowList>(model1);
      }
    }
    if (m.find("NonExistMediaWorkflowIds") != m.end() && !m["NonExistMediaWorkflowIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistMediaWorkflowIds"].type()) {
        QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistMediaWorkflowIds"]));
        nonExistMediaWorkflowIds = make_shared<QueryMediaWorkflowListResponseBodyNonExistMediaWorkflowIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaWorkflowListResponseBody() = default;
};
class QueryMediaWorkflowListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaWorkflowListResponseBody> body{};

  QueryMediaWorkflowListResponse() {}

  explicit QueryMediaWorkflowListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaWorkflowListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaWorkflowListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaWorkflowListResponse() = default;
};
class QueryPipelineListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineIds{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryPipelineListRequest() {}

  explicit QueryPipelineListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineIds) {
      res["PipelineIds"] = boost::any(*pipelineIds);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineIds") != m.end() && !m["PipelineIds"].empty()) {
      pipelineIds = make_shared<string>(boost::any_cast<string>(m["PipelineIds"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryPipelineListRequest() = default;
};
class QueryPipelineListResponseBodyNonExistPids : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryPipelineListResponseBodyNonExistPids() {}

  explicit QueryPipelineListResponseBodyNonExistPids(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryPipelineListResponseBodyNonExistPids() = default;
};
class QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> queueName{};
  shared_ptr<string> topic{};

  QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class QueryPipelineListResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> role{};
  shared_ptr<string> speed{};
  shared_ptr<long> speedLevel{};
  shared_ptr<string> state{};

  QueryPipelineListResponseBodyPipelineListPipeline() {}

  explicit QueryPipelineListResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (speedLevel) {
      res["SpeedLevel"] = boost::any(*speedLevel);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<QueryPipelineListResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("SpeedLevel") != m.end() && !m["SpeedLevel"].empty()) {
      speedLevel = make_shared<long>(boost::any_cast<long>(m["SpeedLevel"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~QueryPipelineListResponseBodyPipelineListPipeline() = default;
};
class QueryPipelineListResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryPipelineListResponseBodyPipelineListPipeline>> pipeline{};

  QueryPipelineListResponseBodyPipelineList() {}

  explicit QueryPipelineListResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<QueryPipelineListResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryPipelineListResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<QueryPipelineListResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~QueryPipelineListResponseBodyPipelineList() = default;
};
class QueryPipelineListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryPipelineListResponseBodyNonExistPids> nonExistPids{};
  shared_ptr<QueryPipelineListResponseBodyPipelineList> pipelineList{};
  shared_ptr<string> requestId{};

  QueryPipelineListResponseBody() {}

  explicit QueryPipelineListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistPids) {
      res["NonExistPids"] = nonExistPids ? boost::any(nonExistPids->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistPids") != m.end() && !m["NonExistPids"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistPids"].type()) {
        QueryPipelineListResponseBodyNonExistPids model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistPids"]));
        nonExistPids = make_shared<QueryPipelineListResponseBodyNonExistPids>(model1);
      }
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        QueryPipelineListResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<QueryPipelineListResponseBodyPipelineList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryPipelineListResponseBody() = default;
};
class QueryPipelineListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPipelineListResponseBody> body{};

  QueryPipelineListResponse() {}

  explicit QueryPipelineListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPipelineListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPipelineListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPipelineListResponse() = default;
};
class QuerySnapshotJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfJobCreatedTimeRange{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> snapshotJobIds{};
  shared_ptr<string> startOfJobCreatedTimeRange{};
  shared_ptr<string> state{};

  QuerySnapshotJobListRequest() {}

  explicit QuerySnapshotJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfJobCreatedTimeRange) {
      res["EndOfJobCreatedTimeRange"] = boost::any(*endOfJobCreatedTimeRange);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (snapshotJobIds) {
      res["SnapshotJobIds"] = boost::any(*snapshotJobIds);
    }
    if (startOfJobCreatedTimeRange) {
      res["StartOfJobCreatedTimeRange"] = boost::any(*startOfJobCreatedTimeRange);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfJobCreatedTimeRange") != m.end() && !m["EndOfJobCreatedTimeRange"].empty()) {
      endOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["EndOfJobCreatedTimeRange"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SnapshotJobIds") != m.end() && !m["SnapshotJobIds"].empty()) {
      snapshotJobIds = make_shared<string>(boost::any_cast<string>(m["SnapshotJobIds"]));
    }
    if (m.find("StartOfJobCreatedTimeRange") != m.end() && !m["StartOfJobCreatedTimeRange"].empty()) {
      startOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["StartOfJobCreatedTimeRange"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~QuerySnapshotJobListRequest() = default;
};
class QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds() {}

  explicit QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut : public Darabonba::Model {
public:
  shared_ptr<string> cellHeight{};
  shared_ptr<string> cellSelStep{};
  shared_ptr<string> cellWidth{};
  shared_ptr<string> color{};
  shared_ptr<string> columns{};
  shared_ptr<string> isKeepCellPic{};
  shared_ptr<string> lines{};
  shared_ptr<string> margin{};
  shared_ptr<string> padding{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cellHeight) {
      res["CellHeight"] = boost::any(*cellHeight);
    }
    if (cellSelStep) {
      res["CellSelStep"] = boost::any(*cellSelStep);
    }
    if (cellWidth) {
      res["CellWidth"] = boost::any(*cellWidth);
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (isKeepCellPic) {
      res["IsKeepCellPic"] = boost::any(*isKeepCellPic);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (margin) {
      res["Margin"] = boost::any(*margin);
    }
    if (padding) {
      res["Padding"] = boost::any(*padding);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CellHeight") != m.end() && !m["CellHeight"].empty()) {
      cellHeight = make_shared<string>(boost::any_cast<string>(m["CellHeight"]));
    }
    if (m.find("CellSelStep") != m.end() && !m["CellSelStep"].empty()) {
      cellSelStep = make_shared<string>(boost::any_cast<string>(m["CellSelStep"]));
    }
    if (m.find("CellWidth") != m.end() && !m["CellWidth"].empty()) {
      cellWidth = make_shared<string>(boost::any_cast<string>(m["CellWidth"]));
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      columns = make_shared<string>(boost::any_cast<string>(m["Columns"]));
    }
    if (m.find("IsKeepCellPic") != m.end() && !m["IsKeepCellPic"].empty()) {
      isKeepCellPic = make_shared<string>(boost::any_cast<string>(m["IsKeepCellPic"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<string>(boost::any_cast<string>(m["Lines"]));
    }
    if (m.find("Margin") != m.end() && !m["Margin"].empty()) {
      margin = make_shared<string>(boost::any_cast<string>(m["Margin"]));
    }
    if (m.find("Padding") != m.end() && !m["Padding"].empty()) {
      padding = make_shared<string>(boost::any_cast<string>(m["Padding"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig : public Darabonba::Model {
public:
  shared_ptr<string> frameType{};
  shared_ptr<string> height{};
  shared_ptr<string> interval{};
  shared_ptr<string> num{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile> outputFile{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut> tileOut{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile> tileOutputFile{};
  shared_ptr<string> time{};
  shared_ptr<string> width{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameType) {
      res["FrameType"] = boost::any(*frameType);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (num) {
      res["Num"] = boost::any(*num);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tileOut) {
      res["TileOut"] = tileOut ? boost::any(tileOut->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tileOutputFile) {
      res["TileOutputFile"] = tileOutputFile ? boost::any(tileOutputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameType") != m.end() && !m["FrameType"].empty()) {
      frameType = make_shared<string>(boost::any_cast<string>(m["FrameType"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("Num") != m.end() && !m["Num"].empty()) {
      num = make_shared<string>(boost::any_cast<string>(m["Num"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigOutputFile>(model1);
      }
    }
    if (m.find("TileOut") != m.end() && !m["TileOut"].empty()) {
      if (typeid(map<string, boost::any>) == m["TileOut"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TileOut"]));
        tileOut = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOut>(model1);
      }
    }
    if (m.find("TileOutputFile") != m.end() && !m["TileOutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["TileOutputFile"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TileOutputFile"]));
        tileOutputFile = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfigTileOutputFile>(model1);
      }
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> id{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput> input{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig> snapshotConfig{};
  shared_ptr<string> state{};
  shared_ptr<string> tileCount{};
  shared_ptr<string> userData{};

  QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (snapshotConfig) {
      res["SnapshotConfig"] = snapshotConfig ? boost::any(snapshotConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tileCount) {
      res["TileCount"] = boost::any(*tileCount);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobInput>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("SnapshotConfig") != m.end() && !m["SnapshotConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotConfig"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotConfig"]));
        snapshotConfig = make_shared<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJobSnapshotConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TileCount") != m.end() && !m["TileCount"].empty()) {
      tileCount = make_shared<string>(boost::any_cast<string>(m["TileCount"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob() = default;
};
class QuerySnapshotJobListResponseBodySnapshotJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob>> snapshotJob{};

  QuerySnapshotJobListResponseBodySnapshotJobList() {}

  explicit QuerySnapshotJobListResponseBodySnapshotJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotJob) {
      vector<boost::any> temp1;
      for(auto item1:*snapshotJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SnapshotJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotJob") != m.end() && !m["SnapshotJob"].empty()) {
      if (typeid(vector<boost::any>) == m["SnapshotJob"].type()) {
        vector<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SnapshotJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshotJob = make_shared<vector<QuerySnapshotJobListResponseBodySnapshotJobListSnapshotJob>>(expect1);
      }
    }
  }


  virtual ~QuerySnapshotJobListResponseBodySnapshotJobList() = default;
};
class QuerySnapshotJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextPageToken{};
  shared_ptr<QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds> nonExistSnapshotJobIds{};
  shared_ptr<string> requestId{};
  shared_ptr<QuerySnapshotJobListResponseBodySnapshotJobList> snapshotJobList{};

  QuerySnapshotJobListResponseBody() {}

  explicit QuerySnapshotJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nonExistSnapshotJobIds) {
      res["NonExistSnapshotJobIds"] = nonExistSnapshotJobIds ? boost::any(nonExistSnapshotJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotJobList) {
      res["SnapshotJobList"] = snapshotJobList ? boost::any(snapshotJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NonExistSnapshotJobIds") != m.end() && !m["NonExistSnapshotJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistSnapshotJobIds"].type()) {
        QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistSnapshotJobIds"]));
        nonExistSnapshotJobIds = make_shared<QuerySnapshotJobListResponseBodyNonExistSnapshotJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotJobList") != m.end() && !m["SnapshotJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotJobList"].type()) {
        QuerySnapshotJobListResponseBodySnapshotJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotJobList"]));
        snapshotJobList = make_shared<QuerySnapshotJobListResponseBodySnapshotJobList>(model1);
      }
    }
  }


  virtual ~QuerySnapshotJobListResponseBody() = default;
};
class QuerySnapshotJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySnapshotJobListResponseBody> body{};

  QuerySnapshotJobListResponse() {}

  explicit QuerySnapshotJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySnapshotJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySnapshotJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySnapshotJobListResponse() = default;
};
class QueryTemplateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateIds{};

  QueryTemplateListRequest() {}

  explicit QueryTemplateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateIds) {
      res["TemplateIds"] = boost::any(*templateIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      templateIds = make_shared<string>(boost::any_cast<string>(m["TemplateIds"]));
    }
  }


  virtual ~QueryTemplateListRequest() = default;
};
class QueryTemplateListResponseBodyNonExistTids : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryTemplateListResponseBodyNonExistTids() {}

  explicit QueryTemplateListResponseBodyNonExistTids(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryTemplateListResponseBodyNonExistTids() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};

  QueryTemplateListResponseBodyTemplateListTemplateAudio() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateAudio() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  QueryTemplateListResponseBodyTemplateListTemplateContainer() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateContainer() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif> gif{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment> segment{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp> webp{};

  QueryTemplateListResponseBodyTemplateListTemplateMuxConfig() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigSegment>(model1);
      }
    }
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<QueryTemplateListResponseBodyTemplateListTemplateMuxConfigWebp>(model1);
      }
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateMuxConfig() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  QueryTemplateListResponseBodyTemplateListTemplateTransConfig() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateTransConfig() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> resoPriority{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  QueryTemplateListResponseBodyTemplateListTemplateVideo() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<QueryTemplateListResponseBodyTemplateListTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplateVideo() = default;
};
class QueryTemplateListResponseBodyTemplateListTemplate : public Darabonba::Model {
public:
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateAudio> audio{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateContainer> container{};
  shared_ptr<string> id{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateTransConfig> transConfig{};
  shared_ptr<QueryTemplateListResponseBodyTemplateListTemplateVideo> video{};

  QueryTemplateListResponseBodyTemplateListTemplate() {}

  explicit QueryTemplateListResponseBodyTemplateListTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<QueryTemplateListResponseBodyTemplateListTemplateAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<QueryTemplateListResponseBodyTemplateListTemplateContainer>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<QueryTemplateListResponseBodyTemplateListTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<QueryTemplateListResponseBodyTemplateListTemplateTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        QueryTemplateListResponseBodyTemplateListTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<QueryTemplateListResponseBodyTemplateListTemplateVideo>(model1);
      }
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateListTemplate() = default;
};
class QueryTemplateListResponseBodyTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTemplateListResponseBodyTemplateListTemplate>> template_{};

  QueryTemplateListResponseBodyTemplateList() {}

  explicit QueryTemplateListResponseBodyTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<QueryTemplateListResponseBodyTemplateListTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTemplateListResponseBodyTemplateListTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<QueryTemplateListResponseBodyTemplateListTemplate>>(expect1);
      }
    }
  }


  virtual ~QueryTemplateListResponseBodyTemplateList() = default;
};
class QueryTemplateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryTemplateListResponseBodyNonExistTids> nonExistTids{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryTemplateListResponseBodyTemplateList> templateList{};

  QueryTemplateListResponseBody() {}

  explicit QueryTemplateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistTids) {
      res["NonExistTids"] = nonExistTids ? boost::any(nonExistTids->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateList) {
      res["TemplateList"] = templateList ? boost::any(templateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistTids") != m.end() && !m["NonExistTids"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistTids"].type()) {
        QueryTemplateListResponseBodyNonExistTids model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistTids"]));
        nonExistTids = make_shared<QueryTemplateListResponseBodyNonExistTids>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateList"].type()) {
        QueryTemplateListResponseBodyTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateList"]));
        templateList = make_shared<QueryTemplateListResponseBodyTemplateList>(model1);
      }
    }
  }


  virtual ~QueryTemplateListResponseBody() = default;
};
class QueryTemplateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTemplateListResponseBody> body{};

  QueryTemplateListResponse() {}

  explicit QueryTemplateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTemplateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTemplateListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTemplateListResponse() = default;
};
class QueryWaterMarkTemplateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> waterMarkTemplateIds{};

  QueryWaterMarkTemplateListRequest() {}

  explicit QueryWaterMarkTemplateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (waterMarkTemplateIds) {
      res["WaterMarkTemplateIds"] = boost::any(*waterMarkTemplateIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("WaterMarkTemplateIds") != m.end() && !m["WaterMarkTemplateIds"].empty()) {
      waterMarkTemplateIds = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateIds"]));
    }
  }


  virtual ~QueryWaterMarkTemplateListRequest() = default;
};
class QueryWaterMarkTemplateListResponseBodyNonExistWids : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryWaterMarkTemplateListResponseBodyNonExistWids() {}

  explicit QueryWaterMarkTemplateListResponseBodyNonExistWids(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyNonExistWids() = default;
};
class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> width{};

  QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer() {}

  explicit QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer() = default;
};
class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline() {}

  explicit QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline() = default;
};
class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer> ratioRefer{};
  shared_ptr<string> referPos{};
  shared_ptr<string> state{};
  shared_ptr<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline> timeline{};
  shared_ptr<string> type{};
  shared_ptr<string> width{};

  QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate() {}

  explicit QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ratioRefer) {
      res["RatioRefer"] = ratioRefer ? boost::any(ratioRefer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RatioRefer") != m.end() && !m["RatioRefer"].empty()) {
      if (typeid(map<string, boost::any>) == m["RatioRefer"].type()) {
        QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RatioRefer"]));
        ratioRefer = make_shared<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate() = default;
};
class QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate>> waterMarkTemplate{};

  QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList() {}

  explicit QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMarkTemplate) {
      vector<boost::any> temp1;
      for(auto item1:*waterMarkTemplate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMarkTemplate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMarkTemplate") != m.end() && !m["WaterMarkTemplate"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMarkTemplate"].type()) {
        vector<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMarkTemplate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMarkTemplate = make_shared<vector<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateListWaterMarkTemplate>>(expect1);
      }
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList() = default;
};
class QueryWaterMarkTemplateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryWaterMarkTemplateListResponseBodyNonExistWids> nonExistWids{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList> waterMarkTemplateList{};

  QueryWaterMarkTemplateListResponseBody() {}

  explicit QueryWaterMarkTemplateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistWids) {
      res["NonExistWids"] = nonExistWids ? boost::any(nonExistWids->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (waterMarkTemplateList) {
      res["WaterMarkTemplateList"] = waterMarkTemplateList ? boost::any(waterMarkTemplateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistWids") != m.end() && !m["NonExistWids"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistWids"].type()) {
        QueryWaterMarkTemplateListResponseBodyNonExistWids model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistWids"]));
        nonExistWids = make_shared<QueryWaterMarkTemplateListResponseBodyNonExistWids>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WaterMarkTemplateList") != m.end() && !m["WaterMarkTemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkTemplateList"].type()) {
        QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkTemplateList"]));
        waterMarkTemplateList = make_shared<QueryWaterMarkTemplateListResponseBodyWaterMarkTemplateList>(model1);
      }
    }
  }


  virtual ~QueryWaterMarkTemplateListResponseBody() = default;
};
class QueryWaterMarkTemplateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryWaterMarkTemplateListResponseBody> body{};

  QueryWaterMarkTemplateListResponse() {}

  explicit QueryWaterMarkTemplateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryWaterMarkTemplateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryWaterMarkTemplateListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryWaterMarkTemplateListResponse() = default;
};
class SearchMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> stateList{};

  SearchMediaWorkflowRequest() {}

  explicit SearchMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (stateList) {
      res["StateList"] = boost::any(*stateList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StateList") != m.end() && !m["StateList"].empty()) {
      stateList = make_shared<string>(boost::any_cast<string>(m["StateList"]));
    }
  }


  virtual ~SearchMediaWorkflowRequest() = default;
};
class SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};
  shared_ptr<string> triggerMode{};

  SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow() {}

  explicit SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow() = default;
};
class SearchMediaWorkflowResponseBodyMediaWorkflowList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow>> mediaWorkflow{};

  SearchMediaWorkflowResponseBodyMediaWorkflowList() {}

  explicit SearchMediaWorkflowResponseBodyMediaWorkflowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      vector<boost::any> temp1;
      for(auto item1:*mediaWorkflow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaWorkflow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaWorkflow"].type()) {
        vector<SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaWorkflow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaWorkflow = make_shared<vector<SearchMediaWorkflowResponseBodyMediaWorkflowListMediaWorkflow>>(expect1);
      }
    }
  }


  virtual ~SearchMediaWorkflowResponseBodyMediaWorkflowList() = default;
};
class SearchMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchMediaWorkflowResponseBodyMediaWorkflowList> mediaWorkflowList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  SearchMediaWorkflowResponseBody() {}

  explicit SearchMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowList) {
      res["MediaWorkflowList"] = mediaWorkflowList ? boost::any(mediaWorkflowList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowList") != m.end() && !m["MediaWorkflowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflowList"].type()) {
        SearchMediaWorkflowResponseBodyMediaWorkflowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflowList"]));
        mediaWorkflowList = make_shared<SearchMediaWorkflowResponseBodyMediaWorkflowList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchMediaWorkflowResponseBody() = default;
};
class SearchMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchMediaWorkflowResponseBody> body{};

  SearchMediaWorkflowResponse() {}

  explicit SearchMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~SearchMediaWorkflowResponse() = default;
};
class SearchPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> state{};

  SearchPipelineRequest() {}

  explicit SearchPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SearchPipelineRequest() = default;
};
class SearchPipelineResponseBodyPipelineListPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> queueName{};
  shared_ptr<string> topic{};

  SearchPipelineResponseBodyPipelineListPipelineNotifyConfig() {}

  explicit SearchPipelineResponseBodyPipelineListPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~SearchPipelineResponseBodyPipelineListPipelineNotifyConfig() = default;
};
class SearchPipelineResponseBodyPipelineListPipeline : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<SearchPipelineResponseBodyPipelineListPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> role{};
  shared_ptr<string> speed{};
  shared_ptr<long> speedLevel{};
  shared_ptr<string> state{};

  SearchPipelineResponseBodyPipelineListPipeline() {}

  explicit SearchPipelineResponseBodyPipelineListPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (speedLevel) {
      res["SpeedLevel"] = boost::any(*speedLevel);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        SearchPipelineResponseBodyPipelineListPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<SearchPipelineResponseBodyPipelineListPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("SpeedLevel") != m.end() && !m["SpeedLevel"].empty()) {
      speedLevel = make_shared<long>(boost::any_cast<long>(m["SpeedLevel"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SearchPipelineResponseBodyPipelineListPipeline() = default;
};
class SearchPipelineResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchPipelineResponseBodyPipelineListPipeline>> pipeline{};

  SearchPipelineResponseBodyPipelineList() {}

  explicit SearchPipelineResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      vector<boost::any> temp1;
      for(auto item1:*pipeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Pipeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(vector<boost::any>) == m["Pipeline"].type()) {
        vector<SearchPipelineResponseBodyPipelineListPipeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Pipeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchPipelineResponseBodyPipelineListPipeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipeline = make_shared<vector<SearchPipelineResponseBodyPipelineListPipeline>>(expect1);
      }
    }
  }


  virtual ~SearchPipelineResponseBodyPipelineList() = default;
};
class SearchPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<SearchPipelineResponseBodyPipelineList> pipelineList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  SearchPipelineResponseBody() {}

  explicit SearchPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pipelineList) {
      res["PipelineList"] = pipelineList ? boost::any(pipelineList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PipelineList"].type()) {
        SearchPipelineResponseBodyPipelineList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PipelineList"]));
        pipelineList = make_shared<SearchPipelineResponseBodyPipelineList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchPipelineResponseBody() = default;
};
class SearchPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchPipelineResponseBody> body{};

  SearchPipelineResponse() {}

  explicit SearchPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~SearchPipelineResponse() = default;
};
class SearchTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> state{};

  SearchTemplateRequest() {}

  explicit SearchTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SearchTemplateRequest() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};

  SearchTemplateResponseBodyTemplateListTemplateAudio() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateAudio() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SearchTemplateResponseBodyTemplateListTemplateContainer() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateContainer() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif> gif{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment> segment{};

  SearchTemplateResponseBodyTemplateListTemplateMuxConfig() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<SearchTemplateResponseBodyTemplateListTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SearchTemplateResponseBodyTemplateListTemplateMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateMuxConfig() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  SearchTemplateResponseBodyTemplateListTemplateTransConfig() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateTransConfig() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd() = default;
};
class SearchTemplateResponseBodyTemplateListTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  SearchTemplateResponseBodyTemplateListTemplateVideo() {}

  explicit SearchTemplateResponseBodyTemplateListTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<SearchTemplateResponseBodyTemplateListTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplateVideo() = default;
};
class SearchTemplateResponseBodyTemplateListTemplate : public Darabonba::Model {
public:
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateAudio> audio{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateContainer> container{};
  shared_ptr<string> id{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateTransConfig> transConfig{};
  shared_ptr<SearchTemplateResponseBodyTemplateListTemplateVideo> video{};

  SearchTemplateResponseBodyTemplateListTemplate() {}

  explicit SearchTemplateResponseBodyTemplateListTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SearchTemplateResponseBodyTemplateListTemplateAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SearchTemplateResponseBodyTemplateListTemplateContainer>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SearchTemplateResponseBodyTemplateListTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SearchTemplateResponseBodyTemplateListTemplateTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SearchTemplateResponseBodyTemplateListTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SearchTemplateResponseBodyTemplateListTemplateVideo>(model1);
      }
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateListTemplate() = default;
};
class SearchTemplateResponseBodyTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchTemplateResponseBodyTemplateListTemplate>> template_{};

  SearchTemplateResponseBodyTemplateList() {}

  explicit SearchTemplateResponseBodyTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<SearchTemplateResponseBodyTemplateListTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchTemplateResponseBodyTemplateListTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<SearchTemplateResponseBodyTemplateListTemplate>>(expect1);
      }
    }
  }


  virtual ~SearchTemplateResponseBodyTemplateList() = default;
};
class SearchTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<SearchTemplateResponseBodyTemplateList> templateList{};
  shared_ptr<long> totalCount{};

  SearchTemplateResponseBody() {}

  explicit SearchTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateList) {
      res["TemplateList"] = templateList ? boost::any(templateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateList"].type()) {
        SearchTemplateResponseBodyTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateList"]));
        templateList = make_shared<SearchTemplateResponseBodyTemplateList>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchTemplateResponseBody() = default;
};
class SearchTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchTemplateResponseBody> body{};

  SearchTemplateResponse() {}

  explicit SearchTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~SearchTemplateResponse() = default;
};
class SearchWaterMarkTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> state{};

  SearchWaterMarkTemplateRequest() {}

  explicit SearchWaterMarkTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SearchWaterMarkTemplateRequest() = default;
};
class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> width{};

  SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer() {}

  explicit SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer() = default;
};
class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline() {}

  explicit SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline() = default;
};
class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer> ratioRefer{};
  shared_ptr<string> referPos{};
  shared_ptr<string> state{};
  shared_ptr<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline> timeline{};
  shared_ptr<string> type{};
  shared_ptr<string> width{};

  SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate() {}

  explicit SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ratioRefer) {
      res["RatioRefer"] = ratioRefer ? boost::any(ratioRefer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RatioRefer") != m.end() && !m["RatioRefer"].empty()) {
      if (typeid(map<string, boost::any>) == m["RatioRefer"].type()) {
        SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RatioRefer"]));
        ratioRefer = make_shared<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateRatioRefer>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplateTimeline>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate() = default;
};
class SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate>> waterMarkTemplate{};

  SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList() {}

  explicit SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMarkTemplate) {
      vector<boost::any> temp1;
      for(auto item1:*waterMarkTemplate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMarkTemplate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMarkTemplate") != m.end() && !m["WaterMarkTemplate"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMarkTemplate"].type()) {
        vector<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMarkTemplate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMarkTemplate = make_shared<vector<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateListWaterMarkTemplate>>(expect1);
      }
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList() = default;
};
class SearchWaterMarkTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList> waterMarkTemplateList{};

  SearchWaterMarkTemplateResponseBody() {}

  explicit SearchWaterMarkTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (waterMarkTemplateList) {
      res["WaterMarkTemplateList"] = waterMarkTemplateList ? boost::any(waterMarkTemplateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("WaterMarkTemplateList") != m.end() && !m["WaterMarkTemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkTemplateList"].type()) {
        SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkTemplateList"]));
        waterMarkTemplateList = make_shared<SearchWaterMarkTemplateResponseBodyWaterMarkTemplateList>(model1);
      }
    }
  }


  virtual ~SearchWaterMarkTemplateResponseBody() = default;
};
class SearchWaterMarkTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchWaterMarkTemplateResponseBody> body{};

  SearchWaterMarkTemplateResponse() {}

  explicit SearchWaterMarkTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchWaterMarkTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchWaterMarkTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~SearchWaterMarkTemplateResponse() = default;
};
class SubmitAnalysisJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> analysisConfig{};
  shared_ptr<string> input{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> priority{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> userData{};

  SubmitAnalysisJobRequest() {}

  explicit SubmitAnalysisJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisConfig) {
      res["AnalysisConfig"] = boost::any(*analysisConfig);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisConfig") != m.end() && !m["AnalysisConfig"].empty()) {
      analysisConfig = make_shared<string>(boost::any_cast<string>(m["AnalysisConfig"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitAnalysisJobRequest() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop : public Darabonba::Model {
public:
  shared_ptr<string> height{};
  shared_ptr<string> left{};
  shared_ptr<string> mode{};
  shared_ptr<string> top{};
  shared_ptr<string> width{};

  SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop> crop{};
  shared_ptr<string> deinterlace{};

  SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (crop) {
      res["Crop"] = crop ? boost::any(crop->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deinterlace) {
      res["Deinterlace"] = boost::any(*deinterlace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      if (typeid(map<string, boost::any>) == m["Crop"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Crop"]));
        crop = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControlCrop>(model1);
      }
    }
    if (m.find("Deinterlace") != m.end() && !m["Deinterlace"].empty()) {
      deinterlace = make_shared<string>(boost::any_cast<string>(m["Deinterlace"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl : public Darabonba::Model {
public:
  shared_ptr<string> methodStreaming{};
  shared_ptr<string> rateQuality{};

  SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methodStreaming) {
      res["MethodStreaming"] = boost::any(*methodStreaming);
    }
    if (rateQuality) {
      res["RateQuality"] = boost::any(*rateQuality);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MethodStreaming") != m.end() && !m["MethodStreaming"].empty()) {
      methodStreaming = make_shared<string>(boost::any_cast<string>(m["MethodStreaming"]));
    }
    if (m.find("RateQuality") != m.end() && !m["RateQuality"].empty()) {
      rateQuality = make_shared<string>(boost::any_cast<string>(m["RateQuality"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl> propertiesControl{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl> qualityControl{};

  SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertiesControl) {
      res["PropertiesControl"] = propertiesControl ? boost::any(propertiesControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (qualityControl) {
      res["QualityControl"] = qualityControl ? boost::any(qualityControl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertiesControl") != m.end() && !m["PropertiesControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertiesControl"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertiesControl"]));
        propertiesControl = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigPropertiesControl>(model1);
      }
    }
    if (m.find("QualityControl") != m.end() && !m["QualityControl"].empty()) {
      if (typeid(map<string, boost::any>) == m["QualityControl"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QualityControl"]));
        qualityControl = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfigQualityControl>(model1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitAnalysisJobResponseBodyAnalysisJobInputFile() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobInputFile() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> samplerate{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> finalDelay{};
  shared_ptr<string> loop{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif> gif{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment> segment{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> transMode{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio> audio{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer> container{};
  shared_ptr<string> id{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig> transConfig{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo> video{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateContainer>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplateVideo>(model1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJobTemplateList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate>> template_{};

  SubmitAnalysisJobResponseBodyAnalysisJobTemplateList() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJobTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<SubmitAnalysisJobResponseBodyAnalysisJobTemplateListTemplate>>(expect1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJobTemplateList() = default;
};
class SubmitAnalysisJobResponseBodyAnalysisJob : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig> analysisConfig{};
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> id{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobInputFile> inputFile{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<long> percent{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> priority{};
  shared_ptr<string> state{};
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJobTemplateList> templateList{};
  shared_ptr<string> userData{};

  SubmitAnalysisJobResponseBodyAnalysisJob() {}

  explicit SubmitAnalysisJobResponseBodyAnalysisJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisConfig) {
      res["AnalysisConfig"] = analysisConfig ? boost::any(analysisConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (templateList) {
      res["TemplateList"] = templateList ? boost::any(templateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisConfig") != m.end() && !m["AnalysisConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AnalysisConfig"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AnalysisConfig"]));
        analysisConfig = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobAnalysisConfig>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobInputFile>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateList"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJobTemplateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateList"]));
        templateList = make_shared<SubmitAnalysisJobResponseBodyAnalysisJobTemplateList>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBodyAnalysisJob() = default;
};
class SubmitAnalysisJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitAnalysisJobResponseBodyAnalysisJob> analysisJob{};
  shared_ptr<string> requestId{};

  SubmitAnalysisJobResponseBody() {}

  explicit SubmitAnalysisJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisJob) {
      res["AnalysisJob"] = analysisJob ? boost::any(analysisJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisJob") != m.end() && !m["AnalysisJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["AnalysisJob"].type()) {
        SubmitAnalysisJobResponseBodyAnalysisJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AnalysisJob"]));
        analysisJob = make_shared<SubmitAnalysisJobResponseBodyAnalysisJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitAnalysisJobResponseBody() = default;
};
class SubmitAnalysisJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitAnalysisJobResponseBody> body{};

  SubmitAnalysisJobResponse() {}

  explicit SubmitAnalysisJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAnalysisJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAnalysisJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAnalysisJobResponse() = default;
};
class SubmitEditingJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> editingInputs{};
  shared_ptr<string> editingJobOutputs{};
  shared_ptr<string> outputBucket{};
  shared_ptr<string> outputLocation{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  SubmitEditingJobsRequest() {}

  explicit SubmitEditingJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingInputs) {
      res["EditingInputs"] = boost::any(*editingInputs);
    }
    if (editingJobOutputs) {
      res["EditingJobOutputs"] = boost::any(*editingJobOutputs);
    }
    if (outputBucket) {
      res["OutputBucket"] = boost::any(*outputBucket);
    }
    if (outputLocation) {
      res["OutputLocation"] = boost::any(*outputLocation);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingInputs") != m.end() && !m["EditingInputs"].empty()) {
      editingInputs = make_shared<string>(boost::any_cast<string>(m["EditingInputs"]));
    }
    if (m.find("EditingJobOutputs") != m.end() && !m["EditingJobOutputs"].empty()) {
      editingJobOutputs = make_shared<string>(boost::any_cast<string>(m["EditingJobOutputs"]));
    }
    if (m.find("OutputBucket") != m.end() && !m["OutputBucket"].empty()) {
      outputBucket = make_shared<string>(boost::any_cast<string>(m["OutputBucket"]));
    }
    if (m.find("OutputLocation") != m.end() && !m["OutputLocation"].empty()) {
      outputLocation = make_shared<string>(boost::any_cast<string>(m["OutputLocation"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~SubmitEditingJobsRequest() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> method{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> samplerate{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume> volume{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudioVolume>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> seek{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan> timeSpan{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClipTimeSpan>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> alpha{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile> inputFile{};
  shared_ptr<string> type{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alpha) {
      res["Alpha"] = boost::any(*alpha);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alpha") != m.end() && !m["Alpha"].empty()) {
      alpha = make_shared<string>(boost::any_cast<string>(m["Alpha"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMarkInputFile>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect : public Darabonba::Model {
public:
  shared_ptr<string> effect{};
  shared_ptr<string> effectConfig{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (effectConfig) {
      res["EffectConfig"] = boost::any(*effectConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("EffectConfig") != m.end() && !m["EffectConfig"].empty()) {
      effectConfig = make_shared<string>(boost::any_cast<string>(m["EffectConfig"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect>> effect{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effect) {
      vector<boost::any> temp1;
      for(auto item1:*effect){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Effect"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      if (typeid(vector<boost::any>) == m["Effect"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Effect"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        effect = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffectsEffect>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects> effects{};
  shared_ptr<string> id{};
  shared_ptr<string> in{};
  shared_ptr<string> out{};
  shared_ptr<string> sourceID{};
  shared_ptr<string> sourceStrmMap{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effects) {
      res["Effects"] = effects ? boost::any(effects->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (sourceID) {
      res["SourceID"] = boost::any(*sourceID);
    }
    if (sourceStrmMap) {
      res["SourceStrmMap"] = boost::any(*sourceStrmMap);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Effects") != m.end() && !m["Effects"].empty()) {
      if (typeid(map<string, boost::any>) == m["Effects"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Effects"]));
        effects = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClipEffects>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<string>(boost::any_cast<string>(m["In"]));
    }
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<string>(boost::any_cast<string>(m["Out"]));
    }
    if (m.find("SourceID") != m.end() && !m["SourceID"].empty()) {
      sourceID = make_shared<string>(boost::any_cast<string>(m["SourceID"]));
    }
    if (m.find("SourceStrmMap") != m.end() && !m["SourceStrmMap"].empty()) {
      sourceStrmMap = make_shared<string>(boost::any_cast<string>(m["SourceStrmMap"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip>> clip{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clip) {
      vector<boost::any> temp1;
      for(auto item1:*clip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(vector<boost::any>) == m["Clip"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clip = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipListClip>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio : public Darabonba::Model {
public:
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> samplerate{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> isGpuData{};
  shared_ptr<string> isOneTrackData{};
  shared_ptr<string> reclosePrec{};
  shared_ptr<string> renderRatio{};
  shared_ptr<string> width{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (isGpuData) {
      res["IsGpuData"] = boost::any(*isGpuData);
    }
    if (isOneTrackData) {
      res["IsOneTrackData"] = boost::any(*isOneTrackData);
    }
    if (reclosePrec) {
      res["ReclosePrec"] = boost::any(*reclosePrec);
    }
    if (renderRatio) {
      res["RenderRatio"] = boost::any(*renderRatio);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("IsGpuData") != m.end() && !m["IsGpuData"].empty()) {
      isGpuData = make_shared<string>(boost::any_cast<string>(m["IsGpuData"]));
    }
    if (m.find("IsOneTrackData") != m.end() && !m["IsOneTrackData"].empty()) {
      isOneTrackData = make_shared<string>(boost::any_cast<string>(m["IsOneTrackData"]));
    }
    if (m.find("ReclosePrec") != m.end() && !m["ReclosePrec"].empty()) {
      reclosePrec = make_shared<string>(boost::any_cast<string>(m["ReclosePrec"]));
    }
    if (m.find("RenderRatio") != m.end() && !m["RenderRatio"].empty()) {
      renderRatio = make_shared<string>(boost::any_cast<string>(m["RenderRatio"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio> timelineConfigAudio{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo> timelineConfigVideo{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timelineConfigAudio) {
      res["TimelineConfigAudio"] = timelineConfigAudio ? boost::any(timelineConfigAudio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timelineConfigVideo) {
      res["TimelineConfigVideo"] = timelineConfigVideo ? boost::any(timelineConfigVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimelineConfigAudio") != m.end() && !m["TimelineConfigAudio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfigAudio"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfigAudio"]));
        timelineConfigAudio = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigAudio>(model1);
      }
    }
    if (m.find("TimelineConfigVideo") != m.end() && !m["TimelineConfigVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfigVideo"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfigVideo"]));
        timelineConfigVideo = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfigTimelineConfigVideo>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> l{};
  shared_ptr<string> t{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (l) {
      res["L"] = boost::any(*l);
    }
    if (t) {
      res["T"] = boost::any(*t);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("L") != m.end() && !m["L"].empty()) {
      l = make_shared<string>(boost::any_cast<string>(m["L"]));
    }
    if (m.find("T") != m.end() && !m["T"].empty()) {
      t = make_shared<string>(boost::any_cast<string>(m["T"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo> clipsConfigVideo{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsConfigVideo) {
      res["ClipsConfigVideo"] = clipsConfigVideo ? boost::any(clipsConfigVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsConfigVideo") != m.end() && !m["ClipsConfigVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipsConfigVideo"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipsConfigVideo"]));
        clipsConfigVideo = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfigClipsConfigVideo>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig> clipsConfig{};
  shared_ptr<string> in{};
  shared_ptr<string> out{};
  shared_ptr<string> clipID{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsConfig) {
      res["ClipsConfig"] = clipsConfig ? boost::any(clipsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (clipID) {
      res["clipID"] = boost::any(*clipID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsConfig") != m.end() && !m["ClipsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipsConfig"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipsConfig"]));
        clipsConfig = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClipClipsConfig>(model1);
      }
    }
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<string>(boost::any_cast<string>(m["In"]));
    }
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<string>(boost::any_cast<string>(m["Out"]));
    }
    if (m.find("clipID") != m.end() && !m["clipID"].empty()) {
      clipID = make_shared<string>(boost::any_cast<string>(m["clipID"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip>> clip{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clip) {
      vector<boost::any> temp1;
      for(auto item1:*clip){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clip"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(vector<boost::any>) == m["Clip"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clip"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clip = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClipsClip>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips> clips{};
  shared_ptr<string> id{};
  shared_ptr<string> order{};
  shared_ptr<string> type{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clips) {
      res["Clips"] = clips ? boost::any(clips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clips") != m.end() && !m["Clips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clips"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clips"]));
        clips = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrackClips>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack>> track{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (track) {
      vector<boost::any> temp1;
      for(auto item1:*track){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Track"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Track") != m.end() && !m["Track"].empty()) {
      if (typeid(vector<boost::any>) == m["Track"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Track"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        track = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackListTrack>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig> timelineConfig{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList> trackList{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timelineConfig) {
      res["TimelineConfig"] = timelineConfig ? boost::any(timelineConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trackList) {
      res["TrackList"] = trackList ? boost::any(trackList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimelineConfig") != m.end() && !m["TimelineConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineConfig"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineConfig"]));
        timelineConfig = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTimelineConfig>(model1);
      }
    }
    if (m.find("TrackList") != m.end() && !m["TrackList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrackList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrackList"]));
        trackList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimelineTrackList>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList> clipList{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline> timeline{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipList) {
      res["ClipList"] = clipList ? boost::any(clipList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipList") != m.end() && !m["ClipList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClipList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClipList"]));
        clipList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingClipList>(model1);
      }
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditingTimeline>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};
  shared_ptr<string> type{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> md5Support{};
  shared_ptr<bool> sizeSupport{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS> TS{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> start{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge>> merge{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif> gif{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment> segment{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList> videoStreamList{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> fileSize{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams> streams{};
  shared_ptr<string> width{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesFormat>(model1);
      }
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigPropertiesStreams>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle>> subtitle{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList> subtitleList{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> duration{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> referPos{};
  shared_ptr<string> type{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> width{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark>> waterMark{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip> clip{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer> container{};
  shared_ptr<string> deWatermark{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark> digiWaterMark{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing> editing{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption> encryption{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList> mergeList{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig> muxConfig{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile> outputFile{};
  shared_ptr<string> priority{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties> properties{};
  shared_ptr<string> rotate{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig> subtitleConfig{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso> superReso{};
  shared_ptr<string> templateId{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig> transConfig{};
  shared_ptr<string> userData{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo> video{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList> waterMarkList{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (digiWaterMark) {
      res["DigiWaterMark"] = digiWaterMark ? boost::any(digiWaterMark->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (editing) {
      res["Editing"] = editing ? boost::any(editing->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigClip>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigContainer>(model1);
      }
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("DigiWaterMark") != m.end() && !m["DigiWaterMark"].empty()) {
      if (typeid(map<string, boost::any>) == m["DigiWaterMark"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DigiWaterMark"]));
        digiWaterMark = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigDigiWaterMark>(model1);
      }
    }
    if (m.find("Editing") != m.end() && !m["Editing"].empty()) {
      if (typeid(map<string, boost::any>) == m["Editing"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Editing"]));
        editing = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEditing>(model1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigEncryption>(model1);
      }
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMergeList>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigMuxConfig>(model1);
      }
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigOutputFile>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigProperties>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSubtitleConfig>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigSuperReso>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigTransConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigVideo>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfigWaterMarkList>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig : public Darabonba::Model {
public:
  shared_ptr<string> deinterlaceMethod{};
  shared_ptr<string> isNormalSar{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deinterlaceMethod) {
      res["DeinterlaceMethod"] = boost::any(*deinterlaceMethod);
    }
    if (isNormalSar) {
      res["IsNormalSar"] = boost::any(*isNormalSar);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeinterlaceMethod") != m.end() && !m["DeinterlaceMethod"].empty()) {
      deinterlaceMethod = make_shared<string>(boost::any_cast<string>(m["DeinterlaceMethod"]));
    }
    if (m.find("IsNormalSar") != m.end() && !m["IsNormalSar"].empty()) {
      isNormalSar = make_shared<string>(boost::any_cast<string>(m["IsNormalSar"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig> inputConfig{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile> inputFile{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputConfig) {
      res["InputConfig"] = inputConfig ? boost::any(inputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputConfig"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputConfig"]));
        inputConfig = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputConfig>(model1);
      }
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInputInputFile>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput>> editingInput{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingInput) {
      vector<boost::any> temp1;
      for(auto item1:*editingInput){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EditingInput"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingInput") != m.end() && !m["EditingInput"].empty()) {
      if (typeid(vector<boost::any>) == m["EditingInput"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EditingInput"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        editingInput = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputsEditingInput>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResultJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig> editingConfig{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs> editingInputs{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> jobId{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<long> percent{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> state{};

  SubmitEditingJobsResponseBodyJobResultListJobResultJob() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResultJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (editingConfig) {
      res["EditingConfig"] = editingConfig ? boost::any(editingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (editingInputs) {
      res["EditingInputs"] = editingInputs ? boost::any(editingInputs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["EditingConfig"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EditingConfig"]));
        editingConfig = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingConfig>(model1);
      }
    }
    if (m.find("EditingInputs") != m.end() && !m["EditingInputs"].empty()) {
      if (typeid(map<string, boost::any>) == m["EditingInputs"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EditingInputs"]));
        editingInputs = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobEditingInputs>(model1);
      }
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResultJob() = default;
};
class SubmitEditingJobsResponseBodyJobResultListJobResult : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SubmitEditingJobsResponseBodyJobResultListJobResultJob> job{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  SubmitEditingJobsResponseBodyJobResultListJobResult() {}

  explicit SubmitEditingJobsResponseBodyJobResultListJobResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        SubmitEditingJobsResponseBodyJobResultListJobResultJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<SubmitEditingJobsResponseBodyJobResultListJobResultJob>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultListJobResult() = default;
};
class SubmitEditingJobsResponseBodyJobResultList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitEditingJobsResponseBodyJobResultListJobResult>> jobResult{};

  SubmitEditingJobsResponseBodyJobResultList() {}

  explicit SubmitEditingJobsResponseBodyJobResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobResult) {
      vector<boost::any> temp1;
      for(auto item1:*jobResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobResult") != m.end() && !m["JobResult"].empty()) {
      if (typeid(vector<boost::any>) == m["JobResult"].type()) {
        vector<SubmitEditingJobsResponseBodyJobResultListJobResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEditingJobsResponseBodyJobResultListJobResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobResult = make_shared<vector<SubmitEditingJobsResponseBodyJobResultListJobResult>>(expect1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponseBodyJobResultList() = default;
};
class SubmitEditingJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitEditingJobsResponseBodyJobResultList> jobResultList{};
  shared_ptr<string> requestId{};

  SubmitEditingJobsResponseBody() {}

  explicit SubmitEditingJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobResultList) {
      res["JobResultList"] = jobResultList ? boost::any(jobResultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobResultList") != m.end() && !m["JobResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobResultList"].type()) {
        SubmitEditingJobsResponseBodyJobResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobResultList"]));
        jobResultList = make_shared<SubmitEditingJobsResponseBodyJobResultList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitEditingJobsResponseBody() = default;
};
class SubmitEditingJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitEditingJobsResponseBody> body{};

  SubmitEditingJobsResponse() {}

  explicit SubmitEditingJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitEditingJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitEditingJobsResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitEditingJobsResponse() = default;
};
class SubmitJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> outputBucket{};
  shared_ptr<string> outputLocation{};
  shared_ptr<string> outputs{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  SubmitJobsRequest() {}

  explicit SubmitJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (outputBucket) {
      res["OutputBucket"] = boost::any(*outputBucket);
    }
    if (outputLocation) {
      res["OutputLocation"] = boost::any(*outputLocation);
    }
    if (outputs) {
      res["Outputs"] = boost::any(*outputs);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OutputBucket") != m.end() && !m["OutputBucket"].empty()) {
      outputBucket = make_shared<string>(boost::any_cast<string>(m["OutputBucket"]));
    }
    if (m.find("OutputLocation") != m.end() && !m["OutputLocation"].empty()) {
      outputLocation = make_shared<string>(boost::any_cast<string>(m["OutputLocation"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["Outputs"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~SubmitJobsRequest() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitJobsResponseBodyJobResultListJobResultJobInput() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobInput() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix : public Darabonba::Model {
public:
  shared_ptr<string> amixURL{};
  shared_ptr<string> duration{};
  shared_ptr<string> map{};
  shared_ptr<string> mixDurMode{};
  shared_ptr<string> start{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amixURL) {
      res["AmixURL"] = boost::any(*amixURL);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (map) {
      res["Map"] = boost::any(*map);
    }
    if (mixDurMode) {
      res["MixDurMode"] = boost::any(*mixDurMode);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AmixURL") != m.end() && !m["AmixURL"].empty()) {
      amixURL = make_shared<string>(boost::any_cast<string>(m["AmixURL"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
    if (m.find("MixDurMode") != m.end() && !m["MixDurMode"].empty()) {
      mixDurMode = make_shared<string>(boost::any_cast<string>(m["MixDurMode"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix>> amix{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amix) {
      vector<boost::any> temp1;
      for(auto item1:*amix){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Amix"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amix") != m.end() && !m["Amix"].empty()) {
      if (typeid(vector<boost::any>) == m["Amix"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Amix"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        amix = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixListAmix>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> method{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> samplerate{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume> volume{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputAudioVolume>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> seek{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputClip : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan> timeSpan{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputClip() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputClip(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputClipTimeSpan>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputClip() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> alpha{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile> inputFile{};
  shared_ptr<string> type{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alpha) {
      res["Alpha"] = boost::any(*alpha);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alpha") != m.end() && !m["Alpha"].empty()) {
      alpha = make_shared<string>(boost::any_cast<string>(m["Alpha"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMarkInputFile>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<string> keyType{};
  shared_ptr<string> keyUri{};
  shared_ptr<string> skipCnt{};
  shared_ptr<string> type{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (skipCnt) {
      res["SkipCnt"] = boost::any(*skipCnt);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("SkipCnt") != m.end() && !m["SkipCnt"].empty()) {
      skipCnt = make_shared<string>(boost::any_cast<string>(m["SkipCnt"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS : public Darabonba::Model {
public:
  shared_ptr<bool> md5Support{};
  shared_ptr<bool> sizeSupport{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (md5Support) {
      res["Md5Support"] = boost::any(*md5Support);
    }
    if (sizeSupport) {
      res["SizeSupport"] = boost::any(*sizeSupport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Md5Support") != m.end() && !m["Md5Support"].empty()) {
      md5Support = make_shared<bool>(boost::any_cast<bool>(m["Md5Support"]));
    }
    if (m.find("SizeSupport") != m.end() && !m["SizeSupport"].empty()) {
      sizeSupport = make_shared<bool>(boost::any_cast<bool>(m["SizeSupport"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS> TS{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (TS) {
      res["TS"] = TS ? boost::any(TS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      if (typeid(map<string, boost::any>) == m["TS"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TS"]));
        TS = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupportTS>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> mergeURL{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> start{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mergeURL) {
      res["MergeURL"] = boost::any(*mergeURL);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("MergeURL") != m.end() && !m["MergeURL"].empty()) {
      mergeURL = make_shared<string>(boost::any_cast<string>(m["MergeURL"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge>> merge{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merge) {
      vector<boost::any> temp1;
      for(auto item1:*merge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Merge"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      if (typeid(vector<boost::any>) == m["Merge"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Merge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        merge = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeListMerge>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif> gif{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment> segment{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp> webp{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigSegment>(model1);
      }
    }
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfigWebp>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening : public Darabonba::Model {
public:
  shared_ptr<string> height{};
  shared_ptr<string> start{};
  shared_ptr<string> width{};
  shared_ptr<string> openUrl{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (openUrl) {
      res["openUrl"] = boost::any(*openUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
    if (m.find("openUrl") != m.end() && !m["openUrl"].empty()) {
      openUrl = make_shared<string>(boost::any_cast<string>(m["openUrl"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening>> opening{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opening) {
      vector<boost::any> temp1;
      for(auto item1:*opening){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Opening"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Opening") != m.end() && !m["Opening"].empty()) {
      if (typeid(vector<boost::any>) == m["Opening"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Opening"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        opening = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningListOpening>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};
  shared_ptr<string> message{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile> outSubtitleFile{};
  shared_ptr<bool> success{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (outSubtitleFile) {
      res["OutSubtitleFile"] = outSubtitleFile ? boost::any(outSubtitleFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OutSubtitleFile") != m.end() && !m["OutSubtitleFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleFile"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleFile"]));
        outSubtitleFile = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitleOutSubtitleFile>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle>> outSubtitle{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*outSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutSubtitle") != m.end() && !m["OutSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["OutSubtitle"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outSubtitle = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleListOutSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList> videoStreamList{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> fileSize{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams> streams{};
  shared_ptr<string> width{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesFormat>(model1);
      }
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputPropertiesStreams>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<string> fontName{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput> input{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitleInput>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle>> extSubtitle{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitle) {
      vector<boost::any> temp1;
      for(auto item1:*extSubtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtSubtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitle") != m.end() && !m["ExtSubtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtSubtitle"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtSubtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extSubtitle = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleListExtSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> map{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (map) {
      res["Map"] = boost::any(*map);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Map") != m.end() && !m["Map"].empty()) {
      map = make_shared<string>(boost::any_cast<string>(m["Map"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle>> subtitle{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitle) {
      vector<boost::any> temp1;
      for(auto item1:*subtitle){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitle"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitle"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitle"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitle = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleListSubtitle>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList> extSubtitleList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList> subtitleList{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extSubtitleList) {
      res["ExtSubtitleList"] = extSubtitleList ? boost::any(extSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleList) {
      res["SubtitleList"] = subtitleList ? boost::any(subtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtSubtitleList") != m.end() && !m["ExtSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtSubtitleList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtSubtitleList"]));
        extSubtitleList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigExtSubtitleList>(model1);
      }
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleList"]));
        subtitleList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfigSubtitleList>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso : public Darabonba::Model {
public:
  shared_ptr<string> isHalfSample{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isHalfSample) {
      res["IsHalfSample"] = boost::any(*isHalfSample);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsHalfSample") != m.end() && !m["IsHalfSample"].empty()) {
      isHalfSample = make_shared<string>(boost::any_cast<string>(m["IsHalfSample"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate : public Darabonba::Model {
public:
  shared_ptr<string> bgColor{};
  shared_ptr<string> blendDuration{};
  shared_ptr<string> height{};
  shared_ptr<bool> isMergeAudio{};
  shared_ptr<string> start{};
  shared_ptr<string> tailUrl{};
  shared_ptr<string> width{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgColor) {
      res["BgColor"] = boost::any(*bgColor);
    }
    if (blendDuration) {
      res["BlendDuration"] = boost::any(*blendDuration);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (isMergeAudio) {
      res["IsMergeAudio"] = boost::any(*isMergeAudio);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (tailUrl) {
      res["TailUrl"] = boost::any(*tailUrl);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgColor") != m.end() && !m["BgColor"].empty()) {
      bgColor = make_shared<string>(boost::any_cast<string>(m["BgColor"]));
    }
    if (m.find("BlendDuration") != m.end() && !m["BlendDuration"].empty()) {
      blendDuration = make_shared<string>(boost::any_cast<string>(m["BlendDuration"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("IsMergeAudio") != m.end() && !m["IsMergeAudio"].empty()) {
      isMergeAudio = make_shared<bool>(boost::any_cast<bool>(m["IsMergeAudio"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("TailUrl") != m.end() && !m["TailUrl"].empty()) {
      tailUrl = make_shared<string>(boost::any_cast<string>(m["TailUrl"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate>> tailSlate{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tailSlate) {
      vector<boost::any> temp1;
      for(auto item1:*tailSlate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TailSlate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TailSlate") != m.end() && !m["TailSlate"].empty()) {
      if (typeid(vector<boost::any>) == m["TailSlate"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TailSlate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tailSlate = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateListTailSlate>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> resoPriority{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile> inputFile{};
  shared_ptr<string> referPos{};
  shared_ptr<string> type{};
  shared_ptr<string> waterMarkTemplateId{};
  shared_ptr<string> width{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMarkInputFile>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark>> waterMark{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (waterMark) {
      vector<boost::any> temp1;
      for(auto item1:*waterMark){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WaterMark"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WaterMark") != m.end() && !m["WaterMark"].empty()) {
      if (typeid(vector<boost::any>) == m["WaterMark"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WaterMark"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        waterMark = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkListWaterMark>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJobOutput : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList> amixList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio> audio{};
  shared_ptr<string> audioStreamMap{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputClip> clip{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer> container{};
  shared_ptr<string> deWatermark{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark> digiWaterMark{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption> encryption{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport> m3U8NonStandardSupport{};
  shared_ptr<string> mergeConfigUrl{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList> mergeList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig> muxConfig{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList> openingList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList> outSubtitleList{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile> outputFile{};
  shared_ptr<string> priority{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties> properties{};
  shared_ptr<string> rotate{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig> subtitleConfig{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso> superReso{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList> tailSlateList{};
  shared_ptr<string> templateId{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig> transConfig{};
  shared_ptr<string> userData{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo> video{};
  shared_ptr<string> videoStreamMap{};
  shared_ptr<string> waterMarkConfigUrl{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList> waterMarkList{};

  SubmitJobsResponseBodyJobResultListJobResultJobOutput() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJobOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amixList) {
      res["AmixList"] = amixList ? boost::any(amixList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioStreamMap) {
      res["AudioStreamMap"] = boost::any(*audioStreamMap);
    }
    if (clip) {
      res["Clip"] = clip ? boost::any(clip->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deWatermark) {
      res["DeWatermark"] = boost::any(*deWatermark);
    }
    if (digiWaterMark) {
      res["DigiWaterMark"] = digiWaterMark ? boost::any(digiWaterMark->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (m3U8NonStandardSupport) {
      res["M3U8NonStandardSupport"] = m3U8NonStandardSupport ? boost::any(m3U8NonStandardSupport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mergeConfigUrl) {
      res["MergeConfigUrl"] = boost::any(*mergeConfigUrl);
    }
    if (mergeList) {
      res["MergeList"] = mergeList ? boost::any(mergeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (openingList) {
      res["OpeningList"] = openingList ? boost::any(openingList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outSubtitleList) {
      res["OutSubtitleList"] = outSubtitleList ? boost::any(outSubtitleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (subtitleConfig) {
      res["SubtitleConfig"] = subtitleConfig ? boost::any(subtitleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (superReso) {
      res["SuperReso"] = superReso ? boost::any(superReso->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tailSlateList) {
      res["TailSlateList"] = tailSlateList ? boost::any(tailSlateList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamMap) {
      res["VideoStreamMap"] = boost::any(*videoStreamMap);
    }
    if (waterMarkConfigUrl) {
      res["WaterMarkConfigUrl"] = boost::any(*waterMarkConfigUrl);
    }
    if (waterMarkList) {
      res["WaterMarkList"] = waterMarkList ? boost::any(waterMarkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AmixList") != m.end() && !m["AmixList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AmixList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AmixList"]));
        amixList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputAmixList>(model1);
      }
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputAudio>(model1);
      }
    }
    if (m.find("AudioStreamMap") != m.end() && !m["AudioStreamMap"].empty()) {
      audioStreamMap = make_shared<string>(boost::any_cast<string>(m["AudioStreamMap"]));
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clip"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputClip model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clip"]));
        clip = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputClip>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputContainer>(model1);
      }
    }
    if (m.find("DeWatermark") != m.end() && !m["DeWatermark"].empty()) {
      deWatermark = make_shared<string>(boost::any_cast<string>(m["DeWatermark"]));
    }
    if (m.find("DigiWaterMark") != m.end() && !m["DigiWaterMark"].empty()) {
      if (typeid(map<string, boost::any>) == m["DigiWaterMark"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DigiWaterMark"]));
        digiWaterMark = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputDigiWaterMark>(model1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputEncryption>(model1);
      }
    }
    if (m.find("M3U8NonStandardSupport") != m.end() && !m["M3U8NonStandardSupport"].empty()) {
      if (typeid(map<string, boost::any>) == m["M3U8NonStandardSupport"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["M3U8NonStandardSupport"]));
        m3U8NonStandardSupport = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputM3U8NonStandardSupport>(model1);
      }
    }
    if (m.find("MergeConfigUrl") != m.end() && !m["MergeConfigUrl"].empty()) {
      mergeConfigUrl = make_shared<string>(boost::any_cast<string>(m["MergeConfigUrl"]));
    }
    if (m.find("MergeList") != m.end() && !m["MergeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MergeList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MergeList"]));
        mergeList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMergeList>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputMuxConfig>(model1);
      }
    }
    if (m.find("OpeningList") != m.end() && !m["OpeningList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpeningList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpeningList"]));
        openingList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputOpeningList>(model1);
      }
    }
    if (m.find("OutSubtitleList") != m.end() && !m["OutSubtitleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutSubtitleList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutSubtitleList"]));
        outSubtitleList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutSubtitleList>(model1);
      }
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputOutputFile>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputProperties>(model1);
      }
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("SubtitleConfig") != m.end() && !m["SubtitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleConfig"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleConfig"]));
        subtitleConfig = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSubtitleConfig>(model1);
      }
    }
    if (m.find("SuperReso") != m.end() && !m["SuperReso"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuperReso"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuperReso"]));
        superReso = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputSuperReso>(model1);
      }
    }
    if (m.find("TailSlateList") != m.end() && !m["TailSlateList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TailSlateList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TailSlateList"]));
        tailSlateList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputTailSlateList>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputTransConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputVideo>(model1);
      }
    }
    if (m.find("VideoStreamMap") != m.end() && !m["VideoStreamMap"].empty()) {
      videoStreamMap = make_shared<string>(boost::any_cast<string>(m["VideoStreamMap"]));
    }
    if (m.find("WaterMarkConfigUrl") != m.end() && !m["WaterMarkConfigUrl"].empty()) {
      waterMarkConfigUrl = make_shared<string>(boost::any_cast<string>(m["WaterMarkConfigUrl"]));
    }
    if (m.find("WaterMarkList") != m.end() && !m["WaterMarkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkList"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkList"]));
        waterMarkList = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutputWaterMarkList>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJobOutput() = default;
};
class SubmitJobsResponseBodyJobResultListJobResultJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJobOutput> output{};
  shared_ptr<long> percent{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> state{};

  SubmitJobsResponseBodyJobResultListJobResultJob() {}

  explicit SubmitJobsResponseBodyJobResultListJobResultJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJobOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitJobsResponseBodyJobResultListJobResultJobOutput>(model1);
      }
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResultJob() = default;
};
class SubmitJobsResponseBodyJobResultListJobResult : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SubmitJobsResponseBodyJobResultListJobResultJob> job{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  SubmitJobsResponseBodyJobResultListJobResult() {}

  explicit SubmitJobsResponseBodyJobResultListJobResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        SubmitJobsResponseBodyJobResultListJobResultJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<SubmitJobsResponseBodyJobResultListJobResultJob>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultListJobResult() = default;
};
class SubmitJobsResponseBodyJobResultList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitJobsResponseBodyJobResultListJobResult>> jobResult{};

  SubmitJobsResponseBodyJobResultList() {}

  explicit SubmitJobsResponseBodyJobResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobResult) {
      vector<boost::any> temp1;
      for(auto item1:*jobResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobResult") != m.end() && !m["JobResult"].empty()) {
      if (typeid(vector<boost::any>) == m["JobResult"].type()) {
        vector<SubmitJobsResponseBodyJobResultListJobResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitJobsResponseBodyJobResultListJobResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobResult = make_shared<vector<SubmitJobsResponseBodyJobResultListJobResult>>(expect1);
      }
    }
  }


  virtual ~SubmitJobsResponseBodyJobResultList() = default;
};
class SubmitJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitJobsResponseBodyJobResultList> jobResultList{};
  shared_ptr<string> requestId{};

  SubmitJobsResponseBody() {}

  explicit SubmitJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobResultList) {
      res["JobResultList"] = jobResultList ? boost::any(jobResultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobResultList") != m.end() && !m["JobResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobResultList"].type()) {
        SubmitJobsResponseBodyJobResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobResultList"]));
        jobResultList = make_shared<SubmitJobsResponseBodyJobResultList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitJobsResponseBody() = default;
};
class SubmitJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitJobsResponseBody> body{};

  SubmitJobsResponse() {}

  explicit SubmitJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitJobsResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitJobsResponse() = default;
};
class SubmitMediaInfoJobRequest : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> input{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> userData{};

  SubmitMediaInfoJobRequest() {}

  explicit SubmitMediaInfoJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaInfoJobRequest() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobInput() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobInput() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> numPrograms{};
  shared_ptr<string> numStreams{};
  shared_ptr<string> size{};
  shared_ptr<string> startTime{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (numPrograms) {
      res["NumPrograms"] = boost::any(*numPrograms);
    }
    if (numStreams) {
      res["NumStreams"] = boost::any(*numStreams);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("NumPrograms") != m.end() && !m["NumPrograms"].empty()) {
      numPrograms = make_shared<string>(boost::any_cast<string>(m["NumPrograms"]));
    }
    if (m.find("NumStreams") != m.end() && !m["NumStreams"].empty()) {
      numStreams = make_shared<string>(boost::any_cast<string>(m["NumStreams"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> samplerate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream>> audioStream{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStream) {
      vector<boost::any> temp1;
      for(auto item1:*audioStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStream") != m.end() && !m["AudioStream"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStream"].type()) {
        vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStream = make_shared<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamListAudioStream>>(expect1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> lang{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream>> subtitleStream{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtitleStream) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubtitleStream") != m.end() && !m["SubtitleStream"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStream"].type()) {
        vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStream = make_shared<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamListSubtitleStream>>(expect1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost : public Darabonba::Model {
public:
  shared_ptr<string> avgBitrate{};
  shared_ptr<string> costBandwidth{};
  shared_ptr<string> preloadTime{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgBitrate) {
      res["AvgBitrate"] = boost::any(*avgBitrate);
    }
    if (costBandwidth) {
      res["CostBandwidth"] = boost::any(*costBandwidth);
    }
    if (preloadTime) {
      res["PreloadTime"] = boost::any(*preloadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgBitrate") != m.end() && !m["AvgBitrate"].empty()) {
      avgBitrate = make_shared<string>(boost::any_cast<string>(m["AvgBitrate"]));
    }
    if (m.find("CostBandwidth") != m.end() && !m["CostBandwidth"].empty()) {
      costBandwidth = make_shared<string>(boost::any_cast<string>(m["CostBandwidth"]));
    }
    if (m.find("PreloadTime") != m.end() && !m["PreloadTime"].empty()) {
      preloadTime = make_shared<string>(boost::any_cast<string>(m["PreloadTime"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost> networkCost{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (networkCost) {
      res["NetworkCost"] = networkCost ? boost::any(networkCost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NetworkCost") != m.end() && !m["NetworkCost"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkCost"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkCost"]));
        networkCost = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStreamNetworkCost>(model1);
      }
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream>> videoStream{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoStream) {
      vector<boost::any> temp1;
      for(auto item1:*videoStream){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStream"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoStream") != m.end() && !m["VideoStream"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStream"].type()) {
        vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStream"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStream = make_shared<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamListVideoStream>>(expect1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams : public Darabonba::Model {
public:
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList> audioStreamList{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList> subtitleStreamList{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList> videoStreamList{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = audioStreamList ? boost::any(audioStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = subtitleStreamList ? boost::any(subtitleStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamList) {
      res["VideoStreamList"] = videoStreamList ? boost::any(videoStreamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioStreamList"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioStreamList"]));
        audioStreamList = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsAudioStreamList>(model1);
      }
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubtitleStreamList"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubtitleStreamList"]));
        subtitleStreamList = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsSubtitleStreamList>(model1);
      }
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoStreamList"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoStreamList"]));
        videoStreamList = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreamsVideoStreamList>(model1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobProperties : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> fileSize{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams> streams{};
  shared_ptr<string> width{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobProperties() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (format) {
      res["Format"] = format ? boost::any(format->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (streams) {
      res["Streams"] = streams ? boost::any(streams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      if (typeid(map<string, boost::any>) == m["Format"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Format"]));
        format = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesFormat>(model1);
      }
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(map<string, boost::any>) == m["Streams"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Streams"]));
        streams = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobPropertiesStreams>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobProperties() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJob : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobProperties> properties{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};

  SubmitMediaInfoJobResponseBodyMediaInfoJob() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobProperties>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJob() = default;
};
class SubmitMediaInfoJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJob> mediaInfoJob{};
  shared_ptr<string> requestId{};

  SubmitMediaInfoJobResponseBody() {}

  explicit SubmitMediaInfoJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJob) {
      res["MediaInfoJob"] = mediaInfoJob ? boost::any(mediaInfoJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJob") != m.end() && !m["MediaInfoJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoJob"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoJob"]));
        mediaInfoJob = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBody() = default;
};
class SubmitMediaInfoJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitMediaInfoJobResponseBody> body{};

  SubmitMediaInfoJobResponse() {}

  explicit SubmitMediaInfoJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaInfoJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaInfoJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponse() = default;
};
class SubmitSnapshotJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> snapshotConfig{};
  shared_ptr<string> userData{};

  SubmitSnapshotJobRequest() {}

  explicit SubmitSnapshotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (snapshotConfig) {
      res["SnapshotConfig"] = boost::any(*snapshotConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SnapshotConfig") != m.end() && !m["SnapshotConfig"].empty()) {
      snapshotConfig = make_shared<string>(boost::any_cast<string>(m["SnapshotConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSnapshotJobRequest() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  SubmitSnapshotJobResponseBodySnapshotJobInput() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobInput() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> messageId{};

  SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut : public Darabonba::Model {
public:
  shared_ptr<string> cellHeight{};
  shared_ptr<string> cellSelStep{};
  shared_ptr<string> cellWidth{};
  shared_ptr<string> color{};
  shared_ptr<string> columns{};
  shared_ptr<string> isKeepCellPic{};
  shared_ptr<string> lines{};
  shared_ptr<string> margin{};
  shared_ptr<string> padding{};

  SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cellHeight) {
      res["CellHeight"] = boost::any(*cellHeight);
    }
    if (cellSelStep) {
      res["CellSelStep"] = boost::any(*cellSelStep);
    }
    if (cellWidth) {
      res["CellWidth"] = boost::any(*cellWidth);
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (isKeepCellPic) {
      res["IsKeepCellPic"] = boost::any(*isKeepCellPic);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (margin) {
      res["Margin"] = boost::any(*margin);
    }
    if (padding) {
      res["Padding"] = boost::any(*padding);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CellHeight") != m.end() && !m["CellHeight"].empty()) {
      cellHeight = make_shared<string>(boost::any_cast<string>(m["CellHeight"]));
    }
    if (m.find("CellSelStep") != m.end() && !m["CellSelStep"].empty()) {
      cellSelStep = make_shared<string>(boost::any_cast<string>(m["CellSelStep"]));
    }
    if (m.find("CellWidth") != m.end() && !m["CellWidth"].empty()) {
      cellWidth = make_shared<string>(boost::any_cast<string>(m["CellWidth"]));
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      columns = make_shared<string>(boost::any_cast<string>(m["Columns"]));
    }
    if (m.find("IsKeepCellPic") != m.end() && !m["IsKeepCellPic"].empty()) {
      isKeepCellPic = make_shared<string>(boost::any_cast<string>(m["IsKeepCellPic"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<string>(boost::any_cast<string>(m["Lines"]));
    }
    if (m.find("Margin") != m.end() && !m["Margin"].empty()) {
      margin = make_shared<string>(boost::any_cast<string>(m["Margin"]));
    }
    if (m.find("Padding") != m.end() && !m["Padding"].empty()) {
      padding = make_shared<string>(boost::any_cast<string>(m["Padding"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<string> roleArn{};

  SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig : public Darabonba::Model {
public:
  shared_ptr<string> frameType{};
  shared_ptr<string> height{};
  shared_ptr<string> interval{};
  shared_ptr<string> num{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile> outputFile{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut> tileOut{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile> tileOutputFile{};
  shared_ptr<string> time{};
  shared_ptr<string> width{};

  SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameType) {
      res["FrameType"] = boost::any(*frameType);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (num) {
      res["Num"] = boost::any(*num);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tileOut) {
      res["TileOut"] = tileOut ? boost::any(tileOut->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tileOutputFile) {
      res["TileOutputFile"] = tileOutputFile ? boost::any(tileOutputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameType") != m.end() && !m["FrameType"].empty()) {
      frameType = make_shared<string>(boost::any_cast<string>(m["FrameType"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("Num") != m.end() && !m["Num"].empty()) {
      num = make_shared<string>(boost::any_cast<string>(m["Num"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigOutputFile>(model1);
      }
    }
    if (m.find("TileOut") != m.end() && !m["TileOut"].empty()) {
      if (typeid(map<string, boost::any>) == m["TileOut"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TileOut"]));
        tileOut = make_shared<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOut>(model1);
      }
    }
    if (m.find("TileOutputFile") != m.end() && !m["TileOutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["TileOutputFile"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TileOutputFile"]));
        tileOutputFile = make_shared<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfigTileOutputFile>(model1);
      }
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> id{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobInput> input{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult> MNSMessageResult{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig> snapshotConfig{};
  shared_ptr<string> state{};
  shared_ptr<string> tileCount{};
  shared_ptr<string> userData{};

  SubmitSnapshotJobResponseBodySnapshotJob() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (MNSMessageResult) {
      res["MNSMessageResult"] = MNSMessageResult ? boost::any(MNSMessageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (snapshotConfig) {
      res["SnapshotConfig"] = snapshotConfig ? boost::any(snapshotConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tileCount) {
      res["TileCount"] = boost::any(*tileCount);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitSnapshotJobResponseBodySnapshotJobInput>(model1);
      }
    }
    if (m.find("MNSMessageResult") != m.end() && !m["MNSMessageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNSMessageResult"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNSMessageResult"]));
        MNSMessageResult = make_shared<SubmitSnapshotJobResponseBodySnapshotJobMNSMessageResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("SnapshotConfig") != m.end() && !m["SnapshotConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotConfig"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotConfig"]));
        snapshotConfig = make_shared<SubmitSnapshotJobResponseBodySnapshotJobSnapshotConfig>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TileCount") != m.end() && !m["TileCount"].empty()) {
      tileCount = make_shared<string>(boost::any_cast<string>(m["TileCount"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJob() = default;
};
class SubmitSnapshotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJob> snapshotJob{};

  SubmitSnapshotJobResponseBody() {}

  explicit SubmitSnapshotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotJob) {
      res["SnapshotJob"] = snapshotJob ? boost::any(snapshotJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotJob") != m.end() && !m["SnapshotJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotJob"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotJob"]));
        snapshotJob = make_shared<SubmitSnapshotJobResponseBodySnapshotJob>(model1);
      }
    }
  }


  virtual ~SubmitSnapshotJobResponseBody() = default;
};
class SubmitSnapshotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSnapshotJobResponseBody> body{};

  SubmitSnapshotJobResponse() {}

  explicit SubmitSnapshotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSnapshotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSnapshotJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSnapshotJobResponse() = default;
};
class UnbindInputBucketRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> roleArn{};

  UnbindInputBucketRequest() {}

  explicit UnbindInputBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~UnbindInputBucketRequest() = default;
};
class UnbindInputBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindInputBucketResponseBody() {}

  explicit UnbindInputBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindInputBucketResponseBody() = default;
};
class UnbindInputBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindInputBucketResponseBody> body{};

  UnbindInputBucketResponse() {}

  explicit UnbindInputBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindInputBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindInputBucketResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindInputBucketResponse() = default;
};
class UnbindOutputBucketRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UnbindOutputBucketRequest() {}

  explicit UnbindOutputBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UnbindOutputBucketRequest() = default;
};
class UnbindOutputBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindOutputBucketResponseBody() {}

  explicit UnbindOutputBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindOutputBucketResponseBody() = default;
};
class UnbindOutputBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindOutputBucketResponseBody> body{};

  UnbindOutputBucketResponse() {}

  explicit UnbindOutputBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindOutputBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindOutputBucketResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindOutputBucketResponse() = default;
};
class UpdateCategoryNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UpdateCategoryNameRequest() {}

  explicit UpdateCategoryNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<string>(boost::any_cast<string>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UpdateCategoryNameRequest() = default;
};
class UpdateCategoryNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCategoryNameResponseBody() {}

  explicit UpdateCategoryNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCategoryNameResponseBody() = default;
};
class UpdateCategoryNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCategoryNameResponseBody> body{};

  UpdateCategoryNameResponse() {}

  explicit UpdateCategoryNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCategoryNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCategoryNameResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCategoryNameResponse() = default;
};
class UpdateMediaRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};

  UpdateMediaRequest() {}

  explicit UpdateMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateMediaRequest() = default;
};
class UpdateMediaResponseBodyMediaFile : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<string> URL{};

  UpdateMediaResponseBodyMediaFile() {}

  explicit UpdateMediaResponseBodyMediaFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~UpdateMediaResponseBodyMediaFile() = default;
};
class UpdateMediaResponseBodyMediaRunIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> runId{};

  UpdateMediaResponseBodyMediaRunIdList() {}

  explicit UpdateMediaResponseBodyMediaRunIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (runId) {
      res["RunId"] = boost::any(*runId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RunId") != m.end() && !m["RunId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateMediaResponseBodyMediaRunIdList() = default;
};
class UpdateMediaResponseBodyMediaTags : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tag{};

  UpdateMediaResponseBodyMediaTags() {}

  explicit UpdateMediaResponseBodyMediaTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tag"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tag = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateMediaResponseBodyMediaTags() = default;
};
class UpdateMediaResponseBodyMedia : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<long> cateId{};
  shared_ptr<string> censorState{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> duration{};
  shared_ptr<UpdateMediaResponseBodyMediaFile> file{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> publishState{};
  shared_ptr<UpdateMediaResponseBodyMediaRunIdList> runIdList{};
  shared_ptr<string> size{};
  shared_ptr<UpdateMediaResponseBodyMediaTags> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> width{};

  UpdateMediaResponseBodyMedia() {}

  explicit UpdateMediaResponseBodyMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (censorState) {
      res["CensorState"] = boost::any(*censorState);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (runIdList) {
      res["RunIdList"] = runIdList ? boost::any(runIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CensorState") != m.end() && !m["CensorState"].empty()) {
      censorState = make_shared<string>(boost::any_cast<string>(m["CensorState"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        UpdateMediaResponseBodyMediaFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<UpdateMediaResponseBodyMediaFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<string>(boost::any_cast<string>(m["PublishState"]));
    }
    if (m.find("RunIdList") != m.end() && !m["RunIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RunIdList"].type()) {
        UpdateMediaResponseBodyMediaRunIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RunIdList"]));
        runIdList = make_shared<UpdateMediaResponseBodyMediaRunIdList>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        UpdateMediaResponseBodyMediaTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<UpdateMediaResponseBodyMediaTags>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~UpdateMediaResponseBodyMedia() = default;
};
class UpdateMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateMediaResponseBodyMedia> media{};
  shared_ptr<string> requestId{};

  UpdateMediaResponseBody() {}

  explicit UpdateMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = media ? boost::any(media->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(map<string, boost::any>) == m["Media"].type()) {
        UpdateMediaResponseBodyMedia model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Media"]));
        media = make_shared<UpdateMediaResponseBodyMedia>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaResponseBody() = default;
};
class UpdateMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaResponseBody> body{};

  UpdateMediaResponse() {}

  explicit UpdateMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaResponse() = default;
};
class UpdateMediaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UpdateMediaCategoryRequest() {}

  explicit UpdateMediaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UpdateMediaCategoryRequest() = default;
};
class UpdateMediaCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateMediaCategoryResponseBody() {}

  explicit UpdateMediaCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaCategoryResponseBody() = default;
};
class UpdateMediaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaCategoryResponseBody> body{};

  UpdateMediaCategoryResponse() {}

  explicit UpdateMediaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaCategoryResponse() = default;
};
class UpdateMediaCoverRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UpdateMediaCoverRequest() {}

  explicit UpdateMediaCoverRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UpdateMediaCoverRequest() = default;
};
class UpdateMediaCoverResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateMediaCoverResponseBody() {}

  explicit UpdateMediaCoverResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaCoverResponseBody() = default;
};
class UpdateMediaCoverResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaCoverResponseBody> body{};

  UpdateMediaCoverResponse() {}

  explicit UpdateMediaCoverResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaCoverResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaCoverResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaCoverResponse() = default;
};
class UpdateMediaPublishStateRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<bool> publish{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  UpdateMediaPublishStateRequest() {}

  explicit UpdateMediaPublishStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (publish) {
      res["Publish"] = boost::any(*publish);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Publish") != m.end() && !m["Publish"].empty()) {
      publish = make_shared<bool>(boost::any_cast<bool>(m["Publish"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~UpdateMediaPublishStateRequest() = default;
};
class UpdateMediaPublishStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateMediaPublishStateResponseBody() {}

  explicit UpdateMediaPublishStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaPublishStateResponseBody() = default;
};
class UpdateMediaPublishStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaPublishStateResponseBody> body{};

  UpdateMediaPublishStateResponse() {}

  explicit UpdateMediaPublishStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaPublishStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaPublishStateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaPublishStateResponse() = default;
};
class UpdateMediaWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> topology{};

  UpdateMediaWorkflowRequest() {}

  explicit UpdateMediaWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
  }


  virtual ~UpdateMediaWorkflowRequest() = default;
};
class UpdateMediaWorkflowResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};
  shared_ptr<string> triggerMode{};

  UpdateMediaWorkflowResponseBodyMediaWorkflow() {}

  explicit UpdateMediaWorkflowResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~UpdateMediaWorkflowResponseBodyMediaWorkflow() = default;
};
class UpdateMediaWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateMediaWorkflowResponseBodyMediaWorkflow> mediaWorkflow{};
  shared_ptr<string> requestId{};

  UpdateMediaWorkflowResponseBody() {}

  explicit UpdateMediaWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        UpdateMediaWorkflowResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<UpdateMediaWorkflowResponseBodyMediaWorkflow>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaWorkflowResponseBody() = default;
};
class UpdateMediaWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaWorkflowResponseBody> body{};

  UpdateMediaWorkflowResponse() {}

  explicit UpdateMediaWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaWorkflowResponse() = default;
};
class UpdateMediaWorkflowTriggerModeRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> triggerMode{};

  UpdateMediaWorkflowTriggerModeRequest() {}

  explicit UpdateMediaWorkflowTriggerModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~UpdateMediaWorkflowTriggerModeRequest() = default;
};
class UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaWorkflowId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> topology{};
  shared_ptr<string> triggerMode{};

  UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow() {}

  explicit UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaWorkflowId) {
      res["MediaWorkflowId"] = boost::any(*mediaWorkflowId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (triggerMode) {
      res["TriggerMode"] = boost::any(*triggerMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaWorkflowId") != m.end() && !m["MediaWorkflowId"].empty()) {
      mediaWorkflowId = make_shared<string>(boost::any_cast<string>(m["MediaWorkflowId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("TriggerMode") != m.end() && !m["TriggerMode"].empty()) {
      triggerMode = make_shared<string>(boost::any_cast<string>(m["TriggerMode"]));
    }
  }


  virtual ~UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow() = default;
};
class UpdateMediaWorkflowTriggerModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow> mediaWorkflow{};
  shared_ptr<string> requestId{};

  UpdateMediaWorkflowTriggerModeResponseBody() {}

  explicit UpdateMediaWorkflowTriggerModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaWorkflow) {
      res["MediaWorkflow"] = mediaWorkflow ? boost::any(mediaWorkflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaWorkflow") != m.end() && !m["MediaWorkflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaWorkflow"].type()) {
        UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaWorkflow"]));
        mediaWorkflow = make_shared<UpdateMediaWorkflowTriggerModeResponseBodyMediaWorkflow>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaWorkflowTriggerModeResponseBody() = default;
};
class UpdateMediaWorkflowTriggerModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaWorkflowTriggerModeResponseBody> body{};

  UpdateMediaWorkflowTriggerModeResponse() {}

  explicit UpdateMediaWorkflowTriggerModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaWorkflowTriggerModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaWorkflowTriggerModeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaWorkflowTriggerModeResponse() = default;
};
class UpdatePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> notifyConfig{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> role{};
  shared_ptr<string> state{};

  UpdatePipelineRequest() {}

  explicit UpdatePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = boost::any(*notifyConfig);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      notifyConfig = make_shared<string>(boost::any_cast<string>(m["NotifyConfig"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~UpdatePipelineRequest() = default;
};
class UpdatePipelineResponseBodyPipelineNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> queueName{};
  shared_ptr<string> topic{};

  UpdatePipelineResponseBodyPipelineNotifyConfig() {}

  explicit UpdatePipelineResponseBodyPipelineNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~UpdatePipelineResponseBodyPipelineNotifyConfig() = default;
};
class UpdatePipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<UpdatePipelineResponseBodyPipelineNotifyConfig> notifyConfig{};
  shared_ptr<string> role{};
  shared_ptr<string> speed{};
  shared_ptr<string> state{};

  UpdatePipelineResponseBodyPipeline() {}

  explicit UpdatePipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyConfig) {
      res["NotifyConfig"] = notifyConfig ? boost::any(notifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyConfig") != m.end() && !m["NotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfig"].type()) {
        UpdatePipelineResponseBodyPipelineNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfig"]));
        notifyConfig = make_shared<UpdatePipelineResponseBodyPipelineNotifyConfig>(model1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~UpdatePipelineResponseBodyPipeline() = default;
};
class UpdatePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdatePipelineResponseBodyPipeline> pipeline{};
  shared_ptr<string> requestId{};

  UpdatePipelineResponseBody() {}

  explicit UpdatePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        UpdatePipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<UpdatePipelineResponseBodyPipeline>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdatePipelineResponseBody() = default;
};
class UpdatePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePipelineResponseBody> body{};

  UpdatePipelineResponse() {}

  explicit UpdatePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePipelineResponse() = default;
};
class UpdateTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> audio{};
  shared_ptr<string> container{};
  shared_ptr<string> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> transConfig{};
  shared_ptr<string> video{};

  UpdateTemplateRequest() {}

  explicit UpdateTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = boost::any(*audio);
    }
    if (container) {
      res["Container"] = boost::any(*container);
    }
    if (muxConfig) {
      res["MuxConfig"] = boost::any(*muxConfig);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (transConfig) {
      res["TransConfig"] = boost::any(*transConfig);
    }
    if (video) {
      res["Video"] = boost::any(*video);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      audio = make_shared<string>(boost::any_cast<string>(m["Audio"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      container = make_shared<string>(boost::any_cast<string>(m["Container"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      muxConfig = make_shared<string>(boost::any_cast<string>(m["MuxConfig"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      transConfig = make_shared<string>(boost::any_cast<string>(m["TransConfig"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      video = make_shared<string>(boost::any_cast<string>(m["Video"]));
    }
  }


  virtual ~UpdateTemplateRequest() = default;
};
class UpdateTemplateResponseBodyTemplateAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};

  UpdateTemplateResponseBodyTemplateAudio() {}

  explicit UpdateTemplateResponseBodyTemplateAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateAudio() = default;
};
class UpdateTemplateResponseBodyTemplateContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  UpdateTemplateResponseBodyTemplateContainer() {}

  explicit UpdateTemplateResponseBodyTemplateContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateContainer() = default;
};
class UpdateTemplateResponseBodyTemplateMuxConfigGif : public Darabonba::Model {
public:
  shared_ptr<string> ditherMode{};
  shared_ptr<string> finalDelay{};
  shared_ptr<string> isCustomPalette{};
  shared_ptr<string> loop{};

  UpdateTemplateResponseBodyTemplateMuxConfigGif() {}

  explicit UpdateTemplateResponseBodyTemplateMuxConfigGif(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ditherMode) {
      res["DitherMode"] = boost::any(*ditherMode);
    }
    if (finalDelay) {
      res["FinalDelay"] = boost::any(*finalDelay);
    }
    if (isCustomPalette) {
      res["IsCustomPalette"] = boost::any(*isCustomPalette);
    }
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DitherMode") != m.end() && !m["DitherMode"].empty()) {
      ditherMode = make_shared<string>(boost::any_cast<string>(m["DitherMode"]));
    }
    if (m.find("FinalDelay") != m.end() && !m["FinalDelay"].empty()) {
      finalDelay = make_shared<string>(boost::any_cast<string>(m["FinalDelay"]));
    }
    if (m.find("IsCustomPalette") != m.end() && !m["IsCustomPalette"].empty()) {
      isCustomPalette = make_shared<string>(boost::any_cast<string>(m["IsCustomPalette"]));
    }
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateMuxConfigGif() = default;
};
class UpdateTemplateResponseBodyTemplateMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};

  UpdateTemplateResponseBodyTemplateMuxConfigSegment() {}

  explicit UpdateTemplateResponseBodyTemplateMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateMuxConfigSegment() = default;
};
class UpdateTemplateResponseBodyTemplateMuxConfigWebp : public Darabonba::Model {
public:
  shared_ptr<string> loop{};

  UpdateTemplateResponseBodyTemplateMuxConfigWebp() {}

  explicit UpdateTemplateResponseBodyTemplateMuxConfigWebp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loop) {
      res["Loop"] = boost::any(*loop);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loop") != m.end() && !m["Loop"].empty()) {
      loop = make_shared<string>(boost::any_cast<string>(m["Loop"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateMuxConfigWebp() = default;
};
class UpdateTemplateResponseBodyTemplateMuxConfig : public Darabonba::Model {
public:
  shared_ptr<UpdateTemplateResponseBodyTemplateMuxConfigGif> gif{};
  shared_ptr<UpdateTemplateResponseBodyTemplateMuxConfigSegment> segment{};
  shared_ptr<UpdateTemplateResponseBodyTemplateMuxConfigWebp> webp{};

  UpdateTemplateResponseBodyTemplateMuxConfig() {}

  explicit UpdateTemplateResponseBodyTemplateMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gif) {
      res["Gif"] = gif ? boost::any(gif->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webp) {
      res["Webp"] = webp ? boost::any(webp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gif") != m.end() && !m["Gif"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gif"].type()) {
        UpdateTemplateResponseBodyTemplateMuxConfigGif model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gif"]));
        gif = make_shared<UpdateTemplateResponseBodyTemplateMuxConfigGif>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        UpdateTemplateResponseBodyTemplateMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<UpdateTemplateResponseBodyTemplateMuxConfigSegment>(model1);
      }
    }
    if (m.find("Webp") != m.end() && !m["Webp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Webp"].type()) {
        UpdateTemplateResponseBodyTemplateMuxConfigWebp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Webp"]));
        webp = make_shared<UpdateTemplateResponseBodyTemplateMuxConfigWebp>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateMuxConfig() = default;
};
class UpdateTemplateResponseBodyTemplateTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  UpdateTemplateResponseBodyTemplateTransConfig() {}

  explicit UpdateTemplateResponseBodyTemplateTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateTransConfig() = default;
};
class UpdateTemplateResponseBodyTemplateVideoBitrateBnd : public Darabonba::Model {
public:
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  UpdateTemplateResponseBodyTemplateVideoBitrateBnd() {}

  explicit UpdateTemplateResponseBodyTemplateVideoBitrateBnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateVideoBitrateBnd() = default;
};
class UpdateTemplateResponseBodyTemplateVideo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<UpdateTemplateResponseBodyTemplateVideoBitrateBnd> bitrateBnd{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> degrain{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> maxFps{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> qscale{};
  shared_ptr<string> remove{};
  shared_ptr<string> resoPriority{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  UpdateTemplateResponseBodyTemplateVideo() {}

  explicit UpdateTemplateResponseBodyTemplateVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateBnd) {
      res["BitrateBnd"] = bitrateBnd ? boost::any(bitrateBnd->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (degrain) {
      res["Degrain"] = boost::any(*degrain);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (resoPriority) {
      res["ResoPriority"] = boost::any(*resoPriority);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("BitrateBnd") != m.end() && !m["BitrateBnd"].empty()) {
      if (typeid(map<string, boost::any>) == m["BitrateBnd"].type()) {
        UpdateTemplateResponseBodyTemplateVideoBitrateBnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BitrateBnd"]));
        bitrateBnd = make_shared<UpdateTemplateResponseBodyTemplateVideoBitrateBnd>(model1);
      }
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Degrain") != m.end() && !m["Degrain"].empty()) {
      degrain = make_shared<string>(boost::any_cast<string>(m["Degrain"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<string>(boost::any_cast<string>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<string>(boost::any_cast<string>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ResoPriority") != m.end() && !m["ResoPriority"].empty()) {
      resoPriority = make_shared<string>(boost::any_cast<string>(m["ResoPriority"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplateVideo() = default;
};
class UpdateTemplateResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<UpdateTemplateResponseBodyTemplateAudio> audio{};
  shared_ptr<UpdateTemplateResponseBodyTemplateContainer> container{};
  shared_ptr<string> id{};
  shared_ptr<UpdateTemplateResponseBodyTemplateMuxConfig> muxConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<UpdateTemplateResponseBodyTemplateTransConfig> transConfig{};
  shared_ptr<UpdateTemplateResponseBodyTemplateVideo> video{};

  UpdateTemplateResponseBodyTemplate() {}

  explicit UpdateTemplateResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        UpdateTemplateResponseBodyTemplateAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<UpdateTemplateResponseBodyTemplateAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        UpdateTemplateResponseBodyTemplateContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<UpdateTemplateResponseBodyTemplateContainer>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        UpdateTemplateResponseBodyTemplateMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<UpdateTemplateResponseBodyTemplateMuxConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        UpdateTemplateResponseBodyTemplateTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<UpdateTemplateResponseBodyTemplateTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        UpdateTemplateResponseBodyTemplateVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<UpdateTemplateResponseBodyTemplateVideo>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponseBodyTemplate() = default;
};
class UpdateTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateTemplateResponseBodyTemplate> template_{};

  UpdateTemplateResponseBody() {}

  explicit UpdateTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(map<string, boost::any>) == m["Template"].type()) {
        UpdateTemplateResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Template"]));
        template_ = make_shared<UpdateTemplateResponseBodyTemplate>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponseBody() = default;
};
class UpdateTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTemplateResponseBody> body{};

  UpdateTemplateResponse() {}

  explicit UpdateTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponse() = default;
};
class UpdateWaterMarkTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> waterMarkTemplateId{};

  UpdateWaterMarkTemplateRequest() {}

  explicit UpdateWaterMarkTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (waterMarkTemplateId) {
      res["WaterMarkTemplateId"] = boost::any(*waterMarkTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("WaterMarkTemplateId") != m.end() && !m["WaterMarkTemplateId"].empty()) {
      waterMarkTemplateId = make_shared<string>(boost::any_cast<string>(m["WaterMarkTemplateId"]));
    }
  }


  virtual ~UpdateWaterMarkTemplateRequest() = default;
};
class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> width{};

  UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer() {}

  explicit UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer() = default;
};
class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline() {}

  explicit UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline() = default;
};
class UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<string> height{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer> ratioRefer{};
  shared_ptr<string> referPos{};
  shared_ptr<string> state{};
  shared_ptr<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline> timeline{};
  shared_ptr<string> type{};
  shared_ptr<string> width{};

  UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate() {}

  explicit UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ratioRefer) {
      res["RatioRefer"] = ratioRefer ? boost::any(ratioRefer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RatioRefer") != m.end() && !m["RatioRefer"].empty()) {
      if (typeid(map<string, boost::any>) == m["RatioRefer"].type()) {
        UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RatioRefer"]));
        ratioRefer = make_shared<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateRatioRefer>(model1);
      }
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplateTimeline>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate() = default;
};
class UpdateWaterMarkTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate> waterMarkTemplate{};

  UpdateWaterMarkTemplateResponseBody() {}

  explicit UpdateWaterMarkTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (waterMarkTemplate) {
      res["WaterMarkTemplate"] = waterMarkTemplate ? boost::any(waterMarkTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WaterMarkTemplate") != m.end() && !m["WaterMarkTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["WaterMarkTemplate"].type()) {
        UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WaterMarkTemplate"]));
        waterMarkTemplate = make_shared<UpdateWaterMarkTemplateResponseBodyWaterMarkTemplate>(model1);
      }
    }
  }


  virtual ~UpdateWaterMarkTemplateResponseBody() = default;
};
class UpdateWaterMarkTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWaterMarkTemplateResponseBody> body{};

  UpdateWaterMarkTemplateResponse() {}

  explicit UpdateWaterMarkTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWaterMarkTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWaterMarkTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWaterMarkTemplateResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  ActivateMediaWorkflowResponse activateMediaWorkflowWithOptions(shared_ptr<ActivateMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ActivateMediaWorkflowResponse activateMediaWorkflow(shared_ptr<ActivateMediaWorkflowRequest> request);
  AddCategoryResponse addCategoryWithOptions(shared_ptr<AddCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCategoryResponse addCategory(shared_ptr<AddCategoryRequest> request);
  AddMediaResponse addMediaWithOptions(shared_ptr<AddMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMediaResponse addMedia(shared_ptr<AddMediaRequest> request);
  AddMediaTagResponse addMediaTagWithOptions(shared_ptr<AddMediaTagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMediaTagResponse addMediaTag(shared_ptr<AddMediaTagRequest> request);
  AddMediaWorkflowResponse addMediaWorkflowWithOptions(shared_ptr<AddMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMediaWorkflowResponse addMediaWorkflow(shared_ptr<AddMediaWorkflowRequest> request);
  AddPipelineResponse addPipelineWithOptions(shared_ptr<AddPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPipelineResponse addPipeline(shared_ptr<AddPipelineRequest> request);
  AddTemplateResponse addTemplateWithOptions(shared_ptr<AddTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTemplateResponse addTemplate(shared_ptr<AddTemplateRequest> request);
  AddWaterMarkTemplateResponse addWaterMarkTemplateWithOptions(shared_ptr<AddWaterMarkTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddWaterMarkTemplateResponse addWaterMarkTemplate(shared_ptr<AddWaterMarkTemplateRequest> request);
  BindInputBucketResponse bindInputBucketWithOptions(shared_ptr<BindInputBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindInputBucketResponse bindInputBucket(shared_ptr<BindInputBucketRequest> request);
  BindOutputBucketResponse bindOutputBucketWithOptions(shared_ptr<BindOutputBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindOutputBucketResponse bindOutputBucket(shared_ptr<BindOutputBucketRequest> request);
  CancelJobResponse cancelJobWithOptions(shared_ptr<CancelJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelJobResponse cancelJob(shared_ptr<CancelJobRequest> request);
  CategoryTreeResponse categoryTreeWithOptions(shared_ptr<CategoryTreeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CategoryTreeResponse categoryTree(shared_ptr<CategoryTreeRequest> request);
  DeactivateMediaWorkflowResponse deactivateMediaWorkflowWithOptions(shared_ptr<DeactivateMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeactivateMediaWorkflowResponse deactivateMediaWorkflow(shared_ptr<DeactivateMediaWorkflowRequest> request);
  DeleteCategoryResponse deleteCategoryWithOptions(shared_ptr<DeleteCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCategoryResponse deleteCategory(shared_ptr<DeleteCategoryRequest> request);
  DeleteMediaResponse deleteMediaWithOptions(shared_ptr<DeleteMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaResponse deleteMedia(shared_ptr<DeleteMediaRequest> request);
  DeleteMediaTagResponse deleteMediaTagWithOptions(shared_ptr<DeleteMediaTagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaTagResponse deleteMediaTag(shared_ptr<DeleteMediaTagRequest> request);
  DeleteMediaWorkflowResponse deleteMediaWorkflowWithOptions(shared_ptr<DeleteMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaWorkflowResponse deleteMediaWorkflow(shared_ptr<DeleteMediaWorkflowRequest> request);
  DeletePipelineResponse deletePipelineWithOptions(shared_ptr<DeletePipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePipelineResponse deletePipeline(shared_ptr<DeletePipelineRequest> request);
  DeleteTemplateResponse deleteTemplateWithOptions(shared_ptr<DeleteTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTemplateResponse deleteTemplate(shared_ptr<DeleteTemplateRequest> request);
  DeleteWaterMarkTemplateResponse deleteWaterMarkTemplateWithOptions(shared_ptr<DeleteWaterMarkTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWaterMarkTemplateResponse deleteWaterMarkTemplate(shared_ptr<DeleteWaterMarkTemplateRequest> request);
  DescribeMtsUserResourcePackageResponse describeMtsUserResourcePackageWithOptions(shared_ptr<DescribeMtsUserResourcePackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMtsUserResourcePackageResponse describeMtsUserResourcePackage(shared_ptr<DescribeMtsUserResourcePackageRequest> request);
  ListAllCategoryResponse listAllCategoryWithOptions(shared_ptr<ListAllCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAllCategoryResponse listAllCategory(shared_ptr<ListAllCategoryRequest> request);
  ListAllMediaBucketResponse listAllMediaBucketWithOptions(shared_ptr<ListAllMediaBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAllMediaBucketResponse listAllMediaBucket(shared_ptr<ListAllMediaBucketRequest> request);
  ListJobResponse listJobWithOptions(shared_ptr<ListJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJobResponse listJob(shared_ptr<ListJobRequest> request);
  ListMediaResponse listMediaWithOptions(shared_ptr<ListMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaResponse listMedia(shared_ptr<ListMediaRequest> request);
  ListMediaWorkflowExecutionsResponse listMediaWorkflowExecutionsWithOptions(shared_ptr<ListMediaWorkflowExecutionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaWorkflowExecutionsResponse listMediaWorkflowExecutions(shared_ptr<ListMediaWorkflowExecutionsRequest> request);
  QueryAnalysisJobListResponse queryAnalysisJobListWithOptions(shared_ptr<QueryAnalysisJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAnalysisJobListResponse queryAnalysisJobList(shared_ptr<QueryAnalysisJobListRequest> request);
  QueryEditingJobListResponse queryEditingJobListWithOptions(shared_ptr<QueryEditingJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEditingJobListResponse queryEditingJobList(shared_ptr<QueryEditingJobListRequest> request);
  QueryJobListResponse queryJobListWithOptions(shared_ptr<QueryJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryJobListResponse queryJobList(shared_ptr<QueryJobListRequest> request);
  QueryMediaInfoJobListResponse queryMediaInfoJobListWithOptions(shared_ptr<QueryMediaInfoJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaInfoJobListResponse queryMediaInfoJobList(shared_ptr<QueryMediaInfoJobListRequest> request);
  QueryMediaListResponse queryMediaListWithOptions(shared_ptr<QueryMediaListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaListResponse queryMediaList(shared_ptr<QueryMediaListRequest> request);
  QueryMediaListByURLResponse queryMediaListByURLWithOptions(shared_ptr<QueryMediaListByURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaListByURLResponse queryMediaListByURL(shared_ptr<QueryMediaListByURLRequest> request);
  QueryMediaWorkflowExecutionListResponse queryMediaWorkflowExecutionListWithOptions(shared_ptr<QueryMediaWorkflowExecutionListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaWorkflowExecutionListResponse queryMediaWorkflowExecutionList(shared_ptr<QueryMediaWorkflowExecutionListRequest> request);
  QueryMediaWorkflowListResponse queryMediaWorkflowListWithOptions(shared_ptr<QueryMediaWorkflowListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaWorkflowListResponse queryMediaWorkflowList(shared_ptr<QueryMediaWorkflowListRequest> request);
  QueryPipelineListResponse queryPipelineListWithOptions(shared_ptr<QueryPipelineListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPipelineListResponse queryPipelineList(shared_ptr<QueryPipelineListRequest> request);
  QuerySnapshotJobListResponse querySnapshotJobListWithOptions(shared_ptr<QuerySnapshotJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySnapshotJobListResponse querySnapshotJobList(shared_ptr<QuerySnapshotJobListRequest> request);
  QueryTemplateListResponse queryTemplateListWithOptions(shared_ptr<QueryTemplateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTemplateListResponse queryTemplateList(shared_ptr<QueryTemplateListRequest> request);
  QueryWaterMarkTemplateListResponse queryWaterMarkTemplateListWithOptions(shared_ptr<QueryWaterMarkTemplateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryWaterMarkTemplateListResponse queryWaterMarkTemplateList(shared_ptr<QueryWaterMarkTemplateListRequest> request);
  SearchMediaWorkflowResponse searchMediaWorkflowWithOptions(shared_ptr<SearchMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchMediaWorkflowResponse searchMediaWorkflow(shared_ptr<SearchMediaWorkflowRequest> request);
  SearchPipelineResponse searchPipelineWithOptions(shared_ptr<SearchPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchPipelineResponse searchPipeline(shared_ptr<SearchPipelineRequest> request);
  SearchTemplateResponse searchTemplateWithOptions(shared_ptr<SearchTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchTemplateResponse searchTemplate(shared_ptr<SearchTemplateRequest> request);
  SearchWaterMarkTemplateResponse searchWaterMarkTemplateWithOptions(shared_ptr<SearchWaterMarkTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchWaterMarkTemplateResponse searchWaterMarkTemplate(shared_ptr<SearchWaterMarkTemplateRequest> request);
  SubmitAnalysisJobResponse submitAnalysisJobWithOptions(shared_ptr<SubmitAnalysisJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAnalysisJobResponse submitAnalysisJob(shared_ptr<SubmitAnalysisJobRequest> request);
  SubmitEditingJobsResponse submitEditingJobsWithOptions(shared_ptr<SubmitEditingJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitEditingJobsResponse submitEditingJobs(shared_ptr<SubmitEditingJobsRequest> request);
  SubmitJobsResponse submitJobsWithOptions(shared_ptr<SubmitJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitJobsResponse submitJobs(shared_ptr<SubmitJobsRequest> request);
  SubmitMediaInfoJobResponse submitMediaInfoJobWithOptions(shared_ptr<SubmitMediaInfoJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaInfoJobResponse submitMediaInfoJob(shared_ptr<SubmitMediaInfoJobRequest> request);
  SubmitSnapshotJobResponse submitSnapshotJobWithOptions(shared_ptr<SubmitSnapshotJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSnapshotJobResponse submitSnapshotJob(shared_ptr<SubmitSnapshotJobRequest> request);
  UnbindInputBucketResponse unbindInputBucketWithOptions(shared_ptr<UnbindInputBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindInputBucketResponse unbindInputBucket(shared_ptr<UnbindInputBucketRequest> request);
  UnbindOutputBucketResponse unbindOutputBucketWithOptions(shared_ptr<UnbindOutputBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindOutputBucketResponse unbindOutputBucket(shared_ptr<UnbindOutputBucketRequest> request);
  UpdateCategoryNameResponse updateCategoryNameWithOptions(shared_ptr<UpdateCategoryNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCategoryNameResponse updateCategoryName(shared_ptr<UpdateCategoryNameRequest> request);
  UpdateMediaResponse updateMediaWithOptions(shared_ptr<UpdateMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaResponse updateMedia(shared_ptr<UpdateMediaRequest> request);
  UpdateMediaCategoryResponse updateMediaCategoryWithOptions(shared_ptr<UpdateMediaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaCategoryResponse updateMediaCategory(shared_ptr<UpdateMediaCategoryRequest> request);
  UpdateMediaCoverResponse updateMediaCoverWithOptions(shared_ptr<UpdateMediaCoverRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaCoverResponse updateMediaCover(shared_ptr<UpdateMediaCoverRequest> request);
  UpdateMediaPublishStateResponse updateMediaPublishStateWithOptions(shared_ptr<UpdateMediaPublishStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaPublishStateResponse updateMediaPublishState(shared_ptr<UpdateMediaPublishStateRequest> request);
  UpdateMediaWorkflowResponse updateMediaWorkflowWithOptions(shared_ptr<UpdateMediaWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaWorkflowResponse updateMediaWorkflow(shared_ptr<UpdateMediaWorkflowRequest> request);
  UpdateMediaWorkflowTriggerModeResponse updateMediaWorkflowTriggerModeWithOptions(shared_ptr<UpdateMediaWorkflowTriggerModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaWorkflowTriggerModeResponse updateMediaWorkflowTriggerMode(shared_ptr<UpdateMediaWorkflowTriggerModeRequest> request);
  UpdatePipelineResponse updatePipelineWithOptions(shared_ptr<UpdatePipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePipelineResponse updatePipeline(shared_ptr<UpdatePipelineRequest> request);
  UpdateTemplateResponse updateTemplateWithOptions(shared_ptr<UpdateTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTemplateResponse updateTemplate(shared_ptr<UpdateTemplateRequest> request);
  UpdateWaterMarkTemplateResponse updateWaterMarkTemplateWithOptions(shared_ptr<UpdateWaterMarkTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWaterMarkTemplateResponse updateWaterMarkTemplate(shared_ptr<UpdateWaterMarkTemplateRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Mts20180528

#endif
