// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_VS20181212_H_
#define ALIBABACLOUD_VS20181212_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Vs20181212 {
class AddVsPullStreamInfoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> always{};
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  AddVsPullStreamInfoConfigRequest() {}

  explicit AddVsPullStreamInfoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (always) {
      res["Always"] = boost::any(*always);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Always") != m.end() && !m["Always"].empty()) {
      always = make_shared<string>(boost::any_cast<string>(m["Always"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~AddVsPullStreamInfoConfigRequest() = default;
};
class AddVsPullStreamInfoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddVsPullStreamInfoConfigResponseBody() {}

  explicit AddVsPullStreamInfoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddVsPullStreamInfoConfigResponseBody() = default;
};
class AddVsPullStreamInfoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddVsPullStreamInfoConfigResponseBody> body{};

  AddVsPullStreamInfoConfigResponse() {}

  explicit AddVsPullStreamInfoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddVsPullStreamInfoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddVsPullStreamInfoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~AddVsPullStreamInfoConfigResponse() = default;
};
class BatchBindDirectoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> directoryId{};
  shared_ptr<long> ownerId{};

  BatchBindDirectoriesRequest() {}

  explicit BatchBindDirectoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~BatchBindDirectoriesRequest() = default;
};
class BatchBindDirectoriesResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> error{};

  BatchBindDirectoriesResponseBodyResults() {}

  explicit BatchBindDirectoriesResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
  }


  virtual ~BatchBindDirectoriesResponseBodyResults() = default;
};
class BatchBindDirectoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchBindDirectoriesResponseBodyResults>> results{};

  BatchBindDirectoriesResponseBody() {}

  explicit BatchBindDirectoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<BatchBindDirectoriesResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchBindDirectoriesResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<BatchBindDirectoriesResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~BatchBindDirectoriesResponseBody() = default;
};
class BatchBindDirectoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchBindDirectoriesResponseBody> body{};

  BatchBindDirectoriesResponse() {}

  explicit BatchBindDirectoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchBindDirectoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchBindDirectoriesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchBindDirectoriesResponse() = default;
};
class BatchBindParentPlatformDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> parentPlatformId{};

  BatchBindParentPlatformDevicesRequest() {}

  explicit BatchBindParentPlatformDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (parentPlatformId) {
      res["ParentPlatformId"] = boost::any(*parentPlatformId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ParentPlatformId") != m.end() && !m["ParentPlatformId"].empty()) {
      parentPlatformId = make_shared<string>(boost::any_cast<string>(m["ParentPlatformId"]));
    }
  }


  virtual ~BatchBindParentPlatformDevicesRequest() = default;
};
class BatchBindParentPlatformDevicesResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> error{};
  shared_ptr<string> parentPlatformId{};

  BatchBindParentPlatformDevicesResponseBodyResults() {}

  explicit BatchBindParentPlatformDevicesResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (parentPlatformId) {
      res["ParentPlatformId"] = boost::any(*parentPlatformId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("ParentPlatformId") != m.end() && !m["ParentPlatformId"].empty()) {
      parentPlatformId = make_shared<string>(boost::any_cast<string>(m["ParentPlatformId"]));
    }
  }


  virtual ~BatchBindParentPlatformDevicesResponseBodyResults() = default;
};
class BatchBindParentPlatformDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchBindParentPlatformDevicesResponseBodyResults>> results{};

  BatchBindParentPlatformDevicesResponseBody() {}

  explicit BatchBindParentPlatformDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<BatchBindParentPlatformDevicesResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchBindParentPlatformDevicesResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<BatchBindParentPlatformDevicesResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~BatchBindParentPlatformDevicesResponseBody() = default;
};
class BatchBindParentPlatformDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchBindParentPlatformDevicesResponseBody> body{};

  BatchBindParentPlatformDevicesResponse() {}

  explicit BatchBindParentPlatformDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchBindParentPlatformDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchBindParentPlatformDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchBindParentPlatformDevicesResponse() = default;
};
class BatchBindPurchasedDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};

  BatchBindPurchasedDevicesRequest() {}

  explicit BatchBindPurchasedDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~BatchBindPurchasedDevicesRequest() = default;
};
class BatchBindPurchasedDevicesResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> error{};
  shared_ptr<string> groupId{};
  shared_ptr<string> region{};

  BatchBindPurchasedDevicesResponseBodyResults() {}

  explicit BatchBindPurchasedDevicesResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~BatchBindPurchasedDevicesResponseBodyResults() = default;
};
class BatchBindPurchasedDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchBindPurchasedDevicesResponseBodyResults>> results{};

  BatchBindPurchasedDevicesResponseBody() {}

  explicit BatchBindPurchasedDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<BatchBindPurchasedDevicesResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchBindPurchasedDevicesResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<BatchBindPurchasedDevicesResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~BatchBindPurchasedDevicesResponseBody() = default;
};
class BatchBindPurchasedDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchBindPurchasedDevicesResponseBody> body{};

  BatchBindPurchasedDevicesResponse() {}

  explicit BatchBindPurchasedDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchBindPurchasedDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchBindPurchasedDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchBindPurchasedDevicesResponse() = default;
};
class BatchBindTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<bool> applyAll{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> ownerId{};
  shared_ptr<bool> replace{};
  shared_ptr<string> templateId{};

  BatchBindTemplateRequest() {}

  explicit BatchBindTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyAll) {
      res["ApplyAll"] = boost::any(*applyAll);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (replace) {
      res["Replace"] = boost::any(*replace);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyAll") != m.end() && !m["ApplyAll"].empty()) {
      applyAll = make_shared<bool>(boost::any_cast<bool>(m["ApplyAll"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Replace") != m.end() && !m["Replace"].empty()) {
      replace = make_shared<bool>(boost::any_cast<bool>(m["Replace"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~BatchBindTemplateRequest() = default;
};
class BatchBindTemplateResponseBodyBindings : public Darabonba::Model {
public:
  shared_ptr<string> error{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> templateId{};

  BatchBindTemplateResponseBodyBindings() {}

  explicit BatchBindTemplateResponseBodyBindings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~BatchBindTemplateResponseBodyBindings() = default;
};
class BatchBindTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<BatchBindTemplateResponseBodyBindings>> bindings{};
  shared_ptr<string> requestId{};

  BatchBindTemplateResponseBody() {}

  explicit BatchBindTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindings) {
      vector<boost::any> temp1;
      for(auto item1:*bindings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Bindings"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bindings") != m.end() && !m["Bindings"].empty()) {
      if (typeid(vector<boost::any>) == m["Bindings"].type()) {
        vector<BatchBindTemplateResponseBodyBindings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Bindings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchBindTemplateResponseBodyBindings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bindings = make_shared<vector<BatchBindTemplateResponseBodyBindings>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchBindTemplateResponseBody() = default;
};
class BatchBindTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchBindTemplateResponseBody> body{};

  BatchBindTemplateResponse() {}

  explicit BatchBindTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchBindTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchBindTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~BatchBindTemplateResponse() = default;
};
class BatchBindTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> applyAll{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> ownerId{};
  shared_ptr<bool> replace{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};

  BatchBindTemplatesRequest() {}

  explicit BatchBindTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyAll) {
      res["ApplyAll"] = boost::any(*applyAll);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (replace) {
      res["Replace"] = boost::any(*replace);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyAll") != m.end() && !m["ApplyAll"].empty()) {
      applyAll = make_shared<bool>(boost::any_cast<bool>(m["ApplyAll"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Replace") != m.end() && !m["Replace"].empty()) {
      replace = make_shared<bool>(boost::any_cast<bool>(m["Replace"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~BatchBindTemplatesRequest() = default;
};
class BatchBindTemplatesResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> error{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> templateId{};

  BatchBindTemplatesResponseBodyResults() {}

  explicit BatchBindTemplatesResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~BatchBindTemplatesResponseBodyResults() = default;
};
class BatchBindTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchBindTemplatesResponseBodyResults>> results{};

  BatchBindTemplatesResponseBody() {}

  explicit BatchBindTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<BatchBindTemplatesResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchBindTemplatesResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<BatchBindTemplatesResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~BatchBindTemplatesResponseBody() = default;
};
class BatchBindTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchBindTemplatesResponseBody> body{};

  BatchBindTemplatesResponse() {}

  explicit BatchBindTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchBindTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchBindTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchBindTemplatesResponse() = default;
};
class BatchDeleteDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  BatchDeleteDevicesRequest() {}

  explicit BatchDeleteDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~BatchDeleteDevicesRequest() = default;
};
class BatchDeleteDevicesResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> error{};
  shared_ptr<string> id{};

  BatchDeleteDevicesResponseBodyResults() {}

  explicit BatchDeleteDevicesResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~BatchDeleteDevicesResponseBodyResults() = default;
};
class BatchDeleteDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchDeleteDevicesResponseBodyResults>> results{};

  BatchDeleteDevicesResponseBody() {}

  explicit BatchDeleteDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<BatchDeleteDevicesResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchDeleteDevicesResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<BatchDeleteDevicesResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~BatchDeleteDevicesResponseBody() = default;
};
class BatchDeleteDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeleteDevicesResponseBody> body{};

  BatchDeleteDevicesResponse() {}

  explicit BatchDeleteDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteDevicesResponse() = default;
};
class BatchDeleteVsDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> functionNames{};
  shared_ptr<long> ownerId{};

  BatchDeleteVsDomainConfigsRequest() {}

  explicit BatchDeleteVsDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~BatchDeleteVsDomainConfigsRequest() = default;
};
class BatchDeleteVsDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchDeleteVsDomainConfigsResponseBody() {}

  explicit BatchDeleteVsDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchDeleteVsDomainConfigsResponseBody() = default;
};
class BatchDeleteVsDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeleteVsDomainConfigsResponseBody> body{};

  BatchDeleteVsDomainConfigsResponse() {}

  explicit BatchDeleteVsDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteVsDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteVsDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteVsDomainConfigsResponse() = default;
};
class BatchForbidVsStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> channel{};
  shared_ptr<string> controlStreamAction{};
  shared_ptr<string> domainName{};
  shared_ptr<string> liveStreamType{};
  shared_ptr<string> oneshot{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resumeTime{};

  BatchForbidVsStreamRequest() {}

  explicit BatchForbidVsStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (controlStreamAction) {
      res["ControlStreamAction"] = boost::any(*controlStreamAction);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (liveStreamType) {
      res["LiveStreamType"] = boost::any(*liveStreamType);
    }
    if (oneshot) {
      res["Oneshot"] = boost::any(*oneshot);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resumeTime) {
      res["ResumeTime"] = boost::any(*resumeTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("ControlStreamAction") != m.end() && !m["ControlStreamAction"].empty()) {
      controlStreamAction = make_shared<string>(boost::any_cast<string>(m["ControlStreamAction"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LiveStreamType") != m.end() && !m["LiveStreamType"].empty()) {
      liveStreamType = make_shared<string>(boost::any_cast<string>(m["LiveStreamType"]));
    }
    if (m.find("Oneshot") != m.end() && !m["Oneshot"].empty()) {
      oneshot = make_shared<string>(boost::any_cast<string>(m["Oneshot"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResumeTime") != m.end() && !m["ResumeTime"].empty()) {
      resumeTime = make_shared<string>(boost::any_cast<string>(m["ResumeTime"]));
    }
  }


  virtual ~BatchForbidVsStreamRequest() = default;
};
class BatchForbidVsStreamResponseBodyForbidResultForbidResultInfoChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channel{};

  BatchForbidVsStreamResponseBodyForbidResultForbidResultInfoChannels() {}

  explicit BatchForbidVsStreamResponseBodyForbidResultForbidResultInfoChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channel"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channel"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channel = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchForbidVsStreamResponseBodyForbidResultForbidResultInfoChannels() = default;
};
class BatchForbidVsStreamResponseBodyForbidResultForbidResultInfo : public Darabonba::Model {
public:
  shared_ptr<BatchForbidVsStreamResponseBodyForbidResultForbidResultInfoChannels> channels{};
  shared_ptr<long> count{};
  shared_ptr<string> detail{};
  shared_ptr<string> result{};

  BatchForbidVsStreamResponseBodyForbidResultForbidResultInfo() {}

  explicit BatchForbidVsStreamResponseBodyForbidResultForbidResultInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = channels ? boost::any(channels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      if (typeid(map<string, boost::any>) == m["Channels"].type()) {
        BatchForbidVsStreamResponseBodyForbidResultForbidResultInfoChannels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Channels"]));
        channels = make_shared<BatchForbidVsStreamResponseBodyForbidResultForbidResultInfoChannels>(model1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~BatchForbidVsStreamResponseBodyForbidResultForbidResultInfo() = default;
};
class BatchForbidVsStreamResponseBodyForbidResult : public Darabonba::Model {
public:
  shared_ptr<vector<BatchForbidVsStreamResponseBodyForbidResultForbidResultInfo>> forbidResultInfo{};

  BatchForbidVsStreamResponseBodyForbidResult() {}

  explicit BatchForbidVsStreamResponseBodyForbidResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forbidResultInfo) {
      vector<boost::any> temp1;
      for(auto item1:*forbidResultInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ForbidResultInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForbidResultInfo") != m.end() && !m["ForbidResultInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ForbidResultInfo"].type()) {
        vector<BatchForbidVsStreamResponseBodyForbidResultForbidResultInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ForbidResultInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchForbidVsStreamResponseBodyForbidResultForbidResultInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        forbidResultInfo = make_shared<vector<BatchForbidVsStreamResponseBodyForbidResultForbidResultInfo>>(expect1);
      }
    }
  }


  virtual ~BatchForbidVsStreamResponseBodyForbidResult() = default;
};
class BatchForbidVsStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<BatchForbidVsStreamResponseBodyForbidResult> forbidResult{};
  shared_ptr<string> requestId{};

  BatchForbidVsStreamResponseBody() {}

  explicit BatchForbidVsStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forbidResult) {
      res["ForbidResult"] = forbidResult ? boost::any(forbidResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForbidResult") != m.end() && !m["ForbidResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ForbidResult"].type()) {
        BatchForbidVsStreamResponseBodyForbidResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ForbidResult"]));
        forbidResult = make_shared<BatchForbidVsStreamResponseBodyForbidResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchForbidVsStreamResponseBody() = default;
};
class BatchForbidVsStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchForbidVsStreamResponseBody> body{};

  BatchForbidVsStreamResponse() {}

  explicit BatchForbidVsStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchForbidVsStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchForbidVsStreamResponseBody>(model1);
      }
    }
  }


  virtual ~BatchForbidVsStreamResponse() = default;
};
class BatchResumeVsStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> channel{};
  shared_ptr<string> controlStreamAction{};
  shared_ptr<string> domainName{};
  shared_ptr<string> liveStreamType{};
  shared_ptr<long> ownerId{};

  BatchResumeVsStreamRequest() {}

  explicit BatchResumeVsStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (controlStreamAction) {
      res["ControlStreamAction"] = boost::any(*controlStreamAction);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (liveStreamType) {
      res["LiveStreamType"] = boost::any(*liveStreamType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("ControlStreamAction") != m.end() && !m["ControlStreamAction"].empty()) {
      controlStreamAction = make_shared<string>(boost::any_cast<string>(m["ControlStreamAction"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LiveStreamType") != m.end() && !m["LiveStreamType"].empty()) {
      liveStreamType = make_shared<string>(boost::any_cast<string>(m["LiveStreamType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~BatchResumeVsStreamRequest() = default;
};
class BatchResumeVsStreamResponseBodyResumeResultResumeResultInfoChannels : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channel{};

  BatchResumeVsStreamResponseBodyResumeResultResumeResultInfoChannels() {}

  explicit BatchResumeVsStreamResponseBodyResumeResultResumeResultInfoChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Channel"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Channel"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channel = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchResumeVsStreamResponseBodyResumeResultResumeResultInfoChannels() = default;
};
class BatchResumeVsStreamResponseBodyResumeResultResumeResultInfo : public Darabonba::Model {
public:
  shared_ptr<BatchResumeVsStreamResponseBodyResumeResultResumeResultInfoChannels> channels{};
  shared_ptr<long> count{};
  shared_ptr<string> detail{};
  shared_ptr<string> result{};

  BatchResumeVsStreamResponseBodyResumeResultResumeResultInfo() {}

  explicit BatchResumeVsStreamResponseBodyResumeResultResumeResultInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = channels ? boost::any(channels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      if (typeid(map<string, boost::any>) == m["Channels"].type()) {
        BatchResumeVsStreamResponseBodyResumeResultResumeResultInfoChannels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Channels"]));
        channels = make_shared<BatchResumeVsStreamResponseBodyResumeResultResumeResultInfoChannels>(model1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~BatchResumeVsStreamResponseBodyResumeResultResumeResultInfo() = default;
};
class BatchResumeVsStreamResponseBodyResumeResult : public Darabonba::Model {
public:
  shared_ptr<vector<BatchResumeVsStreamResponseBodyResumeResultResumeResultInfo>> resumeResultInfo{};

  BatchResumeVsStreamResponseBodyResumeResult() {}

  explicit BatchResumeVsStreamResponseBodyResumeResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resumeResultInfo) {
      vector<boost::any> temp1;
      for(auto item1:*resumeResultInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResumeResultInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResumeResultInfo") != m.end() && !m["ResumeResultInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ResumeResultInfo"].type()) {
        vector<BatchResumeVsStreamResponseBodyResumeResultResumeResultInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResumeResultInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchResumeVsStreamResponseBodyResumeResultResumeResultInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resumeResultInfo = make_shared<vector<BatchResumeVsStreamResponseBodyResumeResultResumeResultInfo>>(expect1);
      }
    }
  }


  virtual ~BatchResumeVsStreamResponseBodyResumeResult() = default;
};
class BatchResumeVsStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<BatchResumeVsStreamResponseBodyResumeResult> resumeResult{};

  BatchResumeVsStreamResponseBody() {}

  explicit BatchResumeVsStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resumeResult) {
      res["ResumeResult"] = resumeResult ? boost::any(resumeResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResumeResult") != m.end() && !m["ResumeResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResumeResult"].type()) {
        BatchResumeVsStreamResponseBodyResumeResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResumeResult"]));
        resumeResult = make_shared<BatchResumeVsStreamResponseBodyResumeResult>(model1);
      }
    }
  }


  virtual ~BatchResumeVsStreamResponseBody() = default;
};
class BatchResumeVsStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchResumeVsStreamResponseBody> body{};

  BatchResumeVsStreamResponse() {}

  explicit BatchResumeVsStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchResumeVsStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchResumeVsStreamResponseBody>(model1);
      }
    }
  }


  virtual ~BatchResumeVsStreamResponse() = default;
};
class BatchSetVsDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> functions{};
  shared_ptr<long> ownerId{};

  BatchSetVsDomainConfigsRequest() {}

  explicit BatchSetVsDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functions) {
      res["Functions"] = boost::any(*functions);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      functions = make_shared<string>(boost::any_cast<string>(m["Functions"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~BatchSetVsDomainConfigsRequest() = default;
};
class BatchSetVsDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchSetVsDomainConfigsResponseBody() {}

  explicit BatchSetVsDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchSetVsDomainConfigsResponseBody() = default;
};
class BatchSetVsDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchSetVsDomainConfigsResponseBody> body{};

  BatchSetVsDomainConfigsResponse() {}

  explicit BatchSetVsDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetVsDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetVsDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetVsDomainConfigsResponse() = default;
};
class BatchStartDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  BatchStartDevicesRequest() {}

  explicit BatchStartDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~BatchStartDevicesRequest() = default;
};
class BatchStartDevicesResponseBodyResultsStreams : public Darabonba::Model {
public:
  shared_ptr<string> error{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  BatchStartDevicesResponseBodyResultsStreams() {}

  explicit BatchStartDevicesResponseBodyResultsStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~BatchStartDevicesResponseBodyResultsStreams() = default;
};
class BatchStartDevicesResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<vector<BatchStartDevicesResponseBodyResultsStreams>> streams{};

  BatchStartDevicesResponseBodyResults() {}

  explicit BatchStartDevicesResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (streams) {
      vector<boost::any> temp1;
      for(auto item1:*streams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Streams"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(vector<boost::any>) == m["Streams"].type()) {
        vector<BatchStartDevicesResponseBodyResultsStreams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Streams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchStartDevicesResponseBodyResultsStreams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streams = make_shared<vector<BatchStartDevicesResponseBodyResultsStreams>>(expect1);
      }
    }
  }


  virtual ~BatchStartDevicesResponseBodyResults() = default;
};
class BatchStartDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchStartDevicesResponseBodyResults>> results{};

  BatchStartDevicesResponseBody() {}

  explicit BatchStartDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<BatchStartDevicesResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchStartDevicesResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<BatchStartDevicesResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~BatchStartDevicesResponseBody() = default;
};
class BatchStartDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchStartDevicesResponseBody> body{};

  BatchStartDevicesResponse() {}

  explicit BatchStartDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchStartDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchStartDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchStartDevicesResponse() = default;
};
class BatchStartStreamsRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  BatchStartStreamsRequest() {}

  explicit BatchStartStreamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~BatchStartStreamsRequest() = default;
};
class BatchStartStreamsResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> error{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  BatchStartStreamsResponseBodyResults() {}

  explicit BatchStartStreamsResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~BatchStartStreamsResponseBodyResults() = default;
};
class BatchStartStreamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchStartStreamsResponseBodyResults>> results{};

  BatchStartStreamsResponseBody() {}

  explicit BatchStartStreamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<BatchStartStreamsResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchStartStreamsResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<BatchStartStreamsResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~BatchStartStreamsResponseBody() = default;
};
class BatchStartStreamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchStartStreamsResponseBody> body{};

  BatchStartStreamsResponse() {}

  explicit BatchStartStreamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchStartStreamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchStartStreamsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchStartStreamsResponse() = default;
};
class BatchStopDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  BatchStopDevicesRequest() {}

  explicit BatchStopDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~BatchStopDevicesRequest() = default;
};
class BatchStopDevicesResponseBodyResultsStreams : public Darabonba::Model {
public:
  shared_ptr<string> error{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  BatchStopDevicesResponseBodyResultsStreams() {}

  explicit BatchStopDevicesResponseBodyResultsStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~BatchStopDevicesResponseBodyResultsStreams() = default;
};
class BatchStopDevicesResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<vector<BatchStopDevicesResponseBodyResultsStreams>> streams{};

  BatchStopDevicesResponseBodyResults() {}

  explicit BatchStopDevicesResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (streams) {
      vector<boost::any> temp1;
      for(auto item1:*streams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Streams"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(vector<boost::any>) == m["Streams"].type()) {
        vector<BatchStopDevicesResponseBodyResultsStreams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Streams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchStopDevicesResponseBodyResultsStreams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streams = make_shared<vector<BatchStopDevicesResponseBodyResultsStreams>>(expect1);
      }
    }
  }


  virtual ~BatchStopDevicesResponseBodyResults() = default;
};
class BatchStopDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchStopDevicesResponseBodyResults>> results{};

  BatchStopDevicesResponseBody() {}

  explicit BatchStopDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<BatchStopDevicesResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchStopDevicesResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<BatchStopDevicesResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~BatchStopDevicesResponseBody() = default;
};
class BatchStopDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchStopDevicesResponseBody> body{};

  BatchStopDevicesResponse() {}

  explicit BatchStopDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchStopDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchStopDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchStopDevicesResponse() = default;
};
class BatchStopStreamsRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  BatchStopStreamsRequest() {}

  explicit BatchStopStreamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~BatchStopStreamsRequest() = default;
};
class BatchStopStreamsResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> error{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  BatchStopStreamsResponseBodyResults() {}

  explicit BatchStopStreamsResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~BatchStopStreamsResponseBodyResults() = default;
};
class BatchStopStreamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchStopStreamsResponseBodyResults>> results{};

  BatchStopStreamsResponseBody() {}

  explicit BatchStopStreamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<BatchStopStreamsResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchStopStreamsResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<BatchStopStreamsResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~BatchStopStreamsResponseBody() = default;
};
class BatchStopStreamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchStopStreamsResponseBody> body{};

  BatchStopStreamsResponse() {}

  explicit BatchStopStreamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchStopStreamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchStopStreamsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchStopStreamsResponse() = default;
};
class BatchUnbindDirectoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> directoryId{};
  shared_ptr<long> ownerId{};

  BatchUnbindDirectoriesRequest() {}

  explicit BatchUnbindDirectoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~BatchUnbindDirectoriesRequest() = default;
};
class BatchUnbindDirectoriesResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> error{};

  BatchUnbindDirectoriesResponseBodyResults() {}

  explicit BatchUnbindDirectoriesResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
  }


  virtual ~BatchUnbindDirectoriesResponseBodyResults() = default;
};
class BatchUnbindDirectoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchUnbindDirectoriesResponseBodyResults>> results{};

  BatchUnbindDirectoriesResponseBody() {}

  explicit BatchUnbindDirectoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<BatchUnbindDirectoriesResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUnbindDirectoriesResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<BatchUnbindDirectoriesResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~BatchUnbindDirectoriesResponseBody() = default;
};
class BatchUnbindDirectoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUnbindDirectoriesResponseBody> body{};

  BatchUnbindDirectoriesResponse() {}

  explicit BatchUnbindDirectoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUnbindDirectoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUnbindDirectoriesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUnbindDirectoriesResponse() = default;
};
class BatchUnbindParentPlatformDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> parentPlatformId{};

  BatchUnbindParentPlatformDevicesRequest() {}

  explicit BatchUnbindParentPlatformDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (parentPlatformId) {
      res["ParentPlatformId"] = boost::any(*parentPlatformId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ParentPlatformId") != m.end() && !m["ParentPlatformId"].empty()) {
      parentPlatformId = make_shared<string>(boost::any_cast<string>(m["ParentPlatformId"]));
    }
  }


  virtual ~BatchUnbindParentPlatformDevicesRequest() = default;
};
class BatchUnbindParentPlatformDevicesResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> error{};
  shared_ptr<string> parentPlatformId{};

  BatchUnbindParentPlatformDevicesResponseBodyResults() {}

  explicit BatchUnbindParentPlatformDevicesResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (parentPlatformId) {
      res["ParentPlatformId"] = boost::any(*parentPlatformId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("ParentPlatformId") != m.end() && !m["ParentPlatformId"].empty()) {
      parentPlatformId = make_shared<string>(boost::any_cast<string>(m["ParentPlatformId"]));
    }
  }


  virtual ~BatchUnbindParentPlatformDevicesResponseBodyResults() = default;
};
class BatchUnbindParentPlatformDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchUnbindParentPlatformDevicesResponseBodyResults>> results{};

  BatchUnbindParentPlatformDevicesResponseBody() {}

  explicit BatchUnbindParentPlatformDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<BatchUnbindParentPlatformDevicesResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUnbindParentPlatformDevicesResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<BatchUnbindParentPlatformDevicesResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~BatchUnbindParentPlatformDevicesResponseBody() = default;
};
class BatchUnbindParentPlatformDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUnbindParentPlatformDevicesResponseBody> body{};

  BatchUnbindParentPlatformDevicesResponse() {}

  explicit BatchUnbindParentPlatformDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUnbindParentPlatformDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUnbindParentPlatformDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUnbindParentPlatformDevicesResponse() = default;
};
class BatchUnbindPurchasedDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<long> ownerId{};

  BatchUnbindPurchasedDevicesRequest() {}

  explicit BatchUnbindPurchasedDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~BatchUnbindPurchasedDevicesRequest() = default;
};
class BatchUnbindPurchasedDevicesResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> error{};

  BatchUnbindPurchasedDevicesResponseBodyResults() {}

  explicit BatchUnbindPurchasedDevicesResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
  }


  virtual ~BatchUnbindPurchasedDevicesResponseBodyResults() = default;
};
class BatchUnbindPurchasedDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchUnbindPurchasedDevicesResponseBodyResults>> results{};

  BatchUnbindPurchasedDevicesResponseBody() {}

  explicit BatchUnbindPurchasedDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<BatchUnbindPurchasedDevicesResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUnbindPurchasedDevicesResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<BatchUnbindPurchasedDevicesResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~BatchUnbindPurchasedDevicesResponseBody() = default;
};
class BatchUnbindPurchasedDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUnbindPurchasedDevicesResponseBody> body{};

  BatchUnbindPurchasedDevicesResponse() {}

  explicit BatchUnbindPurchasedDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUnbindPurchasedDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUnbindPurchasedDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUnbindPurchasedDevicesResponse() = default;
};
class BatchUnbindTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};

  BatchUnbindTemplateRequest() {}

  explicit BatchUnbindTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~BatchUnbindTemplateRequest() = default;
};
class BatchUnbindTemplateResponseBodyBindings : public Darabonba::Model {
public:
  shared_ptr<string> error{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> templateId{};

  BatchUnbindTemplateResponseBodyBindings() {}

  explicit BatchUnbindTemplateResponseBodyBindings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~BatchUnbindTemplateResponseBodyBindings() = default;
};
class BatchUnbindTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<BatchUnbindTemplateResponseBodyBindings>> bindings{};
  shared_ptr<string> requestId{};

  BatchUnbindTemplateResponseBody() {}

  explicit BatchUnbindTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindings) {
      vector<boost::any> temp1;
      for(auto item1:*bindings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Bindings"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bindings") != m.end() && !m["Bindings"].empty()) {
      if (typeid(vector<boost::any>) == m["Bindings"].type()) {
        vector<BatchUnbindTemplateResponseBodyBindings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Bindings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUnbindTemplateResponseBodyBindings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bindings = make_shared<vector<BatchUnbindTemplateResponseBodyBindings>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchUnbindTemplateResponseBody() = default;
};
class BatchUnbindTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUnbindTemplateResponseBody> body{};

  BatchUnbindTemplateResponse() {}

  explicit BatchUnbindTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUnbindTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUnbindTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUnbindTemplateResponse() = default;
};
class BatchUnbindTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};

  BatchUnbindTemplatesRequest() {}

  explicit BatchUnbindTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~BatchUnbindTemplatesRequest() = default;
};
class BatchUnbindTemplatesResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> error{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};

  BatchUnbindTemplatesResponseBodyResults() {}

  explicit BatchUnbindTemplatesResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~BatchUnbindTemplatesResponseBodyResults() = default;
};
class BatchUnbindTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchUnbindTemplatesResponseBodyResults>> results{};

  BatchUnbindTemplatesResponseBody() {}

  explicit BatchUnbindTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<BatchUnbindTemplatesResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUnbindTemplatesResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<BatchUnbindTemplatesResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~BatchUnbindTemplatesResponseBody() = default;
};
class BatchUnbindTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUnbindTemplatesResponseBody> body{};

  BatchUnbindTemplatesResponse() {}

  explicit BatchUnbindTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUnbindTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUnbindTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUnbindTemplatesResponse() = default;
};
class BindDirectoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> directoryId{};
  shared_ptr<long> ownerId{};

  BindDirectoryRequest() {}

  explicit BindDirectoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~BindDirectoryRequest() = default;
};
class BindDirectoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BindDirectoryResponseBody() {}

  explicit BindDirectoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindDirectoryResponseBody() = default;
};
class BindDirectoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindDirectoryResponseBody> body{};

  BindDirectoryResponse() {}

  explicit BindDirectoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindDirectoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindDirectoryResponseBody>(model1);
      }
    }
  }


  virtual ~BindDirectoryResponse() = default;
};
class BindParentPlatformDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> parentPlatformId{};

  BindParentPlatformDeviceRequest() {}

  explicit BindParentPlatformDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (parentPlatformId) {
      res["ParentPlatformId"] = boost::any(*parentPlatformId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ParentPlatformId") != m.end() && !m["ParentPlatformId"].empty()) {
      parentPlatformId = make_shared<string>(boost::any_cast<string>(m["ParentPlatformId"]));
    }
  }


  virtual ~BindParentPlatformDeviceRequest() = default;
};
class BindParentPlatformDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BindParentPlatformDeviceResponseBody() {}

  explicit BindParentPlatformDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindParentPlatformDeviceResponseBody() = default;
};
class BindParentPlatformDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindParentPlatformDeviceResponseBody> body{};

  BindParentPlatformDeviceResponse() {}

  explicit BindParentPlatformDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindParentPlatformDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindParentPlatformDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~BindParentPlatformDeviceResponse() = default;
};
class BindPurchasedDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};

  BindPurchasedDeviceRequest() {}

  explicit BindPurchasedDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~BindPurchasedDeviceRequest() = default;
};
class BindPurchasedDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BindPurchasedDeviceResponseBody() {}

  explicit BindPurchasedDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindPurchasedDeviceResponseBody() = default;
};
class BindPurchasedDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindPurchasedDeviceResponseBody> body{};

  BindPurchasedDeviceResponse() {}

  explicit BindPurchasedDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindPurchasedDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindPurchasedDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~BindPurchasedDeviceResponse() = default;
};
class BindTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<bool> applyAll{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> ownerId{};
  shared_ptr<bool> replace{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};

  BindTemplateRequest() {}

  explicit BindTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyAll) {
      res["ApplyAll"] = boost::any(*applyAll);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (replace) {
      res["Replace"] = boost::any(*replace);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyAll") != m.end() && !m["ApplyAll"].empty()) {
      applyAll = make_shared<bool>(boost::any_cast<bool>(m["ApplyAll"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Replace") != m.end() && !m["Replace"].empty()) {
      replace = make_shared<bool>(boost::any_cast<bool>(m["Replace"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~BindTemplateRequest() = default;
};
class BindTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  BindTemplateResponseBody() {}

  explicit BindTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~BindTemplateResponseBody() = default;
};
class BindTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindTemplateResponseBody> body{};

  BindTemplateResponse() {}

  explicit BindTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~BindTemplateResponse() = default;
};
class ContinuousAdjustRequest : public Darabonba::Model {
public:
  shared_ptr<string> focus{};
  shared_ptr<string> id{};
  shared_ptr<string> iris{};
  shared_ptr<long> ownerId{};

  ContinuousAdjustRequest() {}

  explicit ContinuousAdjustRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (focus) {
      res["Focus"] = boost::any(*focus);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (iris) {
      res["Iris"] = boost::any(*iris);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Focus") != m.end() && !m["Focus"].empty()) {
      focus = make_shared<string>(boost::any_cast<string>(m["Focus"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Iris") != m.end() && !m["Iris"].empty()) {
      iris = make_shared<string>(boost::any_cast<string>(m["Iris"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~ContinuousAdjustRequest() = default;
};
class ContinuousAdjustResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  ContinuousAdjustResponseBody() {}

  explicit ContinuousAdjustResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ContinuousAdjustResponseBody() = default;
};
class ContinuousAdjustResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ContinuousAdjustResponseBody> body{};

  ContinuousAdjustResponse() {}

  explicit ContinuousAdjustResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ContinuousAdjustResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ContinuousAdjustResponseBody>(model1);
      }
    }
  }


  virtual ~ContinuousAdjustResponse() = default;
};
class ContinuousMoveRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pan{};
  shared_ptr<string> tilt{};
  shared_ptr<string> zoom{};

  ContinuousMoveRequest() {}

  explicit ContinuousMoveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pan) {
      res["Pan"] = boost::any(*pan);
    }
    if (tilt) {
      res["Tilt"] = boost::any(*tilt);
    }
    if (zoom) {
      res["Zoom"] = boost::any(*zoom);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Pan") != m.end() && !m["Pan"].empty()) {
      pan = make_shared<string>(boost::any_cast<string>(m["Pan"]));
    }
    if (m.find("Tilt") != m.end() && !m["Tilt"].empty()) {
      tilt = make_shared<string>(boost::any_cast<string>(m["Tilt"]));
    }
    if (m.find("Zoom") != m.end() && !m["Zoom"].empty()) {
      zoom = make_shared<string>(boost::any_cast<string>(m["Zoom"]));
    }
  }


  virtual ~ContinuousMoveRequest() = default;
};
class ContinuousMoveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  ContinuousMoveResponseBody() {}

  explicit ContinuousMoveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ContinuousMoveResponseBody() = default;
};
class ContinuousMoveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ContinuousMoveResponseBody> body{};

  ContinuousMoveResponse() {}

  explicit ContinuousMoveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ContinuousMoveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ContinuousMoveResponseBody>(model1);
      }
    }
  }


  virtual ~ContinuousMoveResponse() = default;
};
class CreateDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> alarmMethod{};
  shared_ptr<bool> autoDirectory{};
  shared_ptr<bool> autoPos{};
  shared_ptr<bool> autoStart{};
  shared_ptr<string> description{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> dsn{};
  shared_ptr<string> gbId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> ip{};
  shared_ptr<string> latitude{};
  shared_ptr<string> longitude{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> params{};
  shared_ptr<string> parentId{};
  shared_ptr<string> password{};
  shared_ptr<long> port{};
  shared_ptr<long> posInterval{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> username{};
  shared_ptr<string> vendor{};

  CreateDeviceRequest() {}

  explicit CreateDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmMethod) {
      res["AlarmMethod"] = boost::any(*alarmMethod);
    }
    if (autoDirectory) {
      res["AutoDirectory"] = boost::any(*autoDirectory);
    }
    if (autoPos) {
      res["AutoPos"] = boost::any(*autoPos);
    }
    if (autoStart) {
      res["AutoStart"] = boost::any(*autoStart);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (dsn) {
      res["Dsn"] = boost::any(*dsn);
    }
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (latitude) {
      res["Latitude"] = boost::any(*latitude);
    }
    if (longitude) {
      res["Longitude"] = boost::any(*longitude);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (posInterval) {
      res["PosInterval"] = boost::any(*posInterval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmMethod") != m.end() && !m["AlarmMethod"].empty()) {
      alarmMethod = make_shared<string>(boost::any_cast<string>(m["AlarmMethod"]));
    }
    if (m.find("AutoDirectory") != m.end() && !m["AutoDirectory"].empty()) {
      autoDirectory = make_shared<bool>(boost::any_cast<bool>(m["AutoDirectory"]));
    }
    if (m.find("AutoPos") != m.end() && !m["AutoPos"].empty()) {
      autoPos = make_shared<bool>(boost::any_cast<bool>(m["AutoPos"]));
    }
    if (m.find("AutoStart") != m.end() && !m["AutoStart"].empty()) {
      autoStart = make_shared<bool>(boost::any_cast<bool>(m["AutoStart"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("Dsn") != m.end() && !m["Dsn"].empty()) {
      dsn = make_shared<string>(boost::any_cast<string>(m["Dsn"]));
    }
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Latitude") != m.end() && !m["Latitude"].empty()) {
      latitude = make_shared<string>(boost::any_cast<string>(m["Latitude"]));
    }
    if (m.find("Longitude") != m.end() && !m["Longitude"].empty()) {
      longitude = make_shared<string>(boost::any_cast<string>(m["Longitude"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("PosInterval") != m.end() && !m["PosInterval"].empty()) {
      posInterval = make_shared<long>(boost::any_cast<long>(m["PosInterval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~CreateDeviceRequest() = default;
};
class CreateDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateDeviceResponseBody() {}

  explicit CreateDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDeviceResponseBody() = default;
};
class CreateDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDeviceResponseBody> body{};

  CreateDeviceResponse() {}

  explicit CreateDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeviceResponse() = default;
};
class CreateDeviceAlarmRequest : public Darabonba::Model {
public:
  shared_ptr<long> alarm{};
  shared_ptr<long> channelId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> expire{};
  shared_ptr<string> id{};
  shared_ptr<long> objectType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> subAlarm{};

  CreateDeviceAlarmRequest() {}

  explicit CreateDeviceAlarmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarm) {
      res["Alarm"] = boost::any(*alarm);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (subAlarm) {
      res["SubAlarm"] = boost::any(*subAlarm);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alarm") != m.end() && !m["Alarm"].empty()) {
      alarm = make_shared<long>(boost::any_cast<long>(m["Alarm"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<long>(boost::any_cast<long>(m["ChannelId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<long>(boost::any_cast<long>(m["ObjectType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("SubAlarm") != m.end() && !m["SubAlarm"].empty()) {
      subAlarm = make_shared<long>(boost::any_cast<long>(m["SubAlarm"]));
    }
  }


  virtual ~CreateDeviceAlarmRequest() = default;
};
class CreateDeviceAlarmResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> alarmDelay{};
  shared_ptr<string> alarmId{};
  shared_ptr<long> expire{};
  shared_ptr<string> requestId{};
  shared_ptr<string> url{};

  CreateDeviceAlarmResponseBody() {}

  explicit CreateDeviceAlarmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmDelay) {
      res["AlarmDelay"] = boost::any(*alarmDelay);
    }
    if (alarmId) {
      res["AlarmId"] = boost::any(*alarmId);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmDelay") != m.end() && !m["AlarmDelay"].empty()) {
      alarmDelay = make_shared<long>(boost::any_cast<long>(m["AlarmDelay"]));
    }
    if (m.find("AlarmId") != m.end() && !m["AlarmId"].empty()) {
      alarmId = make_shared<string>(boost::any_cast<string>(m["AlarmId"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateDeviceAlarmResponseBody() = default;
};
class CreateDeviceAlarmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDeviceAlarmResponseBody> body{};

  CreateDeviceAlarmResponse() {}

  explicit CreateDeviceAlarmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeviceAlarmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeviceAlarmResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeviceAlarmResponse() = default;
};
class CreateDirectoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> parentId{};

  CreateDirectoryRequest() {}

  explicit CreateDirectoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
  }


  virtual ~CreateDirectoryRequest() = default;
};
class CreateDirectoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateDirectoryResponseBody() {}

  explicit CreateDirectoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDirectoryResponseBody() = default;
};
class CreateDirectoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDirectoryResponseBody> body{};

  CreateDirectoryResponse() {}

  explicit CreateDirectoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDirectoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDirectoryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDirectoryResponse() = default;
};
class CreateGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> callback{};
  shared_ptr<string> description{};
  shared_ptr<string> inProtocol{};
  shared_ptr<bool> lazyPull{};
  shared_ptr<string> name{};
  shared_ptr<string> outProtocol{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> playDomain{};
  shared_ptr<string> pushDomain{};
  shared_ptr<string> region{};

  CreateGroupRequest() {}

  explicit CreateGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inProtocol) {
      res["InProtocol"] = boost::any(*inProtocol);
    }
    if (lazyPull) {
      res["LazyPull"] = boost::any(*lazyPull);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outProtocol) {
      res["OutProtocol"] = boost::any(*outProtocol);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (playDomain) {
      res["PlayDomain"] = boost::any(*playDomain);
    }
    if (pushDomain) {
      res["PushDomain"] = boost::any(*pushDomain);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InProtocol") != m.end() && !m["InProtocol"].empty()) {
      inProtocol = make_shared<string>(boost::any_cast<string>(m["InProtocol"]));
    }
    if (m.find("LazyPull") != m.end() && !m["LazyPull"].empty()) {
      lazyPull = make_shared<bool>(boost::any_cast<bool>(m["LazyPull"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutProtocol") != m.end() && !m["OutProtocol"].empty()) {
      outProtocol = make_shared<string>(boost::any_cast<string>(m["OutProtocol"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PlayDomain") != m.end() && !m["PlayDomain"].empty()) {
      playDomain = make_shared<string>(boost::any_cast<string>(m["PlayDomain"]));
    }
    if (m.find("PushDomain") != m.end() && !m["PushDomain"].empty()) {
      pushDomain = make_shared<string>(boost::any_cast<string>(m["PushDomain"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~CreateGroupRequest() = default;
};
class CreateGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> gbId{};
  shared_ptr<string> gbIp{};
  shared_ptr<long> gbPort{};
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateGroupResponseBody() {}

  explicit CreateGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (gbIp) {
      res["GbIp"] = boost::any(*gbIp);
    }
    if (gbPort) {
      res["GbPort"] = boost::any(*gbPort);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("GbIp") != m.end() && !m["GbIp"].empty()) {
      gbIp = make_shared<string>(boost::any_cast<string>(m["GbIp"]));
    }
    if (m.find("GbPort") != m.end() && !m["GbPort"].empty()) {
      gbPort = make_shared<long>(boost::any_cast<long>(m["GbPort"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateGroupResponseBody() = default;
};
class CreateGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateGroupResponseBody> body{};

  CreateGroupResponse() {}

  explicit CreateGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateGroupResponse() = default;
};
class CreateParentPlatformRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoStart{};
  shared_ptr<bool> clientAuth{};
  shared_ptr<string> clientPassword{};
  shared_ptr<string> clientUsername{};
  shared_ptr<string> description{};
  shared_ptr<string> gbId{};
  shared_ptr<string> ip{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};

  CreateParentPlatformRequest() {}

  explicit CreateParentPlatformRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoStart) {
      res["AutoStart"] = boost::any(*autoStart);
    }
    if (clientAuth) {
      res["ClientAuth"] = boost::any(*clientAuth);
    }
    if (clientPassword) {
      res["ClientPassword"] = boost::any(*clientPassword);
    }
    if (clientUsername) {
      res["ClientUsername"] = boost::any(*clientUsername);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoStart") != m.end() && !m["AutoStart"].empty()) {
      autoStart = make_shared<bool>(boost::any_cast<bool>(m["AutoStart"]));
    }
    if (m.find("ClientAuth") != m.end() && !m["ClientAuth"].empty()) {
      clientAuth = make_shared<bool>(boost::any_cast<bool>(m["ClientAuth"]));
    }
    if (m.find("ClientPassword") != m.end() && !m["ClientPassword"].empty()) {
      clientPassword = make_shared<string>(boost::any_cast<string>(m["ClientPassword"]));
    }
    if (m.find("ClientUsername") != m.end() && !m["ClientUsername"].empty()) {
      clientUsername = make_shared<string>(boost::any_cast<string>(m["ClientUsername"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~CreateParentPlatformRequest() = default;
};
class CreateParentPlatformResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateParentPlatformResponseBody() {}

  explicit CreateParentPlatformResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateParentPlatformResponseBody() = default;
};
class CreateParentPlatformResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateParentPlatformResponseBody> body{};

  CreateParentPlatformResponse() {}

  explicit CreateParentPlatformResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateParentPlatformResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateParentPlatformResponseBody>(model1);
      }
    }
  }


  virtual ~CreateParentPlatformResponse() = default;
};
class CreateRenderingDataPackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> description{};
  shared_ptr<string> renderingInstanceId{};

  CreateRenderingDataPackageRequest() {}

  explicit CreateRenderingDataPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~CreateRenderingDataPackageRequest() = default;
};
class CreateRenderingDataPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataPackageId{};
  shared_ptr<string> requestId{};

  CreateRenderingDataPackageResponseBody() {}

  explicit CreateRenderingDataPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataPackageId) {
      res["DataPackageId"] = boost::any(*dataPackageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataPackageId") != m.end() && !m["DataPackageId"].empty()) {
      dataPackageId = make_shared<string>(boost::any_cast<string>(m["DataPackageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRenderingDataPackageResponseBody() = default;
};
class CreateRenderingDataPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRenderingDataPackageResponseBody> body{};

  CreateRenderingDataPackageResponse() {}

  explicit CreateRenderingDataPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRenderingDataPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRenderingDataPackageResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRenderingDataPackageResponse() = default;
};
class CreateRenderingInstanceRequestClientInfo : public Darabonba::Model {
public:
  shared_ptr<string> clientIp{};

  CreateRenderingInstanceRequestClientInfo() {}

  explicit CreateRenderingInstanceRequestClientInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
  }


  virtual ~CreateRenderingInstanceRequestClientInfo() = default;
};
class CreateRenderingInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<CreateRenderingInstanceRequestClientInfo> clientInfo{};
  shared_ptr<string> instanceBillingCycle{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidth{};
  shared_ptr<string> period{};
  shared_ptr<string> renderingSpec{};
  shared_ptr<string> storageSize{};

  CreateRenderingInstanceRequest() {}

  explicit CreateRenderingInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (clientInfo) {
      res["ClientInfo"] = clientInfo ? boost::any(clientInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceBillingCycle) {
      res["InstanceBillingCycle"] = boost::any(*instanceBillingCycle);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidth) {
      res["InternetMaxBandwidth"] = boost::any(*internetMaxBandwidth);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (renderingSpec) {
      res["RenderingSpec"] = boost::any(*renderingSpec);
    }
    if (storageSize) {
      res["StorageSize"] = boost::any(*storageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("ClientInfo") != m.end() && !m["ClientInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClientInfo"].type()) {
        CreateRenderingInstanceRequestClientInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClientInfo"]));
        clientInfo = make_shared<CreateRenderingInstanceRequestClientInfo>(model1);
      }
    }
    if (m.find("InstanceBillingCycle") != m.end() && !m["InstanceBillingCycle"].empty()) {
      instanceBillingCycle = make_shared<string>(boost::any_cast<string>(m["InstanceBillingCycle"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidth") != m.end() && !m["InternetMaxBandwidth"].empty()) {
      internetMaxBandwidth = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidth"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RenderingSpec") != m.end() && !m["RenderingSpec"].empty()) {
      renderingSpec = make_shared<string>(boost::any_cast<string>(m["RenderingSpec"]));
    }
    if (m.find("StorageSize") != m.end() && !m["StorageSize"].empty()) {
      storageSize = make_shared<string>(boost::any_cast<string>(m["StorageSize"]));
    }
  }


  virtual ~CreateRenderingInstanceRequest() = default;
};
class CreateRenderingInstanceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> clientInfoShrink{};
  shared_ptr<string> instanceBillingCycle{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> internetMaxBandwidth{};
  shared_ptr<string> period{};
  shared_ptr<string> renderingSpec{};
  shared_ptr<string> storageSize{};

  CreateRenderingInstanceShrinkRequest() {}

  explicit CreateRenderingInstanceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (clientInfoShrink) {
      res["ClientInfo"] = boost::any(*clientInfoShrink);
    }
    if (instanceBillingCycle) {
      res["InstanceBillingCycle"] = boost::any(*instanceBillingCycle);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (internetMaxBandwidth) {
      res["InternetMaxBandwidth"] = boost::any(*internetMaxBandwidth);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (renderingSpec) {
      res["RenderingSpec"] = boost::any(*renderingSpec);
    }
    if (storageSize) {
      res["StorageSize"] = boost::any(*storageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("ClientInfo") != m.end() && !m["ClientInfo"].empty()) {
      clientInfoShrink = make_shared<string>(boost::any_cast<string>(m["ClientInfo"]));
    }
    if (m.find("InstanceBillingCycle") != m.end() && !m["InstanceBillingCycle"].empty()) {
      instanceBillingCycle = make_shared<string>(boost::any_cast<string>(m["InstanceBillingCycle"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InternetMaxBandwidth") != m.end() && !m["InternetMaxBandwidth"].empty()) {
      internetMaxBandwidth = make_shared<long>(boost::any_cast<long>(m["InternetMaxBandwidth"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RenderingSpec") != m.end() && !m["RenderingSpec"].empty()) {
      renderingSpec = make_shared<string>(boost::any_cast<string>(m["RenderingSpec"]));
    }
    if (m.find("StorageSize") != m.end() && !m["StorageSize"].empty()) {
      storageSize = make_shared<string>(boost::any_cast<string>(m["StorageSize"]));
    }
  }


  virtual ~CreateRenderingInstanceShrinkRequest() = default;
};
class CreateRenderingInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> renderingInstanceId{};
  shared_ptr<string> requestId{};

  CreateRenderingInstanceResponseBody() {}

  explicit CreateRenderingInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRenderingInstanceResponseBody() = default;
};
class CreateRenderingInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRenderingInstanceResponseBody> body{};

  CreateRenderingInstanceResponse() {}

  explicit CreateRenderingInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRenderingInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRenderingInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRenderingInstanceResponse() = default;
};
class CreateRenderingInstanceGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> gatewayInstanceId{};
  shared_ptr<string> renderingInstanceId{};

  CreateRenderingInstanceGatewayRequest() {}

  explicit CreateRenderingInstanceGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayInstanceId) {
      res["GatewayInstanceId"] = boost::any(*gatewayInstanceId);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayInstanceId") != m.end() && !m["GatewayInstanceId"].empty()) {
      gatewayInstanceId = make_shared<string>(boost::any_cast<string>(m["GatewayInstanceId"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~CreateRenderingInstanceGatewayRequest() = default;
};
class CreateRenderingInstanceGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateRenderingInstanceGatewayResponseBody() {}

  explicit CreateRenderingInstanceGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRenderingInstanceGatewayResponseBody() = default;
};
class CreateRenderingInstanceGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRenderingInstanceGatewayResponseBody> body{};

  CreateRenderingInstanceGatewayResponse() {}

  explicit CreateRenderingInstanceGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRenderingInstanceGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRenderingInstanceGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRenderingInstanceGatewayResponse() = default;
};
class CreateStreamSnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> location{};
  shared_ptr<long> ownerId{};

  CreateStreamSnapshotRequest() {}

  explicit CreateStreamSnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~CreateStreamSnapshotRequest() = default;
};
class CreateStreamSnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<long> height{};
  shared_ptr<string> id{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<string> requestId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> url{};
  shared_ptr<long> width{};

  CreateStreamSnapshotResponseBody() {}

  explicit CreateStreamSnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~CreateStreamSnapshotResponseBody() = default;
};
class CreateStreamSnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateStreamSnapshotResponseBody> body{};

  CreateStreamSnapshotResponse() {}

  explicit CreateStreamSnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateStreamSnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateStreamSnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~CreateStreamSnapshotResponse() = default;
};
class CreateTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> callback{};
  shared_ptr<string> description{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> flv{};
  shared_ptr<string> hlsM3u8{};
  shared_ptr<string> hlsTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> jpgOnDemand{};
  shared_ptr<string> jpgOverwrite{};
  shared_ptr<string> jpgSequence{};
  shared_ptr<string> mp4{};
  shared_ptr<string> name{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossFilePrefix{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<long> retention{};
  shared_ptr<string> transConfigsJSON{};
  shared_ptr<string> trigger{};
  shared_ptr<string> type{};

  CreateTemplateRequest() {}

  explicit CreateTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (flv) {
      res["Flv"] = boost::any(*flv);
    }
    if (hlsM3u8) {
      res["HlsM3u8"] = boost::any(*hlsM3u8);
    }
    if (hlsTs) {
      res["HlsTs"] = boost::any(*hlsTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (jpgOnDemand) {
      res["JpgOnDemand"] = boost::any(*jpgOnDemand);
    }
    if (jpgOverwrite) {
      res["JpgOverwrite"] = boost::any(*jpgOverwrite);
    }
    if (jpgSequence) {
      res["JpgSequence"] = boost::any(*jpgSequence);
    }
    if (mp4) {
      res["Mp4"] = boost::any(*mp4);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossFilePrefix) {
      res["OssFilePrefix"] = boost::any(*ossFilePrefix);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (transConfigsJSON) {
      res["TransConfigsJSON"] = boost::any(*transConfigsJSON);
    }
    if (trigger) {
      res["Trigger"] = boost::any(*trigger);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Flv") != m.end() && !m["Flv"].empty()) {
      flv = make_shared<string>(boost::any_cast<string>(m["Flv"]));
    }
    if (m.find("HlsM3u8") != m.end() && !m["HlsM3u8"].empty()) {
      hlsM3u8 = make_shared<string>(boost::any_cast<string>(m["HlsM3u8"]));
    }
    if (m.find("HlsTs") != m.end() && !m["HlsTs"].empty()) {
      hlsTs = make_shared<string>(boost::any_cast<string>(m["HlsTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("JpgOnDemand") != m.end() && !m["JpgOnDemand"].empty()) {
      jpgOnDemand = make_shared<string>(boost::any_cast<string>(m["JpgOnDemand"]));
    }
    if (m.find("JpgOverwrite") != m.end() && !m["JpgOverwrite"].empty()) {
      jpgOverwrite = make_shared<string>(boost::any_cast<string>(m["JpgOverwrite"]));
    }
    if (m.find("JpgSequence") != m.end() && !m["JpgSequence"].empty()) {
      jpgSequence = make_shared<string>(boost::any_cast<string>(m["JpgSequence"]));
    }
    if (m.find("Mp4") != m.end() && !m["Mp4"].empty()) {
      mp4 = make_shared<string>(boost::any_cast<string>(m["Mp4"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssFilePrefix") != m.end() && !m["OssFilePrefix"].empty()) {
      ossFilePrefix = make_shared<string>(boost::any_cast<string>(m["OssFilePrefix"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("TransConfigsJSON") != m.end() && !m["TransConfigsJSON"].empty()) {
      transConfigsJSON = make_shared<string>(boost::any_cast<string>(m["TransConfigsJSON"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      trigger = make_shared<string>(boost::any_cast<string>(m["Trigger"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateTemplateRequest() = default;
};
class CreateTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateTemplateResponseBody() {}

  explicit CreateTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateTemplateResponseBody() = default;
};
class CreateTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTemplateResponseBody> body{};

  CreateTemplateResponse() {}

  explicit CreateTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTemplateResponse() = default;
};
class DeleteCloudAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DeleteCloudAppRequest() {}

  explicit DeleteCloudAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DeleteCloudAppRequest() = default;
};
class DeleteCloudAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCloudAppResponseBody() {}

  explicit DeleteCloudAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCloudAppResponseBody() = default;
};
class DeleteCloudAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCloudAppResponseBody> body{};

  DeleteCloudAppResponse() {}

  explicit DeleteCloudAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCloudAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCloudAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCloudAppResponse() = default;
};
class DeleteDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  DeleteDeviceRequest() {}

  explicit DeleteDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteDeviceRequest() = default;
};
class DeleteDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDeviceResponseBody() {}

  explicit DeleteDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDeviceResponseBody() = default;
};
class DeleteDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeviceResponseBody> body{};

  DeleteDeviceResponse() {}

  explicit DeleteDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceResponse() = default;
};
class DeleteDirectoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  DeleteDirectoryRequest() {}

  explicit DeleteDirectoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteDirectoryRequest() = default;
};
class DeleteDirectoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDirectoryResponseBody() {}

  explicit DeleteDirectoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDirectoryResponseBody() = default;
};
class DeleteDirectoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDirectoryResponseBody> body{};

  DeleteDirectoryResponse() {}

  explicit DeleteDirectoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDirectoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDirectoryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDirectoryResponse() = default;
};
class DeleteFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};

  DeleteFileRequest() {}

  explicit DeleteFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
  }


  virtual ~DeleteFileRequest() = default;
};
class DeleteFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteFileResponseBody() {}

  explicit DeleteFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFileResponseBody() = default;
};
class DeleteFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFileResponseBody> body{};

  DeleteFileResponse() {}

  explicit DeleteFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFileResponse() = default;
};
class DeleteGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  DeleteGroupRequest() {}

  explicit DeleteGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteGroupRequest() = default;
};
class DeleteGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteGroupResponseBody() {}

  explicit DeleteGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteGroupResponseBody() = default;
};
class DeleteGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGroupResponseBody> body{};

  DeleteGroupResponse() {}

  explicit DeleteGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGroupResponse() = default;
};
class DeleteParentPlatformRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  DeleteParentPlatformRequest() {}

  explicit DeleteParentPlatformRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteParentPlatformRequest() = default;
};
class DeleteParentPlatformResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteParentPlatformResponseBody() {}

  explicit DeleteParentPlatformResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteParentPlatformResponseBody() = default;
};
class DeleteParentPlatformResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteParentPlatformResponseBody> body{};

  DeleteParentPlatformResponse() {}

  explicit DeleteParentPlatformResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteParentPlatformResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteParentPlatformResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteParentPlatformResponse() = default;
};
class DeletePresetRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> presetId{};

  DeletePresetRequest() {}

  explicit DeletePresetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (presetId) {
      res["PresetId"] = boost::any(*presetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PresetId") != m.end() && !m["PresetId"].empty()) {
      presetId = make_shared<string>(boost::any_cast<string>(m["PresetId"]));
    }
  }


  virtual ~DeletePresetRequest() = default;
};
class DeletePresetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  DeletePresetResponseBody() {}

  explicit DeletePresetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePresetResponseBody() = default;
};
class DeletePresetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePresetResponseBody> body{};

  DeletePresetResponse() {}

  explicit DeletePresetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePresetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePresetResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePresetResponse() = default;
};
class DeletePublicKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyName{};

  DeletePublicKeyRequest() {}

  explicit DeletePublicKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyName) {
      res["KeyName"] = boost::any(*keyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyName") != m.end() && !m["KeyName"].empty()) {
      keyName = make_shared<string>(boost::any_cast<string>(m["KeyName"]));
    }
  }


  virtual ~DeletePublicKeyRequest() = default;
};
class DeletePublicKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeletePublicKeyResponseBody() {}

  explicit DeletePublicKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePublicKeyResponseBody() = default;
};
class DeletePublicKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePublicKeyResponseBody> body{};

  DeletePublicKeyResponse() {}

  explicit DeletePublicKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePublicKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePublicKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePublicKeyResponse() = default;
};
class DeleteRenderingInstanceConfigurationRequestConfiguration : public Darabonba::Model {
public:
  shared_ptr<vector<string>> attributeNames{};
  shared_ptr<string> moduleName{};

  DeleteRenderingInstanceConfigurationRequestConfiguration() {}

  explicit DeleteRenderingInstanceConfigurationRequestConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeNames) {
      res["AttributeNames"] = boost::any(*attributeNames);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeNames") != m.end() && !m["AttributeNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AttributeNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AttributeNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      attributeNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~DeleteRenderingInstanceConfigurationRequestConfiguration() = default;
};
class DeleteRenderingInstanceConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteRenderingInstanceConfigurationRequestConfiguration>> configuration{};
  shared_ptr<string> renderingInstanceId{};

  DeleteRenderingInstanceConfigurationRequest() {}

  explicit DeleteRenderingInstanceConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      vector<boost::any> temp1;
      for(auto item1:*configuration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configuration"] = boost::any(temp1);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      if (typeid(vector<boost::any>) == m["Configuration"].type()) {
        vector<DeleteRenderingInstanceConfigurationRequestConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configuration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteRenderingInstanceConfigurationRequestConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configuration = make_shared<vector<DeleteRenderingInstanceConfigurationRequestConfiguration>>(expect1);
      }
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~DeleteRenderingInstanceConfigurationRequest() = default;
};
class DeleteRenderingInstanceConfigurationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> configurationShrink{};
  shared_ptr<string> renderingInstanceId{};

  DeleteRenderingInstanceConfigurationShrinkRequest() {}

  explicit DeleteRenderingInstanceConfigurationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationShrink) {
      res["Configuration"] = boost::any(*configurationShrink);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configurationShrink = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~DeleteRenderingInstanceConfigurationShrinkRequest() = default;
};
class DeleteRenderingInstanceConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRenderingInstanceConfigurationResponseBody() {}

  explicit DeleteRenderingInstanceConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRenderingInstanceConfigurationResponseBody() = default;
};
class DeleteRenderingInstanceConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRenderingInstanceConfigurationResponseBody> body{};

  DeleteRenderingInstanceConfigurationResponse() {}

  explicit DeleteRenderingInstanceConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRenderingInstanceConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRenderingInstanceConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRenderingInstanceConfigurationResponse() = default;
};
class DeleteRenderingInstanceGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> renderingInstanceId{};

  DeleteRenderingInstanceGatewayRequest() {}

  explicit DeleteRenderingInstanceGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~DeleteRenderingInstanceGatewayRequest() = default;
};
class DeleteRenderingInstanceGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRenderingInstanceGatewayResponseBody() {}

  explicit DeleteRenderingInstanceGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRenderingInstanceGatewayResponseBody() = default;
};
class DeleteRenderingInstanceGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRenderingInstanceGatewayResponseBody> body{};

  DeleteRenderingInstanceGatewayResponse() {}

  explicit DeleteRenderingInstanceGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRenderingInstanceGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRenderingInstanceGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRenderingInstanceGatewayResponse() = default;
};
class DeleteRenderingInstanceSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> attributeNames{};
  shared_ptr<string> renderingInstanceId{};

  DeleteRenderingInstanceSettingsRequest() {}

  explicit DeleteRenderingInstanceSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeNames) {
      res["AttributeNames"] = boost::any(*attributeNames);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeNames") != m.end() && !m["AttributeNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AttributeNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AttributeNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      attributeNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~DeleteRenderingInstanceSettingsRequest() = default;
};
class DeleteRenderingInstanceSettingsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attributeNamesShrink{};
  shared_ptr<string> renderingInstanceId{};

  DeleteRenderingInstanceSettingsShrinkRequest() {}

  explicit DeleteRenderingInstanceSettingsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeNamesShrink) {
      res["AttributeNames"] = boost::any(*attributeNamesShrink);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeNames") != m.end() && !m["AttributeNames"].empty()) {
      attributeNamesShrink = make_shared<string>(boost::any_cast<string>(m["AttributeNames"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~DeleteRenderingInstanceSettingsShrinkRequest() = default;
};
class DeleteRenderingInstanceSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRenderingInstanceSettingsResponseBody() {}

  explicit DeleteRenderingInstanceSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRenderingInstanceSettingsResponseBody() = default;
};
class DeleteRenderingInstanceSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRenderingInstanceSettingsResponseBody> body{};

  DeleteRenderingInstanceSettingsResponse() {}

  explicit DeleteRenderingInstanceSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRenderingInstanceSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRenderingInstanceSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRenderingInstanceSettingsResponse() = default;
};
class DeleteTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  DeleteTemplateRequest() {}

  explicit DeleteTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteTemplateRequest() = default;
};
class DeleteTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTemplateResponseBody() {}

  explicit DeleteTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTemplateResponseBody() = default;
};
class DeleteTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTemplateResponseBody> body{};

  DeleteTemplateResponse() {}

  explicit DeleteTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTemplateResponse() = default;
};
class DeleteVsPullStreamInfoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};

  DeleteVsPullStreamInfoConfigRequest() {}

  explicit DeleteVsPullStreamInfoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DeleteVsPullStreamInfoConfigRequest() = default;
};
class DeleteVsPullStreamInfoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVsPullStreamInfoConfigResponseBody() {}

  explicit DeleteVsPullStreamInfoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVsPullStreamInfoConfigResponseBody() = default;
};
class DeleteVsPullStreamInfoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVsPullStreamInfoConfigResponseBody> body{};

  DeleteVsPullStreamInfoConfigResponse() {}

  explicit DeleteVsPullStreamInfoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVsPullStreamInfoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVsPullStreamInfoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVsPullStreamInfoConfigResponse() = default;
};
class DeleteVsStreamsNotifyUrlConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DeleteVsStreamsNotifyUrlConfigRequest() {}

  explicit DeleteVsStreamsNotifyUrlConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteVsStreamsNotifyUrlConfigRequest() = default;
};
class DeleteVsStreamsNotifyUrlConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVsStreamsNotifyUrlConfigResponseBody() {}

  explicit DeleteVsStreamsNotifyUrlConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVsStreamsNotifyUrlConfigResponseBody() = default;
};
class DeleteVsStreamsNotifyUrlConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVsStreamsNotifyUrlConfigResponseBody> body{};

  DeleteVsStreamsNotifyUrlConfigResponse() {}

  explicit DeleteVsStreamsNotifyUrlConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVsStreamsNotifyUrlConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVsStreamsNotifyUrlConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVsStreamsNotifyUrlConfigResponse() = default;
};
class DescribeAccountStatRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  DescribeAccountStatRequest() {}

  explicit DescribeAccountStatRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeAccountStatRequest() = default;
};
class DescribeAccountStatResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> groupLimit{};
  shared_ptr<long> groupNum{};
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};
  shared_ptr<long> templateLimit{};
  shared_ptr<long> templateNum{};

  DescribeAccountStatResponseBody() {}

  explicit DescribeAccountStatResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupLimit) {
      res["GroupLimit"] = boost::any(*groupLimit);
    }
    if (groupNum) {
      res["GroupNum"] = boost::any(*groupNum);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateLimit) {
      res["TemplateLimit"] = boost::any(*templateLimit);
    }
    if (templateNum) {
      res["TemplateNum"] = boost::any(*templateNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupLimit") != m.end() && !m["GroupLimit"].empty()) {
      groupLimit = make_shared<long>(boost::any_cast<long>(m["GroupLimit"]));
    }
    if (m.find("GroupNum") != m.end() && !m["GroupNum"].empty()) {
      groupNum = make_shared<long>(boost::any_cast<long>(m["GroupNum"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateLimit") != m.end() && !m["TemplateLimit"].empty()) {
      templateLimit = make_shared<long>(boost::any_cast<long>(m["TemplateLimit"]));
    }
    if (m.find("TemplateNum") != m.end() && !m["TemplateNum"].empty()) {
      templateNum = make_shared<long>(boost::any_cast<long>(m["TemplateNum"]));
    }
  }


  virtual ~DescribeAccountStatResponseBody() = default;
};
class DescribeAccountStatResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAccountStatResponseBody> body{};

  DescribeAccountStatResponse() {}

  explicit DescribeAccountStatResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAccountStatResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAccountStatResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAccountStatResponse() = default;
};
class DescribeDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<bool> includeDirectory{};
  shared_ptr<bool> includeStats{};
  shared_ptr<long> ownerId{};

  DescribeDeviceRequest() {}

  explicit DescribeDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (includeDirectory) {
      res["IncludeDirectory"] = boost::any(*includeDirectory);
    }
    if (includeStats) {
      res["IncludeStats"] = boost::any(*includeStats);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IncludeDirectory") != m.end() && !m["IncludeDirectory"].empty()) {
      includeDirectory = make_shared<bool>(boost::any_cast<bool>(m["IncludeDirectory"]));
    }
    if (m.find("IncludeStats") != m.end() && !m["IncludeStats"].empty()) {
      includeStats = make_shared<bool>(boost::any_cast<bool>(m["IncludeStats"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeDeviceRequest() = default;
};
class DescribeDeviceResponseBodyDirectory : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};

  DescribeDeviceResponseBodyDirectory() {}

  explicit DescribeDeviceResponseBodyDirectory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
  }


  virtual ~DescribeDeviceResponseBodyDirectory() = default;
};
class DescribeDeviceResponseBodyStats : public Darabonba::Model {
public:
  shared_ptr<long> channelNum{};
  shared_ptr<long> failedNum{};
  shared_ptr<long> offlineNum{};
  shared_ptr<long> onlineNum{};
  shared_ptr<long> streamNum{};

  DescribeDeviceResponseBodyStats() {}

  explicit DescribeDeviceResponseBodyStats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelNum) {
      res["ChannelNum"] = boost::any(*channelNum);
    }
    if (failedNum) {
      res["FailedNum"] = boost::any(*failedNum);
    }
    if (offlineNum) {
      res["OfflineNum"] = boost::any(*offlineNum);
    }
    if (onlineNum) {
      res["OnlineNum"] = boost::any(*onlineNum);
    }
    if (streamNum) {
      res["StreamNum"] = boost::any(*streamNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelNum") != m.end() && !m["ChannelNum"].empty()) {
      channelNum = make_shared<long>(boost::any_cast<long>(m["ChannelNum"]));
    }
    if (m.find("FailedNum") != m.end() && !m["FailedNum"].empty()) {
      failedNum = make_shared<long>(boost::any_cast<long>(m["FailedNum"]));
    }
    if (m.find("OfflineNum") != m.end() && !m["OfflineNum"].empty()) {
      offlineNum = make_shared<long>(boost::any_cast<long>(m["OfflineNum"]));
    }
    if (m.find("OnlineNum") != m.end() && !m["OnlineNum"].empty()) {
      onlineNum = make_shared<long>(boost::any_cast<long>(m["OnlineNum"]));
    }
    if (m.find("StreamNum") != m.end() && !m["StreamNum"].empty()) {
      streamNum = make_shared<long>(boost::any_cast<long>(m["StreamNum"]));
    }
  }


  virtual ~DescribeDeviceResponseBodyStats() = default;
};
class DescribeDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> alarmMethod{};
  shared_ptr<bool> autoDirectory{};
  shared_ptr<bool> autoPos{};
  shared_ptr<bool> autoStart{};
  shared_ptr<string> channelSyncTime{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<DescribeDeviceResponseBodyDirectory> directory{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> dsn{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> gbId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<string> ip{};
  shared_ptr<string> latitude{};
  shared_ptr<string> longitude{};
  shared_ptr<string> name{};
  shared_ptr<string> params{};
  shared_ptr<string> parentId{};
  shared_ptr<string> password{};
  shared_ptr<long> port{};
  shared_ptr<long> posInterval{};
  shared_ptr<string> protocol{};
  shared_ptr<string> registeredTime{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDeviceResponseBodyStats> stats{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> username{};
  shared_ptr<string> vendor{};

  DescribeDeviceResponseBody() {}

  explicit DescribeDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmMethod) {
      res["AlarmMethod"] = boost::any(*alarmMethod);
    }
    if (autoDirectory) {
      res["AutoDirectory"] = boost::any(*autoDirectory);
    }
    if (autoPos) {
      res["AutoPos"] = boost::any(*autoPos);
    }
    if (autoStart) {
      res["AutoStart"] = boost::any(*autoStart);
    }
    if (channelSyncTime) {
      res["ChannelSyncTime"] = boost::any(*channelSyncTime);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (directory) {
      res["Directory"] = directory ? boost::any(directory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (dsn) {
      res["Dsn"] = boost::any(*dsn);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (latitude) {
      res["Latitude"] = boost::any(*latitude);
    }
    if (longitude) {
      res["Longitude"] = boost::any(*longitude);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (posInterval) {
      res["PosInterval"] = boost::any(*posInterval);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (registeredTime) {
      res["RegisteredTime"] = boost::any(*registeredTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stats) {
      res["Stats"] = stats ? boost::any(stats->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmMethod") != m.end() && !m["AlarmMethod"].empty()) {
      alarmMethod = make_shared<string>(boost::any_cast<string>(m["AlarmMethod"]));
    }
    if (m.find("AutoDirectory") != m.end() && !m["AutoDirectory"].empty()) {
      autoDirectory = make_shared<bool>(boost::any_cast<bool>(m["AutoDirectory"]));
    }
    if (m.find("AutoPos") != m.end() && !m["AutoPos"].empty()) {
      autoPos = make_shared<bool>(boost::any_cast<bool>(m["AutoPos"]));
    }
    if (m.find("AutoStart") != m.end() && !m["AutoStart"].empty()) {
      autoStart = make_shared<bool>(boost::any_cast<bool>(m["AutoStart"]));
    }
    if (m.find("ChannelSyncTime") != m.end() && !m["ChannelSyncTime"].empty()) {
      channelSyncTime = make_shared<string>(boost::any_cast<string>(m["ChannelSyncTime"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Directory") != m.end() && !m["Directory"].empty()) {
      if (typeid(map<string, boost::any>) == m["Directory"].type()) {
        DescribeDeviceResponseBodyDirectory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Directory"]));
        directory = make_shared<DescribeDeviceResponseBodyDirectory>(model1);
      }
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("Dsn") != m.end() && !m["Dsn"].empty()) {
      dsn = make_shared<string>(boost::any_cast<string>(m["Dsn"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Latitude") != m.end() && !m["Latitude"].empty()) {
      latitude = make_shared<string>(boost::any_cast<string>(m["Latitude"]));
    }
    if (m.find("Longitude") != m.end() && !m["Longitude"].empty()) {
      longitude = make_shared<string>(boost::any_cast<string>(m["Longitude"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("PosInterval") != m.end() && !m["PosInterval"].empty()) {
      posInterval = make_shared<long>(boost::any_cast<long>(m["PosInterval"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RegisteredTime") != m.end() && !m["RegisteredTime"].empty()) {
      registeredTime = make_shared<string>(boost::any_cast<string>(m["RegisteredTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Stats") != m.end() && !m["Stats"].empty()) {
      if (typeid(map<string, boost::any>) == m["Stats"].type()) {
        DescribeDeviceResponseBodyStats model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Stats"]));
        stats = make_shared<DescribeDeviceResponseBodyStats>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~DescribeDeviceResponseBody() = default;
};
class DescribeDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDeviceResponseBody> body{};

  DescribeDeviceResponse() {}

  explicit DescribeDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceResponse() = default;
};
class DescribeDeviceChannelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  DescribeDeviceChannelsRequest() {}

  explicit DescribeDeviceChannelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeDeviceChannelsRequest() = default;
};
class DescribeDeviceChannelsResponseBodyChannels : public Darabonba::Model {
public:
  shared_ptr<long> channelId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceStatus{};
  shared_ptr<string> gbId{};
  shared_ptr<string> name{};
  shared_ptr<string> params{};
  shared_ptr<string> streamId{};
  shared_ptr<string> streamStatus{};

  DescribeDeviceChannelsResponseBodyChannels() {}

  explicit DescribeDeviceChannelsResponseBodyChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceStatus) {
      res["DeviceStatus"] = boost::any(*deviceStatus);
    }
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (streamId) {
      res["StreamId"] = boost::any(*streamId);
    }
    if (streamStatus) {
      res["StreamStatus"] = boost::any(*streamStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<long>(boost::any_cast<long>(m["ChannelId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceStatus") != m.end() && !m["DeviceStatus"].empty()) {
      deviceStatus = make_shared<string>(boost::any_cast<string>(m["DeviceStatus"]));
    }
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("StreamId") != m.end() && !m["StreamId"].empty()) {
      streamId = make_shared<string>(boost::any_cast<string>(m["StreamId"]));
    }
    if (m.find("StreamStatus") != m.end() && !m["StreamStatus"].empty()) {
      streamStatus = make_shared<string>(boost::any_cast<string>(m["StreamStatus"]));
    }
  }


  virtual ~DescribeDeviceChannelsResponseBodyChannels() = default;
};
class DescribeDeviceChannelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeviceChannelsResponseBodyChannels>> channels{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDeviceChannelsResponseBody() {}

  explicit DescribeDeviceChannelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      vector<boost::any> temp1;
      for(auto item1:*channels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Channels"] = boost::any(temp1);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<DescribeDeviceChannelsResponseBodyChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Channels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceChannelsResponseBodyChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channels = make_shared<vector<DescribeDeviceChannelsResponseBodyChannels>>(expect1);
      }
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDeviceChannelsResponseBody() = default;
};
class DescribeDeviceChannelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDeviceChannelsResponseBody> body{};

  DescribeDeviceChannelsResponse() {}

  explicit DescribeDeviceChannelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceChannelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceChannelsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceChannelsResponse() = default;
};
class DescribeDeviceGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientIp{};
  shared_ptr<long> expire{};
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  DescribeDeviceGatewayRequest() {}

  explicit DescribeDeviceGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeDeviceGatewayRequest() = default;
};
class DescribeDeviceGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> requestId{};
  shared_ptr<string> token{};

  DescribeDeviceGatewayResponseBody() {}

  explicit DescribeDeviceGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~DescribeDeviceGatewayResponseBody() = default;
};
class DescribeDeviceGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDeviceGatewayResponseBody> body{};

  DescribeDeviceGatewayResponse() {}

  explicit DescribeDeviceGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceGatewayResponse() = default;
};
class DescribeDeviceURLRequest : public Darabonba::Model {
public:
  shared_ptr<bool> auth{};
  shared_ptr<long> expire{};
  shared_ptr<string> id{};
  shared_ptr<string> mode{};
  shared_ptr<string> outProtocol{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> stream{};
  shared_ptr<string> type{};

  DescribeDeviceURLRequest() {}

  explicit DescribeDeviceURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auth) {
      res["Auth"] = boost::any(*auth);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (outProtocol) {
      res["OutProtocol"] = boost::any(*outProtocol);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Auth") != m.end() && !m["Auth"].empty()) {
      auth = make_shared<bool>(boost::any_cast<bool>(m["Auth"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("OutProtocol") != m.end() && !m["OutProtocol"].empty()) {
      outProtocol = make_shared<string>(boost::any_cast<string>(m["OutProtocol"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<string>(boost::any_cast<string>(m["Stream"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDeviceURLRequest() = default;
};
class DescribeDeviceURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> expireTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> url{};

  DescribeDeviceURLResponseBody() {}

  explicit DescribeDeviceURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeDeviceURLResponseBody() = default;
};
class DescribeDeviceURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDeviceURLResponseBody> body{};

  DescribeDeviceURLResponse() {}

  explicit DescribeDeviceURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceURLResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceURLResponse() = default;
};
class DescribeDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> directoryId{};
  shared_ptr<string> dsn{};
  shared_ptr<string> gbId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<bool> includeDirectory{};
  shared_ptr<bool> includeStats{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortDirection{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> vendor{};

  DescribeDevicesRequest() {}

  explicit DescribeDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (dsn) {
      res["Dsn"] = boost::any(*dsn);
    }
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (includeDirectory) {
      res["IncludeDirectory"] = boost::any(*includeDirectory);
    }
    if (includeStats) {
      res["IncludeStats"] = boost::any(*includeStats);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortDirection) {
      res["SortDirection"] = boost::any(*sortDirection);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("Dsn") != m.end() && !m["Dsn"].empty()) {
      dsn = make_shared<string>(boost::any_cast<string>(m["Dsn"]));
    }
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IncludeDirectory") != m.end() && !m["IncludeDirectory"].empty()) {
      includeDirectory = make_shared<bool>(boost::any_cast<bool>(m["IncludeDirectory"]));
    }
    if (m.find("IncludeStats") != m.end() && !m["IncludeStats"].empty()) {
      includeStats = make_shared<bool>(boost::any_cast<bool>(m["IncludeStats"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortDirection") != m.end() && !m["SortDirection"].empty()) {
      sortDirection = make_shared<string>(boost::any_cast<string>(m["SortDirection"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~DescribeDevicesRequest() = default;
};
class DescribeDevicesResponseBodyDevicesDirectory : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};

  DescribeDevicesResponseBodyDevicesDirectory() {}

  explicit DescribeDevicesResponseBodyDevicesDirectory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
  }


  virtual ~DescribeDevicesResponseBodyDevicesDirectory() = default;
};
class DescribeDevicesResponseBodyDevicesStats : public Darabonba::Model {
public:
  shared_ptr<long> channelNum{};
  shared_ptr<long> failedNum{};
  shared_ptr<long> offlineNum{};
  shared_ptr<long> onlineNum{};
  shared_ptr<long> streamNum{};

  DescribeDevicesResponseBodyDevicesStats() {}

  explicit DescribeDevicesResponseBodyDevicesStats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelNum) {
      res["ChannelNum"] = boost::any(*channelNum);
    }
    if (failedNum) {
      res["FailedNum"] = boost::any(*failedNum);
    }
    if (offlineNum) {
      res["OfflineNum"] = boost::any(*offlineNum);
    }
    if (onlineNum) {
      res["OnlineNum"] = boost::any(*onlineNum);
    }
    if (streamNum) {
      res["StreamNum"] = boost::any(*streamNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelNum") != m.end() && !m["ChannelNum"].empty()) {
      channelNum = make_shared<long>(boost::any_cast<long>(m["ChannelNum"]));
    }
    if (m.find("FailedNum") != m.end() && !m["FailedNum"].empty()) {
      failedNum = make_shared<long>(boost::any_cast<long>(m["FailedNum"]));
    }
    if (m.find("OfflineNum") != m.end() && !m["OfflineNum"].empty()) {
      offlineNum = make_shared<long>(boost::any_cast<long>(m["OfflineNum"]));
    }
    if (m.find("OnlineNum") != m.end() && !m["OnlineNum"].empty()) {
      onlineNum = make_shared<long>(boost::any_cast<long>(m["OnlineNum"]));
    }
    if (m.find("StreamNum") != m.end() && !m["StreamNum"].empty()) {
      streamNum = make_shared<long>(boost::any_cast<long>(m["StreamNum"]));
    }
  }


  virtual ~DescribeDevicesResponseBodyDevicesStats() = default;
};
class DescribeDevicesResponseBodyDevices : public Darabonba::Model {
public:
  shared_ptr<string> alarmMethod{};
  shared_ptr<bool> autoDirectory{};
  shared_ptr<bool> autoPos{};
  shared_ptr<bool> autoStart{};
  shared_ptr<string> channelSyncTime{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<DescribeDevicesResponseBodyDevicesDirectory> directory{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> dsn{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> gbId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<string> ip{};
  shared_ptr<string> latitude{};
  shared_ptr<string> longitude{};
  shared_ptr<string> name{};
  shared_ptr<string> params{};
  shared_ptr<string> parentId{};
  shared_ptr<string> password{};
  shared_ptr<long> port{};
  shared_ptr<long> posInterval{};
  shared_ptr<string> protocol{};
  shared_ptr<string> registeredTime{};
  shared_ptr<DescribeDevicesResponseBodyDevicesStats> stats{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> username{};
  shared_ptr<string> vendor{};

  DescribeDevicesResponseBodyDevices() {}

  explicit DescribeDevicesResponseBodyDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmMethod) {
      res["AlarmMethod"] = boost::any(*alarmMethod);
    }
    if (autoDirectory) {
      res["AutoDirectory"] = boost::any(*autoDirectory);
    }
    if (autoPos) {
      res["AutoPos"] = boost::any(*autoPos);
    }
    if (autoStart) {
      res["AutoStart"] = boost::any(*autoStart);
    }
    if (channelSyncTime) {
      res["ChannelSyncTime"] = boost::any(*channelSyncTime);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (directory) {
      res["Directory"] = directory ? boost::any(directory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (dsn) {
      res["Dsn"] = boost::any(*dsn);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (latitude) {
      res["Latitude"] = boost::any(*latitude);
    }
    if (longitude) {
      res["Longitude"] = boost::any(*longitude);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (posInterval) {
      res["PosInterval"] = boost::any(*posInterval);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (registeredTime) {
      res["RegisteredTime"] = boost::any(*registeredTime);
    }
    if (stats) {
      res["Stats"] = stats ? boost::any(stats->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmMethod") != m.end() && !m["AlarmMethod"].empty()) {
      alarmMethod = make_shared<string>(boost::any_cast<string>(m["AlarmMethod"]));
    }
    if (m.find("AutoDirectory") != m.end() && !m["AutoDirectory"].empty()) {
      autoDirectory = make_shared<bool>(boost::any_cast<bool>(m["AutoDirectory"]));
    }
    if (m.find("AutoPos") != m.end() && !m["AutoPos"].empty()) {
      autoPos = make_shared<bool>(boost::any_cast<bool>(m["AutoPos"]));
    }
    if (m.find("AutoStart") != m.end() && !m["AutoStart"].empty()) {
      autoStart = make_shared<bool>(boost::any_cast<bool>(m["AutoStart"]));
    }
    if (m.find("ChannelSyncTime") != m.end() && !m["ChannelSyncTime"].empty()) {
      channelSyncTime = make_shared<string>(boost::any_cast<string>(m["ChannelSyncTime"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Directory") != m.end() && !m["Directory"].empty()) {
      if (typeid(map<string, boost::any>) == m["Directory"].type()) {
        DescribeDevicesResponseBodyDevicesDirectory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Directory"]));
        directory = make_shared<DescribeDevicesResponseBodyDevicesDirectory>(model1);
      }
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("Dsn") != m.end() && !m["Dsn"].empty()) {
      dsn = make_shared<string>(boost::any_cast<string>(m["Dsn"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Latitude") != m.end() && !m["Latitude"].empty()) {
      latitude = make_shared<string>(boost::any_cast<string>(m["Latitude"]));
    }
    if (m.find("Longitude") != m.end() && !m["Longitude"].empty()) {
      longitude = make_shared<string>(boost::any_cast<string>(m["Longitude"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("PosInterval") != m.end() && !m["PosInterval"].empty()) {
      posInterval = make_shared<long>(boost::any_cast<long>(m["PosInterval"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RegisteredTime") != m.end() && !m["RegisteredTime"].empty()) {
      registeredTime = make_shared<string>(boost::any_cast<string>(m["RegisteredTime"]));
    }
    if (m.find("Stats") != m.end() && !m["Stats"].empty()) {
      if (typeid(map<string, boost::any>) == m["Stats"].type()) {
        DescribeDevicesResponseBodyDevicesStats model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Stats"]));
        stats = make_shared<DescribeDevicesResponseBodyDevicesStats>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~DescribeDevicesResponseBodyDevices() = default;
};
class DescribeDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDevicesResponseBodyDevices>> devices{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDevicesResponseBody() {}

  explicit DescribeDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<DescribeDevicesResponseBodyDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDevicesResponseBodyDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<DescribeDevicesResponseBodyDevices>>(expect1);
      }
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDevicesResponseBody() = default;
};
class DescribeDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDevicesResponseBody> body{};

  DescribeDevicesResponse() {}

  explicit DescribeDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDevicesResponse() = default;
};
class DescribeDirectoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<bool> noPagination{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortDirection{};

  DescribeDirectoriesRequest() {}

  explicit DescribeDirectoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (noPagination) {
      res["NoPagination"] = boost::any(*noPagination);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortDirection) {
      res["SortDirection"] = boost::any(*sortDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("NoPagination") != m.end() && !m["NoPagination"].empty()) {
      noPagination = make_shared<bool>(boost::any_cast<bool>(m["NoPagination"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortDirection") != m.end() && !m["SortDirection"].empty()) {
      sortDirection = make_shared<string>(boost::any_cast<string>(m["SortDirection"]));
    }
  }


  virtual ~DescribeDirectoriesRequest() = default;
};
class DescribeDirectoriesResponseBodyDirectories : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};

  DescribeDirectoriesResponseBodyDirectories() {}

  explicit DescribeDirectoriesResponseBodyDirectories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
  }


  virtual ~DescribeDirectoriesResponseBodyDirectories() = default;
};
class DescribeDirectoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDirectoriesResponseBodyDirectories>> directories{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDirectoriesResponseBody() {}

  explicit DescribeDirectoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directories) {
      vector<boost::any> temp1;
      for(auto item1:*directories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Directories"] = boost::any(temp1);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Directories") != m.end() && !m["Directories"].empty()) {
      if (typeid(vector<boost::any>) == m["Directories"].type()) {
        vector<DescribeDirectoriesResponseBodyDirectories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Directories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDirectoriesResponseBodyDirectories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        directories = make_shared<vector<DescribeDirectoriesResponseBodyDirectories>>(expect1);
      }
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDirectoriesResponseBody() = default;
};
class DescribeDirectoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDirectoriesResponseBody> body{};

  DescribeDirectoriesResponse() {}

  explicit DescribeDirectoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDirectoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDirectoriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDirectoriesResponse() = default;
};
class DescribeDirectoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  DescribeDirectoryRequest() {}

  explicit DescribeDirectoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeDirectoryRequest() = default;
};
class DescribeDirectoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};
  shared_ptr<string> requestId{};

  DescribeDirectoryResponseBody() {}

  explicit DescribeDirectoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDirectoryResponseBody() = default;
};
class DescribeDirectoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDirectoryResponseBody> body{};

  DescribeDirectoryResponse() {}

  explicit DescribeDirectoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDirectoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDirectoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDirectoryResponse() = default;
};
class DescribeGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<bool> includeStats{};
  shared_ptr<long> ownerId{};

  DescribeGroupRequest() {}

  explicit DescribeGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (includeStats) {
      res["IncludeStats"] = boost::any(*includeStats);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IncludeStats") != m.end() && !m["IncludeStats"].empty()) {
      includeStats = make_shared<bool>(boost::any_cast<bool>(m["IncludeStats"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeGroupRequest() = default;
};
class DescribeGroupResponseBodyStats : public Darabonba::Model {
public:
  shared_ptr<long> deviceNum{};
  shared_ptr<long> iedNum{};
  shared_ptr<long> ipcNum{};
  shared_ptr<long> platformNum{};

  DescribeGroupResponseBodyStats() {}

  explicit DescribeGroupResponseBodyStats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceNum) {
      res["DeviceNum"] = boost::any(*deviceNum);
    }
    if (iedNum) {
      res["IedNum"] = boost::any(*iedNum);
    }
    if (ipcNum) {
      res["IpcNum"] = boost::any(*ipcNum);
    }
    if (platformNum) {
      res["PlatformNum"] = boost::any(*platformNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceNum") != m.end() && !m["DeviceNum"].empty()) {
      deviceNum = make_shared<long>(boost::any_cast<long>(m["DeviceNum"]));
    }
    if (m.find("IedNum") != m.end() && !m["IedNum"].empty()) {
      iedNum = make_shared<long>(boost::any_cast<long>(m["IedNum"]));
    }
    if (m.find("IpcNum") != m.end() && !m["IpcNum"].empty()) {
      ipcNum = make_shared<long>(boost::any_cast<long>(m["IpcNum"]));
    }
    if (m.find("PlatformNum") != m.end() && !m["PlatformNum"].empty()) {
      platformNum = make_shared<long>(boost::any_cast<long>(m["PlatformNum"]));
    }
  }


  virtual ~DescribeGroupResponseBodyStats() = default;
};
class DescribeGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aliasId{};
  shared_ptr<string> app{};
  shared_ptr<string> callback{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> gbId{};
  shared_ptr<string> gbIp{};
  shared_ptr<long> gbPort{};
  shared_ptr<vector<string>> gbTcpPorts{};
  shared_ptr<vector<string>> gbUdpPorts{};
  shared_ptr<string> id{};
  shared_ptr<string> inProtocol{};
  shared_ptr<bool> lazyPull{};
  shared_ptr<string> name{};
  shared_ptr<string> outProtocol{};
  shared_ptr<string> playDomain{};
  shared_ptr<string> pushDomain{};
  shared_ptr<string> region{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeGroupResponseBodyStats> stats{};
  shared_ptr<string> status{};

  DescribeGroupResponseBody() {}

  explicit DescribeGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasId) {
      res["AliasId"] = boost::any(*aliasId);
    }
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (gbIp) {
      res["GbIp"] = boost::any(*gbIp);
    }
    if (gbPort) {
      res["GbPort"] = boost::any(*gbPort);
    }
    if (gbTcpPorts) {
      res["GbTcpPorts"] = boost::any(*gbTcpPorts);
    }
    if (gbUdpPorts) {
      res["GbUdpPorts"] = boost::any(*gbUdpPorts);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inProtocol) {
      res["InProtocol"] = boost::any(*inProtocol);
    }
    if (lazyPull) {
      res["LazyPull"] = boost::any(*lazyPull);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outProtocol) {
      res["OutProtocol"] = boost::any(*outProtocol);
    }
    if (playDomain) {
      res["PlayDomain"] = boost::any(*playDomain);
    }
    if (pushDomain) {
      res["PushDomain"] = boost::any(*pushDomain);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stats) {
      res["Stats"] = stats ? boost::any(stats->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasId") != m.end() && !m["AliasId"].empty()) {
      aliasId = make_shared<string>(boost::any_cast<string>(m["AliasId"]));
    }
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("GbIp") != m.end() && !m["GbIp"].empty()) {
      gbIp = make_shared<string>(boost::any_cast<string>(m["GbIp"]));
    }
    if (m.find("GbPort") != m.end() && !m["GbPort"].empty()) {
      gbPort = make_shared<long>(boost::any_cast<long>(m["GbPort"]));
    }
    if (m.find("GbTcpPorts") != m.end() && !m["GbTcpPorts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GbTcpPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GbTcpPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      gbTcpPorts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GbUdpPorts") != m.end() && !m["GbUdpPorts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GbUdpPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GbUdpPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      gbUdpPorts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InProtocol") != m.end() && !m["InProtocol"].empty()) {
      inProtocol = make_shared<string>(boost::any_cast<string>(m["InProtocol"]));
    }
    if (m.find("LazyPull") != m.end() && !m["LazyPull"].empty()) {
      lazyPull = make_shared<bool>(boost::any_cast<bool>(m["LazyPull"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutProtocol") != m.end() && !m["OutProtocol"].empty()) {
      outProtocol = make_shared<string>(boost::any_cast<string>(m["OutProtocol"]));
    }
    if (m.find("PlayDomain") != m.end() && !m["PlayDomain"].empty()) {
      playDomain = make_shared<string>(boost::any_cast<string>(m["PlayDomain"]));
    }
    if (m.find("PushDomain") != m.end() && !m["PushDomain"].empty()) {
      pushDomain = make_shared<string>(boost::any_cast<string>(m["PushDomain"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Stats") != m.end() && !m["Stats"].empty()) {
      if (typeid(map<string, boost::any>) == m["Stats"].type()) {
        DescribeGroupResponseBodyStats model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Stats"]));
        stats = make_shared<DescribeGroupResponseBodyStats>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeGroupResponseBody() = default;
};
class DescribeGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupResponseBody> body{};

  DescribeGroupResponse() {}

  explicit DescribeGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupResponse() = default;
};
class DescribeGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> inProtocol{};
  shared_ptr<bool> includeStats{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> region{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortDirection{};
  shared_ptr<string> status{};

  DescribeGroupsRequest() {}

  explicit DescribeGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inProtocol) {
      res["InProtocol"] = boost::any(*inProtocol);
    }
    if (includeStats) {
      res["IncludeStats"] = boost::any(*includeStats);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortDirection) {
      res["SortDirection"] = boost::any(*sortDirection);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InProtocol") != m.end() && !m["InProtocol"].empty()) {
      inProtocol = make_shared<string>(boost::any_cast<string>(m["InProtocol"]));
    }
    if (m.find("IncludeStats") != m.end() && !m["IncludeStats"].empty()) {
      includeStats = make_shared<bool>(boost::any_cast<bool>(m["IncludeStats"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortDirection") != m.end() && !m["SortDirection"].empty()) {
      sortDirection = make_shared<string>(boost::any_cast<string>(m["SortDirection"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeGroupsRequest() = default;
};
class DescribeGroupsResponseBodyGroupsStats : public Darabonba::Model {
public:
  shared_ptr<long> deviceNum{};
  shared_ptr<long> iedNum{};
  shared_ptr<long> ipcNum{};
  shared_ptr<long> platformNum{};

  DescribeGroupsResponseBodyGroupsStats() {}

  explicit DescribeGroupsResponseBodyGroupsStats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceNum) {
      res["DeviceNum"] = boost::any(*deviceNum);
    }
    if (iedNum) {
      res["IedNum"] = boost::any(*iedNum);
    }
    if (ipcNum) {
      res["IpcNum"] = boost::any(*ipcNum);
    }
    if (platformNum) {
      res["PlatformNum"] = boost::any(*platformNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceNum") != m.end() && !m["DeviceNum"].empty()) {
      deviceNum = make_shared<long>(boost::any_cast<long>(m["DeviceNum"]));
    }
    if (m.find("IedNum") != m.end() && !m["IedNum"].empty()) {
      iedNum = make_shared<long>(boost::any_cast<long>(m["IedNum"]));
    }
    if (m.find("IpcNum") != m.end() && !m["IpcNum"].empty()) {
      ipcNum = make_shared<long>(boost::any_cast<long>(m["IpcNum"]));
    }
    if (m.find("PlatformNum") != m.end() && !m["PlatformNum"].empty()) {
      platformNum = make_shared<long>(boost::any_cast<long>(m["PlatformNum"]));
    }
  }


  virtual ~DescribeGroupsResponseBodyGroupsStats() = default;
};
class DescribeGroupsResponseBodyGroups : public Darabonba::Model {
public:
  shared_ptr<string> aliasId{};
  shared_ptr<string> app{};
  shared_ptr<string> callback{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> gbId{};
  shared_ptr<string> gbIp{};
  shared_ptr<long> gbPort{};
  shared_ptr<vector<string>> gbTcpPorts{};
  shared_ptr<vector<string>> gbUdpPorts{};
  shared_ptr<string> id{};
  shared_ptr<string> inProtocol{};
  shared_ptr<bool> lazyPull{};
  shared_ptr<string> name{};
  shared_ptr<string> outProtocol{};
  shared_ptr<string> playDomain{};
  shared_ptr<string> pushDomain{};
  shared_ptr<string> region{};
  shared_ptr<DescribeGroupsResponseBodyGroupsStats> stats{};
  shared_ptr<string> status{};

  DescribeGroupsResponseBodyGroups() {}

  explicit DescribeGroupsResponseBodyGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasId) {
      res["AliasId"] = boost::any(*aliasId);
    }
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (gbIp) {
      res["GbIp"] = boost::any(*gbIp);
    }
    if (gbPort) {
      res["GbPort"] = boost::any(*gbPort);
    }
    if (gbTcpPorts) {
      res["GbTcpPorts"] = boost::any(*gbTcpPorts);
    }
    if (gbUdpPorts) {
      res["GbUdpPorts"] = boost::any(*gbUdpPorts);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inProtocol) {
      res["InProtocol"] = boost::any(*inProtocol);
    }
    if (lazyPull) {
      res["LazyPull"] = boost::any(*lazyPull);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outProtocol) {
      res["OutProtocol"] = boost::any(*outProtocol);
    }
    if (playDomain) {
      res["PlayDomain"] = boost::any(*playDomain);
    }
    if (pushDomain) {
      res["PushDomain"] = boost::any(*pushDomain);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (stats) {
      res["Stats"] = stats ? boost::any(stats->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasId") != m.end() && !m["AliasId"].empty()) {
      aliasId = make_shared<string>(boost::any_cast<string>(m["AliasId"]));
    }
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("GbIp") != m.end() && !m["GbIp"].empty()) {
      gbIp = make_shared<string>(boost::any_cast<string>(m["GbIp"]));
    }
    if (m.find("GbPort") != m.end() && !m["GbPort"].empty()) {
      gbPort = make_shared<long>(boost::any_cast<long>(m["GbPort"]));
    }
    if (m.find("GbTcpPorts") != m.end() && !m["GbTcpPorts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GbTcpPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GbTcpPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      gbTcpPorts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GbUdpPorts") != m.end() && !m["GbUdpPorts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GbUdpPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GbUdpPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      gbUdpPorts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InProtocol") != m.end() && !m["InProtocol"].empty()) {
      inProtocol = make_shared<string>(boost::any_cast<string>(m["InProtocol"]));
    }
    if (m.find("LazyPull") != m.end() && !m["LazyPull"].empty()) {
      lazyPull = make_shared<bool>(boost::any_cast<bool>(m["LazyPull"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutProtocol") != m.end() && !m["OutProtocol"].empty()) {
      outProtocol = make_shared<string>(boost::any_cast<string>(m["OutProtocol"]));
    }
    if (m.find("PlayDomain") != m.end() && !m["PlayDomain"].empty()) {
      playDomain = make_shared<string>(boost::any_cast<string>(m["PlayDomain"]));
    }
    if (m.find("PushDomain") != m.end() && !m["PushDomain"].empty()) {
      pushDomain = make_shared<string>(boost::any_cast<string>(m["PushDomain"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Stats") != m.end() && !m["Stats"].empty()) {
      if (typeid(map<string, boost::any>) == m["Stats"].type()) {
        DescribeGroupsResponseBodyGroupsStats model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Stats"]));
        stats = make_shared<DescribeGroupsResponseBodyGroupsStats>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeGroupsResponseBodyGroups() = default;
};
class DescribeGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGroupsResponseBodyGroups>> groups{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeGroupsResponseBody() {}

  explicit DescribeGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<DescribeGroupsResponseBodyGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupsResponseBodyGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<DescribeGroupsResponseBodyGroups>>(expect1);
      }
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeGroupsResponseBody() = default;
};
class DescribeGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupsResponseBody> body{};

  DescribeGroupsResponse() {}

  explicit DescribeGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupsResponse() = default;
};
class DescribeParentPlatformRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  DescribeParentPlatformRequest() {}

  explicit DescribeParentPlatformRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeParentPlatformRequest() = default;
};
class DescribeParentPlatformResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> autoStart{};
  shared_ptr<bool> clientAuth{};
  shared_ptr<string> clientGbId{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> clientPassword{};
  shared_ptr<long> clientPort{};
  shared_ptr<string> clientUsername{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> gbId{};
  shared_ptr<string> id{};
  shared_ptr<string> ip{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribeParentPlatformResponseBody() {}

  explicit DescribeParentPlatformResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoStart) {
      res["AutoStart"] = boost::any(*autoStart);
    }
    if (clientAuth) {
      res["ClientAuth"] = boost::any(*clientAuth);
    }
    if (clientGbId) {
      res["ClientGbId"] = boost::any(*clientGbId);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (clientPassword) {
      res["ClientPassword"] = boost::any(*clientPassword);
    }
    if (clientPort) {
      res["ClientPort"] = boost::any(*clientPort);
    }
    if (clientUsername) {
      res["ClientUsername"] = boost::any(*clientUsername);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoStart") != m.end() && !m["AutoStart"].empty()) {
      autoStart = make_shared<bool>(boost::any_cast<bool>(m["AutoStart"]));
    }
    if (m.find("ClientAuth") != m.end() && !m["ClientAuth"].empty()) {
      clientAuth = make_shared<bool>(boost::any_cast<bool>(m["ClientAuth"]));
    }
    if (m.find("ClientGbId") != m.end() && !m["ClientGbId"].empty()) {
      clientGbId = make_shared<string>(boost::any_cast<string>(m["ClientGbId"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("ClientPassword") != m.end() && !m["ClientPassword"].empty()) {
      clientPassword = make_shared<string>(boost::any_cast<string>(m["ClientPassword"]));
    }
    if (m.find("ClientPort") != m.end() && !m["ClientPort"].empty()) {
      clientPort = make_shared<long>(boost::any_cast<long>(m["ClientPort"]));
    }
    if (m.find("ClientUsername") != m.end() && !m["ClientUsername"].empty()) {
      clientUsername = make_shared<string>(boost::any_cast<string>(m["ClientUsername"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeParentPlatformResponseBody() = default;
};
class DescribeParentPlatformResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeParentPlatformResponseBody> body{};

  DescribeParentPlatformResponse() {}

  explicit DescribeParentPlatformResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeParentPlatformResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeParentPlatformResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeParentPlatformResponse() = default;
};
class DescribeParentPlatformDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortDirection{};

  DescribeParentPlatformDevicesRequest() {}

  explicit DescribeParentPlatformDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortDirection) {
      res["SortDirection"] = boost::any(*sortDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortDirection") != m.end() && !m["SortDirection"].empty()) {
      sortDirection = make_shared<string>(boost::any_cast<string>(m["SortDirection"]));
    }
  }


  virtual ~DescribeParentPlatformDevicesRequest() = default;
};
class DescribeParentPlatformDevicesResponseBodyDevices : public Darabonba::Model {
public:
  shared_ptr<string> gbId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};

  DescribeParentPlatformDevicesResponseBodyDevices() {}

  explicit DescribeParentPlatformDevicesResponseBodyDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
  }


  virtual ~DescribeParentPlatformDevicesResponseBodyDevices() = default;
};
class DescribeParentPlatformDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeParentPlatformDevicesResponseBodyDevices>> devices{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeParentPlatformDevicesResponseBody() {}

  explicit DescribeParentPlatformDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<DescribeParentPlatformDevicesResponseBodyDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeParentPlatformDevicesResponseBodyDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<DescribeParentPlatformDevicesResponseBodyDevices>>(expect1);
      }
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeParentPlatformDevicesResponseBody() = default;
};
class DescribeParentPlatformDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeParentPlatformDevicesResponseBody> body{};

  DescribeParentPlatformDevicesResponse() {}

  explicit DescribeParentPlatformDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeParentPlatformDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeParentPlatformDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeParentPlatformDevicesResponse() = default;
};
class DescribeParentPlatformsRequest : public Darabonba::Model {
public:
  shared_ptr<string> gbId{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortDirection{};
  shared_ptr<string> status{};

  DescribeParentPlatformsRequest() {}

  explicit DescribeParentPlatformsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortDirection) {
      res["SortDirection"] = boost::any(*sortDirection);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortDirection") != m.end() && !m["SortDirection"].empty()) {
      sortDirection = make_shared<string>(boost::any_cast<string>(m["SortDirection"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeParentPlatformsRequest() = default;
};
class DescribeParentPlatformsResponseBodyPlatforms : public Darabonba::Model {
public:
  shared_ptr<bool> autoStart{};
  shared_ptr<bool> clientAuth{};
  shared_ptr<string> clientGbId{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> clientPassword{};
  shared_ptr<long> clientPort{};
  shared_ptr<string> clientUsername{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> gbId{};
  shared_ptr<string> id{};
  shared_ptr<string> ip{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> status{};

  DescribeParentPlatformsResponseBodyPlatforms() {}

  explicit DescribeParentPlatformsResponseBodyPlatforms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoStart) {
      res["AutoStart"] = boost::any(*autoStart);
    }
    if (clientAuth) {
      res["ClientAuth"] = boost::any(*clientAuth);
    }
    if (clientGbId) {
      res["ClientGbId"] = boost::any(*clientGbId);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (clientPassword) {
      res["ClientPassword"] = boost::any(*clientPassword);
    }
    if (clientPort) {
      res["ClientPort"] = boost::any(*clientPort);
    }
    if (clientUsername) {
      res["ClientUsername"] = boost::any(*clientUsername);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoStart") != m.end() && !m["AutoStart"].empty()) {
      autoStart = make_shared<bool>(boost::any_cast<bool>(m["AutoStart"]));
    }
    if (m.find("ClientAuth") != m.end() && !m["ClientAuth"].empty()) {
      clientAuth = make_shared<bool>(boost::any_cast<bool>(m["ClientAuth"]));
    }
    if (m.find("ClientGbId") != m.end() && !m["ClientGbId"].empty()) {
      clientGbId = make_shared<string>(boost::any_cast<string>(m["ClientGbId"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("ClientPassword") != m.end() && !m["ClientPassword"].empty()) {
      clientPassword = make_shared<string>(boost::any_cast<string>(m["ClientPassword"]));
    }
    if (m.find("ClientPort") != m.end() && !m["ClientPort"].empty()) {
      clientPort = make_shared<long>(boost::any_cast<long>(m["ClientPort"]));
    }
    if (m.find("ClientUsername") != m.end() && !m["ClientUsername"].empty()) {
      clientUsername = make_shared<string>(boost::any_cast<string>(m["ClientUsername"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeParentPlatformsResponseBodyPlatforms() = default;
};
class DescribeParentPlatformsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeParentPlatformsResponseBodyPlatforms>> platforms{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeParentPlatformsResponseBody() {}

  explicit DescribeParentPlatformsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (platforms) {
      vector<boost::any> temp1;
      for(auto item1:*platforms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Platforms"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Platforms") != m.end() && !m["Platforms"].empty()) {
      if (typeid(vector<boost::any>) == m["Platforms"].type()) {
        vector<DescribeParentPlatformsResponseBodyPlatforms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Platforms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeParentPlatformsResponseBodyPlatforms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        platforms = make_shared<vector<DescribeParentPlatformsResponseBodyPlatforms>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeParentPlatformsResponseBody() = default;
};
class DescribeParentPlatformsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeParentPlatformsResponseBody> body{};

  DescribeParentPlatformsResponse() {}

  explicit DescribeParentPlatformsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeParentPlatformsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeParentPlatformsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeParentPlatformsResponse() = default;
};
class DescribePresetsRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  DescribePresetsRequest() {}

  explicit DescribePresetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribePresetsRequest() = default;
};
class DescribePresetsResponseBodyPresets : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  DescribePresetsResponseBodyPresets() {}

  explicit DescribePresetsResponseBodyPresets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribePresetsResponseBodyPresets() = default;
};
class DescribePresetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<vector<DescribePresetsResponseBodyPresets>> presets{};
  shared_ptr<string> requestId{};

  DescribePresetsResponseBody() {}

  explicit DescribePresetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (presets) {
      vector<boost::any> temp1;
      for(auto item1:*presets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Presets"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Presets") != m.end() && !m["Presets"].empty()) {
      if (typeid(vector<boost::any>) == m["Presets"].type()) {
        vector<DescribePresetsResponseBodyPresets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Presets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePresetsResponseBodyPresets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        presets = make_shared<vector<DescribePresetsResponseBodyPresets>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePresetsResponseBody() = default;
};
class DescribePresetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePresetsResponseBody> body{};

  DescribePresetsResponse() {}

  explicit DescribePresetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePresetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePresetsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePresetsResponse() = default;
};
class DescribePublishStreamStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> ownerId{};

  DescribePublishStreamStatusRequest() {}

  explicit DescribePublishStreamStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribePublishStreamStatusRequest() = default;
};
class DescribePublishStreamStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> message{};
  shared_ptr<string> requestId{};

  DescribePublishStreamStatusResponseBody() {}

  explicit DescribePublishStreamStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<long>(boost::any_cast<long>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePublishStreamStatusResponseBody() = default;
};
class DescribePublishStreamStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePublishStreamStatusResponseBody> body{};

  DescribePublishStreamStatusResponse() {}

  explicit DescribePublishStreamStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePublishStreamStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePublishStreamStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePublishStreamStatusResponse() = default;
};
class DescribePurchasedDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  DescribePurchasedDeviceRequest() {}

  explicit DescribePurchasedDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribePurchasedDeviceRequest() = default;
};
class DescribePurchasedDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> orderId{};
  shared_ptr<string> region{};
  shared_ptr<string> registerCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subType{};
  shared_ptr<string> type{};
  shared_ptr<string> vendor{};

  DescribePurchasedDeviceResponseBody() {}

  explicit DescribePurchasedDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (registerCode) {
      res["RegisterCode"] = boost::any(*registerCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegisterCode") != m.end() && !m["RegisterCode"].empty()) {
      registerCode = make_shared<string>(boost::any_cast<string>(m["RegisterCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~DescribePurchasedDeviceResponseBody() = default;
};
class DescribePurchasedDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePurchasedDeviceResponseBody> body{};

  DescribePurchasedDeviceResponse() {}

  explicit DescribePurchasedDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePurchasedDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePurchasedDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePurchasedDeviceResponse() = default;
};
class DescribePurchasedDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortDirection{};
  shared_ptr<string> subType{};
  shared_ptr<string> type{};
  shared_ptr<string> vendor{};

  DescribePurchasedDevicesRequest() {}

  explicit DescribePurchasedDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortDirection) {
      res["SortDirection"] = boost::any(*sortDirection);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortDirection") != m.end() && !m["SortDirection"].empty()) {
      sortDirection = make_shared<string>(boost::any_cast<string>(m["SortDirection"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~DescribePurchasedDevicesRequest() = default;
};
class DescribePurchasedDevicesResponseBodyDevices : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> orderId{};
  shared_ptr<string> region{};
  shared_ptr<string> registerCode{};
  shared_ptr<string> subType{};
  shared_ptr<string> type{};
  shared_ptr<string> vendor{};

  DescribePurchasedDevicesResponseBodyDevices() {}

  explicit DescribePurchasedDevicesResponseBodyDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (registerCode) {
      res["RegisterCode"] = boost::any(*registerCode);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegisterCode") != m.end() && !m["RegisterCode"].empty()) {
      registerCode = make_shared<string>(boost::any_cast<string>(m["RegisterCode"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~DescribePurchasedDevicesResponseBodyDevices() = default;
};
class DescribePurchasedDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePurchasedDevicesResponseBodyDevices>> devices{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePurchasedDevicesResponseBody() {}

  explicit DescribePurchasedDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<DescribePurchasedDevicesResponseBodyDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurchasedDevicesResponseBodyDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<DescribePurchasedDevicesResponseBodyDevices>>(expect1);
      }
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePurchasedDevicesResponseBody() = default;
};
class DescribePurchasedDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePurchasedDevicesResponseBody> body{};

  DescribePurchasedDevicesResponse() {}

  explicit DescribePurchasedDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePurchasedDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePurchasedDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePurchasedDevicesResponse() = default;
};
class DescribeRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> privateBucket{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortDirection{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamId{};
  shared_ptr<string> type{};

  DescribeRecordsRequest() {}

  explicit DescribeRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (privateBucket) {
      res["PrivateBucket"] = boost::any(*privateBucket);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortDirection) {
      res["SortDirection"] = boost::any(*sortDirection);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamId) {
      res["StreamId"] = boost::any(*streamId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PrivateBucket") != m.end() && !m["PrivateBucket"].empty()) {
      privateBucket = make_shared<bool>(boost::any_cast<bool>(m["PrivateBucket"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortDirection") != m.end() && !m["SortDirection"].empty()) {
      sortDirection = make_shared<string>(boost::any_cast<string>(m["SortDirection"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamId") != m.end() && !m["StreamId"].empty()) {
      streamId = make_shared<string>(boost::any_cast<string>(m["StreamId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeRecordsRequest() = default;
};
class DescribeRecordsResponseBodyRecords : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> fileFormat{};
  shared_ptr<long> height{};
  shared_ptr<string> id{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<long> width{};

  DescribeRecordsResponseBodyRecords() {}

  explicit DescribeRecordsResponseBodyRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamId) {
      res["StreamId"] = boost::any(*streamId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamId") != m.end() && !m["StreamId"].empty()) {
      streamId = make_shared<string>(boost::any_cast<string>(m["StreamId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~DescribeRecordsResponseBodyRecords() = default;
};
class DescribeRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextStartTime{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeRecordsResponseBodyRecords>> records{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeRecordsResponseBody() {}

  explicit DescribeRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextStartTime) {
      res["NextStartTime"] = boost::any(*nextStartTime);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextStartTime") != m.end() && !m["NextStartTime"].empty()) {
      nextStartTime = make_shared<string>(boost::any_cast<string>(m["NextStartTime"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<DescribeRecordsResponseBodyRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRecordsResponseBodyRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<DescribeRecordsResponseBodyRecords>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeRecordsResponseBody() = default;
};
class DescribeRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRecordsResponseBody> body{};

  DescribeRecordsResponse() {}

  explicit DescribeRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRecordsResponse() = default;
};
class DescribeRenderingInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> renderingInstanceId{};

  DescribeRenderingInstanceRequest() {}

  explicit DescribeRenderingInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~DescribeRenderingInstanceRequest() = default;
};
class DescribeRenderingInstanceResponseBodyConfigInfoConfigurationAttributes : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<boost::any> value{};

  DescribeRenderingInstanceResponseBodyConfigInfoConfigurationAttributes() {}

  explicit DescribeRenderingInstanceResponseBodyConfigInfoConfigurationAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<boost::any>(boost::any_cast<boost::any>(m["Value"]));
    }
  }


  virtual ~DescribeRenderingInstanceResponseBodyConfigInfoConfigurationAttributes() = default;
};
class DescribeRenderingInstanceResponseBodyConfigInfoConfiguration : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRenderingInstanceResponseBodyConfigInfoConfigurationAttributes>> attributes{};
  shared_ptr<string> moduleName{};

  DescribeRenderingInstanceResponseBodyConfigInfoConfiguration() {}

  explicit DescribeRenderingInstanceResponseBodyConfigInfoConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributes) {
      vector<boost::any> temp1;
      for(auto item1:*attributes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attributes"] = boost::any(temp1);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      if (typeid(vector<boost::any>) == m["Attributes"].type()) {
        vector<DescribeRenderingInstanceResponseBodyConfigInfoConfigurationAttributes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attributes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRenderingInstanceResponseBodyConfigInfoConfigurationAttributes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attributes = make_shared<vector<DescribeRenderingInstanceResponseBodyConfigInfoConfigurationAttributes>>(expect1);
      }
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~DescribeRenderingInstanceResponseBodyConfigInfoConfiguration() = default;
};
class DescribeRenderingInstanceResponseBodyConfigInfoNetworkConfig : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthStatus{};
  shared_ptr<long> maxEgressBandwidth{};
  shared_ptr<long> maxIngressBandwidth{};
  shared_ptr<string> updateTime{};

  DescribeRenderingInstanceResponseBodyConfigInfoNetworkConfig() {}

  explicit DescribeRenderingInstanceResponseBodyConfigInfoNetworkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthStatus) {
      res["BandwidthStatus"] = boost::any(*bandwidthStatus);
    }
    if (maxEgressBandwidth) {
      res["MaxEgressBandwidth"] = boost::any(*maxEgressBandwidth);
    }
    if (maxIngressBandwidth) {
      res["MaxIngressBandwidth"] = boost::any(*maxIngressBandwidth);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthStatus") != m.end() && !m["BandwidthStatus"].empty()) {
      bandwidthStatus = make_shared<string>(boost::any_cast<string>(m["BandwidthStatus"]));
    }
    if (m.find("MaxEgressBandwidth") != m.end() && !m["MaxEgressBandwidth"].empty()) {
      maxEgressBandwidth = make_shared<long>(boost::any_cast<long>(m["MaxEgressBandwidth"]));
    }
    if (m.find("MaxIngressBandwidth") != m.end() && !m["MaxIngressBandwidth"].empty()) {
      maxIngressBandwidth = make_shared<long>(boost::any_cast<long>(m["MaxIngressBandwidth"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeRenderingInstanceResponseBodyConfigInfoNetworkConfig() = default;
};
class DescribeRenderingInstanceResponseBodyConfigInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRenderingInstanceResponseBodyConfigInfoConfiguration>> configuration{};
  shared_ptr<DescribeRenderingInstanceResponseBodyConfigInfoNetworkConfig> networkConfig{};

  DescribeRenderingInstanceResponseBodyConfigInfo() {}

  explicit DescribeRenderingInstanceResponseBodyConfigInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      vector<boost::any> temp1;
      for(auto item1:*configuration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configuration"] = boost::any(temp1);
    }
    if (networkConfig) {
      res["NetworkConfig"] = networkConfig ? boost::any(networkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      if (typeid(vector<boost::any>) == m["Configuration"].type()) {
        vector<DescribeRenderingInstanceResponseBodyConfigInfoConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configuration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRenderingInstanceResponseBodyConfigInfoConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configuration = make_shared<vector<DescribeRenderingInstanceResponseBodyConfigInfoConfiguration>>(expect1);
      }
    }
    if (m.find("NetworkConfig") != m.end() && !m["NetworkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkConfig"].type()) {
        DescribeRenderingInstanceResponseBodyConfigInfoNetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkConfig"]));
        networkConfig = make_shared<DescribeRenderingInstanceResponseBodyConfigInfoNetworkConfig>(model1);
      }
    }
  }


  virtual ~DescribeRenderingInstanceResponseBodyConfigInfo() = default;
};
class DescribeRenderingInstanceResponseBodyPortMappings : public Darabonba::Model {
public:
  shared_ptr<string> externalPort{};
  shared_ptr<string> internalPort{};

  DescribeRenderingInstanceResponseBodyPortMappings() {}

  explicit DescribeRenderingInstanceResponseBodyPortMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (externalPort) {
      res["ExternalPort"] = boost::any(*externalPort);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExternalPort") != m.end() && !m["ExternalPort"].empty()) {
      externalPort = make_shared<string>(boost::any_cast<string>(m["ExternalPort"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
  }


  virtual ~DescribeRenderingInstanceResponseBodyPortMappings() = default;
};
class DescribeRenderingInstanceResponseBodyRenderingStatus : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> latestAction{};
  shared_ptr<string> status{};

  DescribeRenderingInstanceResponseBodyRenderingStatus() {}

  explicit DescribeRenderingInstanceResponseBodyRenderingStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (latestAction) {
      res["LatestAction"] = boost::any(*latestAction);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("LatestAction") != m.end() && !m["LatestAction"].empty()) {
      latestAction = make_shared<string>(boost::any_cast<string>(m["LatestAction"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeRenderingInstanceResponseBodyRenderingStatus() = default;
};
class DescribeRenderingInstanceResponseBodySystemInfo : public Darabonba::Model {
public:
  shared_ptr<long> frequency{};
  shared_ptr<string> resolution{};

  DescribeRenderingInstanceResponseBodySystemInfo() {}

  explicit DescribeRenderingInstanceResponseBodySystemInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frequency) {
      res["Frequency"] = boost::any(*frequency);
    }
    if (resolution) {
      res["Resolution"] = boost::any(*resolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Frequency") != m.end() && !m["Frequency"].empty()) {
      frequency = make_shared<long>(boost::any_cast<long>(m["Frequency"]));
    }
    if (m.find("Resolution") != m.end() && !m["Resolution"].empty()) {
      resolution = make_shared<string>(boost::any_cast<string>(m["Resolution"]));
    }
  }


  virtual ~DescribeRenderingInstanceResponseBodySystemInfo() = default;
};
class DescribeRenderingInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRenderingInstanceResponseBodyConfigInfo> configInfo{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> hostname{};
  shared_ptr<vector<DescribeRenderingInstanceResponseBodyPortMappings>> portMappings{};
  shared_ptr<string> renderingInstanceId{};
  shared_ptr<string> renderingSpec{};
  shared_ptr<DescribeRenderingInstanceResponseBodyRenderingStatus> renderingStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<long> storageSize{};
  shared_ptr<DescribeRenderingInstanceResponseBodySystemInfo> systemInfo{};

  DescribeRenderingInstanceResponseBody() {}

  explicit DescribeRenderingInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configInfo) {
      res["ConfigInfo"] = configInfo ? boost::any(configInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (hostname) {
      res["Hostname"] = boost::any(*hostname);
    }
    if (portMappings) {
      vector<boost::any> temp1;
      for(auto item1:*portMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortMappings"] = boost::any(temp1);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    if (renderingSpec) {
      res["RenderingSpec"] = boost::any(*renderingSpec);
    }
    if (renderingStatus) {
      res["RenderingStatus"] = renderingStatus ? boost::any(renderingStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (storageSize) {
      res["StorageSize"] = boost::any(*storageSize);
    }
    if (systemInfo) {
      res["SystemInfo"] = systemInfo ? boost::any(systemInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigInfo") != m.end() && !m["ConfigInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigInfo"].type()) {
        DescribeRenderingInstanceResponseBodyConfigInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigInfo"]));
        configInfo = make_shared<DescribeRenderingInstanceResponseBodyConfigInfo>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Hostname") != m.end() && !m["Hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["Hostname"]));
    }
    if (m.find("PortMappings") != m.end() && !m["PortMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["PortMappings"].type()) {
        vector<DescribeRenderingInstanceResponseBodyPortMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRenderingInstanceResponseBodyPortMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portMappings = make_shared<vector<DescribeRenderingInstanceResponseBodyPortMappings>>(expect1);
      }
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
    if (m.find("RenderingSpec") != m.end() && !m["RenderingSpec"].empty()) {
      renderingSpec = make_shared<string>(boost::any_cast<string>(m["RenderingSpec"]));
    }
    if (m.find("RenderingStatus") != m.end() && !m["RenderingStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["RenderingStatus"].type()) {
        DescribeRenderingInstanceResponseBodyRenderingStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RenderingStatus"]));
        renderingStatus = make_shared<DescribeRenderingInstanceResponseBodyRenderingStatus>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StorageSize") != m.end() && !m["StorageSize"].empty()) {
      storageSize = make_shared<long>(boost::any_cast<long>(m["StorageSize"]));
    }
    if (m.find("SystemInfo") != m.end() && !m["SystemInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemInfo"].type()) {
        DescribeRenderingInstanceResponseBodySystemInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemInfo"]));
        systemInfo = make_shared<DescribeRenderingInstanceResponseBodySystemInfo>(model1);
      }
    }
  }


  virtual ~DescribeRenderingInstanceResponseBody() = default;
};
class DescribeRenderingInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRenderingInstanceResponseBody> body{};

  DescribeRenderingInstanceResponse() {}

  explicit DescribeRenderingInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRenderingInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRenderingInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRenderingInstanceResponse() = default;
};
class DescribeRenderingInstanceConfigurationRequestConfiguration : public Darabonba::Model {
public:
  shared_ptr<vector<string>> attributeNames{};
  shared_ptr<string> moduleName{};

  DescribeRenderingInstanceConfigurationRequestConfiguration() {}

  explicit DescribeRenderingInstanceConfigurationRequestConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeNames) {
      res["AttributeNames"] = boost::any(*attributeNames);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeNames") != m.end() && !m["AttributeNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AttributeNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AttributeNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      attributeNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~DescribeRenderingInstanceConfigurationRequestConfiguration() = default;
};
class DescribeRenderingInstanceConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRenderingInstanceConfigurationRequestConfiguration>> configuration{};
  shared_ptr<string> renderingInstanceId{};

  DescribeRenderingInstanceConfigurationRequest() {}

  explicit DescribeRenderingInstanceConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      vector<boost::any> temp1;
      for(auto item1:*configuration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configuration"] = boost::any(temp1);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      if (typeid(vector<boost::any>) == m["Configuration"].type()) {
        vector<DescribeRenderingInstanceConfigurationRequestConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configuration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRenderingInstanceConfigurationRequestConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configuration = make_shared<vector<DescribeRenderingInstanceConfigurationRequestConfiguration>>(expect1);
      }
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~DescribeRenderingInstanceConfigurationRequest() = default;
};
class DescribeRenderingInstanceConfigurationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> configurationShrink{};
  shared_ptr<string> renderingInstanceId{};

  DescribeRenderingInstanceConfigurationShrinkRequest() {}

  explicit DescribeRenderingInstanceConfigurationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationShrink) {
      res["Configuration"] = boost::any(*configurationShrink);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configurationShrink = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~DescribeRenderingInstanceConfigurationShrinkRequest() = default;
};
class DescribeRenderingInstanceConfigurationResponseBodyConfigurationAttributes : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<boost::any> value{};

  DescribeRenderingInstanceConfigurationResponseBodyConfigurationAttributes() {}

  explicit DescribeRenderingInstanceConfigurationResponseBodyConfigurationAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<boost::any>(boost::any_cast<boost::any>(m["Value"]));
    }
  }


  virtual ~DescribeRenderingInstanceConfigurationResponseBodyConfigurationAttributes() = default;
};
class DescribeRenderingInstanceConfigurationResponseBodyConfiguration : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRenderingInstanceConfigurationResponseBodyConfigurationAttributes>> attributes{};
  shared_ptr<string> moduleName{};

  DescribeRenderingInstanceConfigurationResponseBodyConfiguration() {}

  explicit DescribeRenderingInstanceConfigurationResponseBodyConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributes) {
      vector<boost::any> temp1;
      for(auto item1:*attributes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attributes"] = boost::any(temp1);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      if (typeid(vector<boost::any>) == m["Attributes"].type()) {
        vector<DescribeRenderingInstanceConfigurationResponseBodyConfigurationAttributes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attributes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRenderingInstanceConfigurationResponseBodyConfigurationAttributes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attributes = make_shared<vector<DescribeRenderingInstanceConfigurationResponseBodyConfigurationAttributes>>(expect1);
      }
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~DescribeRenderingInstanceConfigurationResponseBodyConfiguration() = default;
};
class DescribeRenderingInstanceConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRenderingInstanceConfigurationResponseBodyConfiguration>> configuration{};
  shared_ptr<string> requestId{};

  DescribeRenderingInstanceConfigurationResponseBody() {}

  explicit DescribeRenderingInstanceConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      vector<boost::any> temp1;
      for(auto item1:*configuration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configuration"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      if (typeid(vector<boost::any>) == m["Configuration"].type()) {
        vector<DescribeRenderingInstanceConfigurationResponseBodyConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configuration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRenderingInstanceConfigurationResponseBodyConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configuration = make_shared<vector<DescribeRenderingInstanceConfigurationResponseBodyConfiguration>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRenderingInstanceConfigurationResponseBody() = default;
};
class DescribeRenderingInstanceConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRenderingInstanceConfigurationResponseBody> body{};

  DescribeRenderingInstanceConfigurationResponse() {}

  explicit DescribeRenderingInstanceConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRenderingInstanceConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRenderingInstanceConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRenderingInstanceConfigurationResponse() = default;
};
class DescribeRenderingInstanceSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> attributeNames{};
  shared_ptr<string> renderingInstanceId{};

  DescribeRenderingInstanceSettingsRequest() {}

  explicit DescribeRenderingInstanceSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeNames) {
      res["AttributeNames"] = boost::any(*attributeNames);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeNames") != m.end() && !m["AttributeNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AttributeNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AttributeNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      attributeNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~DescribeRenderingInstanceSettingsRequest() = default;
};
class DescribeRenderingInstanceSettingsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attributeNamesShrink{};
  shared_ptr<string> renderingInstanceId{};

  DescribeRenderingInstanceSettingsShrinkRequest() {}

  explicit DescribeRenderingInstanceSettingsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeNamesShrink) {
      res["AttributeNames"] = boost::any(*attributeNamesShrink);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeNames") != m.end() && !m["AttributeNames"].empty()) {
      attributeNamesShrink = make_shared<string>(boost::any_cast<string>(m["AttributeNames"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~DescribeRenderingInstanceSettingsShrinkRequest() = default;
};
class DescribeRenderingInstanceSettingsResponseBodySettings : public Darabonba::Model {
public:
  shared_ptr<string> attributeName{};
  shared_ptr<string> attributeValue{};

  DescribeRenderingInstanceSettingsResponseBodySettings() {}

  explicit DescribeRenderingInstanceSettingsResponseBodySettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (attributeValue) {
      res["AttributeValue"] = boost::any(*attributeValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      attributeName = make_shared<string>(boost::any_cast<string>(m["AttributeName"]));
    }
    if (m.find("AttributeValue") != m.end() && !m["AttributeValue"].empty()) {
      attributeValue = make_shared<string>(boost::any_cast<string>(m["AttributeValue"]));
    }
  }


  virtual ~DescribeRenderingInstanceSettingsResponseBodySettings() = default;
};
class DescribeRenderingInstanceSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRenderingInstanceSettingsResponseBodySettings>> settings{};

  DescribeRenderingInstanceSettingsResponseBody() {}

  explicit DescribeRenderingInstanceSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (settings) {
      vector<boost::any> temp1;
      for(auto item1:*settings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Settings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Settings") != m.end() && !m["Settings"].empty()) {
      if (typeid(vector<boost::any>) == m["Settings"].type()) {
        vector<DescribeRenderingInstanceSettingsResponseBodySettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Settings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRenderingInstanceSettingsResponseBodySettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        settings = make_shared<vector<DescribeRenderingInstanceSettingsResponseBodySettings>>(expect1);
      }
    }
  }


  virtual ~DescribeRenderingInstanceSettingsResponseBody() = default;
};
class DescribeRenderingInstanceSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRenderingInstanceSettingsResponseBody> body{};

  DescribeRenderingInstanceSettingsResponse() {}

  explicit DescribeRenderingInstanceSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRenderingInstanceSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRenderingInstanceSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRenderingInstanceSettingsResponse() = default;
};
class DescribeStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  DescribeStreamRequest() {}

  explicit DescribeStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeStreamRequest() = default;
};
class DescribeStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> deviceId{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> groupId{};
  shared_ptr<long> height{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> playDomain{};
  shared_ptr<string> protocol{};
  shared_ptr<string> pushDomain{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<long> width{};

  DescribeStreamResponseBody() {}

  explicit DescribeStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (playDomain) {
      res["PlayDomain"] = boost::any(*playDomain);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (pushDomain) {
      res["PushDomain"] = boost::any(*pushDomain);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PlayDomain") != m.end() && !m["PlayDomain"].empty()) {
      playDomain = make_shared<string>(boost::any_cast<string>(m["PlayDomain"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("PushDomain") != m.end() && !m["PushDomain"].empty()) {
      pushDomain = make_shared<string>(boost::any_cast<string>(m["PushDomain"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~DescribeStreamResponseBody() = default;
};
class DescribeStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStreamResponseBody> body{};

  DescribeStreamResponse() {}

  explicit DescribeStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStreamResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStreamResponse() = default;
};
class DescribeStreamURLRequest : public Darabonba::Model {
public:
  shared_ptr<bool> auth{};
  shared_ptr<string> authKey{};
  shared_ptr<long> endTime{};
  shared_ptr<long> expire{};
  shared_ptr<string> id{};
  shared_ptr<string> outProtocol{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> transcode{};
  shared_ptr<string> type{};

  DescribeStreamURLRequest() {}

  explicit DescribeStreamURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auth) {
      res["Auth"] = boost::any(*auth);
    }
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (outProtocol) {
      res["OutProtocol"] = boost::any(*outProtocol);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (transcode) {
      res["Transcode"] = boost::any(*transcode);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Auth") != m.end() && !m["Auth"].empty()) {
      auth = make_shared<bool>(boost::any_cast<bool>(m["Auth"]));
    }
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OutProtocol") != m.end() && !m["OutProtocol"].empty()) {
      outProtocol = make_shared<string>(boost::any_cast<string>(m["OutProtocol"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      transcode = make_shared<string>(boost::any_cast<string>(m["Transcode"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeStreamURLRequest() = default;
};
class DescribeStreamURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> expireTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> url{};

  DescribeStreamURLResponseBody() {}

  explicit DescribeStreamURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeStreamURLResponseBody() = default;
};
class DescribeStreamURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStreamURLResponseBody> body{};

  DescribeStreamURLResponse() {}

  explicit DescribeStreamURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStreamURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStreamURLResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStreamURLResponse() = default;
};
class DescribeStreamVodListRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> startTime{};

  DescribeStreamVodListRequest() {}

  explicit DescribeStreamVodListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeStreamVodListRequest() = default;
};
class DescribeStreamVodListResponseBodyRecords : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  DescribeStreamVodListResponseBodyRecords() {}

  explicit DescribeStreamVodListResponseBodyRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeStreamVodListResponseBodyRecords() = default;
};
class DescribeStreamVodListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeStreamVodListResponseBodyRecords>> records{};
  shared_ptr<string> requestId{};

  DescribeStreamVodListResponseBody() {}

  explicit DescribeStreamVodListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<DescribeStreamVodListResponseBodyRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStreamVodListResponseBodyRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<DescribeStreamVodListResponseBodyRecords>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeStreamVodListResponseBody() = default;
};
class DescribeStreamVodListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStreamVodListResponseBody> body{};

  DescribeStreamVodListResponse() {}

  explicit DescribeStreamVodListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStreamVodListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStreamVodListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStreamVodListResponse() = default;
};
class DescribeStreamsRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> domain{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortDirection{};

  DescribeStreamsRequest() {}

  explicit DescribeStreamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortDirection) {
      res["SortDirection"] = boost::any(*sortDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortDirection") != m.end() && !m["SortDirection"].empty()) {
      sortDirection = make_shared<string>(boost::any_cast<string>(m["SortDirection"]));
    }
  }


  virtual ~DescribeStreamsRequest() = default;
};
class DescribeStreamsResponseBodyStreams : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> deviceId{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> groupId{};
  shared_ptr<long> height{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> playDomain{};
  shared_ptr<string> protocol{};
  shared_ptr<string> pushDomain{};
  shared_ptr<string> status{};
  shared_ptr<long> width{};

  DescribeStreamsResponseBodyStreams() {}

  explicit DescribeStreamsResponseBodyStreams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (playDomain) {
      res["PlayDomain"] = boost::any(*playDomain);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (pushDomain) {
      res["PushDomain"] = boost::any(*pushDomain);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PlayDomain") != m.end() && !m["PlayDomain"].empty()) {
      playDomain = make_shared<string>(boost::any_cast<string>(m["PlayDomain"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("PushDomain") != m.end() && !m["PushDomain"].empty()) {
      pushDomain = make_shared<string>(boost::any_cast<string>(m["PushDomain"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~DescribeStreamsResponseBodyStreams() = default;
};
class DescribeStreamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeStreamsResponseBodyStreams>> streams{};
  shared_ptr<long> totalCount{};

  DescribeStreamsResponseBody() {}

  explicit DescribeStreamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (streams) {
      vector<boost::any> temp1;
      for(auto item1:*streams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Streams"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Streams") != m.end() && !m["Streams"].empty()) {
      if (typeid(vector<boost::any>) == m["Streams"].type()) {
        vector<DescribeStreamsResponseBodyStreams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Streams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStreamsResponseBodyStreams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streams = make_shared<vector<DescribeStreamsResponseBodyStreams>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeStreamsResponseBody() = default;
};
class DescribeStreamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStreamsResponseBody> body{};

  DescribeStreamsResponse() {}

  explicit DescribeStreamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStreamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStreamsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStreamsResponse() = default;
};
class DescribeTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  DescribeTemplateRequest() {}

  explicit DescribeTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeTemplateRequest() = default;
};
class DescribeTemplateResponseBodyTransConfigs : public Darabonba::Model {
public:
  shared_ptr<long> fps{};
  shared_ptr<long> gop{};
  shared_ptr<long> height{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> videoBitrate{};
  shared_ptr<string> videoCodec{};
  shared_ptr<long> width{};

  DescribeTemplateResponseBodyTransConfigs() {}

  explicit DescribeTemplateResponseBodyTransConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (videoCodec) {
      res["VideoCodec"] = boost::any(*videoCodec);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<long>(boost::any_cast<long>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<long>(boost::any_cast<long>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<long>(boost::any_cast<long>(m["VideoBitrate"]));
    }
    if (m.find("VideoCodec") != m.end() && !m["VideoCodec"].empty()) {
      videoCodec = make_shared<string>(boost::any_cast<string>(m["VideoCodec"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~DescribeTemplateResponseBodyTransConfigs() = default;
};
class DescribeTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> callback{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> flv{};
  shared_ptr<string> hlsM3u8{};
  shared_ptr<string> hlsTs{};
  shared_ptr<string> id{};
  shared_ptr<long> interval{};
  shared_ptr<string> jpgOnDemand{};
  shared_ptr<string> jpgOverwrite{};
  shared_ptr<string> jpgSequence{};
  shared_ptr<string> mp4{};
  shared_ptr<string> name{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossFilePrefix{};
  shared_ptr<string> region{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retention{};
  shared_ptr<vector<DescribeTemplateResponseBodyTransConfigs>> transConfigs{};
  shared_ptr<string> trigger{};
  shared_ptr<string> type{};

  DescribeTemplateResponseBody() {}

  explicit DescribeTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (flv) {
      res["Flv"] = boost::any(*flv);
    }
    if (hlsM3u8) {
      res["HlsM3u8"] = boost::any(*hlsM3u8);
    }
    if (hlsTs) {
      res["HlsTs"] = boost::any(*hlsTs);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (jpgOnDemand) {
      res["JpgOnDemand"] = boost::any(*jpgOnDemand);
    }
    if (jpgOverwrite) {
      res["JpgOverwrite"] = boost::any(*jpgOverwrite);
    }
    if (jpgSequence) {
      res["JpgSequence"] = boost::any(*jpgSequence);
    }
    if (mp4) {
      res["Mp4"] = boost::any(*mp4);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossFilePrefix) {
      res["OssFilePrefix"] = boost::any(*ossFilePrefix);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (transConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*transConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransConfigs"] = boost::any(temp1);
    }
    if (trigger) {
      res["Trigger"] = boost::any(*trigger);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Flv") != m.end() && !m["Flv"].empty()) {
      flv = make_shared<string>(boost::any_cast<string>(m["Flv"]));
    }
    if (m.find("HlsM3u8") != m.end() && !m["HlsM3u8"].empty()) {
      hlsM3u8 = make_shared<string>(boost::any_cast<string>(m["HlsM3u8"]));
    }
    if (m.find("HlsTs") != m.end() && !m["HlsTs"].empty()) {
      hlsTs = make_shared<string>(boost::any_cast<string>(m["HlsTs"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("JpgOnDemand") != m.end() && !m["JpgOnDemand"].empty()) {
      jpgOnDemand = make_shared<string>(boost::any_cast<string>(m["JpgOnDemand"]));
    }
    if (m.find("JpgOverwrite") != m.end() && !m["JpgOverwrite"].empty()) {
      jpgOverwrite = make_shared<string>(boost::any_cast<string>(m["JpgOverwrite"]));
    }
    if (m.find("JpgSequence") != m.end() && !m["JpgSequence"].empty()) {
      jpgSequence = make_shared<string>(boost::any_cast<string>(m["JpgSequence"]));
    }
    if (m.find("Mp4") != m.end() && !m["Mp4"].empty()) {
      mp4 = make_shared<string>(boost::any_cast<string>(m["Mp4"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssFilePrefix") != m.end() && !m["OssFilePrefix"].empty()) {
      ossFilePrefix = make_shared<string>(boost::any_cast<string>(m["OssFilePrefix"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("TransConfigs") != m.end() && !m["TransConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["TransConfigs"].type()) {
        vector<DescribeTemplateResponseBodyTransConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTemplateResponseBodyTransConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transConfigs = make_shared<vector<DescribeTemplateResponseBodyTransConfigs>>(expect1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      trigger = make_shared<string>(boost::any_cast<string>(m["Trigger"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeTemplateResponseBody() = default;
};
class DescribeTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTemplateResponseBody> body{};

  DescribeTemplateResponse() {}

  explicit DescribeTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTemplateResponse() = default;
};
class DescribeTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortDirection{};
  shared_ptr<string> type{};

  DescribeTemplatesRequest() {}

  explicit DescribeTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortDirection) {
      res["SortDirection"] = boost::any(*sortDirection);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortDirection") != m.end() && !m["SortDirection"].empty()) {
      sortDirection = make_shared<string>(boost::any_cast<string>(m["SortDirection"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeTemplatesRequest() = default;
};
class DescribeTemplatesResponseBodyTemplatesTransConfigs : public Darabonba::Model {
public:
  shared_ptr<long> fps{};
  shared_ptr<long> gop{};
  shared_ptr<long> height{};
  shared_ptr<string> name{};
  shared_ptr<long> videoBitrate{};
  shared_ptr<string> videoCodec{};
  shared_ptr<long> width{};
  shared_ptr<string> id{};

  DescribeTemplatesResponseBodyTemplatesTransConfigs() {}

  explicit DescribeTemplatesResponseBodyTemplatesTransConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (videoBitrate) {
      res["VideoBitrate"] = boost::any(*videoBitrate);
    }
    if (videoCodec) {
      res["VideoCodec"] = boost::any(*videoCodec);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<long>(boost::any_cast<long>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<long>(boost::any_cast<long>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VideoBitrate") != m.end() && !m["VideoBitrate"].empty()) {
      videoBitrate = make_shared<long>(boost::any_cast<long>(m["VideoBitrate"]));
    }
    if (m.find("VideoCodec") != m.end() && !m["VideoCodec"].empty()) {
      videoCodec = make_shared<string>(boost::any_cast<string>(m["VideoCodec"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
  }


  virtual ~DescribeTemplatesResponseBodyTemplatesTransConfigs() = default;
};
class DescribeTemplatesResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<string> callback{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> flv{};
  shared_ptr<string> hlsM3u8{};
  shared_ptr<string> hlsTs{};
  shared_ptr<string> id{};
  shared_ptr<long> interval{};
  shared_ptr<string> jpgOnDemand{};
  shared_ptr<string> jpgOverwrite{};
  shared_ptr<string> jpgSequence{};
  shared_ptr<string> mp4{};
  shared_ptr<string> name{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossFilePrefix{};
  shared_ptr<string> region{};
  shared_ptr<long> retention{};
  shared_ptr<vector<DescribeTemplatesResponseBodyTemplatesTransConfigs>> transConfigs{};
  shared_ptr<string> trigger{};
  shared_ptr<string> type{};

  DescribeTemplatesResponseBodyTemplates() {}

  explicit DescribeTemplatesResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (flv) {
      res["Flv"] = boost::any(*flv);
    }
    if (hlsM3u8) {
      res["HlsM3u8"] = boost::any(*hlsM3u8);
    }
    if (hlsTs) {
      res["HlsTs"] = boost::any(*hlsTs);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (jpgOnDemand) {
      res["JpgOnDemand"] = boost::any(*jpgOnDemand);
    }
    if (jpgOverwrite) {
      res["JpgOverwrite"] = boost::any(*jpgOverwrite);
    }
    if (jpgSequence) {
      res["JpgSequence"] = boost::any(*jpgSequence);
    }
    if (mp4) {
      res["Mp4"] = boost::any(*mp4);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossFilePrefix) {
      res["OssFilePrefix"] = boost::any(*ossFilePrefix);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (transConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*transConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransConfigs"] = boost::any(temp1);
    }
    if (trigger) {
      res["Trigger"] = boost::any(*trigger);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Flv") != m.end() && !m["Flv"].empty()) {
      flv = make_shared<string>(boost::any_cast<string>(m["Flv"]));
    }
    if (m.find("HlsM3u8") != m.end() && !m["HlsM3u8"].empty()) {
      hlsM3u8 = make_shared<string>(boost::any_cast<string>(m["HlsM3u8"]));
    }
    if (m.find("HlsTs") != m.end() && !m["HlsTs"].empty()) {
      hlsTs = make_shared<string>(boost::any_cast<string>(m["HlsTs"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("JpgOnDemand") != m.end() && !m["JpgOnDemand"].empty()) {
      jpgOnDemand = make_shared<string>(boost::any_cast<string>(m["JpgOnDemand"]));
    }
    if (m.find("JpgOverwrite") != m.end() && !m["JpgOverwrite"].empty()) {
      jpgOverwrite = make_shared<string>(boost::any_cast<string>(m["JpgOverwrite"]));
    }
    if (m.find("JpgSequence") != m.end() && !m["JpgSequence"].empty()) {
      jpgSequence = make_shared<string>(boost::any_cast<string>(m["JpgSequence"]));
    }
    if (m.find("Mp4") != m.end() && !m["Mp4"].empty()) {
      mp4 = make_shared<string>(boost::any_cast<string>(m["Mp4"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssFilePrefix") != m.end() && !m["OssFilePrefix"].empty()) {
      ossFilePrefix = make_shared<string>(boost::any_cast<string>(m["OssFilePrefix"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("TransConfigs") != m.end() && !m["TransConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["TransConfigs"].type()) {
        vector<DescribeTemplatesResponseBodyTemplatesTransConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTemplatesResponseBodyTemplatesTransConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transConfigs = make_shared<vector<DescribeTemplatesResponseBodyTemplatesTransConfigs>>(expect1);
      }
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      trigger = make_shared<string>(boost::any_cast<string>(m["Trigger"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeTemplatesResponseBodyTemplates() = default;
};
class DescribeTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTemplatesResponseBodyTemplates>> templates{};
  shared_ptr<long> totalCount{};

  DescribeTemplatesResponseBody() {}

  explicit DescribeTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templates) {
      vector<boost::any> temp1;
      for(auto item1:*templates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Templates"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      if (typeid(vector<boost::any>) == m["Templates"].type()) {
        vector<DescribeTemplatesResponseBodyTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Templates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTemplatesResponseBodyTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templates = make_shared<vector<DescribeTemplatesResponseBodyTemplates>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeTemplatesResponseBody() = default;
};
class DescribeTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTemplatesResponseBody> body{};

  DescribeTemplatesResponse() {}

  explicit DescribeTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTemplatesResponse() = default;
};
class DescribeVodStreamURLRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> url{};

  DescribeVodStreamURLRequest() {}

  explicit DescribeVodStreamURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeVodStreamURLRequest() = default;
};
class DescribeVodStreamURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> outProtocol{};
  shared_ptr<long> port{};
  shared_ptr<string> requestId{};
  shared_ptr<string> url{};

  DescribeVodStreamURLResponseBody() {}

  explicit DescribeVodStreamURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outProtocol) {
      res["OutProtocol"] = boost::any(*outProtocol);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutProtocol") != m.end() && !m["OutProtocol"].empty()) {
      outProtocol = make_shared<string>(boost::any_cast<string>(m["OutProtocol"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeVodStreamURLResponseBody() = default;
};
class DescribeVodStreamURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodStreamURLResponseBody> body{};

  DescribeVodStreamURLResponse() {}

  explicit DescribeVodStreamURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodStreamURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodStreamURLResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodStreamURLResponse() = default;
};
class DescribeVsCertificateDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<long> ownerId{};

  DescribeVsCertificateDetailRequest() {}

  explicit DescribeVsCertificateDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeVsCertificateDetailRequest() = default;
};
class DescribeVsCertificateDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cert{};
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> key{};
  shared_ptr<string> requestId{};

  DescribeVsCertificateDetailResponseBody() {}

  explicit DescribeVsCertificateDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      res["Cert"] = boost::any(*cert);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      cert = make_shared<string>(boost::any_cast<string>(m["Cert"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVsCertificateDetailResponseBody() = default;
};
class DescribeVsCertificateDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsCertificateDetailResponseBody> body{};

  DescribeVsCertificateDetailResponse() {}

  explicit DescribeVsCertificateDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsCertificateDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsCertificateDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsCertificateDetailResponse() = default;
};
class DescribeVsCertificateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeVsCertificateListRequest() {}

  explicit DescribeVsCertificateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeVsCertificateListRequest() = default;
};
class DescribeVsCertificateListResponseBodyCertificateListModelCertList : public Darabonba::Model {
public:
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> common{};
  shared_ptr<string> fingerprint{};
  shared_ptr<string> issuer{};
  shared_ptr<long> lastTime{};

  DescribeVsCertificateListResponseBodyCertificateListModelCertList() {}

  explicit DescribeVsCertificateListResponseBodyCertificateListModelCertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (common) {
      res["Common"] = boost::any(*common);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Common") != m.end() && !m["Common"].empty()) {
      common = make_shared<string>(boost::any_cast<string>(m["Common"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
  }


  virtual ~DescribeVsCertificateListResponseBodyCertificateListModelCertList() = default;
};
class DescribeVsCertificateListResponseBodyCertificateListModel : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsCertificateListResponseBodyCertificateListModelCertList>> certList{};
  shared_ptr<long> count{};

  DescribeVsCertificateListResponseBodyCertificateListModel() {}

  explicit DescribeVsCertificateListResponseBodyCertificateListModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certList) {
      vector<boost::any> temp1;
      for(auto item1:*certList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertList"] = boost::any(temp1);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertList") != m.end() && !m["CertList"].empty()) {
      if (typeid(vector<boost::any>) == m["CertList"].type()) {
        vector<DescribeVsCertificateListResponseBodyCertificateListModelCertList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsCertificateListResponseBodyCertificateListModelCertList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certList = make_shared<vector<DescribeVsCertificateListResponseBodyCertificateListModelCertList>>(expect1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeVsCertificateListResponseBodyCertificateListModel() = default;
};
class DescribeVsCertificateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVsCertificateListResponseBodyCertificateListModel> certificateListModel{};
  shared_ptr<string> requestId{};

  DescribeVsCertificateListResponseBody() {}

  explicit DescribeVsCertificateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateListModel) {
      res["CertificateListModel"] = certificateListModel ? boost::any(certificateListModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateListModel") != m.end() && !m["CertificateListModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertificateListModel"].type()) {
        DescribeVsCertificateListResponseBodyCertificateListModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertificateListModel"]));
        certificateListModel = make_shared<DescribeVsCertificateListResponseBodyCertificateListModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVsCertificateListResponseBody() = default;
};
class DescribeVsCertificateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsCertificateListResponseBody> body{};

  DescribeVsCertificateListResponse() {}

  explicit DescribeVsCertificateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsCertificateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsCertificateListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsCertificateListResponse() = default;
};
class DescribeVsDevicesDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVsDevicesDataRequest() {}

  explicit DescribeVsDevicesDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDevicesDataRequest() = default;
};
class DescribeVsDevicesDataResponseBodyDevicesDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> devicesDataValue{};
  shared_ptr<string> timeStamp{};

  DescribeVsDevicesDataResponseBodyDevicesDataPerIntervalDataModule() {}

  explicit DescribeVsDevicesDataResponseBodyDevicesDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devicesDataValue) {
      res["DevicesDataValue"] = boost::any(*devicesDataValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DevicesDataValue") != m.end() && !m["DevicesDataValue"].empty()) {
      devicesDataValue = make_shared<string>(boost::any_cast<string>(m["DevicesDataValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeVsDevicesDataResponseBodyDevicesDataPerIntervalDataModule() = default;
};
class DescribeVsDevicesDataResponseBodyDevicesDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsDevicesDataResponseBodyDevicesDataPerIntervalDataModule>> dataModule{};

  DescribeVsDevicesDataResponseBodyDevicesDataPerInterval() {}

  explicit DescribeVsDevicesDataResponseBodyDevicesDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeVsDevicesDataResponseBodyDevicesDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsDevicesDataResponseBodyDevicesDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeVsDevicesDataResponseBodyDevicesDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeVsDevicesDataResponseBodyDevicesDataPerInterval() = default;
};
class DescribeVsDevicesDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVsDevicesDataResponseBodyDevicesDataPerInterval> devicesDataPerInterval{};
  shared_ptr<string> requestId{};

  DescribeVsDevicesDataResponseBody() {}

  explicit DescribeVsDevicesDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devicesDataPerInterval) {
      res["DevicesDataPerInterval"] = devicesDataPerInterval ? boost::any(devicesDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DevicesDataPerInterval") != m.end() && !m["DevicesDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["DevicesDataPerInterval"].type()) {
        DescribeVsDevicesDataResponseBodyDevicesDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DevicesDataPerInterval"]));
        devicesDataPerInterval = make_shared<DescribeVsDevicesDataResponseBodyDevicesDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVsDevicesDataResponseBody() = default;
};
class DescribeVsDevicesDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsDevicesDataResponseBody> body{};

  DescribeVsDevicesDataResponse() {}

  explicit DescribeVsDevicesDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsDevicesDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsDevicesDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsDevicesDataResponse() = default;
};
class DescribeVsDomainBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVsDomainBpsDataRequest() {}

  explicit DescribeVsDomainBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainBpsDataRequest() = default;
};
class DescribeVsDomainBpsDataResponseBodyBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> bpsValue{};
  shared_ptr<string> timeStamp{};

  DescribeVsDomainBpsDataResponseBodyBpsDataPerIntervalDataModule() {}

  explicit DescribeVsDomainBpsDataResponseBodyBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsValue) {
      res["BpsValue"] = boost::any(*bpsValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsValue") != m.end() && !m["BpsValue"].empty()) {
      bpsValue = make_shared<string>(boost::any_cast<string>(m["BpsValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeVsDomainBpsDataResponseBodyBpsDataPerIntervalDataModule() = default;
};
class DescribeVsDomainBpsDataResponseBodyBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsDomainBpsDataResponseBodyBpsDataPerIntervalDataModule>> dataModule{};

  DescribeVsDomainBpsDataResponseBodyBpsDataPerInterval() {}

  explicit DescribeVsDomainBpsDataResponseBodyBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeVsDomainBpsDataResponseBodyBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsDomainBpsDataResponseBodyBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeVsDomainBpsDataResponseBodyBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeVsDomainBpsDataResponseBodyBpsDataPerInterval() = default;
};
class DescribeVsDomainBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVsDomainBpsDataResponseBodyBpsDataPerInterval> bpsDataPerInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeVsDomainBpsDataResponseBody() {}

  explicit DescribeVsDomainBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataPerInterval) {
      res["BpsDataPerInterval"] = bpsDataPerInterval ? boost::any(bpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataPerInterval") != m.end() && !m["BpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataPerInterval"].type()) {
        DescribeVsDomainBpsDataResponseBodyBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataPerInterval"]));
        bpsDataPerInterval = make_shared<DescribeVsDomainBpsDataResponseBodyBpsDataPerInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainBpsDataResponseBody() = default;
};
class DescribeVsDomainBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsDomainBpsDataResponseBody> body{};

  DescribeVsDomainBpsDataResponse() {}

  explicit DescribeVsDomainBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsDomainBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsDomainBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainBpsDataResponse() = default;
};
class DescribeVsDomainCertificateInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeVsDomainCertificateInfoRequest() {}

  explicit DescribeVsDomainCertificateInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeVsDomainCertificateInfoRequest() = default;
};
class DescribeVsDomainCertificateInfoResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certDomainName{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certLife{};
  shared_ptr<string> certName{};
  shared_ptr<string> certOrg{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> serverCertificateStatus{};
  shared_ptr<string> status{};

  DescribeVsDomainCertificateInfoResponseBodyCertInfosCertInfo() {}

  explicit DescribeVsDomainCertificateInfoResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certDomainName) {
      res["CertDomainName"] = boost::any(*certDomainName);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certLife) {
      res["CertLife"] = boost::any(*certLife);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certOrg) {
      res["CertOrg"] = boost::any(*certOrg);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (serverCertificateStatus) {
      res["ServerCertificateStatus"] = boost::any(*serverCertificateStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertDomainName") != m.end() && !m["CertDomainName"].empty()) {
      certDomainName = make_shared<string>(boost::any_cast<string>(m["CertDomainName"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertLife") != m.end() && !m["CertLife"].empty()) {
      certLife = make_shared<string>(boost::any_cast<string>(m["CertLife"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertOrg") != m.end() && !m["CertOrg"].empty()) {
      certOrg = make_shared<string>(boost::any_cast<string>(m["CertOrg"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("ServerCertificateStatus") != m.end() && !m["ServerCertificateStatus"].empty()) {
      serverCertificateStatus = make_shared<string>(boost::any_cast<string>(m["ServerCertificateStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeVsDomainCertificateInfoResponseBodyCertInfosCertInfo() = default;
};
class DescribeVsDomainCertificateInfoResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsDomainCertificateInfoResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeVsDomainCertificateInfoResponseBodyCertInfos() {}

  explicit DescribeVsDomainCertificateInfoResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeVsDomainCertificateInfoResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsDomainCertificateInfoResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeVsDomainCertificateInfoResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeVsDomainCertificateInfoResponseBodyCertInfos() = default;
};
class DescribeVsDomainCertificateInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVsDomainCertificateInfoResponseBodyCertInfos> certInfos{};
  shared_ptr<string> requestId{};

  DescribeVsDomainCertificateInfoResponseBody() {}

  explicit DescribeVsDomainCertificateInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeVsDomainCertificateInfoResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeVsDomainCertificateInfoResponseBodyCertInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVsDomainCertificateInfoResponseBody() = default;
};
class DescribeVsDomainCertificateInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsDomainCertificateInfoResponseBody> body{};

  DescribeVsDomainCertificateInfoResponse() {}

  explicit DescribeVsDomainCertificateInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsDomainCertificateInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsDomainCertificateInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainCertificateInfoResponse() = default;
};
class DescribeVsDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionNames{};
  shared_ptr<long> ownerId{};

  DescribeVsDomainConfigsRequest() {}

  explicit DescribeVsDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeVsDomainConfigsRequest() = default;
};
class DescribeVsDomainConfigsResponseBodyDomainConfigsFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeVsDomainConfigsResponseBodyDomainConfigsFunctionArgs() {}

  explicit DescribeVsDomainConfigsResponseBodyDomainConfigsFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeVsDomainConfigsResponseBodyDomainConfigsFunctionArgs() = default;
};
class DescribeVsDomainConfigsResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<vector<DescribeVsDomainConfigsResponseBodyDomainConfigsFunctionArgs>> functionArgs{};
  shared_ptr<string> functionName{};
  shared_ptr<string> status{};

  DescribeVsDomainConfigsResponseBodyDomainConfigs() {}

  explicit DescribeVsDomainConfigsResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionArgs) {
      vector<boost::any> temp1;
      for(auto item1:*functionArgs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArgs"] = boost::any(temp1);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArgs"].type()) {
        vector<DescribeVsDomainConfigsResponseBodyDomainConfigsFunctionArgs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArgs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsDomainConfigsResponseBodyDomainConfigsFunctionArgs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArgs = make_shared<vector<DescribeVsDomainConfigsResponseBodyDomainConfigsFunctionArgs>>(expect1);
      }
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeVsDomainConfigsResponseBodyDomainConfigs() = default;
};
class DescribeVsDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsDomainConfigsResponseBodyDomainConfigs>> domainConfigs{};
  shared_ptr<string> requestId{};

  DescribeVsDomainConfigsResponseBody() {}

  explicit DescribeVsDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfigs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfigs"].type()) {
        vector<DescribeVsDomainConfigsResponseBodyDomainConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsDomainConfigsResponseBodyDomainConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfigs = make_shared<vector<DescribeVsDomainConfigsResponseBodyDomainConfigs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVsDomainConfigsResponseBody() = default;
};
class DescribeVsDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsDomainConfigsResponseBody> body{};

  DescribeVsDomainConfigsResponse() {}

  explicit DescribeVsDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainConfigsResponse() = default;
};
class DescribeVsDomainDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeVsDomainDetailRequest() {}

  explicit DescribeVsDomainDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeVsDomainDetailRequest() = default;
};
class DescribeVsDomainDetailResponseBodyDomainConfig : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> domainType{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> region{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> scope{};

  DescribeVsDomainDetailResponseBodyDomainConfig() {}

  explicit DescribeVsDomainDetailResponseBodyDomainConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
  }


  virtual ~DescribeVsDomainDetailResponseBodyDomainConfig() = default;
};
class DescribeVsDomainDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVsDomainDetailResponseBodyDomainConfig> domainConfig{};
  shared_ptr<string> requestId{};

  DescribeVsDomainDetailResponseBody() {}

  explicit DescribeVsDomainDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfig) {
      res["DomainConfig"] = domainConfig ? boost::any(domainConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfig") != m.end() && !m["DomainConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainConfig"].type()) {
        DescribeVsDomainDetailResponseBodyDomainConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainConfig"]));
        domainConfig = make_shared<DescribeVsDomainDetailResponseBodyDomainConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVsDomainDetailResponseBody() = default;
};
class DescribeVsDomainDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsDomainDetailResponseBody> body{};

  DescribeVsDomainDetailResponse() {}

  explicit DescribeVsDomainDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsDomainDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsDomainDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainDetailResponse() = default;
};
class DescribeVsDomainPvDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVsDomainPvDataRequest() {}

  explicit DescribeVsDomainPvDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainPvDataRequest() = default;
};
class DescribeVsDomainPvDataResponseBodyPvDataIntervalUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeVsDomainPvDataResponseBodyPvDataIntervalUsageData() {}

  explicit DescribeVsDomainPvDataResponseBodyPvDataIntervalUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVsDomainPvDataResponseBodyPvDataIntervalUsageData() = default;
};
class DescribeVsDomainPvDataResponseBodyPvDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsDomainPvDataResponseBodyPvDataIntervalUsageData>> usageData{};

  DescribeVsDomainPvDataResponseBodyPvDataInterval() {}

  explicit DescribeVsDomainPvDataResponseBodyPvDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeVsDomainPvDataResponseBodyPvDataIntervalUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsDomainPvDataResponseBodyPvDataIntervalUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeVsDomainPvDataResponseBodyPvDataIntervalUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeVsDomainPvDataResponseBodyPvDataInterval() = default;
};
class DescribeVsDomainPvDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeVsDomainPvDataResponseBodyPvDataInterval> pvDataInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeVsDomainPvDataResponseBody() {}

  explicit DescribeVsDomainPvDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pvDataInterval) {
      res["PvDataInterval"] = pvDataInterval ? boost::any(pvDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PvDataInterval") != m.end() && !m["PvDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["PvDataInterval"].type()) {
        DescribeVsDomainPvDataResponseBodyPvDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PvDataInterval"]));
        pvDataInterval = make_shared<DescribeVsDomainPvDataResponseBodyPvDataInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainPvDataResponseBody() = default;
};
class DescribeVsDomainPvDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsDomainPvDataResponseBody> body{};

  DescribeVsDomainPvDataResponse() {}

  explicit DescribeVsDomainPvDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsDomainPvDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsDomainPvDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainPvDataResponse() = default;
};
class DescribeVsDomainPvUvDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVsDomainPvUvDataRequest() {}

  explicit DescribeVsDomainPvUvDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainPvUvDataRequest() = default;
};
class DescribeVsDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> PV{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> UV{};

  DescribeVsDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo() {}

  explicit DescribeVsDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (PV) {
      res["PV"] = boost::any(*PV);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (UV) {
      res["UV"] = boost::any(*UV);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PV") != m.end() && !m["PV"].empty()) {
      PV = make_shared<string>(boost::any_cast<string>(m["PV"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("UV") != m.end() && !m["UV"].empty()) {
      UV = make_shared<string>(boost::any_cast<string>(m["UV"]));
    }
  }


  virtual ~DescribeVsDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo() = default;
};
class DescribeVsDomainPvUvDataResponseBodyPvUvDataInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo>> pvUvDataInfo{};

  DescribeVsDomainPvUvDataResponseBodyPvUvDataInfos() {}

  explicit DescribeVsDomainPvUvDataResponseBodyPvUvDataInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pvUvDataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*pvUvDataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PvUvDataInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PvUvDataInfo") != m.end() && !m["PvUvDataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PvUvDataInfo"].type()) {
        vector<DescribeVsDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PvUvDataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pvUvDataInfo = make_shared<vector<DescribeVsDomainPvUvDataResponseBodyPvUvDataInfosPvUvDataInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeVsDomainPvUvDataResponseBodyPvUvDataInfos() = default;
};
class DescribeVsDomainPvUvDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeVsDomainPvUvDataResponseBodyPvUvDataInfos> pvUvDataInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeVsDomainPvUvDataResponseBody() {}

  explicit DescribeVsDomainPvUvDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pvUvDataInfos) {
      res["PvUvDataInfos"] = pvUvDataInfos ? boost::any(pvUvDataInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PvUvDataInfos") != m.end() && !m["PvUvDataInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PvUvDataInfos"].type()) {
        DescribeVsDomainPvUvDataResponseBodyPvUvDataInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PvUvDataInfos"]));
        pvUvDataInfos = make_shared<DescribeVsDomainPvUvDataResponseBodyPvUvDataInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainPvUvDataResponseBody() = default;
};
class DescribeVsDomainPvUvDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsDomainPvUvDataResponseBody> body{};

  DescribeVsDomainPvUvDataResponse() {}

  explicit DescribeVsDomainPvUvDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsDomainPvUvDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsDomainPvUvDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainPvUvDataResponse() = default;
};
class DescribeVsDomainRecordDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> startTime{};

  DescribeVsDomainRecordDataRequest() {}

  explicit DescribeVsDomainRecordDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainRecordDataRequest() = default;
};
class DescribeVsDomainRecordDataResponseBodyRecordDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> recordValue{};
  shared_ptr<string> streamCountValue{};
  shared_ptr<string> timeStamp{};

  DescribeVsDomainRecordDataResponseBodyRecordDataPerIntervalDataModule() {}

  explicit DescribeVsDomainRecordDataResponseBodyRecordDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordValue) {
      res["RecordValue"] = boost::any(*recordValue);
    }
    if (streamCountValue) {
      res["StreamCountValue"] = boost::any(*streamCountValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordValue") != m.end() && !m["RecordValue"].empty()) {
      recordValue = make_shared<string>(boost::any_cast<string>(m["RecordValue"]));
    }
    if (m.find("StreamCountValue") != m.end() && !m["StreamCountValue"].empty()) {
      streamCountValue = make_shared<string>(boost::any_cast<string>(m["StreamCountValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeVsDomainRecordDataResponseBodyRecordDataPerIntervalDataModule() = default;
};
class DescribeVsDomainRecordDataResponseBodyRecordDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsDomainRecordDataResponseBodyRecordDataPerIntervalDataModule>> dataModule{};

  DescribeVsDomainRecordDataResponseBodyRecordDataPerInterval() {}

  explicit DescribeVsDomainRecordDataResponseBodyRecordDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeVsDomainRecordDataResponseBodyRecordDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsDomainRecordDataResponseBodyRecordDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeVsDomainRecordDataResponseBodyRecordDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeVsDomainRecordDataResponseBodyRecordDataPerInterval() = default;
};
class DescribeVsDomainRecordDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVsDomainRecordDataResponseBodyRecordDataPerInterval> recordDataPerInterval{};
  shared_ptr<string> requestId{};

  DescribeVsDomainRecordDataResponseBody() {}

  explicit DescribeVsDomainRecordDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordDataPerInterval) {
      res["RecordDataPerInterval"] = recordDataPerInterval ? boost::any(recordDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordDataPerInterval") != m.end() && !m["RecordDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordDataPerInterval"].type()) {
        DescribeVsDomainRecordDataResponseBodyRecordDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordDataPerInterval"]));
        recordDataPerInterval = make_shared<DescribeVsDomainRecordDataResponseBodyRecordDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVsDomainRecordDataResponseBody() = default;
};
class DescribeVsDomainRecordDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsDomainRecordDataResponseBody> body{};

  DescribeVsDomainRecordDataResponse() {}

  explicit DescribeVsDomainRecordDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsDomainRecordDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsDomainRecordDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainRecordDataResponse() = default;
};
class DescribeVsDomainRegionDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVsDomainRegionDataRequest() {}

  explicit DescribeVsDomainRegionDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainRegionDataRequest() = default;
};
class DescribeVsDomainRegionDataResponseBodyValueRegionProportionData : public Darabonba::Model {
public:
  shared_ptr<string> avgObjectSize{};
  shared_ptr<string> avgResponseRate{};
  shared_ptr<string> avgResponseTime{};
  shared_ptr<string> bps{};
  shared_ptr<string> bytesProportion{};
  shared_ptr<string> proportion{};
  shared_ptr<string> qps{};
  shared_ptr<string> region{};
  shared_ptr<string> regionEname{};
  shared_ptr<string> reqErrRate{};
  shared_ptr<string> totalBytes{};
  shared_ptr<string> totalQuery{};

  DescribeVsDomainRegionDataResponseBodyValueRegionProportionData() {}

  explicit DescribeVsDomainRegionDataResponseBodyValueRegionProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgObjectSize) {
      res["AvgObjectSize"] = boost::any(*avgObjectSize);
    }
    if (avgResponseRate) {
      res["AvgResponseRate"] = boost::any(*avgResponseRate);
    }
    if (avgResponseTime) {
      res["AvgResponseTime"] = boost::any(*avgResponseTime);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (bytesProportion) {
      res["BytesProportion"] = boost::any(*bytesProportion);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionEname) {
      res["RegionEname"] = boost::any(*regionEname);
    }
    if (reqErrRate) {
      res["ReqErrRate"] = boost::any(*reqErrRate);
    }
    if (totalBytes) {
      res["TotalBytes"] = boost::any(*totalBytes);
    }
    if (totalQuery) {
      res["TotalQuery"] = boost::any(*totalQuery);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgObjectSize") != m.end() && !m["AvgObjectSize"].empty()) {
      avgObjectSize = make_shared<string>(boost::any_cast<string>(m["AvgObjectSize"]));
    }
    if (m.find("AvgResponseRate") != m.end() && !m["AvgResponseRate"].empty()) {
      avgResponseRate = make_shared<string>(boost::any_cast<string>(m["AvgResponseRate"]));
    }
    if (m.find("AvgResponseTime") != m.end() && !m["AvgResponseTime"].empty()) {
      avgResponseTime = make_shared<string>(boost::any_cast<string>(m["AvgResponseTime"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<string>(boost::any_cast<string>(m["Bps"]));
    }
    if (m.find("BytesProportion") != m.end() && !m["BytesProportion"].empty()) {
      bytesProportion = make_shared<string>(boost::any_cast<string>(m["BytesProportion"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<string>(boost::any_cast<string>(m["Qps"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionEname") != m.end() && !m["RegionEname"].empty()) {
      regionEname = make_shared<string>(boost::any_cast<string>(m["RegionEname"]));
    }
    if (m.find("ReqErrRate") != m.end() && !m["ReqErrRate"].empty()) {
      reqErrRate = make_shared<string>(boost::any_cast<string>(m["ReqErrRate"]));
    }
    if (m.find("TotalBytes") != m.end() && !m["TotalBytes"].empty()) {
      totalBytes = make_shared<string>(boost::any_cast<string>(m["TotalBytes"]));
    }
    if (m.find("TotalQuery") != m.end() && !m["TotalQuery"].empty()) {
      totalQuery = make_shared<string>(boost::any_cast<string>(m["TotalQuery"]));
    }
  }


  virtual ~DescribeVsDomainRegionDataResponseBodyValueRegionProportionData() = default;
};
class DescribeVsDomainRegionDataResponseBodyValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsDomainRegionDataResponseBodyValueRegionProportionData>> regionProportionData{};

  DescribeVsDomainRegionDataResponseBodyValue() {}

  explicit DescribeVsDomainRegionDataResponseBodyValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*regionProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionProportionData") != m.end() && !m["RegionProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionProportionData"].type()) {
        vector<DescribeVsDomainRegionDataResponseBodyValueRegionProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsDomainRegionDataResponseBodyValueRegionProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionProportionData = make_shared<vector<DescribeVsDomainRegionDataResponseBodyValueRegionProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeVsDomainRegionDataResponseBodyValue() = default;
};
class DescribeVsDomainRegionDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeVsDomainRegionDataResponseBodyValue> value{};

  DescribeVsDomainRegionDataResponseBody() {}

  explicit DescribeVsDomainRegionDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeVsDomainRegionDataResponseBodyValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeVsDomainRegionDataResponseBodyValue>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainRegionDataResponseBody() = default;
};
class DescribeVsDomainRegionDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsDomainRegionDataResponseBody> body{};

  DescribeVsDomainRegionDataResponse() {}

  explicit DescribeVsDomainRegionDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsDomainRegionDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsDomainRegionDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainRegionDataResponse() = default;
};
class DescribeVsDomainReqBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVsDomainReqBpsDataRequest() {}

  explicit DescribeVsDomainReqBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainReqBpsDataRequest() = default;
};
class DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> reqBpsValue{};
  shared_ptr<string> timeStamp{};

  DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerIntervalDataModule() {}

  explicit DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reqBpsValue) {
      res["ReqBpsValue"] = boost::any(*reqBpsValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReqBpsValue") != m.end() && !m["ReqBpsValue"].empty()) {
      reqBpsValue = make_shared<string>(boost::any_cast<string>(m["ReqBpsValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerIntervalDataModule() = default;
};
class DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerIntervalDataModule>> dataModule{};

  DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerInterval() {}

  explicit DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerInterval() = default;
};
class DescribeVsDomainReqBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerInterval> reqBpsDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeVsDomainReqBpsDataResponseBody() {}

  explicit DescribeVsDomainReqBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (reqBpsDataPerInterval) {
      res["ReqBpsDataPerInterval"] = reqBpsDataPerInterval ? boost::any(reqBpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ReqBpsDataPerInterval") != m.end() && !m["ReqBpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReqBpsDataPerInterval"].type()) {
        DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReqBpsDataPerInterval"]));
        reqBpsDataPerInterval = make_shared<DescribeVsDomainReqBpsDataResponseBodyReqBpsDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainReqBpsDataResponseBody() = default;
};
class DescribeVsDomainReqBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsDomainReqBpsDataResponseBody> body{};

  DescribeVsDomainReqBpsDataResponse() {}

  explicit DescribeVsDomainReqBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsDomainReqBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsDomainReqBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainReqBpsDataResponse() = default;
};
class DescribeVsDomainReqTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVsDomainReqTrafficDataRequest() {}

  explicit DescribeVsDomainReqTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainReqTrafficDataRequest() = default;
};
class DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> reqTrafficValue{};
  shared_ptr<string> timeStamp{};

  DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerIntervalDataModule() {}

  explicit DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reqTrafficValue) {
      res["ReqTrafficValue"] = boost::any(*reqTrafficValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReqTrafficValue") != m.end() && !m["ReqTrafficValue"].empty()) {
      reqTrafficValue = make_shared<string>(boost::any_cast<string>(m["ReqTrafficValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerIntervalDataModule() = default;
};
class DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerInterval() {}

  explicit DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerInterval() = default;
};
class DescribeVsDomainReqTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerInterval> reqTrafficDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeVsDomainReqTrafficDataResponseBody() {}

  explicit DescribeVsDomainReqTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (reqTrafficDataPerInterval) {
      res["ReqTrafficDataPerInterval"] = reqTrafficDataPerInterval ? boost::any(reqTrafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ReqTrafficDataPerInterval") != m.end() && !m["ReqTrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReqTrafficDataPerInterval"].type()) {
        DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReqTrafficDataPerInterval"]));
        reqTrafficDataPerInterval = make_shared<DescribeVsDomainReqTrafficDataResponseBodyReqTrafficDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainReqTrafficDataResponseBody() = default;
};
class DescribeVsDomainReqTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsDomainReqTrafficDataResponseBody> body{};

  DescribeVsDomainReqTrafficDataResponse() {}

  explicit DescribeVsDomainReqTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsDomainReqTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsDomainReqTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainReqTrafficDataResponse() = default;
};
class DescribeVsDomainSnapshotDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVsDomainSnapshotDataRequest() {}

  explicit DescribeVsDomainSnapshotDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainSnapshotDataRequest() = default;
};
class DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> snapshotValue{};
  shared_ptr<string> timeStamp{};

  DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerIntervalDataModule() {}

  explicit DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshotValue) {
      res["SnapshotValue"] = boost::any(*snapshotValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnapshotValue") != m.end() && !m["SnapshotValue"].empty()) {
      snapshotValue = make_shared<string>(boost::any_cast<string>(m["SnapshotValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerIntervalDataModule() = default;
};
class DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerIntervalDataModule>> dataModule{};

  DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerInterval() {}

  explicit DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerInterval() = default;
};
class DescribeVsDomainSnapshotDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerInterval> snapshotDataPerInterval{};

  DescribeVsDomainSnapshotDataResponseBody() {}

  explicit DescribeVsDomainSnapshotDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotDataPerInterval) {
      res["SnapshotDataPerInterval"] = snapshotDataPerInterval ? boost::any(snapshotDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotDataPerInterval") != m.end() && !m["SnapshotDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotDataPerInterval"].type()) {
        DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotDataPerInterval"]));
        snapshotDataPerInterval = make_shared<DescribeVsDomainSnapshotDataResponseBodySnapshotDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainSnapshotDataResponseBody() = default;
};
class DescribeVsDomainSnapshotDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsDomainSnapshotDataResponseBody> body{};

  DescribeVsDomainSnapshotDataResponse() {}

  explicit DescribeVsDomainSnapshotDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsDomainSnapshotDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsDomainSnapshotDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainSnapshotDataResponse() = default;
};
class DescribeVsDomainTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVsDomainTrafficDataRequest() {}

  explicit DescribeVsDomainTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainTrafficDataRequest() = default;
};
class DescribeVsDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> trafficValue{};

  DescribeVsDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule() {}

  explicit DescribeVsDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<string>(boost::any_cast<string>(m["TrafficValue"]));
    }
  }


  virtual ~DescribeVsDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule() = default;
};
class DescribeVsDomainTrafficDataResponseBodyTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeVsDomainTrafficDataResponseBodyTrafficDataPerInterval() {}

  explicit DescribeVsDomainTrafficDataResponseBodyTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeVsDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeVsDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeVsDomainTrafficDataResponseBodyTrafficDataPerInterval() = default;
};
class DescribeVsDomainTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeVsDomainTrafficDataResponseBodyTrafficDataPerInterval> trafficDataPerInterval{};

  DescribeVsDomainTrafficDataResponseBody() {}

  explicit DescribeVsDomainTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (trafficDataPerInterval) {
      res["TrafficDataPerInterval"] = trafficDataPerInterval ? boost::any(trafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TrafficDataPerInterval") != m.end() && !m["TrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficDataPerInterval"].type()) {
        DescribeVsDomainTrafficDataResponseBodyTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficDataPerInterval"]));
        trafficDataPerInterval = make_shared<DescribeVsDomainTrafficDataResponseBodyTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainTrafficDataResponseBody() = default;
};
class DescribeVsDomainTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsDomainTrafficDataResponseBody> body{};

  DescribeVsDomainTrafficDataResponse() {}

  explicit DescribeVsDomainTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsDomainTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsDomainTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainTrafficDataResponse() = default;
};
class DescribeVsDomainUvDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVsDomainUvDataRequest() {}

  explicit DescribeVsDomainUvDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsDomainUvDataRequest() = default;
};
class DescribeVsDomainUvDataResponseBodyUvDataIntervalUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeVsDomainUvDataResponseBodyUvDataIntervalUsageData() {}

  explicit DescribeVsDomainUvDataResponseBodyUvDataIntervalUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVsDomainUvDataResponseBodyUvDataIntervalUsageData() = default;
};
class DescribeVsDomainUvDataResponseBodyUvDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsDomainUvDataResponseBodyUvDataIntervalUsageData>> usageData{};

  DescribeVsDomainUvDataResponseBodyUvDataInterval() {}

  explicit DescribeVsDomainUvDataResponseBodyUvDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeVsDomainUvDataResponseBodyUvDataIntervalUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsDomainUvDataResponseBodyUvDataIntervalUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeVsDomainUvDataResponseBodyUvDataIntervalUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeVsDomainUvDataResponseBodyUvDataInterval() = default;
};
class DescribeVsDomainUvDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeVsDomainUvDataResponseBodyUvDataInterval> uvDataInterval{};

  DescribeVsDomainUvDataResponseBody() {}

  explicit DescribeVsDomainUvDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (uvDataInterval) {
      res["UvDataInterval"] = uvDataInterval ? boost::any(uvDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("UvDataInterval") != m.end() && !m["UvDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["UvDataInterval"].type()) {
        DescribeVsDomainUvDataResponseBodyUvDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UvDataInterval"]));
        uvDataInterval = make_shared<DescribeVsDomainUvDataResponseBodyUvDataInterval>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainUvDataResponseBody() = default;
};
class DescribeVsDomainUvDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsDomainUvDataResponseBody> body{};

  DescribeVsDomainUvDataResponse() {}

  explicit DescribeVsDomainUvDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsDomainUvDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsDomainUvDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsDomainUvDataResponse() = default;
};
class DescribeVsPullStreamInfoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeVsPullStreamInfoConfigRequest() {}

  explicit DescribeVsPullStreamInfoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeVsPullStreamInfoConfigRequest() = default;
};
class DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordListLiveAppRecord : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordListLiveAppRecord() {}

  explicit DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordListLiveAppRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordListLiveAppRecord() = default;
};
class DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordListLiveAppRecord>> liveAppRecord{};

  DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordList() {}

  explicit DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAppRecord) {
      vector<boost::any> temp1;
      for(auto item1:*liveAppRecord){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveAppRecord"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAppRecord") != m.end() && !m["LiveAppRecord"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveAppRecord"].type()) {
        vector<DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordListLiveAppRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveAppRecord"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordListLiveAppRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveAppRecord = make_shared<vector<DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordListLiveAppRecord>>(expect1);
      }
    }
  }


  virtual ~DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordList() = default;
};
class DescribeVsPullStreamInfoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordList> liveAppRecordList{};
  shared_ptr<string> requestId{};

  DescribeVsPullStreamInfoConfigResponseBody() {}

  explicit DescribeVsPullStreamInfoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveAppRecordList) {
      res["LiveAppRecordList"] = liveAppRecordList ? boost::any(liveAppRecordList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveAppRecordList") != m.end() && !m["LiveAppRecordList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveAppRecordList"].type()) {
        DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveAppRecordList"]));
        liveAppRecordList = make_shared<DescribeVsPullStreamInfoConfigResponseBodyLiveAppRecordList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVsPullStreamInfoConfigResponseBody() = default;
};
class DescribeVsPullStreamInfoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsPullStreamInfoConfigResponseBody> body{};

  DescribeVsPullStreamInfoConfigResponse() {}

  explicit DescribeVsPullStreamInfoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsPullStreamInfoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsPullStreamInfoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsPullStreamInfoConfigResponse() = default;
};
class DescribeVsStreamsNotifyUrlConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeVsStreamsNotifyUrlConfigRequest() {}

  explicit DescribeVsStreamsNotifyUrlConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeVsStreamsNotifyUrlConfigRequest() = default;
};
class DescribeVsStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig : public Darabonba::Model {
public:
  shared_ptr<string> authKey{};
  shared_ptr<string> authType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyUrl{};

  DescribeVsStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig() {}

  explicit DescribeVsStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
  }


  virtual ~DescribeVsStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig() = default;
};
class DescribeVsStreamsNotifyUrlConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVsStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig> liveStreamsNotifyConfig{};
  shared_ptr<string> requestId{};

  DescribeVsStreamsNotifyUrlConfigResponseBody() {}

  explicit DescribeVsStreamsNotifyUrlConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamsNotifyConfig) {
      res["LiveStreamsNotifyConfig"] = liveStreamsNotifyConfig ? boost::any(liveStreamsNotifyConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamsNotifyConfig") != m.end() && !m["LiveStreamsNotifyConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamsNotifyConfig"].type()) {
        DescribeVsStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamsNotifyConfig"]));
        liveStreamsNotifyConfig = make_shared<DescribeVsStreamsNotifyUrlConfigResponseBodyLiveStreamsNotifyConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVsStreamsNotifyUrlConfigResponseBody() = default;
};
class DescribeVsStreamsNotifyUrlConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsStreamsNotifyUrlConfigResponseBody> body{};

  DescribeVsStreamsNotifyUrlConfigResponse() {}

  explicit DescribeVsStreamsNotifyUrlConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsStreamsNotifyUrlConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsStreamsNotifyUrlConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsStreamsNotifyUrlConfigResponse() = default;
};
class DescribeVsStreamsOnlineListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<string> streamType{};

  DescribeVsStreamsOnlineListRequest() {}

  explicit DescribeVsStreamsOnlineListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
  }


  virtual ~DescribeVsStreamsOnlineListRequest() = default;
};
class DescribeVsStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> publishDomain{};
  shared_ptr<string> publishTime{};
  shared_ptr<string> publishType{};
  shared_ptr<string> publishUrl{};
  shared_ptr<string> streamName{};
  shared_ptr<string> transcodeId{};
  shared_ptr<string> transcoded{};

  DescribeVsStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo() {}

  explicit DescribeVsStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (publishDomain) {
      res["PublishDomain"] = boost::any(*publishDomain);
    }
    if (publishTime) {
      res["PublishTime"] = boost::any(*publishTime);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (publishUrl) {
      res["PublishUrl"] = boost::any(*publishUrl);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (transcodeId) {
      res["TranscodeId"] = boost::any(*transcodeId);
    }
    if (transcoded) {
      res["Transcoded"] = boost::any(*transcoded);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("PublishDomain") != m.end() && !m["PublishDomain"].empty()) {
      publishDomain = make_shared<string>(boost::any_cast<string>(m["PublishDomain"]));
    }
    if (m.find("PublishTime") != m.end() && !m["PublishTime"].empty()) {
      publishTime = make_shared<string>(boost::any_cast<string>(m["PublishTime"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<string>(boost::any_cast<string>(m["PublishType"]));
    }
    if (m.find("PublishUrl") != m.end() && !m["PublishUrl"].empty()) {
      publishUrl = make_shared<string>(boost::any_cast<string>(m["PublishUrl"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("TranscodeId") != m.end() && !m["TranscodeId"].empty()) {
      transcodeId = make_shared<string>(boost::any_cast<string>(m["TranscodeId"]));
    }
    if (m.find("Transcoded") != m.end() && !m["Transcoded"].empty()) {
      transcoded = make_shared<string>(boost::any_cast<string>(m["Transcoded"]));
    }
  }


  virtual ~DescribeVsStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo() = default;
};
class DescribeVsStreamsOnlineListResponseBodyOnlineInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo>> liveStreamOnlineInfo{};

  DescribeVsStreamsOnlineListResponseBodyOnlineInfo() {}

  explicit DescribeVsStreamsOnlineListResponseBodyOnlineInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamOnlineInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamOnlineInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamOnlineInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamOnlineInfo") != m.end() && !m["LiveStreamOnlineInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamOnlineInfo"].type()) {
        vector<DescribeVsStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamOnlineInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamOnlineInfo = make_shared<vector<DescribeVsStreamsOnlineListResponseBodyOnlineInfoLiveStreamOnlineInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeVsStreamsOnlineListResponseBodyOnlineInfo() = default;
};
class DescribeVsStreamsOnlineListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVsStreamsOnlineListResponseBodyOnlineInfo> onlineInfo{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeVsStreamsOnlineListResponseBody() {}

  explicit DescribeVsStreamsOnlineListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onlineInfo) {
      res["OnlineInfo"] = onlineInfo ? boost::any(onlineInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnlineInfo") != m.end() && !m["OnlineInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OnlineInfo"].type()) {
        DescribeVsStreamsOnlineListResponseBodyOnlineInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OnlineInfo"]));
        onlineInfo = make_shared<DescribeVsStreamsOnlineListResponseBodyOnlineInfo>(model1);
      }
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeVsStreamsOnlineListResponseBody() = default;
};
class DescribeVsStreamsOnlineListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsStreamsOnlineListResponseBody> body{};

  DescribeVsStreamsOnlineListResponse() {}

  explicit DescribeVsStreamsOnlineListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsStreamsOnlineListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsStreamsOnlineListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsStreamsOnlineListResponse() = default;
};
class DescribeVsStreamsPublishListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};
  shared_ptr<string> streamType{};

  DescribeVsStreamsPublishListRequest() {}

  explicit DescribeVsStreamsPublishListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
  }


  virtual ~DescribeVsStreamsPublishListRequest() = default;
};
class DescribeVsStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> clientAddr{};
  shared_ptr<string> domainName{};
  shared_ptr<string> edgeNodeAddr{};
  shared_ptr<string> publishDomain{};
  shared_ptr<string> publishTime{};
  shared_ptr<string> publishType{};
  shared_ptr<string> publishUrl{};
  shared_ptr<string> stopTime{};
  shared_ptr<string> streamName{};
  shared_ptr<string> streamUrl{};
  shared_ptr<string> transcodeId{};
  shared_ptr<string> transcoded{};

  DescribeVsStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo() {}

  explicit DescribeVsStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clientAddr) {
      res["ClientAddr"] = boost::any(*clientAddr);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (edgeNodeAddr) {
      res["EdgeNodeAddr"] = boost::any(*edgeNodeAddr);
    }
    if (publishDomain) {
      res["PublishDomain"] = boost::any(*publishDomain);
    }
    if (publishTime) {
      res["PublishTime"] = boost::any(*publishTime);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (publishUrl) {
      res["PublishUrl"] = boost::any(*publishUrl);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    if (transcodeId) {
      res["TranscodeId"] = boost::any(*transcodeId);
    }
    if (transcoded) {
      res["Transcoded"] = boost::any(*transcoded);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClientAddr") != m.end() && !m["ClientAddr"].empty()) {
      clientAddr = make_shared<string>(boost::any_cast<string>(m["ClientAddr"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EdgeNodeAddr") != m.end() && !m["EdgeNodeAddr"].empty()) {
      edgeNodeAddr = make_shared<string>(boost::any_cast<string>(m["EdgeNodeAddr"]));
    }
    if (m.find("PublishDomain") != m.end() && !m["PublishDomain"].empty()) {
      publishDomain = make_shared<string>(boost::any_cast<string>(m["PublishDomain"]));
    }
    if (m.find("PublishTime") != m.end() && !m["PublishTime"].empty()) {
      publishTime = make_shared<string>(boost::any_cast<string>(m["PublishTime"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<string>(boost::any_cast<string>(m["PublishType"]));
    }
    if (m.find("PublishUrl") != m.end() && !m["PublishUrl"].empty()) {
      publishUrl = make_shared<string>(boost::any_cast<string>(m["PublishUrl"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<string>(boost::any_cast<string>(m["StopTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
    if (m.find("TranscodeId") != m.end() && !m["TranscodeId"].empty()) {
      transcodeId = make_shared<string>(boost::any_cast<string>(m["TranscodeId"]));
    }
    if (m.find("Transcoded") != m.end() && !m["Transcoded"].empty()) {
      transcoded = make_shared<string>(boost::any_cast<string>(m["Transcoded"]));
    }
  }


  virtual ~DescribeVsStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo() = default;
};
class DescribeVsStreamsPublishListResponseBodyPublishInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo>> liveStreamPublishInfo{};

  DescribeVsStreamsPublishListResponseBodyPublishInfo() {}

  explicit DescribeVsStreamsPublishListResponseBodyPublishInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveStreamPublishInfo) {
      vector<boost::any> temp1;
      for(auto item1:*liveStreamPublishInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveStreamPublishInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveStreamPublishInfo") != m.end() && !m["LiveStreamPublishInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveStreamPublishInfo"].type()) {
        vector<DescribeVsStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveStreamPublishInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveStreamPublishInfo = make_shared<vector<DescribeVsStreamsPublishListResponseBodyPublishInfoLiveStreamPublishInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeVsStreamsPublishListResponseBodyPublishInfo() = default;
};
class DescribeVsStreamsPublishListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribeVsStreamsPublishListResponseBodyPublishInfo> publishInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> totalPage{};

  DescribeVsStreamsPublishListResponseBody() {}

  explicit DescribeVsStreamsPublishListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (publishInfo) {
      res["PublishInfo"] = publishInfo ? boost::any(publishInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PublishInfo") != m.end() && !m["PublishInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublishInfo"].type()) {
        DescribeVsStreamsPublishListResponseBodyPublishInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublishInfo"]));
        publishInfo = make_shared<DescribeVsStreamsPublishListResponseBodyPublishInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
  }


  virtual ~DescribeVsStreamsPublishListResponseBody() = default;
};
class DescribeVsStreamsPublishListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsStreamsPublishListResponseBody> body{};

  DescribeVsStreamsPublishListResponse() {}

  explicit DescribeVsStreamsPublishListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsStreamsPublishListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsStreamsPublishListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsStreamsPublishListResponse() = default;
};
class DescribeVsTopDomainsByFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> limit{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVsTopDomainsByFlowRequest() {}

  explicit DescribeVsTopDomainsByFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsTopDomainsByFlowRequest() = default;
};
class DescribeVsTopDomainsByFlowResponseBodyTopDomainsTopDomain : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> maxBps{};
  shared_ptr<string> maxBpsTime{};
  shared_ptr<long> rank{};
  shared_ptr<long> totalAccess{};
  shared_ptr<string> totalTraffic{};
  shared_ptr<string> trafficPercent{};

  DescribeVsTopDomainsByFlowResponseBodyTopDomainsTopDomain() {}

  explicit DescribeVsTopDomainsByFlowResponseBodyTopDomainsTopDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (maxBps) {
      res["MaxBps"] = boost::any(*maxBps);
    }
    if (maxBpsTime) {
      res["MaxBpsTime"] = boost::any(*maxBpsTime);
    }
    if (rank) {
      res["Rank"] = boost::any(*rank);
    }
    if (totalAccess) {
      res["TotalAccess"] = boost::any(*totalAccess);
    }
    if (totalTraffic) {
      res["TotalTraffic"] = boost::any(*totalTraffic);
    }
    if (trafficPercent) {
      res["TrafficPercent"] = boost::any(*trafficPercent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("MaxBps") != m.end() && !m["MaxBps"].empty()) {
      maxBps = make_shared<long>(boost::any_cast<long>(m["MaxBps"]));
    }
    if (m.find("MaxBpsTime") != m.end() && !m["MaxBpsTime"].empty()) {
      maxBpsTime = make_shared<string>(boost::any_cast<string>(m["MaxBpsTime"]));
    }
    if (m.find("Rank") != m.end() && !m["Rank"].empty()) {
      rank = make_shared<long>(boost::any_cast<long>(m["Rank"]));
    }
    if (m.find("TotalAccess") != m.end() && !m["TotalAccess"].empty()) {
      totalAccess = make_shared<long>(boost::any_cast<long>(m["TotalAccess"]));
    }
    if (m.find("TotalTraffic") != m.end() && !m["TotalTraffic"].empty()) {
      totalTraffic = make_shared<string>(boost::any_cast<string>(m["TotalTraffic"]));
    }
    if (m.find("TrafficPercent") != m.end() && !m["TrafficPercent"].empty()) {
      trafficPercent = make_shared<string>(boost::any_cast<string>(m["TrafficPercent"]));
    }
  }


  virtual ~DescribeVsTopDomainsByFlowResponseBodyTopDomainsTopDomain() = default;
};
class DescribeVsTopDomainsByFlowResponseBodyTopDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsTopDomainsByFlowResponseBodyTopDomainsTopDomain>> topDomain{};

  DescribeVsTopDomainsByFlowResponseBodyTopDomains() {}

  explicit DescribeVsTopDomainsByFlowResponseBodyTopDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topDomain) {
      vector<boost::any> temp1;
      for(auto item1:*topDomain){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopDomain"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopDomain") != m.end() && !m["TopDomain"].empty()) {
      if (typeid(vector<boost::any>) == m["TopDomain"].type()) {
        vector<DescribeVsTopDomainsByFlowResponseBodyTopDomainsTopDomain> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopDomain"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsTopDomainsByFlowResponseBodyTopDomainsTopDomain model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topDomain = make_shared<vector<DescribeVsTopDomainsByFlowResponseBodyTopDomainsTopDomain>>(expect1);
      }
    }
  }


  virtual ~DescribeVsTopDomainsByFlowResponseBodyTopDomains() = default;
};
class DescribeVsTopDomainsByFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> domainCount{};
  shared_ptr<long> domainOnlineCount{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeVsTopDomainsByFlowResponseBodyTopDomains> topDomains{};

  DescribeVsTopDomainsByFlowResponseBody() {}

  explicit DescribeVsTopDomainsByFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainCount) {
      res["DomainCount"] = boost::any(*domainCount);
    }
    if (domainOnlineCount) {
      res["DomainOnlineCount"] = boost::any(*domainOnlineCount);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (topDomains) {
      res["TopDomains"] = topDomains ? boost::any(topDomains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainCount") != m.end() && !m["DomainCount"].empty()) {
      domainCount = make_shared<long>(boost::any_cast<long>(m["DomainCount"]));
    }
    if (m.find("DomainOnlineCount") != m.end() && !m["DomainOnlineCount"].empty()) {
      domainOnlineCount = make_shared<long>(boost::any_cast<long>(m["DomainOnlineCount"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TopDomains") != m.end() && !m["TopDomains"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopDomains"].type()) {
        DescribeVsTopDomainsByFlowResponseBodyTopDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopDomains"]));
        topDomains = make_shared<DescribeVsTopDomainsByFlowResponseBodyTopDomains>(model1);
      }
    }
  }


  virtual ~DescribeVsTopDomainsByFlowResponseBody() = default;
};
class DescribeVsTopDomainsByFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsTopDomainsByFlowResponseBody> body{};

  DescribeVsTopDomainsByFlowResponse() {}

  explicit DescribeVsTopDomainsByFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsTopDomainsByFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsTopDomainsByFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsTopDomainsByFlowResponse() = default;
};
class DescribeVsUpPeakPublishStreamDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainSwitch{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVsUpPeakPublishStreamDataRequest() {}

  explicit DescribeVsUpPeakPublishStreamDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainSwitch) {
      res["DomainSwitch"] = boost::any(*domainSwitch);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainSwitch") != m.end() && !m["DomainSwitch"].empty()) {
      domainSwitch = make_shared<string>(boost::any_cast<string>(m["DomainSwitch"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVsUpPeakPublishStreamDataRequest() = default;
};
class DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatasDescribeVsUpPeakPublishStreamData : public Darabonba::Model {
public:
  shared_ptr<string> bandWidth{};
  shared_ptr<string> peakTime{};
  shared_ptr<long> publishStreamNum{};
  shared_ptr<string> queryTime{};
  shared_ptr<string> statName{};

  DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatasDescribeVsUpPeakPublishStreamData() {}

  explicit DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatasDescribeVsUpPeakPublishStreamData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidth) {
      res["BandWidth"] = boost::any(*bandWidth);
    }
    if (peakTime) {
      res["PeakTime"] = boost::any(*peakTime);
    }
    if (publishStreamNum) {
      res["PublishStreamNum"] = boost::any(*publishStreamNum);
    }
    if (queryTime) {
      res["QueryTime"] = boost::any(*queryTime);
    }
    if (statName) {
      res["StatName"] = boost::any(*statName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidth") != m.end() && !m["BandWidth"].empty()) {
      bandWidth = make_shared<string>(boost::any_cast<string>(m["BandWidth"]));
    }
    if (m.find("PeakTime") != m.end() && !m["PeakTime"].empty()) {
      peakTime = make_shared<string>(boost::any_cast<string>(m["PeakTime"]));
    }
    if (m.find("PublishStreamNum") != m.end() && !m["PublishStreamNum"].empty()) {
      publishStreamNum = make_shared<long>(boost::any_cast<long>(m["PublishStreamNum"]));
    }
    if (m.find("QueryTime") != m.end() && !m["QueryTime"].empty()) {
      queryTime = make_shared<string>(boost::any_cast<string>(m["QueryTime"]));
    }
    if (m.find("StatName") != m.end() && !m["StatName"].empty()) {
      statName = make_shared<string>(boost::any_cast<string>(m["StatName"]));
    }
  }


  virtual ~DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatasDescribeVsUpPeakPublishStreamData() = default;
};
class DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatasDescribeVsUpPeakPublishStreamData>> describeVsUpPeakPublishStreamData{};

  DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatas() {}

  explicit DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeVsUpPeakPublishStreamData) {
      vector<boost::any> temp1;
      for(auto item1:*describeVsUpPeakPublishStreamData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DescribeVsUpPeakPublishStreamData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeVsUpPeakPublishStreamData") != m.end() && !m["DescribeVsUpPeakPublishStreamData"].empty()) {
      if (typeid(vector<boost::any>) == m["DescribeVsUpPeakPublishStreamData"].type()) {
        vector<DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatasDescribeVsUpPeakPublishStreamData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DescribeVsUpPeakPublishStreamData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatasDescribeVsUpPeakPublishStreamData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        describeVsUpPeakPublishStreamData = make_shared<vector<DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatasDescribeVsUpPeakPublishStreamData>>(expect1);
      }
    }
  }


  virtual ~DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatas() = default;
};
class DescribeVsUpPeakPublishStreamDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatas> describeVsUpPeakPublishStreamDatas{};
  shared_ptr<string> requestId{};

  DescribeVsUpPeakPublishStreamDataResponseBody() {}

  explicit DescribeVsUpPeakPublishStreamDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeVsUpPeakPublishStreamDatas) {
      res["DescribeVsUpPeakPublishStreamDatas"] = describeVsUpPeakPublishStreamDatas ? boost::any(describeVsUpPeakPublishStreamDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeVsUpPeakPublishStreamDatas") != m.end() && !m["DescribeVsUpPeakPublishStreamDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescribeVsUpPeakPublishStreamDatas"].type()) {
        DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescribeVsUpPeakPublishStreamDatas"]));
        describeVsUpPeakPublishStreamDatas = make_shared<DescribeVsUpPeakPublishStreamDataResponseBodyDescribeVsUpPeakPublishStreamDatas>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVsUpPeakPublishStreamDataResponseBody() = default;
};
class DescribeVsUpPeakPublishStreamDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsUpPeakPublishStreamDataResponseBody> body{};

  DescribeVsUpPeakPublishStreamDataResponse() {}

  explicit DescribeVsUpPeakPublishStreamDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsUpPeakPublishStreamDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsUpPeakPublishStreamDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsUpPeakPublishStreamDataResponse() = default;
};
class DescribeVsUserResourcePackageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeVsUserResourcePackageRequest() {}

  explicit DescribeVsUserResourcePackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeVsUserResourcePackageRequest() = default;
};
class DescribeVsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> currCapacity{};
  shared_ptr<string> displayName{};
  shared_ptr<string> initCapacity{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> status{};

  DescribeVsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo() {}

  explicit DescribeVsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (currCapacity) {
      res["CurrCapacity"] = boost::any(*currCapacity);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (initCapacity) {
      res["InitCapacity"] = boost::any(*initCapacity);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CurrCapacity") != m.end() && !m["CurrCapacity"].empty()) {
      currCapacity = make_shared<string>(boost::any_cast<string>(m["CurrCapacity"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InitCapacity") != m.end() && !m["InitCapacity"].empty()) {
      initCapacity = make_shared<string>(boost::any_cast<string>(m["InitCapacity"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeVsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo() = default;
};
class DescribeVsUserResourcePackageResponseBodyResourcePackageInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo>> resourcePackageInfo{};

  DescribeVsUserResourcePackageResponseBodyResourcePackageInfos() {}

  explicit DescribeVsUserResourcePackageResponseBodyResourcePackageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourcePackageInfo) {
      vector<boost::any> temp1;
      for(auto item1:*resourcePackageInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcePackageInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourcePackageInfo") != m.end() && !m["ResourcePackageInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcePackageInfo"].type()) {
        vector<DescribeVsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcePackageInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcePackageInfo = make_shared<vector<DescribeVsUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeVsUserResourcePackageResponseBodyResourcePackageInfos() = default;
};
class DescribeVsUserResourcePackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeVsUserResourcePackageResponseBodyResourcePackageInfos> resourcePackageInfos{};

  DescribeVsUserResourcePackageResponseBody() {}

  explicit DescribeVsUserResourcePackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourcePackageInfos) {
      res["ResourcePackageInfos"] = resourcePackageInfos ? boost::any(resourcePackageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourcePackageInfos") != m.end() && !m["ResourcePackageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourcePackageInfos"].type()) {
        DescribeVsUserResourcePackageResponseBodyResourcePackageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourcePackageInfos"]));
        resourcePackageInfos = make_shared<DescribeVsUserResourcePackageResponseBodyResourcePackageInfos>(model1);
      }
    }
  }


  virtual ~DescribeVsUserResourcePackageResponseBody() = default;
};
class DescribeVsUserResourcePackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsUserResourcePackageResponseBody> body{};

  DescribeVsUserResourcePackageResponse() {}

  explicit DescribeVsUserResourcePackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsUserResourcePackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsUserResourcePackageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsUserResourcePackageResponse() = default;
};
class DescribeVsVerifyContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeVsVerifyContentRequest() {}

  explicit DescribeVsVerifyContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeVsVerifyContentRequest() = default;
};
class DescribeVsVerifyContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeVsVerifyContentResponseBody() {}

  explicit DescribeVsVerifyContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVsVerifyContentResponseBody() = default;
};
class DescribeVsVerifyContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVsVerifyContentResponseBody> body{};

  DescribeVsVerifyContentResponse() {}

  explicit DescribeVsVerifyContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVsVerifyContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVsVerifyContentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVsVerifyContentResponse() = default;
};
class ForbidVsStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> controlStreamAction{};
  shared_ptr<string> domainName{};
  shared_ptr<string> liveStreamType{};
  shared_ptr<string> oneshot{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resumeTime{};
  shared_ptr<string> streamName{};

  ForbidVsStreamRequest() {}

  explicit ForbidVsStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (controlStreamAction) {
      res["ControlStreamAction"] = boost::any(*controlStreamAction);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (liveStreamType) {
      res["LiveStreamType"] = boost::any(*liveStreamType);
    }
    if (oneshot) {
      res["Oneshot"] = boost::any(*oneshot);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resumeTime) {
      res["ResumeTime"] = boost::any(*resumeTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ControlStreamAction") != m.end() && !m["ControlStreamAction"].empty()) {
      controlStreamAction = make_shared<string>(boost::any_cast<string>(m["ControlStreamAction"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LiveStreamType") != m.end() && !m["LiveStreamType"].empty()) {
      liveStreamType = make_shared<string>(boost::any_cast<string>(m["LiveStreamType"]));
    }
    if (m.find("Oneshot") != m.end() && !m["Oneshot"].empty()) {
      oneshot = make_shared<string>(boost::any_cast<string>(m["Oneshot"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResumeTime") != m.end() && !m["ResumeTime"].empty()) {
      resumeTime = make_shared<string>(boost::any_cast<string>(m["ResumeTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~ForbidVsStreamRequest() = default;
};
class ForbidVsStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ForbidVsStreamResponseBody() {}

  explicit ForbidVsStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ForbidVsStreamResponseBody() = default;
};
class ForbidVsStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ForbidVsStreamResponseBody> body{};

  ForbidVsStreamResponse() {}

  explicit ForbidVsStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ForbidVsStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ForbidVsStreamResponseBody>(model1);
      }
    }
  }


  virtual ~ForbidVsStreamResponse() = default;
};
class GetRenderingInstanceStreamingInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> renderingInstanceId{};

  GetRenderingInstanceStreamingInfoRequest() {}

  explicit GetRenderingInstanceStreamingInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~GetRenderingInstanceStreamingInfoRequest() = default;
};
class GetRenderingInstanceStreamingInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};
  shared_ptr<string> gateway{};
  shared_ptr<string> hostname{};
  shared_ptr<string> port{};
  shared_ptr<string> renderingInstanceId{};
  shared_ptr<string> requestId{};

  GetRenderingInstanceStreamingInfoResponseBody() {}

  explicit GetRenderingInstanceStreamingInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (hostname) {
      res["Hostname"] = boost::any(*hostname);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("Hostname") != m.end() && !m["Hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["Hostname"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRenderingInstanceStreamingInfoResponseBody() = default;
};
class GetRenderingInstanceStreamingInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRenderingInstanceStreamingInfoResponseBody> body{};

  GetRenderingInstanceStreamingInfoResponse() {}

  explicit GetRenderingInstanceStreamingInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRenderingInstanceStreamingInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRenderingInstanceStreamingInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetRenderingInstanceStreamingInfoResponse() = default;
};
class GotoPresetRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> presetId{};

  GotoPresetRequest() {}

  explicit GotoPresetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (presetId) {
      res["PresetId"] = boost::any(*presetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PresetId") != m.end() && !m["PresetId"].empty()) {
      presetId = make_shared<string>(boost::any_cast<string>(m["PresetId"]));
    }
  }


  virtual ~GotoPresetRequest() = default;
};
class GotoPresetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  GotoPresetResponseBody() {}

  explicit GotoPresetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GotoPresetResponseBody() = default;
};
class GotoPresetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GotoPresetResponseBody> body{};

  GotoPresetResponse() {}

  explicit GotoPresetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GotoPresetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GotoPresetResponseBody>(model1);
      }
    }
  }


  virtual ~GotoPresetResponse() = default;
};
class InstallCloudAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> renderingInstanceId{};

  InstallCloudAppRequest() {}

  explicit InstallCloudAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~InstallCloudAppRequest() = default;
};
class InstallCloudAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  InstallCloudAppResponseBody() {}

  explicit InstallCloudAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InstallCloudAppResponseBody() = default;
};
class InstallCloudAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallCloudAppResponseBody> body{};

  InstallCloudAppResponse() {}

  explicit InstallCloudAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallCloudAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallCloudAppResponseBody>(model1);
      }
    }
  }


  virtual ~InstallCloudAppResponse() = default;
};
class ListCloudAppInstallationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> appVersion{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> renderingInstanceId{};

  ListCloudAppInstallationsRequest() {}

  explicit ListCloudAppInstallationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~ListCloudAppInstallationsRequest() = default;
};
class ListCloudAppInstallationsResponseBodyInstallationInfos : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> appVersion{};
  shared_ptr<string> installationTime{};
  shared_ptr<string> renderingInstanceId{};
  shared_ptr<string> status{};
  shared_ptr<string> statusDescription{};
  shared_ptr<string> updateTime{};

  ListCloudAppInstallationsResponseBodyInstallationInfos() {}

  explicit ListCloudAppInstallationsResponseBodyInstallationInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (installationTime) {
      res["InstallationTime"] = boost::any(*installationTime);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusDescription) {
      res["StatusDescription"] = boost::any(*statusDescription);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("InstallationTime") != m.end() && !m["InstallationTime"].empty()) {
      installationTime = make_shared<string>(boost::any_cast<string>(m["InstallationTime"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusDescription") != m.end() && !m["StatusDescription"].empty()) {
      statusDescription = make_shared<string>(boost::any_cast<string>(m["StatusDescription"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListCloudAppInstallationsResponseBodyInstallationInfos() = default;
};
class ListCloudAppInstallationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudAppInstallationsResponseBodyInstallationInfos>> installationInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListCloudAppInstallationsResponseBody() {}

  explicit ListCloudAppInstallationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (installationInfos) {
      vector<boost::any> temp1;
      for(auto item1:*installationInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstallationInfos"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstallationInfos") != m.end() && !m["InstallationInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["InstallationInfos"].type()) {
        vector<ListCloudAppInstallationsResponseBodyInstallationInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstallationInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudAppInstallationsResponseBodyInstallationInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        installationInfos = make_shared<vector<ListCloudAppInstallationsResponseBodyInstallationInfos>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCloudAppInstallationsResponseBody() = default;
};
class ListCloudAppInstallationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCloudAppInstallationsResponseBody> body{};

  ListCloudAppInstallationsResponse() {}

  explicit ListCloudAppInstallationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCloudAppInstallationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCloudAppInstallationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCloudAppInstallationsResponse() = default;
};
class ListCloudAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> appVersion{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListCloudAppsRequest() {}

  explicit ListCloudAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListCloudAppsRequest() = default;
};
class ListCloudAppsResponseBodyCloudApps : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> appVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> status{};
  shared_ptr<string> statusDescription{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> uploadTime{};

  ListCloudAppsResponseBodyCloudApps() {}

  explicit ListCloudAppsResponseBodyCloudApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusDescription) {
      res["StatusDescription"] = boost::any(*statusDescription);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (uploadTime) {
      res["UploadTime"] = boost::any(*uploadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusDescription") != m.end() && !m["StatusDescription"].empty()) {
      statusDescription = make_shared<string>(boost::any_cast<string>(m["StatusDescription"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UploadTime") != m.end() && !m["UploadTime"].empty()) {
      uploadTime = make_shared<string>(boost::any_cast<string>(m["UploadTime"]));
    }
  }


  virtual ~ListCloudAppsResponseBodyCloudApps() = default;
};
class ListCloudAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudAppsResponseBodyCloudApps>> cloudApps{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListCloudAppsResponseBody() {}

  explicit ListCloudAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudApps) {
      vector<boost::any> temp1;
      for(auto item1:*cloudApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CloudApps"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudApps") != m.end() && !m["CloudApps"].empty()) {
      if (typeid(vector<boost::any>) == m["CloudApps"].type()) {
        vector<ListCloudAppsResponseBodyCloudApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CloudApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudAppsResponseBodyCloudApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cloudApps = make_shared<vector<ListCloudAppsResponseBodyCloudApps>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCloudAppsResponseBody() = default;
};
class ListCloudAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCloudAppsResponseBody> body{};

  ListCloudAppsResponse() {}

  explicit ListCloudAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCloudAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCloudAppsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCloudAppsResponse() = default;
};
class ListFilePushStatusesRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> renderingInstanceId{};

  ListFilePushStatusesRequest() {}

  explicit ListFilePushStatusesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~ListFilePushStatusesRequest() = default;
};
class ListFilePushStatusesResponseBodyPushStatuses : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> pushTime{};
  shared_ptr<string> renderingInstanceId{};
  shared_ptr<string> status{};
  shared_ptr<string> statusDescription{};
  shared_ptr<string> updateTime{};

  ListFilePushStatusesResponseBodyPushStatuses() {}

  explicit ListFilePushStatusesResponseBodyPushStatuses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (pushTime) {
      res["PushTime"] = boost::any(*pushTime);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusDescription) {
      res["StatusDescription"] = boost::any(*statusDescription);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("PushTime") != m.end() && !m["PushTime"].empty()) {
      pushTime = make_shared<string>(boost::any_cast<string>(m["PushTime"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusDescription") != m.end() && !m["StatusDescription"].empty()) {
      statusDescription = make_shared<string>(boost::any_cast<string>(m["StatusDescription"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListFilePushStatusesResponseBodyPushStatuses() = default;
};
class ListFilePushStatusesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListFilePushStatusesResponseBodyPushStatuses>> pushStatuses{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListFilePushStatusesResponseBody() {}

  explicit ListFilePushStatusesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pushStatuses) {
      vector<boost::any> temp1;
      for(auto item1:*pushStatuses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PushStatuses"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PushStatuses") != m.end() && !m["PushStatuses"].empty()) {
      if (typeid(vector<boost::any>) == m["PushStatuses"].type()) {
        vector<ListFilePushStatusesResponseBodyPushStatuses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PushStatuses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFilePushStatusesResponseBodyPushStatuses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pushStatuses = make_shared<vector<ListFilePushStatusesResponseBodyPushStatuses>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListFilePushStatusesResponseBody() = default;
};
class ListFilePushStatusesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFilePushStatusesResponseBody> body{};

  ListFilePushStatusesResponse() {}

  explicit ListFilePushStatusesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFilePushStatusesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFilePushStatusesResponseBody>(model1);
      }
    }
  }


  virtual ~ListFilePushStatusesResponse() = default;
};
class ListFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListFilesRequest() {}

  explicit ListFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListFilesRequest() = default;
};
class ListFilesResponseBodyFiles : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> status{};
  shared_ptr<string> statusDescription{};
  shared_ptr<string> targetPath{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> uploadTime{};

  ListFilesResponseBodyFiles() {}

  explicit ListFilesResponseBodyFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusDescription) {
      res["StatusDescription"] = boost::any(*statusDescription);
    }
    if (targetPath) {
      res["TargetPath"] = boost::any(*targetPath);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (uploadTime) {
      res["UploadTime"] = boost::any(*uploadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusDescription") != m.end() && !m["StatusDescription"].empty()) {
      statusDescription = make_shared<string>(boost::any_cast<string>(m["StatusDescription"]));
    }
    if (m.find("TargetPath") != m.end() && !m["TargetPath"].empty()) {
      targetPath = make_shared<string>(boost::any_cast<string>(m["TargetPath"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UploadTime") != m.end() && !m["UploadTime"].empty()) {
      uploadTime = make_shared<string>(boost::any_cast<string>(m["UploadTime"]));
    }
  }


  virtual ~ListFilesResponseBodyFiles() = default;
};
class ListFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListFilesResponseBodyFiles>> files{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListFilesResponseBody() {}

  explicit ListFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<ListFilesResponseBodyFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFilesResponseBodyFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<ListFilesResponseBodyFiles>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListFilesResponseBody() = default;
};
class ListFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFilesResponseBody> body{};

  ListFilesResponse() {}

  explicit ListFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListFilesResponse() = default;
};
class ListPublicKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyGroup{};
  shared_ptr<string> keyName{};
  shared_ptr<string> keyType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListPublicKeysRequest() {}

  explicit ListPublicKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyGroup) {
      res["KeyGroup"] = boost::any(*keyGroup);
    }
    if (keyName) {
      res["KeyName"] = boost::any(*keyName);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyGroup") != m.end() && !m["KeyGroup"].empty()) {
      keyGroup = make_shared<string>(boost::any_cast<string>(m["KeyGroup"]));
    }
    if (m.find("KeyName") != m.end() && !m["KeyName"].empty()) {
      keyName = make_shared<string>(boost::any_cast<string>(m["KeyName"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListPublicKeysRequest() = default;
};
class ListPublicKeysResponseBodyPublicKeys : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> description{};
  shared_ptr<string> keyGroup{};
  shared_ptr<string> keyName{};
  shared_ptr<string> keyType{};
  shared_ptr<string> uploadTime{};

  ListPublicKeysResponseBodyPublicKeys() {}

  explicit ListPublicKeysResponseBodyPublicKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (keyGroup) {
      res["KeyGroup"] = boost::any(*keyGroup);
    }
    if (keyName) {
      res["KeyName"] = boost::any(*keyName);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    if (uploadTime) {
      res["UploadTime"] = boost::any(*uploadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("KeyGroup") != m.end() && !m["KeyGroup"].empty()) {
      keyGroup = make_shared<string>(boost::any_cast<string>(m["KeyGroup"]));
    }
    if (m.find("KeyName") != m.end() && !m["KeyName"].empty()) {
      keyName = make_shared<string>(boost::any_cast<string>(m["KeyName"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
    if (m.find("UploadTime") != m.end() && !m["UploadTime"].empty()) {
      uploadTime = make_shared<string>(boost::any_cast<string>(m["UploadTime"]));
    }
  }


  virtual ~ListPublicKeysResponseBodyPublicKeys() = default;
};
class ListPublicKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListPublicKeysResponseBodyPublicKeys>> publicKeys{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListPublicKeysResponseBody() {}

  explicit ListPublicKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (publicKeys) {
      vector<boost::any> temp1;
      for(auto item1:*publicKeys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublicKeys"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PublicKeys") != m.end() && !m["PublicKeys"].empty()) {
      if (typeid(vector<boost::any>) == m["PublicKeys"].type()) {
        vector<ListPublicKeysResponseBodyPublicKeys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublicKeys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPublicKeysResponseBodyPublicKeys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publicKeys = make_shared<vector<ListPublicKeysResponseBodyPublicKeys>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPublicKeysResponseBody() = default;
};
class ListPublicKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPublicKeysResponseBody> body{};

  ListPublicKeysResponse() {}

  explicit ListPublicKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPublicKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPublicKeysResponseBody>(model1);
      }
    }
  }


  virtual ~ListPublicKeysResponse() = default;
};
class ListRenderingDataPackagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> dataPackageId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> size{};
  shared_ptr<string> status{};

  ListRenderingDataPackagesRequest() {}

  explicit ListRenderingDataPackagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (dataPackageId) {
      res["DataPackageId"] = boost::any(*dataPackageId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DataPackageId") != m.end() && !m["DataPackageId"].empty()) {
      dataPackageId = make_shared<string>(boost::any_cast<string>(m["DataPackageId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListRenderingDataPackagesRequest() = default;
};
class ListRenderingDataPackagesResponseBodyDataPackages : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> dataPackageId{};
  shared_ptr<string> description{};
  shared_ptr<string> renderingInstanceId{};
  shared_ptr<long> size{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};

  ListRenderingDataPackagesResponseBodyDataPackages() {}

  explicit ListRenderingDataPackagesResponseBodyDataPackages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (dataPackageId) {
      res["DataPackageId"] = boost::any(*dataPackageId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DataPackageId") != m.end() && !m["DataPackageId"].empty()) {
      dataPackageId = make_shared<string>(boost::any_cast<string>(m["DataPackageId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListRenderingDataPackagesResponseBodyDataPackages() = default;
};
class ListRenderingDataPackagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListRenderingDataPackagesResponseBodyDataPackages>> dataPackages{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListRenderingDataPackagesResponseBody() {}

  explicit ListRenderingDataPackagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataPackages) {
      vector<boost::any> temp1;
      for(auto item1:*dataPackages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataPackages"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataPackages") != m.end() && !m["DataPackages"].empty()) {
      if (typeid(vector<boost::any>) == m["DataPackages"].type()) {
        vector<ListRenderingDataPackagesResponseBodyDataPackages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataPackages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRenderingDataPackagesResponseBodyDataPackages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataPackages = make_shared<vector<ListRenderingDataPackagesResponseBodyDataPackages>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRenderingDataPackagesResponseBody() = default;
};
class ListRenderingDataPackagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRenderingDataPackagesResponseBody> body{};

  ListRenderingDataPackagesResponse() {}

  explicit ListRenderingDataPackagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRenderingDataPackagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRenderingDataPackagesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRenderingDataPackagesResponse() = default;
};
class ListRenderingInstanceGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> gatewayInstanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> renderingInstanceId{};

  ListRenderingInstanceGatewayRequest() {}

  explicit ListRenderingInstanceGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayInstanceId) {
      res["GatewayInstanceId"] = boost::any(*gatewayInstanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayInstanceId") != m.end() && !m["GatewayInstanceId"].empty()) {
      gatewayInstanceId = make_shared<string>(boost::any_cast<string>(m["GatewayInstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~ListRenderingInstanceGatewayRequest() = default;
};
class ListRenderingInstanceGatewayResponseBodyGatewayConfigurationInfos : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> gatewayInstanceId{};
  shared_ptr<string> renderingInstanceId{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};

  ListRenderingInstanceGatewayResponseBodyGatewayConfigurationInfos() {}

  explicit ListRenderingInstanceGatewayResponseBodyGatewayConfigurationInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (gatewayInstanceId) {
      res["GatewayInstanceId"] = boost::any(*gatewayInstanceId);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("GatewayInstanceId") != m.end() && !m["GatewayInstanceId"].empty()) {
      gatewayInstanceId = make_shared<string>(boost::any_cast<string>(m["GatewayInstanceId"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListRenderingInstanceGatewayResponseBodyGatewayConfigurationInfos() = default;
};
class ListRenderingInstanceGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListRenderingInstanceGatewayResponseBodyGatewayConfigurationInfos>> gatewayConfigurationInfos{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  ListRenderingInstanceGatewayResponseBody() {}

  explicit ListRenderingInstanceGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayConfigurationInfos) {
      vector<boost::any> temp1;
      for(auto item1:*gatewayConfigurationInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GatewayConfigurationInfos"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayConfigurationInfos") != m.end() && !m["GatewayConfigurationInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["GatewayConfigurationInfos"].type()) {
        vector<ListRenderingInstanceGatewayResponseBodyGatewayConfigurationInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GatewayConfigurationInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRenderingInstanceGatewayResponseBodyGatewayConfigurationInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        gatewayConfigurationInfos = make_shared<vector<ListRenderingInstanceGatewayResponseBodyGatewayConfigurationInfos>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListRenderingInstanceGatewayResponseBody() = default;
};
class ListRenderingInstanceGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRenderingInstanceGatewayResponseBody> body{};

  ListRenderingInstanceGatewayResponse() {}

  explicit ListRenderingInstanceGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRenderingInstanceGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRenderingInstanceGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~ListRenderingInstanceGatewayResponse() = default;
};
class ListRenderingInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> renderingInstanceId{};
  shared_ptr<string> renderingSpec{};
  shared_ptr<long> storageSize{};

  ListRenderingInstancesRequest() {}

  explicit ListRenderingInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    if (renderingSpec) {
      res["RenderingSpec"] = boost::any(*renderingSpec);
    }
    if (storageSize) {
      res["StorageSize"] = boost::any(*storageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
    if (m.find("RenderingSpec") != m.end() && !m["RenderingSpec"].empty()) {
      renderingSpec = make_shared<string>(boost::any_cast<string>(m["RenderingSpec"]));
    }
    if (m.find("StorageSize") != m.end() && !m["StorageSize"].empty()) {
      storageSize = make_shared<long>(boost::any_cast<long>(m["StorageSize"]));
    }
  }


  virtual ~ListRenderingInstancesRequest() = default;
};
class ListRenderingInstancesResponseBodyRenderingInstances : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> renderingInstanceId{};
  shared_ptr<string> renderingSpec{};
  shared_ptr<long> storageSize{};

  ListRenderingInstancesResponseBodyRenderingInstances() {}

  explicit ListRenderingInstancesResponseBodyRenderingInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    if (renderingSpec) {
      res["RenderingSpec"] = boost::any(*renderingSpec);
    }
    if (storageSize) {
      res["StorageSize"] = boost::any(*storageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
    if (m.find("RenderingSpec") != m.end() && !m["RenderingSpec"].empty()) {
      renderingSpec = make_shared<string>(boost::any_cast<string>(m["RenderingSpec"]));
    }
    if (m.find("StorageSize") != m.end() && !m["StorageSize"].empty()) {
      storageSize = make_shared<long>(boost::any_cast<long>(m["StorageSize"]));
    }
  }


  virtual ~ListRenderingInstancesResponseBodyRenderingInstances() = default;
};
class ListRenderingInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListRenderingInstancesResponseBodyRenderingInstances>> renderingInstances{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListRenderingInstancesResponseBody() {}

  explicit ListRenderingInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderingInstances) {
      vector<boost::any> temp1;
      for(auto item1:*renderingInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RenderingInstances"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderingInstances") != m.end() && !m["RenderingInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["RenderingInstances"].type()) {
        vector<ListRenderingInstancesResponseBodyRenderingInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RenderingInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRenderingInstancesResponseBodyRenderingInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        renderingInstances = make_shared<vector<ListRenderingInstancesResponseBodyRenderingInstances>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRenderingInstancesResponseBody() = default;
};
class ListRenderingInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRenderingInstancesResponseBody> body{};

  ListRenderingInstancesResponse() {}

  explicit ListRenderingInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRenderingInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRenderingInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRenderingInstancesResponse() = default;
};
class ManageLoginRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionName{};
  shared_ptr<string> keyGroup{};
  shared_ptr<string> keyName{};
  shared_ptr<string> renderingInstanceId{};

  ManageLoginRequest() {}

  explicit ManageLoginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionName) {
      res["ActionName"] = boost::any(*actionName);
    }
    if (keyGroup) {
      res["KeyGroup"] = boost::any(*keyGroup);
    }
    if (keyName) {
      res["KeyName"] = boost::any(*keyName);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionName") != m.end() && !m["ActionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["ActionName"]));
    }
    if (m.find("KeyGroup") != m.end() && !m["KeyGroup"].empty()) {
      keyGroup = make_shared<string>(boost::any_cast<string>(m["KeyGroup"]));
    }
    if (m.find("KeyName") != m.end() && !m["KeyName"].empty()) {
      keyName = make_shared<string>(boost::any_cast<string>(m["KeyName"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~ManageLoginRequest() = default;
};
class ManageLoginResponseBodyLoginInfo : public Darabonba::Model {
public:
  shared_ptr<long> adbLoginPort{};
  shared_ptr<string> loginHostname{};
  shared_ptr<long> loginPort{};

  ManageLoginResponseBodyLoginInfo() {}

  explicit ManageLoginResponseBodyLoginInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbLoginPort) {
      res["AdbLoginPort"] = boost::any(*adbLoginPort);
    }
    if (loginHostname) {
      res["LoginHostname"] = boost::any(*loginHostname);
    }
    if (loginPort) {
      res["LoginPort"] = boost::any(*loginPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbLoginPort") != m.end() && !m["AdbLoginPort"].empty()) {
      adbLoginPort = make_shared<long>(boost::any_cast<long>(m["AdbLoginPort"]));
    }
    if (m.find("LoginHostname") != m.end() && !m["LoginHostname"].empty()) {
      loginHostname = make_shared<string>(boost::any_cast<string>(m["LoginHostname"]));
    }
    if (m.find("LoginPort") != m.end() && !m["LoginPort"].empty()) {
      loginPort = make_shared<long>(boost::any_cast<long>(m["LoginPort"]));
    }
  }


  virtual ~ManageLoginResponseBodyLoginInfo() = default;
};
class ManageLoginResponseBody : public Darabonba::Model {
public:
  shared_ptr<ManageLoginResponseBodyLoginInfo> loginInfo{};
  shared_ptr<string> requestId{};

  ManageLoginResponseBody() {}

  explicit ManageLoginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loginInfo) {
      res["LoginInfo"] = loginInfo ? boost::any(loginInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoginInfo") != m.end() && !m["LoginInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["LoginInfo"].type()) {
        ManageLoginResponseBodyLoginInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LoginInfo"]));
        loginInfo = make_shared<ManageLoginResponseBodyLoginInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ManageLoginResponseBody() = default;
};
class ManageLoginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ManageLoginResponseBody> body{};

  ManageLoginResponse() {}

  explicit ManageLoginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ManageLoginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ManageLoginResponseBody>(model1);
      }
    }
  }


  virtual ~ManageLoginResponse() = default;
};
class ModifyDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> alarmMethod{};
  shared_ptr<bool> autoDirectory{};
  shared_ptr<bool> autoPos{};
  shared_ptr<bool> autoStart{};
  shared_ptr<string> description{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> gbId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<string> ip{};
  shared_ptr<string> latitude{};
  shared_ptr<string> longitude{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> params{};
  shared_ptr<string> parentId{};
  shared_ptr<string> password{};
  shared_ptr<long> port{};
  shared_ptr<long> posInterval{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> username{};
  shared_ptr<string> vendor{};

  ModifyDeviceRequest() {}

  explicit ModifyDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmMethod) {
      res["AlarmMethod"] = boost::any(*alarmMethod);
    }
    if (autoDirectory) {
      res["AutoDirectory"] = boost::any(*autoDirectory);
    }
    if (autoPos) {
      res["AutoPos"] = boost::any(*autoPos);
    }
    if (autoStart) {
      res["AutoStart"] = boost::any(*autoStart);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (latitude) {
      res["Latitude"] = boost::any(*latitude);
    }
    if (longitude) {
      res["Longitude"] = boost::any(*longitude);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (posInterval) {
      res["PosInterval"] = boost::any(*posInterval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmMethod") != m.end() && !m["AlarmMethod"].empty()) {
      alarmMethod = make_shared<string>(boost::any_cast<string>(m["AlarmMethod"]));
    }
    if (m.find("AutoDirectory") != m.end() && !m["AutoDirectory"].empty()) {
      autoDirectory = make_shared<bool>(boost::any_cast<bool>(m["AutoDirectory"]));
    }
    if (m.find("AutoPos") != m.end() && !m["AutoPos"].empty()) {
      autoPos = make_shared<bool>(boost::any_cast<bool>(m["AutoPos"]));
    }
    if (m.find("AutoStart") != m.end() && !m["AutoStart"].empty()) {
      autoStart = make_shared<bool>(boost::any_cast<bool>(m["AutoStart"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Latitude") != m.end() && !m["Latitude"].empty()) {
      latitude = make_shared<string>(boost::any_cast<string>(m["Latitude"]));
    }
    if (m.find("Longitude") != m.end() && !m["Longitude"].empty()) {
      longitude = make_shared<string>(boost::any_cast<string>(m["Longitude"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("PosInterval") != m.end() && !m["PosInterval"].empty()) {
      posInterval = make_shared<long>(boost::any_cast<long>(m["PosInterval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
  }


  virtual ~ModifyDeviceRequest() = default;
};
class ModifyDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  ModifyDeviceResponseBody() {}

  explicit ModifyDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDeviceResponseBody() = default;
};
class ModifyDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDeviceResponseBody> body{};

  ModifyDeviceResponse() {}

  explicit ModifyDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDeviceResponse() = default;
};
class ModifyDeviceAlarmRequest : public Darabonba::Model {
public:
  shared_ptr<string> alarmId{};
  shared_ptr<long> channelId{};
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> status{};

  ModifyDeviceAlarmRequest() {}

  explicit ModifyDeviceAlarmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmId) {
      res["AlarmId"] = boost::any(*alarmId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmId") != m.end() && !m["AlarmId"].empty()) {
      alarmId = make_shared<string>(boost::any_cast<string>(m["AlarmId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<long>(boost::any_cast<long>(m["ChannelId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ModifyDeviceAlarmRequest() = default;
};
class ModifyDeviceAlarmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDeviceAlarmResponseBody() {}

  explicit ModifyDeviceAlarmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDeviceAlarmResponseBody() = default;
};
class ModifyDeviceAlarmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDeviceAlarmResponseBody> body{};

  ModifyDeviceAlarmResponse() {}

  explicit ModifyDeviceAlarmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDeviceAlarmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDeviceAlarmResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDeviceAlarmResponse() = default;
};
class ModifyDeviceCaptureRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> image{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> video{};

  ModifyDeviceCaptureRequest() {}

  explicit ModifyDeviceCaptureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (video) {
      res["Video"] = boost::any(*video);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<long>(boost::any_cast<long>(m["Image"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      video = make_shared<long>(boost::any_cast<long>(m["Video"]));
    }
  }


  virtual ~ModifyDeviceCaptureRequest() = default;
};
class ModifyDeviceCaptureResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDeviceCaptureResponseBody() {}

  explicit ModifyDeviceCaptureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDeviceCaptureResponseBody() = default;
};
class ModifyDeviceCaptureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDeviceCaptureResponseBody> body{};

  ModifyDeviceCaptureResponse() {}

  explicit ModifyDeviceCaptureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDeviceCaptureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDeviceCaptureResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDeviceCaptureResponse() = default;
};
class ModifyDeviceChannelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> channels{};
  shared_ptr<string> deviceStatus{};
  shared_ptr<string> dsn{};
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  ModifyDeviceChannelsRequest() {}

  explicit ModifyDeviceChannelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (deviceStatus) {
      res["DeviceStatus"] = boost::any(*deviceStatus);
    }
    if (dsn) {
      res["Dsn"] = boost::any(*dsn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("DeviceStatus") != m.end() && !m["DeviceStatus"].empty()) {
      deviceStatus = make_shared<string>(boost::any_cast<string>(m["DeviceStatus"]));
    }
    if (m.find("Dsn") != m.end() && !m["Dsn"].empty()) {
      dsn = make_shared<string>(boost::any_cast<string>(m["Dsn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~ModifyDeviceChannelsRequest() = default;
};
class ModifyDeviceChannelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDeviceChannelsResponseBody() {}

  explicit ModifyDeviceChannelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDeviceChannelsResponseBody() = default;
};
class ModifyDeviceChannelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDeviceChannelsResponseBody> body{};

  ModifyDeviceChannelsResponse() {}

  explicit ModifyDeviceChannelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDeviceChannelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDeviceChannelsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDeviceChannelsResponse() = default;
};
class ModifyDirectoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};

  ModifyDirectoryRequest() {}

  explicit ModifyDirectoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~ModifyDirectoryRequest() = default;
};
class ModifyDirectoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  ModifyDirectoryResponseBody() {}

  explicit ModifyDirectoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDirectoryResponseBody() = default;
};
class ModifyDirectoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDirectoryResponseBody> body{};

  ModifyDirectoryResponse() {}

  explicit ModifyDirectoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDirectoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDirectoryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDirectoryResponse() = default;
};
class ModifyGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> callback{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> id{};
  shared_ptr<string> inProtocol{};
  shared_ptr<bool> lazyPull{};
  shared_ptr<string> name{};
  shared_ptr<string> outProtocol{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> playDomain{};
  shared_ptr<string> pushDomain{};
  shared_ptr<string> region{};

  ModifyGroupRequest() {}

  explicit ModifyGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inProtocol) {
      res["InProtocol"] = boost::any(*inProtocol);
    }
    if (lazyPull) {
      res["LazyPull"] = boost::any(*lazyPull);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outProtocol) {
      res["OutProtocol"] = boost::any(*outProtocol);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (playDomain) {
      res["PlayDomain"] = boost::any(*playDomain);
    }
    if (pushDomain) {
      res["PushDomain"] = boost::any(*pushDomain);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InProtocol") != m.end() && !m["InProtocol"].empty()) {
      inProtocol = make_shared<string>(boost::any_cast<string>(m["InProtocol"]));
    }
    if (m.find("LazyPull") != m.end() && !m["LazyPull"].empty()) {
      lazyPull = make_shared<bool>(boost::any_cast<bool>(m["LazyPull"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutProtocol") != m.end() && !m["OutProtocol"].empty()) {
      outProtocol = make_shared<string>(boost::any_cast<string>(m["OutProtocol"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PlayDomain") != m.end() && !m["PlayDomain"].empty()) {
      playDomain = make_shared<string>(boost::any_cast<string>(m["PlayDomain"]));
    }
    if (m.find("PushDomain") != m.end() && !m["PushDomain"].empty()) {
      pushDomain = make_shared<string>(boost::any_cast<string>(m["PushDomain"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~ModifyGroupRequest() = default;
};
class ModifyGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  ModifyGroupResponseBody() {}

  explicit ModifyGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyGroupResponseBody() = default;
};
class ModifyGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyGroupResponseBody> body{};

  ModifyGroupResponse() {}

  explicit ModifyGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyGroupResponse() = default;
};
class ModifyParentPlatformRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoStart{};
  shared_ptr<bool> clientAuth{};
  shared_ptr<string> clientPassword{};
  shared_ptr<string> clientUsername{};
  shared_ptr<string> description{};
  shared_ptr<string> gbId{};
  shared_ptr<string> id{};
  shared_ptr<string> ip{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> port{};

  ModifyParentPlatformRequest() {}

  explicit ModifyParentPlatformRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoStart) {
      res["AutoStart"] = boost::any(*autoStart);
    }
    if (clientAuth) {
      res["ClientAuth"] = boost::any(*clientAuth);
    }
    if (clientPassword) {
      res["ClientPassword"] = boost::any(*clientPassword);
    }
    if (clientUsername) {
      res["ClientUsername"] = boost::any(*clientUsername);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gbId) {
      res["GbId"] = boost::any(*gbId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoStart") != m.end() && !m["AutoStart"].empty()) {
      autoStart = make_shared<bool>(boost::any_cast<bool>(m["AutoStart"]));
    }
    if (m.find("ClientAuth") != m.end() && !m["ClientAuth"].empty()) {
      clientAuth = make_shared<bool>(boost::any_cast<bool>(m["ClientAuth"]));
    }
    if (m.find("ClientPassword") != m.end() && !m["ClientPassword"].empty()) {
      clientPassword = make_shared<string>(boost::any_cast<string>(m["ClientPassword"]));
    }
    if (m.find("ClientUsername") != m.end() && !m["ClientUsername"].empty()) {
      clientUsername = make_shared<string>(boost::any_cast<string>(m["ClientUsername"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GbId") != m.end() && !m["GbId"].empty()) {
      gbId = make_shared<string>(boost::any_cast<string>(m["GbId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~ModifyParentPlatformRequest() = default;
};
class ModifyParentPlatformResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  ModifyParentPlatformResponseBody() {}

  explicit ModifyParentPlatformResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyParentPlatformResponseBody() = default;
};
class ModifyParentPlatformResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyParentPlatformResponseBody> body{};

  ModifyParentPlatformResponse() {}

  explicit ModifyParentPlatformResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyParentPlatformResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyParentPlatformResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyParentPlatformResponse() = default;
};
class ModifyRenderingInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> renderingInstanceId{};
  shared_ptr<string> renderingSpec{};
  shared_ptr<string> storageSize{};

  ModifyRenderingInstanceRequest() {}

  explicit ModifyRenderingInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    if (renderingSpec) {
      res["RenderingSpec"] = boost::any(*renderingSpec);
    }
    if (storageSize) {
      res["StorageSize"] = boost::any(*storageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
    if (m.find("RenderingSpec") != m.end() && !m["RenderingSpec"].empty()) {
      renderingSpec = make_shared<string>(boost::any_cast<string>(m["RenderingSpec"]));
    }
    if (m.find("StorageSize") != m.end() && !m["StorageSize"].empty()) {
      storageSize = make_shared<string>(boost::any_cast<string>(m["StorageSize"]));
    }
  }


  virtual ~ModifyRenderingInstanceRequest() = default;
};
class ModifyRenderingInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyRenderingInstanceResponseBody() {}

  explicit ModifyRenderingInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRenderingInstanceResponseBody() = default;
};
class ModifyRenderingInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyRenderingInstanceResponseBody> body{};

  ModifyRenderingInstanceResponse() {}

  explicit ModifyRenderingInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRenderingInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRenderingInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRenderingInstanceResponse() = default;
};
class ModifyRenderingInstanceBandwidthRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxEgressBandwidth{};
  shared_ptr<long> maxIngressBandwidth{};
  shared_ptr<string> renderingInstanceId{};

  ModifyRenderingInstanceBandwidthRequest() {}

  explicit ModifyRenderingInstanceBandwidthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxEgressBandwidth) {
      res["MaxEgressBandwidth"] = boost::any(*maxEgressBandwidth);
    }
    if (maxIngressBandwidth) {
      res["MaxIngressBandwidth"] = boost::any(*maxIngressBandwidth);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxEgressBandwidth") != m.end() && !m["MaxEgressBandwidth"].empty()) {
      maxEgressBandwidth = make_shared<long>(boost::any_cast<long>(m["MaxEgressBandwidth"]));
    }
    if (m.find("MaxIngressBandwidth") != m.end() && !m["MaxIngressBandwidth"].empty()) {
      maxIngressBandwidth = make_shared<long>(boost::any_cast<long>(m["MaxIngressBandwidth"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~ModifyRenderingInstanceBandwidthRequest() = default;
};
class ModifyRenderingInstanceBandwidthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyRenderingInstanceBandwidthResponseBody() {}

  explicit ModifyRenderingInstanceBandwidthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRenderingInstanceBandwidthResponseBody() = default;
};
class ModifyRenderingInstanceBandwidthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyRenderingInstanceBandwidthResponseBody> body{};

  ModifyRenderingInstanceBandwidthResponse() {}

  explicit ModifyRenderingInstanceBandwidthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRenderingInstanceBandwidthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRenderingInstanceBandwidthResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRenderingInstanceBandwidthResponse() = default;
};
class ModifyTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> callback{};
  shared_ptr<string> description{};
  shared_ptr<string> fileFormat{};
  shared_ptr<string> flv{};
  shared_ptr<string> hlsM3u8{};
  shared_ptr<string> hlsTs{};
  shared_ptr<string> id{};
  shared_ptr<long> interval{};
  shared_ptr<string> jpgOnDemand{};
  shared_ptr<string> jpgOverwrite{};
  shared_ptr<string> jpgSequence{};
  shared_ptr<string> mp4{};
  shared_ptr<string> name{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossFilePrefix{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<long> retention{};
  shared_ptr<string> transConfigsJSON{};
  shared_ptr<string> trigger{};

  ModifyTemplateRequest() {}

  explicit ModifyTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callback) {
      res["Callback"] = boost::any(*callback);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileFormat) {
      res["FileFormat"] = boost::any(*fileFormat);
    }
    if (flv) {
      res["Flv"] = boost::any(*flv);
    }
    if (hlsM3u8) {
      res["HlsM3u8"] = boost::any(*hlsM3u8);
    }
    if (hlsTs) {
      res["HlsTs"] = boost::any(*hlsTs);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (jpgOnDemand) {
      res["JpgOnDemand"] = boost::any(*jpgOnDemand);
    }
    if (jpgOverwrite) {
      res["JpgOverwrite"] = boost::any(*jpgOverwrite);
    }
    if (jpgSequence) {
      res["JpgSequence"] = boost::any(*jpgSequence);
    }
    if (mp4) {
      res["Mp4"] = boost::any(*mp4);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossFilePrefix) {
      res["OssFilePrefix"] = boost::any(*ossFilePrefix);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (transConfigsJSON) {
      res["TransConfigsJSON"] = boost::any(*transConfigsJSON);
    }
    if (trigger) {
      res["Trigger"] = boost::any(*trigger);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callback") != m.end() && !m["Callback"].empty()) {
      callback = make_shared<string>(boost::any_cast<string>(m["Callback"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileFormat") != m.end() && !m["FileFormat"].empty()) {
      fileFormat = make_shared<string>(boost::any_cast<string>(m["FileFormat"]));
    }
    if (m.find("Flv") != m.end() && !m["Flv"].empty()) {
      flv = make_shared<string>(boost::any_cast<string>(m["Flv"]));
    }
    if (m.find("HlsM3u8") != m.end() && !m["HlsM3u8"].empty()) {
      hlsM3u8 = make_shared<string>(boost::any_cast<string>(m["HlsM3u8"]));
    }
    if (m.find("HlsTs") != m.end() && !m["HlsTs"].empty()) {
      hlsTs = make_shared<string>(boost::any_cast<string>(m["HlsTs"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("JpgOnDemand") != m.end() && !m["JpgOnDemand"].empty()) {
      jpgOnDemand = make_shared<string>(boost::any_cast<string>(m["JpgOnDemand"]));
    }
    if (m.find("JpgOverwrite") != m.end() && !m["JpgOverwrite"].empty()) {
      jpgOverwrite = make_shared<string>(boost::any_cast<string>(m["JpgOverwrite"]));
    }
    if (m.find("JpgSequence") != m.end() && !m["JpgSequence"].empty()) {
      jpgSequence = make_shared<string>(boost::any_cast<string>(m["JpgSequence"]));
    }
    if (m.find("Mp4") != m.end() && !m["Mp4"].empty()) {
      mp4 = make_shared<string>(boost::any_cast<string>(m["Mp4"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssFilePrefix") != m.end() && !m["OssFilePrefix"].empty()) {
      ossFilePrefix = make_shared<string>(boost::any_cast<string>(m["OssFilePrefix"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("TransConfigsJSON") != m.end() && !m["TransConfigsJSON"].empty()) {
      transConfigsJSON = make_shared<string>(boost::any_cast<string>(m["TransConfigsJSON"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      trigger = make_shared<string>(boost::any_cast<string>(m["Trigger"]));
    }
  }


  virtual ~ModifyTemplateRequest() = default;
};
class ModifyTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  ModifyTemplateResponseBody() {}

  explicit ModifyTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyTemplateResponseBody() = default;
};
class ModifyTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTemplateResponseBody> body{};

  ModifyTemplateResponse() {}

  explicit ModifyTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTemplateResponse() = default;
};
class OpenVsServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  OpenVsServiceResponseBody() {}

  explicit OpenVsServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenVsServiceResponseBody() = default;
};
class OpenVsServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenVsServiceResponseBody> body{};

  OpenVsServiceResponse() {}

  explicit OpenVsServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenVsServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenVsServiceResponseBody>(model1);
      }
    }
  }


  virtual ~OpenVsServiceResponse() = default;
};
class PushFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> renderingInstanceId{};

  PushFileRequest() {}

  explicit PushFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~PushFileRequest() = default;
};
class PushFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PushFileResponseBody() {}

  explicit PushFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PushFileResponseBody() = default;
};
class PushFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PushFileResponseBody> body{};

  PushFileResponse() {}

  explicit PushFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushFileResponseBody>(model1);
      }
    }
  }


  virtual ~PushFileResponse() = default;
};
class RebootRenderingInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> renderingInstanceId{};

  RebootRenderingInstanceRequest() {}

  explicit RebootRenderingInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~RebootRenderingInstanceRequest() = default;
};
class RebootRenderingInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RebootRenderingInstanceResponseBody() {}

  explicit RebootRenderingInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RebootRenderingInstanceResponseBody() = default;
};
class RebootRenderingInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RebootRenderingInstanceResponseBody> body{};

  RebootRenderingInstanceResponse() {}

  explicit RebootRenderingInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebootRenderingInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebootRenderingInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RebootRenderingInstanceResponse() = default;
};
class RecoverRenderingDataPackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataPackageId{};
  shared_ptr<string> renderingInstanceId{};

  RecoverRenderingDataPackageRequest() {}

  explicit RecoverRenderingDataPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataPackageId) {
      res["DataPackageId"] = boost::any(*dataPackageId);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataPackageId") != m.end() && !m["DataPackageId"].empty()) {
      dataPackageId = make_shared<string>(boost::any_cast<string>(m["DataPackageId"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~RecoverRenderingDataPackageRequest() = default;
};
class RecoverRenderingDataPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RecoverRenderingDataPackageResponseBody() {}

  explicit RecoverRenderingDataPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RecoverRenderingDataPackageResponseBody() = default;
};
class RecoverRenderingDataPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecoverRenderingDataPackageResponseBody> body{};

  RecoverRenderingDataPackageResponse() {}

  explicit RecoverRenderingDataPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecoverRenderingDataPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecoverRenderingDataPackageResponseBody>(model1);
      }
    }
  }


  virtual ~RecoverRenderingDataPackageResponse() = default;
};
class RefreshRenderingInstanceStreamingRequestClientInfo : public Darabonba::Model {
public:
  shared_ptr<string> clientIp{};
  shared_ptr<bool> newClient{};

  RefreshRenderingInstanceStreamingRequestClientInfo() {}

  explicit RefreshRenderingInstanceStreamingRequestClientInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (newClient) {
      res["NewClient"] = boost::any(*newClient);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("NewClient") != m.end() && !m["NewClient"].empty()) {
      newClient = make_shared<bool>(boost::any_cast<bool>(m["NewClient"]));
    }
  }


  virtual ~RefreshRenderingInstanceStreamingRequestClientInfo() = default;
};
class RefreshRenderingInstanceStreamingRequest : public Darabonba::Model {
public:
  shared_ptr<RefreshRenderingInstanceStreamingRequestClientInfo> clientInfo{};
  shared_ptr<string> renderingInstanceId{};

  RefreshRenderingInstanceStreamingRequest() {}

  explicit RefreshRenderingInstanceStreamingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientInfo) {
      res["ClientInfo"] = clientInfo ? boost::any(clientInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientInfo") != m.end() && !m["ClientInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClientInfo"].type()) {
        RefreshRenderingInstanceStreamingRequestClientInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClientInfo"]));
        clientInfo = make_shared<RefreshRenderingInstanceStreamingRequestClientInfo>(model1);
      }
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~RefreshRenderingInstanceStreamingRequest() = default;
};
class RefreshRenderingInstanceStreamingShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientInfoShrink{};
  shared_ptr<string> renderingInstanceId{};

  RefreshRenderingInstanceStreamingShrinkRequest() {}

  explicit RefreshRenderingInstanceStreamingShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientInfoShrink) {
      res["ClientInfo"] = boost::any(*clientInfoShrink);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientInfo") != m.end() && !m["ClientInfo"].empty()) {
      clientInfoShrink = make_shared<string>(boost::any_cast<string>(m["ClientInfo"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~RefreshRenderingInstanceStreamingShrinkRequest() = default;
};
class RefreshRenderingInstanceStreamingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};
  shared_ptr<string> gateway{};
  shared_ptr<string> hostname{};
  shared_ptr<string> port{};
  shared_ptr<string> renderingInstanceId{};
  shared_ptr<string> requestId{};

  RefreshRenderingInstanceStreamingResponseBody() {}

  explicit RefreshRenderingInstanceStreamingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (hostname) {
      res["Hostname"] = boost::any(*hostname);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("Hostname") != m.end() && !m["Hostname"].empty()) {
      hostname = make_shared<string>(boost::any_cast<string>(m["Hostname"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefreshRenderingInstanceStreamingResponseBody() = default;
};
class RefreshRenderingInstanceStreamingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshRenderingInstanceStreamingResponseBody> body{};

  RefreshRenderingInstanceStreamingResponse() {}

  explicit RefreshRenderingInstanceStreamingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshRenderingInstanceStreamingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshRenderingInstanceStreamingResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshRenderingInstanceStreamingResponse() = default;
};
class ReleaseRenderingDataPackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataPackageId{};

  ReleaseRenderingDataPackageRequest() {}

  explicit ReleaseRenderingDataPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataPackageId) {
      res["DataPackageId"] = boost::any(*dataPackageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataPackageId") != m.end() && !m["DataPackageId"].empty()) {
      dataPackageId = make_shared<string>(boost::any_cast<string>(m["DataPackageId"]));
    }
  }


  virtual ~ReleaseRenderingDataPackageRequest() = default;
};
class ReleaseRenderingDataPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseRenderingDataPackageResponseBody() {}

  explicit ReleaseRenderingDataPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseRenderingDataPackageResponseBody() = default;
};
class ReleaseRenderingDataPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseRenderingDataPackageResponseBody> body{};

  ReleaseRenderingDataPackageResponse() {}

  explicit ReleaseRenderingDataPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseRenderingDataPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseRenderingDataPackageResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseRenderingDataPackageResponse() = default;
};
class ReleaseRenderingInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> renderingInstanceId{};

  ReleaseRenderingInstanceRequest() {}

  explicit ReleaseRenderingInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~ReleaseRenderingInstanceRequest() = default;
};
class ReleaseRenderingInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseRenderingInstanceResponseBody() {}

  explicit ReleaseRenderingInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseRenderingInstanceResponseBody() = default;
};
class ReleaseRenderingInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseRenderingInstanceResponseBody> body{};

  ReleaseRenderingInstanceResponse() {}

  explicit ReleaseRenderingInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseRenderingInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseRenderingInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseRenderingInstanceResponse() = default;
};
class RenewRenderingInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> period{};
  shared_ptr<string> renderingInstanceId{};

  RenewRenderingInstanceRequest() {}

  explicit RenewRenderingInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~RenewRenderingInstanceRequest() = default;
};
class RenewRenderingInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RenewRenderingInstanceResponseBody() {}

  explicit RenewRenderingInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RenewRenderingInstanceResponseBody() = default;
};
class RenewRenderingInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenewRenderingInstanceResponseBody> body{};

  RenewRenderingInstanceResponse() {}

  explicit RenewRenderingInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewRenderingInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewRenderingInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RenewRenderingInstanceResponse() = default;
};
class ResetRenderingInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionName{};
  shared_ptr<string> dataPackageId{};
  shared_ptr<string> renderingInstanceId{};

  ResetRenderingInstanceRequest() {}

  explicit ResetRenderingInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionName) {
      res["ActionName"] = boost::any(*actionName);
    }
    if (dataPackageId) {
      res["DataPackageId"] = boost::any(*dataPackageId);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionName") != m.end() && !m["ActionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["ActionName"]));
    }
    if (m.find("DataPackageId") != m.end() && !m["DataPackageId"].empty()) {
      dataPackageId = make_shared<string>(boost::any_cast<string>(m["DataPackageId"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~ResetRenderingInstanceRequest() = default;
};
class ResetRenderingInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetRenderingInstanceResponseBody() {}

  explicit ResetRenderingInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetRenderingInstanceResponseBody() = default;
};
class ResetRenderingInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetRenderingInstanceResponseBody> body{};

  ResetRenderingInstanceResponse() {}

  explicit ResetRenderingInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetRenderingInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetRenderingInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ResetRenderingInstanceResponse() = default;
};
class ResumeVsStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> controlStreamAction{};
  shared_ptr<string> domainName{};
  shared_ptr<string> liveStreamType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> streamName{};

  ResumeVsStreamRequest() {}

  explicit ResumeVsStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (controlStreamAction) {
      res["ControlStreamAction"] = boost::any(*controlStreamAction);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (liveStreamType) {
      res["LiveStreamType"] = boost::any(*liveStreamType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ControlStreamAction") != m.end() && !m["ControlStreamAction"].empty()) {
      controlStreamAction = make_shared<string>(boost::any_cast<string>(m["ControlStreamAction"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LiveStreamType") != m.end() && !m["LiveStreamType"].empty()) {
      liveStreamType = make_shared<string>(boost::any_cast<string>(m["LiveStreamType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~ResumeVsStreamRequest() = default;
};
class ResumeVsStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResumeVsStreamResponseBody() {}

  explicit ResumeVsStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResumeVsStreamResponseBody() = default;
};
class ResumeVsStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeVsStreamResponseBody> body{};

  ResumeVsStreamResponse() {}

  explicit ResumeVsStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeVsStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeVsStreamResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeVsStreamResponse() = default;
};
class SendRenderingInstanceCommandsRequest : public Darabonba::Model {
public:
  shared_ptr<string> commands{};
  shared_ptr<string> renderingInstanceId{};

  SendRenderingInstanceCommandsRequest() {}

  explicit SendRenderingInstanceCommandsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commands) {
      res["Commands"] = boost::any(*commands);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Commands") != m.end() && !m["Commands"].empty()) {
      commands = make_shared<string>(boost::any_cast<string>(m["Commands"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~SendRenderingInstanceCommandsRequest() = default;
};
class SendRenderingInstanceCommandsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  SendRenderingInstanceCommandsResponseBody() {}

  explicit SendRenderingInstanceCommandsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~SendRenderingInstanceCommandsResponseBody() = default;
};
class SendRenderingInstanceCommandsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendRenderingInstanceCommandsResponseBody> body{};

  SendRenderingInstanceCommandsResponse() {}

  explicit SendRenderingInstanceCommandsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendRenderingInstanceCommandsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendRenderingInstanceCommandsResponseBody>(model1);
      }
    }
  }


  virtual ~SendRenderingInstanceCommandsResponse() = default;
};
class SetPresetRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> presetId{};

  SetPresetRequest() {}

  explicit SetPresetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (presetId) {
      res["PresetId"] = boost::any(*presetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PresetId") != m.end() && !m["PresetId"].empty()) {
      presetId = make_shared<string>(boost::any_cast<string>(m["PresetId"]));
    }
  }


  virtual ~SetPresetRequest() = default;
};
class SetPresetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  SetPresetResponseBody() {}

  explicit SetPresetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetPresetResponseBody() = default;
};
class SetPresetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetPresetResponseBody> body{};

  SetPresetResponse() {}

  explicit SetPresetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetPresetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetPresetResponseBody>(model1);
      }
    }
  }


  virtual ~SetPresetResponse() = default;
};
class SetVsDomainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> forceSet{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> SSLPri{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};

  SetVsDomainCertificateRequest() {}

  explicit SetVsDomainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (forceSet) {
      res["ForceSet"] = boost::any(*forceSet);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (SSLPri) {
      res["SSLPri"] = boost::any(*SSLPri);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ForceSet") != m.end() && !m["ForceSet"].empty()) {
      forceSet = make_shared<string>(boost::any_cast<string>(m["ForceSet"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SSLPri") != m.end() && !m["SSLPri"].empty()) {
      SSLPri = make_shared<string>(boost::any_cast<string>(m["SSLPri"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
  }


  virtual ~SetVsDomainCertificateRequest() = default;
};
class SetVsDomainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetVsDomainCertificateResponseBody() {}

  explicit SetVsDomainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetVsDomainCertificateResponseBody() = default;
};
class SetVsDomainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetVsDomainCertificateResponseBody> body{};

  SetVsDomainCertificateResponse() {}

  explicit SetVsDomainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetVsDomainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetVsDomainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetVsDomainCertificateResponse() = default;
};
class SetVsStreamsNotifyUrlConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> authKey{};
  shared_ptr<string> authType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<long> ownerId{};

  SetVsStreamsNotifyUrlConfigRequest() {}

  explicit SetVsStreamsNotifyUrlConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~SetVsStreamsNotifyUrlConfigRequest() = default;
};
class SetVsStreamsNotifyUrlConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetVsStreamsNotifyUrlConfigResponseBody() {}

  explicit SetVsStreamsNotifyUrlConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetVsStreamsNotifyUrlConfigResponseBody() = default;
};
class SetVsStreamsNotifyUrlConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetVsStreamsNotifyUrlConfigResponseBody> body{};

  SetVsStreamsNotifyUrlConfigResponse() {}

  explicit SetVsStreamsNotifyUrlConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetVsStreamsNotifyUrlConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetVsStreamsNotifyUrlConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetVsStreamsNotifyUrlConfigResponse() = default;
};
class StartDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  StartDeviceRequest() {}

  explicit StartDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~StartDeviceRequest() = default;
};
class StartDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  StartDeviceResponseBody() {}

  explicit StartDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartDeviceResponseBody() = default;
};
class StartDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartDeviceResponseBody> body{};

  StartDeviceResponse() {}

  explicit StartDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~StartDeviceResponse() = default;
};
class StartParentPlatformRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  StartParentPlatformRequest() {}

  explicit StartParentPlatformRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~StartParentPlatformRequest() = default;
};
class StartParentPlatformResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  StartParentPlatformResponseBody() {}

  explicit StartParentPlatformResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartParentPlatformResponseBody() = default;
};
class StartParentPlatformResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartParentPlatformResponseBody> body{};

  StartParentPlatformResponse() {}

  explicit StartParentPlatformResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartParentPlatformResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartParentPlatformResponseBody>(model1);
      }
    }
  }


  virtual ~StartParentPlatformResponse() = default;
};
class StartPublishStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> publishUrl{};

  StartPublishStreamRequest() {}

  explicit StartPublishStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (publishUrl) {
      res["PublishUrl"] = boost::any(*publishUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PublishUrl") != m.end() && !m["PublishUrl"].empty()) {
      publishUrl = make_shared<string>(boost::any_cast<string>(m["PublishUrl"]));
    }
  }


  virtual ~StartPublishStreamRequest() = default;
};
class StartPublishStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> message{};
  shared_ptr<string> requestId{};

  StartPublishStreamResponseBody() {}

  explicit StartPublishStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<long>(boost::any_cast<long>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartPublishStreamResponseBody() = default;
};
class StartPublishStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartPublishStreamResponseBody> body{};

  StartPublishStreamResponse() {}

  explicit StartPublishStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartPublishStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartPublishStreamResponseBody>(model1);
      }
    }
  }


  virtual ~StartPublishStreamResponse() = default;
};
class StartRecordStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> playDomain{};

  StartRecordStreamRequest() {}

  explicit StartRecordStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (playDomain) {
      res["PlayDomain"] = boost::any(*playDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PlayDomain") != m.end() && !m["PlayDomain"].empty()) {
      playDomain = make_shared<string>(boost::any_cast<string>(m["PlayDomain"]));
    }
  }


  virtual ~StartRecordStreamRequest() = default;
};
class StartRecordStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartRecordStreamResponseBody() {}

  explicit StartRecordStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartRecordStreamResponseBody() = default;
};
class StartRecordStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartRecordStreamResponseBody> body{};

  StartRecordStreamResponse() {}

  explicit StartRecordStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartRecordStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartRecordStreamResponseBody>(model1);
      }
    }
  }


  virtual ~StartRecordStreamResponse() = default;
};
class StartStreamRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> startTime{};

  StartStreamRequest() {}

  explicit StartStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~StartStreamRequest() = default;
};
class StartStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};

  StartStreamResponseBody() {}

  explicit StartStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartStreamResponseBody() = default;
};
class StartStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartStreamResponseBody> body{};

  StartStreamResponse() {}

  explicit StartStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartStreamResponseBody>(model1);
      }
    }
  }


  virtual ~StartStreamResponse() = default;
};
class StartTransferStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> transcode{};
  shared_ptr<string> url{};

  StartTransferStreamRequest() {}

  explicit StartTransferStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (transcode) {
      res["Transcode"] = boost::any(*transcode);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      transcode = make_shared<string>(boost::any_cast<string>(m["Transcode"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~StartTransferStreamRequest() = default;
};
class StartTransferStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartTransferStreamResponseBody() {}

  explicit StartTransferStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartTransferStreamResponseBody() = default;
};
class StartTransferStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartTransferStreamResponseBody> body{};

  StartTransferStreamResponse() {}

  explicit StartTransferStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartTransferStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartTransferStreamResponseBody>(model1);
      }
    }
  }


  virtual ~StartTransferStreamResponse() = default;
};
class StopAdjustRequest : public Darabonba::Model {
public:
  shared_ptr<bool> focus{};
  shared_ptr<string> id{};
  shared_ptr<bool> iris{};
  shared_ptr<long> ownerId{};

  StopAdjustRequest() {}

  explicit StopAdjustRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (focus) {
      res["Focus"] = boost::any(*focus);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (iris) {
      res["Iris"] = boost::any(*iris);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Focus") != m.end() && !m["Focus"].empty()) {
      focus = make_shared<bool>(boost::any_cast<bool>(m["Focus"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Iris") != m.end() && !m["Iris"].empty()) {
      iris = make_shared<bool>(boost::any_cast<bool>(m["Iris"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~StopAdjustRequest() = default;
};
class StopAdjustResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  StopAdjustResponseBody() {}

  explicit StopAdjustResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopAdjustResponseBody() = default;
};
class StopAdjustResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopAdjustResponseBody> body{};

  StopAdjustResponse() {}

  explicit StopAdjustResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopAdjustResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopAdjustResponseBody>(model1);
      }
    }
  }


  virtual ~StopAdjustResponse() = default;
};
class StopDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  StopDeviceRequest() {}

  explicit StopDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~StopDeviceRequest() = default;
};
class StopDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  StopDeviceResponseBody() {}

  explicit StopDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopDeviceResponseBody() = default;
};
class StopDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopDeviceResponseBody> body{};

  StopDeviceResponse() {}

  explicit StopDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~StopDeviceResponse() = default;
};
class StopMoveRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<bool> pan{};
  shared_ptr<bool> tilt{};
  shared_ptr<bool> zoom{};

  StopMoveRequest() {}

  explicit StopMoveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pan) {
      res["Pan"] = boost::any(*pan);
    }
    if (tilt) {
      res["Tilt"] = boost::any(*tilt);
    }
    if (zoom) {
      res["Zoom"] = boost::any(*zoom);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Pan") != m.end() && !m["Pan"].empty()) {
      pan = make_shared<bool>(boost::any_cast<bool>(m["Pan"]));
    }
    if (m.find("Tilt") != m.end() && !m["Tilt"].empty()) {
      tilt = make_shared<bool>(boost::any_cast<bool>(m["Tilt"]));
    }
    if (m.find("Zoom") != m.end() && !m["Zoom"].empty()) {
      zoom = make_shared<bool>(boost::any_cast<bool>(m["Zoom"]));
    }
  }


  virtual ~StopMoveRequest() = default;
};
class StopMoveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  StopMoveResponseBody() {}

  explicit StopMoveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopMoveResponseBody() = default;
};
class StopMoveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopMoveResponseBody> body{};

  StopMoveResponse() {}

  explicit StopMoveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopMoveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopMoveResponseBody>(model1);
      }
    }
  }


  virtual ~StopMoveResponse() = default;
};
class StopPublishStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> ownerId{};

  StopPublishStreamRequest() {}

  explicit StopPublishStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~StopPublishStreamRequest() = default;
};
class StopPublishStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> message{};
  shared_ptr<string> requestId{};

  StopPublishStreamResponseBody() {}

  explicit StopPublishStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<long>(boost::any_cast<long>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopPublishStreamResponseBody() = default;
};
class StopPublishStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopPublishStreamResponseBody> body{};

  StopPublishStreamResponse() {}

  explicit StopPublishStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopPublishStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopPublishStreamResponseBody>(model1);
      }
    }
  }


  virtual ~StopPublishStreamResponse() = default;
};
class StopRecordStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> playDomain{};

  StopRecordStreamRequest() {}

  explicit StopRecordStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (playDomain) {
      res["PlayDomain"] = boost::any(*playDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PlayDomain") != m.end() && !m["PlayDomain"].empty()) {
      playDomain = make_shared<string>(boost::any_cast<string>(m["PlayDomain"]));
    }
  }


  virtual ~StopRecordStreamRequest() = default;
};
class StopRecordStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopRecordStreamResponseBody() {}

  explicit StopRecordStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopRecordStreamResponseBody() = default;
};
class StopRecordStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopRecordStreamResponseBody> body{};

  StopRecordStreamResponse() {}

  explicit StopRecordStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopRecordStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopRecordStreamResponseBody>(model1);
      }
    }
  }


  virtual ~StopRecordStreamResponse() = default;
};
class StopStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  StopStreamRequest() {}

  explicit StopStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~StopStreamRequest() = default;
};
class StopStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  StopStreamResponseBody() {}

  explicit StopStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopStreamResponseBody() = default;
};
class StopStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopStreamResponseBody> body{};

  StopStreamResponse() {}

  explicit StopStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopStreamResponseBody>(model1);
      }
    }
  }


  virtual ~StopStreamResponse() = default;
};
class StopTransferStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> transcode{};

  StopTransferStreamRequest() {}

  explicit StopTransferStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (transcode) {
      res["Transcode"] = boost::any(*transcode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      transcode = make_shared<string>(boost::any_cast<string>(m["Transcode"]));
    }
  }


  virtual ~StopTransferStreamRequest() = default;
};
class StopTransferStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopTransferStreamResponseBody() {}

  explicit StopTransferStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopTransferStreamResponseBody() = default;
};
class StopTransferStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopTransferStreamResponseBody> body{};

  StopTransferStreamResponse() {}

  explicit StopTransferStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopTransferStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopTransferStreamResponseBody>(model1);
      }
    }
  }


  virtual ~StopTransferStreamResponse() = default;
};
class SyncCatalogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  SyncCatalogsRequest() {}

  explicit SyncCatalogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~SyncCatalogsRequest() = default;
};
class SyncCatalogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  SyncCatalogsResponseBody() {}

  explicit SyncCatalogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SyncCatalogsResponseBody() = default;
};
class SyncCatalogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncCatalogsResponseBody> body{};

  SyncCatalogsResponse() {}

  explicit SyncCatalogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncCatalogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncCatalogsResponseBody>(model1);
      }
    }
  }


  virtual ~SyncCatalogsResponse() = default;
};
class UnbindDirectoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> directoryId{};
  shared_ptr<long> ownerId{};

  UnbindDirectoryRequest() {}

  explicit UnbindDirectoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~UnbindDirectoryRequest() = default;
};
class UnbindDirectoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindDirectoryResponseBody() {}

  explicit UnbindDirectoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindDirectoryResponseBody() = default;
};
class UnbindDirectoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindDirectoryResponseBody> body{};

  UnbindDirectoryResponse() {}

  explicit UnbindDirectoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindDirectoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindDirectoryResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindDirectoryResponse() = default;
};
class UnbindParentPlatformDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> parentPlatformId{};

  UnbindParentPlatformDeviceRequest() {}

  explicit UnbindParentPlatformDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (parentPlatformId) {
      res["ParentPlatformId"] = boost::any(*parentPlatformId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ParentPlatformId") != m.end() && !m["ParentPlatformId"].empty()) {
      parentPlatformId = make_shared<string>(boost::any_cast<string>(m["ParentPlatformId"]));
    }
  }


  virtual ~UnbindParentPlatformDeviceRequest() = default;
};
class UnbindParentPlatformDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindParentPlatformDeviceResponseBody() {}

  explicit UnbindParentPlatformDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindParentPlatformDeviceResponseBody() = default;
};
class UnbindParentPlatformDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindParentPlatformDeviceResponseBody> body{};

  UnbindParentPlatformDeviceResponse() {}

  explicit UnbindParentPlatformDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindParentPlatformDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindParentPlatformDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindParentPlatformDeviceResponse() = default;
};
class UnbindPurchasedDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<long> ownerId{};

  UnbindPurchasedDeviceRequest() {}

  explicit UnbindPurchasedDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~UnbindPurchasedDeviceRequest() = default;
};
class UnbindPurchasedDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindPurchasedDeviceResponseBody() {}

  explicit UnbindPurchasedDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindPurchasedDeviceResponseBody() = default;
};
class UnbindPurchasedDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindPurchasedDeviceResponseBody> body{};

  UnbindPurchasedDeviceResponse() {}

  explicit UnbindPurchasedDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindPurchasedDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindPurchasedDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindPurchasedDeviceResponse() = default;
};
class UnbindTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};

  UnbindTemplateRequest() {}

  explicit UnbindTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~UnbindTemplateRequest() = default;
};
class UnbindTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};

  UnbindTemplateResponseBody() {}

  explicit UnbindTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~UnbindTemplateResponseBody() = default;
};
class UnbindTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindTemplateResponseBody> body{};

  UnbindTemplateResponse() {}

  explicit UnbindTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindTemplateResponse() = default;
};
class UninstallCloudAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> renderingInstanceId{};

  UninstallCloudAppRequest() {}

  explicit UninstallCloudAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~UninstallCloudAppRequest() = default;
};
class UninstallCloudAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UninstallCloudAppResponseBody() {}

  explicit UninstallCloudAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UninstallCloudAppResponseBody() = default;
};
class UninstallCloudAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UninstallCloudAppResponseBody> body{};

  UninstallCloudAppResponse() {}

  explicit UninstallCloudAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UninstallCloudAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UninstallCloudAppResponseBody>(model1);
      }
    }
  }


  virtual ~UninstallCloudAppResponse() = default;
};
class UnlockDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> ownerId{};

  UnlockDeviceRequest() {}

  explicit UnlockDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~UnlockDeviceRequest() = default;
};
class UnlockDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  UnlockDeviceResponseBody() {}

  explicit UnlockDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnlockDeviceResponseBody() = default;
};
class UnlockDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnlockDeviceResponseBody> body{};

  UnlockDeviceResponse() {}

  explicit UnlockDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnlockDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnlockDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~UnlockDeviceResponse() = default;
};
class UpdateCloudAppInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> description{};

  UpdateCloudAppInfoRequest() {}

  explicit UpdateCloudAppInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~UpdateCloudAppInfoRequest() = default;
};
class UpdateCloudAppInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCloudAppInfoResponseBody() {}

  explicit UpdateCloudAppInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCloudAppInfoResponseBody() = default;
};
class UpdateCloudAppInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCloudAppInfoResponseBody> body{};

  UpdateCloudAppInfoResponse() {}

  explicit UpdateCloudAppInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCloudAppInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCloudAppInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCloudAppInfoResponse() = default;
};
class UpdateFileInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> fileId{};

  UpdateFileInfoRequest() {}

  explicit UpdateFileInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
  }


  virtual ~UpdateFileInfoRequest() = default;
};
class UpdateFileInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateFileInfoResponseBody() {}

  explicit UpdateFileInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateFileInfoResponseBody() = default;
};
class UpdateFileInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFileInfoResponseBody> body{};

  UpdateFileInfoResponse() {}

  explicit UpdateFileInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFileInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFileInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFileInfoResponse() = default;
};
class UpdateRenderingInstanceConfigurationRequestConfigurationAttributes : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<boost::any> value{};

  UpdateRenderingInstanceConfigurationRequestConfigurationAttributes() {}

  explicit UpdateRenderingInstanceConfigurationRequestConfigurationAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<boost::any>(boost::any_cast<boost::any>(m["Value"]));
    }
  }


  virtual ~UpdateRenderingInstanceConfigurationRequestConfigurationAttributes() = default;
};
class UpdateRenderingInstanceConfigurationRequestConfiguration : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateRenderingInstanceConfigurationRequestConfigurationAttributes>> attributes{};
  shared_ptr<string> moduleName{};

  UpdateRenderingInstanceConfigurationRequestConfiguration() {}

  explicit UpdateRenderingInstanceConfigurationRequestConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributes) {
      vector<boost::any> temp1;
      for(auto item1:*attributes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attributes"] = boost::any(temp1);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      if (typeid(vector<boost::any>) == m["Attributes"].type()) {
        vector<UpdateRenderingInstanceConfigurationRequestConfigurationAttributes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attributes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRenderingInstanceConfigurationRequestConfigurationAttributes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attributes = make_shared<vector<UpdateRenderingInstanceConfigurationRequestConfigurationAttributes>>(expect1);
      }
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~UpdateRenderingInstanceConfigurationRequestConfiguration() = default;
};
class UpdateRenderingInstanceConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateRenderingInstanceConfigurationRequestConfiguration>> configuration{};
  shared_ptr<string> renderingInstanceId{};

  UpdateRenderingInstanceConfigurationRequest() {}

  explicit UpdateRenderingInstanceConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      vector<boost::any> temp1;
      for(auto item1:*configuration){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configuration"] = boost::any(temp1);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      if (typeid(vector<boost::any>) == m["Configuration"].type()) {
        vector<UpdateRenderingInstanceConfigurationRequestConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configuration"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRenderingInstanceConfigurationRequestConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configuration = make_shared<vector<UpdateRenderingInstanceConfigurationRequestConfiguration>>(expect1);
      }
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~UpdateRenderingInstanceConfigurationRequest() = default;
};
class UpdateRenderingInstanceConfigurationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> configurationShrink{};
  shared_ptr<string> renderingInstanceId{};

  UpdateRenderingInstanceConfigurationShrinkRequest() {}

  explicit UpdateRenderingInstanceConfigurationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationShrink) {
      res["Configuration"] = boost::any(*configurationShrink);
    }
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configurationShrink = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
  }


  virtual ~UpdateRenderingInstanceConfigurationShrinkRequest() = default;
};
class UpdateRenderingInstanceConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateRenderingInstanceConfigurationResponseBody() {}

  explicit UpdateRenderingInstanceConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateRenderingInstanceConfigurationResponseBody() = default;
};
class UpdateRenderingInstanceConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRenderingInstanceConfigurationResponseBody> body{};

  UpdateRenderingInstanceConfigurationResponse() {}

  explicit UpdateRenderingInstanceConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRenderingInstanceConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRenderingInstanceConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRenderingInstanceConfigurationResponse() = default;
};
class UpdateRenderingInstanceSettingsRequestSettings : public Darabonba::Model {
public:
  shared_ptr<string> attributeName{};
  shared_ptr<string> attributeValue{};

  UpdateRenderingInstanceSettingsRequestSettings() {}

  explicit UpdateRenderingInstanceSettingsRequestSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (attributeValue) {
      res["AttributeValue"] = boost::any(*attributeValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      attributeName = make_shared<string>(boost::any_cast<string>(m["AttributeName"]));
    }
    if (m.find("AttributeValue") != m.end() && !m["AttributeValue"].empty()) {
      attributeValue = make_shared<string>(boost::any_cast<string>(m["AttributeValue"]));
    }
  }


  virtual ~UpdateRenderingInstanceSettingsRequestSettings() = default;
};
class UpdateRenderingInstanceSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> renderingInstanceId{};
  shared_ptr<vector<UpdateRenderingInstanceSettingsRequestSettings>> settings{};

  UpdateRenderingInstanceSettingsRequest() {}

  explicit UpdateRenderingInstanceSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    if (settings) {
      vector<boost::any> temp1;
      for(auto item1:*settings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Settings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
    if (m.find("Settings") != m.end() && !m["Settings"].empty()) {
      if (typeid(vector<boost::any>) == m["Settings"].type()) {
        vector<UpdateRenderingInstanceSettingsRequestSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Settings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRenderingInstanceSettingsRequestSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        settings = make_shared<vector<UpdateRenderingInstanceSettingsRequestSettings>>(expect1);
      }
    }
  }


  virtual ~UpdateRenderingInstanceSettingsRequest() = default;
};
class UpdateRenderingInstanceSettingsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> renderingInstanceId{};
  shared_ptr<string> settingsShrink{};

  UpdateRenderingInstanceSettingsShrinkRequest() {}

  explicit UpdateRenderingInstanceSettingsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderingInstanceId) {
      res["RenderingInstanceId"] = boost::any(*renderingInstanceId);
    }
    if (settingsShrink) {
      res["Settings"] = boost::any(*settingsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderingInstanceId") != m.end() && !m["RenderingInstanceId"].empty()) {
      renderingInstanceId = make_shared<string>(boost::any_cast<string>(m["RenderingInstanceId"]));
    }
    if (m.find("Settings") != m.end() && !m["Settings"].empty()) {
      settingsShrink = make_shared<string>(boost::any_cast<string>(m["Settings"]));
    }
  }


  virtual ~UpdateRenderingInstanceSettingsShrinkRequest() = default;
};
class UpdateRenderingInstanceSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateRenderingInstanceSettingsResponseBody() {}

  explicit UpdateRenderingInstanceSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateRenderingInstanceSettingsResponseBody() = default;
};
class UpdateRenderingInstanceSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRenderingInstanceSettingsResponseBody> body{};

  UpdateRenderingInstanceSettingsResponse() {}

  explicit UpdateRenderingInstanceSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRenderingInstanceSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRenderingInstanceSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRenderingInstanceSettingsResponse() = default;
};
class UpdateVsPullStreamInfoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> always{};
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  UpdateVsPullStreamInfoConfigRequest() {}

  explicit UpdateVsPullStreamInfoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (always) {
      res["Always"] = boost::any(*always);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Always") != m.end() && !m["Always"].empty()) {
      always = make_shared<string>(boost::any_cast<string>(m["Always"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~UpdateVsPullStreamInfoConfigRequest() = default;
};
class UpdateVsPullStreamInfoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateVsPullStreamInfoConfigResponseBody() {}

  explicit UpdateVsPullStreamInfoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateVsPullStreamInfoConfigResponseBody() = default;
};
class UpdateVsPullStreamInfoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateVsPullStreamInfoConfigResponseBody> body{};

  UpdateVsPullStreamInfoConfigResponse() {}

  explicit UpdateVsPullStreamInfoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateVsPullStreamInfoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateVsPullStreamInfoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateVsPullStreamInfoConfigResponse() = default;
};
class UploadCloudAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appVersion{};
  shared_ptr<string> description{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> md5{};

  UploadCloudAppRequest() {}

  explicit UploadCloudAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
  }


  virtual ~UploadCloudAppRequest() = default;
};
class UploadCloudAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> requestId{};

  UploadCloudAppResponseBody() {}

  explicit UploadCloudAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UploadCloudAppResponseBody() = default;
};
class UploadCloudAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadCloudAppResponseBody> body{};

  UploadCloudAppResponse() {}

  explicit UploadCloudAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadCloudAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadCloudAppResponseBody>(model1);
      }
    }
  }


  virtual ~UploadCloudAppResponse() = default;
};
class UploadFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> fileName{};
  shared_ptr<string> md5{};
  shared_ptr<string> originUrl{};
  shared_ptr<string> targetPath{};

  UploadFileRequest() {}

  explicit UploadFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (originUrl) {
      res["OriginUrl"] = boost::any(*originUrl);
    }
    if (targetPath) {
      res["TargetPath"] = boost::any(*targetPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("OriginUrl") != m.end() && !m["OriginUrl"].empty()) {
      originUrl = make_shared<string>(boost::any_cast<string>(m["OriginUrl"]));
    }
    if (m.find("TargetPath") != m.end() && !m["TargetPath"].empty()) {
      targetPath = make_shared<string>(boost::any_cast<string>(m["TargetPath"]));
    }
  }


  virtual ~UploadFileRequest() = default;
};
class UploadFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> requestId{};

  UploadFileResponseBody() {}

  explicit UploadFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UploadFileResponseBody() = default;
};
class UploadFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadFileResponseBody> body{};

  UploadFileResponse() {}

  explicit UploadFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadFileResponseBody>(model1);
      }
    }
  }


  virtual ~UploadFileResponse() = default;
};
class UploadPublicKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> description{};
  shared_ptr<string> keyGroup{};
  shared_ptr<string> keyName{};
  shared_ptr<string> keyType{};

  UploadPublicKeyRequest() {}

  explicit UploadPublicKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (keyGroup) {
      res["KeyGroup"] = boost::any(*keyGroup);
    }
    if (keyName) {
      res["KeyName"] = boost::any(*keyName);
    }
    if (keyType) {
      res["KeyType"] = boost::any(*keyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("KeyGroup") != m.end() && !m["KeyGroup"].empty()) {
      keyGroup = make_shared<string>(boost::any_cast<string>(m["KeyGroup"]));
    }
    if (m.find("KeyName") != m.end() && !m["KeyName"].empty()) {
      keyName = make_shared<string>(boost::any_cast<string>(m["KeyName"]));
    }
    if (m.find("KeyType") != m.end() && !m["KeyType"].empty()) {
      keyType = make_shared<string>(boost::any_cast<string>(m["KeyType"]));
    }
  }


  virtual ~UploadPublicKeyRequest() = default;
};
class UploadPublicKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UploadPublicKeyResponseBody() {}

  explicit UploadPublicKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UploadPublicKeyResponseBody() = default;
};
class UploadPublicKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadPublicKeyResponseBody> body{};

  UploadPublicKeyResponse() {}

  explicit UploadPublicKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadPublicKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadPublicKeyResponseBody>(model1);
      }
    }
  }


  virtual ~UploadPublicKeyResponse() = default;
};
class VerifyVsDomainOwnerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> verifyType{};

  VerifyVsDomainOwnerRequest() {}

  explicit VerifyVsDomainOwnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (verifyType) {
      res["VerifyType"] = boost::any(*verifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("VerifyType") != m.end() && !m["VerifyType"].empty()) {
      verifyType = make_shared<string>(boost::any_cast<string>(m["VerifyType"]));
    }
  }


  virtual ~VerifyVsDomainOwnerRequest() = default;
};
class VerifyVsDomainOwnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  VerifyVsDomainOwnerResponseBody() {}

  explicit VerifyVsDomainOwnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VerifyVsDomainOwnerResponseBody() = default;
};
class VerifyVsDomainOwnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifyVsDomainOwnerResponseBody> body{};

  VerifyVsDomainOwnerResponse() {}

  explicit VerifyVsDomainOwnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyVsDomainOwnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyVsDomainOwnerResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyVsDomainOwnerResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddVsPullStreamInfoConfigResponse addVsPullStreamInfoConfigWithOptions(shared_ptr<AddVsPullStreamInfoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddVsPullStreamInfoConfigResponse addVsPullStreamInfoConfig(shared_ptr<AddVsPullStreamInfoConfigRequest> request);
  BatchBindDirectoriesResponse batchBindDirectoriesWithOptions(shared_ptr<BatchBindDirectoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchBindDirectoriesResponse batchBindDirectories(shared_ptr<BatchBindDirectoriesRequest> request);
  BatchBindParentPlatformDevicesResponse batchBindParentPlatformDevicesWithOptions(shared_ptr<BatchBindParentPlatformDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchBindParentPlatformDevicesResponse batchBindParentPlatformDevices(shared_ptr<BatchBindParentPlatformDevicesRequest> request);
  BatchBindPurchasedDevicesResponse batchBindPurchasedDevicesWithOptions(shared_ptr<BatchBindPurchasedDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchBindPurchasedDevicesResponse batchBindPurchasedDevices(shared_ptr<BatchBindPurchasedDevicesRequest> request);
  BatchBindTemplateResponse batchBindTemplateWithOptions(shared_ptr<BatchBindTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchBindTemplateResponse batchBindTemplate(shared_ptr<BatchBindTemplateRequest> request);
  BatchBindTemplatesResponse batchBindTemplatesWithOptions(shared_ptr<BatchBindTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchBindTemplatesResponse batchBindTemplates(shared_ptr<BatchBindTemplatesRequest> request);
  BatchDeleteDevicesResponse batchDeleteDevicesWithOptions(shared_ptr<BatchDeleteDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteDevicesResponse batchDeleteDevices(shared_ptr<BatchDeleteDevicesRequest> request);
  BatchDeleteVsDomainConfigsResponse batchDeleteVsDomainConfigsWithOptions(shared_ptr<BatchDeleteVsDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteVsDomainConfigsResponse batchDeleteVsDomainConfigs(shared_ptr<BatchDeleteVsDomainConfigsRequest> request);
  BatchForbidVsStreamResponse batchForbidVsStreamWithOptions(shared_ptr<BatchForbidVsStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchForbidVsStreamResponse batchForbidVsStream(shared_ptr<BatchForbidVsStreamRequest> request);
  BatchResumeVsStreamResponse batchResumeVsStreamWithOptions(shared_ptr<BatchResumeVsStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchResumeVsStreamResponse batchResumeVsStream(shared_ptr<BatchResumeVsStreamRequest> request);
  BatchSetVsDomainConfigsResponse batchSetVsDomainConfigsWithOptions(shared_ptr<BatchSetVsDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetVsDomainConfigsResponse batchSetVsDomainConfigs(shared_ptr<BatchSetVsDomainConfigsRequest> request);
  BatchStartDevicesResponse batchStartDevicesWithOptions(shared_ptr<BatchStartDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchStartDevicesResponse batchStartDevices(shared_ptr<BatchStartDevicesRequest> request);
  BatchStartStreamsResponse batchStartStreamsWithOptions(shared_ptr<BatchStartStreamsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchStartStreamsResponse batchStartStreams(shared_ptr<BatchStartStreamsRequest> request);
  BatchStopDevicesResponse batchStopDevicesWithOptions(shared_ptr<BatchStopDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchStopDevicesResponse batchStopDevices(shared_ptr<BatchStopDevicesRequest> request);
  BatchStopStreamsResponse batchStopStreamsWithOptions(shared_ptr<BatchStopStreamsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchStopStreamsResponse batchStopStreams(shared_ptr<BatchStopStreamsRequest> request);
  BatchUnbindDirectoriesResponse batchUnbindDirectoriesWithOptions(shared_ptr<BatchUnbindDirectoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUnbindDirectoriesResponse batchUnbindDirectories(shared_ptr<BatchUnbindDirectoriesRequest> request);
  BatchUnbindParentPlatformDevicesResponse batchUnbindParentPlatformDevicesWithOptions(shared_ptr<BatchUnbindParentPlatformDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUnbindParentPlatformDevicesResponse batchUnbindParentPlatformDevices(shared_ptr<BatchUnbindParentPlatformDevicesRequest> request);
  BatchUnbindPurchasedDevicesResponse batchUnbindPurchasedDevicesWithOptions(shared_ptr<BatchUnbindPurchasedDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUnbindPurchasedDevicesResponse batchUnbindPurchasedDevices(shared_ptr<BatchUnbindPurchasedDevicesRequest> request);
  BatchUnbindTemplateResponse batchUnbindTemplateWithOptions(shared_ptr<BatchUnbindTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUnbindTemplateResponse batchUnbindTemplate(shared_ptr<BatchUnbindTemplateRequest> request);
  BatchUnbindTemplatesResponse batchUnbindTemplatesWithOptions(shared_ptr<BatchUnbindTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUnbindTemplatesResponse batchUnbindTemplates(shared_ptr<BatchUnbindTemplatesRequest> request);
  BindDirectoryResponse bindDirectoryWithOptions(shared_ptr<BindDirectoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindDirectoryResponse bindDirectory(shared_ptr<BindDirectoryRequest> request);
  BindParentPlatformDeviceResponse bindParentPlatformDeviceWithOptions(shared_ptr<BindParentPlatformDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindParentPlatformDeviceResponse bindParentPlatformDevice(shared_ptr<BindParentPlatformDeviceRequest> request);
  BindPurchasedDeviceResponse bindPurchasedDeviceWithOptions(shared_ptr<BindPurchasedDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindPurchasedDeviceResponse bindPurchasedDevice(shared_ptr<BindPurchasedDeviceRequest> request);
  BindTemplateResponse bindTemplateWithOptions(shared_ptr<BindTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindTemplateResponse bindTemplate(shared_ptr<BindTemplateRequest> request);
  ContinuousAdjustResponse continuousAdjustWithOptions(shared_ptr<ContinuousAdjustRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ContinuousAdjustResponse continuousAdjust(shared_ptr<ContinuousAdjustRequest> request);
  ContinuousMoveResponse continuousMoveWithOptions(shared_ptr<ContinuousMoveRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ContinuousMoveResponse continuousMove(shared_ptr<ContinuousMoveRequest> request);
  CreateDeviceResponse createDeviceWithOptions(shared_ptr<CreateDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceResponse createDevice(shared_ptr<CreateDeviceRequest> request);
  CreateDeviceAlarmResponse createDeviceAlarmWithOptions(shared_ptr<CreateDeviceAlarmRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceAlarmResponse createDeviceAlarm(shared_ptr<CreateDeviceAlarmRequest> request);
  CreateDirectoryResponse createDirectoryWithOptions(shared_ptr<CreateDirectoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDirectoryResponse createDirectory(shared_ptr<CreateDirectoryRequest> request);
  CreateGroupResponse createGroupWithOptions(shared_ptr<CreateGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateGroupResponse createGroup(shared_ptr<CreateGroupRequest> request);
  CreateParentPlatformResponse createParentPlatformWithOptions(shared_ptr<CreateParentPlatformRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateParentPlatformResponse createParentPlatform(shared_ptr<CreateParentPlatformRequest> request);
  CreateRenderingDataPackageResponse createRenderingDataPackageWithOptions(shared_ptr<CreateRenderingDataPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRenderingDataPackageResponse createRenderingDataPackage(shared_ptr<CreateRenderingDataPackageRequest> request);
  CreateRenderingInstanceResponse createRenderingInstanceWithOptions(shared_ptr<CreateRenderingInstanceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRenderingInstanceResponse createRenderingInstance(shared_ptr<CreateRenderingInstanceRequest> request);
  CreateRenderingInstanceGatewayResponse createRenderingInstanceGatewayWithOptions(shared_ptr<CreateRenderingInstanceGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRenderingInstanceGatewayResponse createRenderingInstanceGateway(shared_ptr<CreateRenderingInstanceGatewayRequest> request);
  CreateStreamSnapshotResponse createStreamSnapshotWithOptions(shared_ptr<CreateStreamSnapshotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateStreamSnapshotResponse createStreamSnapshot(shared_ptr<CreateStreamSnapshotRequest> request);
  CreateTemplateResponse createTemplateWithOptions(shared_ptr<CreateTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTemplateResponse createTemplate(shared_ptr<CreateTemplateRequest> request);
  DeleteCloudAppResponse deleteCloudAppWithOptions(shared_ptr<DeleteCloudAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCloudAppResponse deleteCloudApp(shared_ptr<DeleteCloudAppRequest> request);
  DeleteDeviceResponse deleteDeviceWithOptions(shared_ptr<DeleteDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceResponse deleteDevice(shared_ptr<DeleteDeviceRequest> request);
  DeleteDirectoryResponse deleteDirectoryWithOptions(shared_ptr<DeleteDirectoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDirectoryResponse deleteDirectory(shared_ptr<DeleteDirectoryRequest> request);
  DeleteFileResponse deleteFileWithOptions(shared_ptr<DeleteFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFileResponse deleteFile(shared_ptr<DeleteFileRequest> request);
  DeleteGroupResponse deleteGroupWithOptions(shared_ptr<DeleteGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGroupResponse deleteGroup(shared_ptr<DeleteGroupRequest> request);
  DeleteParentPlatformResponse deleteParentPlatformWithOptions(shared_ptr<DeleteParentPlatformRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteParentPlatformResponse deleteParentPlatform(shared_ptr<DeleteParentPlatformRequest> request);
  DeletePresetResponse deletePresetWithOptions(shared_ptr<DeletePresetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePresetResponse deletePreset(shared_ptr<DeletePresetRequest> request);
  DeletePublicKeyResponse deletePublicKeyWithOptions(shared_ptr<DeletePublicKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePublicKeyResponse deletePublicKey(shared_ptr<DeletePublicKeyRequest> request);
  DeleteRenderingInstanceConfigurationResponse deleteRenderingInstanceConfigurationWithOptions(shared_ptr<DeleteRenderingInstanceConfigurationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRenderingInstanceConfigurationResponse deleteRenderingInstanceConfiguration(shared_ptr<DeleteRenderingInstanceConfigurationRequest> request);
  DeleteRenderingInstanceGatewayResponse deleteRenderingInstanceGatewayWithOptions(shared_ptr<DeleteRenderingInstanceGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRenderingInstanceGatewayResponse deleteRenderingInstanceGateway(shared_ptr<DeleteRenderingInstanceGatewayRequest> request);
  DeleteRenderingInstanceSettingsResponse deleteRenderingInstanceSettingsWithOptions(shared_ptr<DeleteRenderingInstanceSettingsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRenderingInstanceSettingsResponse deleteRenderingInstanceSettings(shared_ptr<DeleteRenderingInstanceSettingsRequest> request);
  DeleteTemplateResponse deleteTemplateWithOptions(shared_ptr<DeleteTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTemplateResponse deleteTemplate(shared_ptr<DeleteTemplateRequest> request);
  DeleteVsPullStreamInfoConfigResponse deleteVsPullStreamInfoConfigWithOptions(shared_ptr<DeleteVsPullStreamInfoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVsPullStreamInfoConfigResponse deleteVsPullStreamInfoConfig(shared_ptr<DeleteVsPullStreamInfoConfigRequest> request);
  DeleteVsStreamsNotifyUrlConfigResponse deleteVsStreamsNotifyUrlConfigWithOptions(shared_ptr<DeleteVsStreamsNotifyUrlConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVsStreamsNotifyUrlConfigResponse deleteVsStreamsNotifyUrlConfig(shared_ptr<DeleteVsStreamsNotifyUrlConfigRequest> request);
  DescribeAccountStatResponse describeAccountStatWithOptions(shared_ptr<DescribeAccountStatRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAccountStatResponse describeAccountStat(shared_ptr<DescribeAccountStatRequest> request);
  DescribeDeviceResponse describeDeviceWithOptions(shared_ptr<DescribeDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceResponse describeDevice(shared_ptr<DescribeDeviceRequest> request);
  DescribeDeviceChannelsResponse describeDeviceChannelsWithOptions(shared_ptr<DescribeDeviceChannelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceChannelsResponse describeDeviceChannels(shared_ptr<DescribeDeviceChannelsRequest> request);
  DescribeDeviceGatewayResponse describeDeviceGatewayWithOptions(shared_ptr<DescribeDeviceGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceGatewayResponse describeDeviceGateway(shared_ptr<DescribeDeviceGatewayRequest> request);
  DescribeDeviceURLResponse describeDeviceURLWithOptions(shared_ptr<DescribeDeviceURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceURLResponse describeDeviceURL(shared_ptr<DescribeDeviceURLRequest> request);
  DescribeDevicesResponse describeDevicesWithOptions(shared_ptr<DescribeDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDevicesResponse describeDevices(shared_ptr<DescribeDevicesRequest> request);
  DescribeDirectoriesResponse describeDirectoriesWithOptions(shared_ptr<DescribeDirectoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDirectoriesResponse describeDirectories(shared_ptr<DescribeDirectoriesRequest> request);
  DescribeDirectoryResponse describeDirectoryWithOptions(shared_ptr<DescribeDirectoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDirectoryResponse describeDirectory(shared_ptr<DescribeDirectoryRequest> request);
  DescribeGroupResponse describeGroupWithOptions(shared_ptr<DescribeGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupResponse describeGroup(shared_ptr<DescribeGroupRequest> request);
  DescribeGroupsResponse describeGroupsWithOptions(shared_ptr<DescribeGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupsResponse describeGroups(shared_ptr<DescribeGroupsRequest> request);
  DescribeParentPlatformResponse describeParentPlatformWithOptions(shared_ptr<DescribeParentPlatformRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeParentPlatformResponse describeParentPlatform(shared_ptr<DescribeParentPlatformRequest> request);
  DescribeParentPlatformDevicesResponse describeParentPlatformDevicesWithOptions(shared_ptr<DescribeParentPlatformDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeParentPlatformDevicesResponse describeParentPlatformDevices(shared_ptr<DescribeParentPlatformDevicesRequest> request);
  DescribeParentPlatformsResponse describeParentPlatformsWithOptions(shared_ptr<DescribeParentPlatformsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeParentPlatformsResponse describeParentPlatforms(shared_ptr<DescribeParentPlatformsRequest> request);
  DescribePresetsResponse describePresetsWithOptions(shared_ptr<DescribePresetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePresetsResponse describePresets(shared_ptr<DescribePresetsRequest> request);
  DescribePublishStreamStatusResponse describePublishStreamStatusWithOptions(shared_ptr<DescribePublishStreamStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePublishStreamStatusResponse describePublishStreamStatus(shared_ptr<DescribePublishStreamStatusRequest> request);
  DescribePurchasedDeviceResponse describePurchasedDeviceWithOptions(shared_ptr<DescribePurchasedDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePurchasedDeviceResponse describePurchasedDevice(shared_ptr<DescribePurchasedDeviceRequest> request);
  DescribePurchasedDevicesResponse describePurchasedDevicesWithOptions(shared_ptr<DescribePurchasedDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePurchasedDevicesResponse describePurchasedDevices(shared_ptr<DescribePurchasedDevicesRequest> request);
  DescribeRecordsResponse describeRecordsWithOptions(shared_ptr<DescribeRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRecordsResponse describeRecords(shared_ptr<DescribeRecordsRequest> request);
  DescribeRenderingInstanceResponse describeRenderingInstanceWithOptions(shared_ptr<DescribeRenderingInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRenderingInstanceResponse describeRenderingInstance(shared_ptr<DescribeRenderingInstanceRequest> request);
  DescribeRenderingInstanceConfigurationResponse describeRenderingInstanceConfigurationWithOptions(shared_ptr<DescribeRenderingInstanceConfigurationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRenderingInstanceConfigurationResponse describeRenderingInstanceConfiguration(shared_ptr<DescribeRenderingInstanceConfigurationRequest> request);
  DescribeRenderingInstanceSettingsResponse describeRenderingInstanceSettingsWithOptions(shared_ptr<DescribeRenderingInstanceSettingsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRenderingInstanceSettingsResponse describeRenderingInstanceSettings(shared_ptr<DescribeRenderingInstanceSettingsRequest> request);
  DescribeStreamResponse describeStreamWithOptions(shared_ptr<DescribeStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStreamResponse describeStream(shared_ptr<DescribeStreamRequest> request);
  DescribeStreamURLResponse describeStreamURLWithOptions(shared_ptr<DescribeStreamURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStreamURLResponse describeStreamURL(shared_ptr<DescribeStreamURLRequest> request);
  DescribeStreamVodListResponse describeStreamVodListWithOptions(shared_ptr<DescribeStreamVodListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStreamVodListResponse describeStreamVodList(shared_ptr<DescribeStreamVodListRequest> request);
  DescribeStreamsResponse describeStreamsWithOptions(shared_ptr<DescribeStreamsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStreamsResponse describeStreams(shared_ptr<DescribeStreamsRequest> request);
  DescribeTemplateResponse describeTemplateWithOptions(shared_ptr<DescribeTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTemplateResponse describeTemplate(shared_ptr<DescribeTemplateRequest> request);
  DescribeTemplatesResponse describeTemplatesWithOptions(shared_ptr<DescribeTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTemplatesResponse describeTemplates(shared_ptr<DescribeTemplatesRequest> request);
  DescribeVodStreamURLResponse describeVodStreamURLWithOptions(shared_ptr<DescribeVodStreamURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodStreamURLResponse describeVodStreamURL(shared_ptr<DescribeVodStreamURLRequest> request);
  DescribeVsCertificateDetailResponse describeVsCertificateDetailWithOptions(shared_ptr<DescribeVsCertificateDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsCertificateDetailResponse describeVsCertificateDetail(shared_ptr<DescribeVsCertificateDetailRequest> request);
  DescribeVsCertificateListResponse describeVsCertificateListWithOptions(shared_ptr<DescribeVsCertificateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsCertificateListResponse describeVsCertificateList(shared_ptr<DescribeVsCertificateListRequest> request);
  DescribeVsDevicesDataResponse describeVsDevicesDataWithOptions(shared_ptr<DescribeVsDevicesDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsDevicesDataResponse describeVsDevicesData(shared_ptr<DescribeVsDevicesDataRequest> request);
  DescribeVsDomainBpsDataResponse describeVsDomainBpsDataWithOptions(shared_ptr<DescribeVsDomainBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsDomainBpsDataResponse describeVsDomainBpsData(shared_ptr<DescribeVsDomainBpsDataRequest> request);
  DescribeVsDomainCertificateInfoResponse describeVsDomainCertificateInfoWithOptions(shared_ptr<DescribeVsDomainCertificateInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsDomainCertificateInfoResponse describeVsDomainCertificateInfo(shared_ptr<DescribeVsDomainCertificateInfoRequest> request);
  DescribeVsDomainConfigsResponse describeVsDomainConfigsWithOptions(shared_ptr<DescribeVsDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsDomainConfigsResponse describeVsDomainConfigs(shared_ptr<DescribeVsDomainConfigsRequest> request);
  DescribeVsDomainDetailResponse describeVsDomainDetailWithOptions(shared_ptr<DescribeVsDomainDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsDomainDetailResponse describeVsDomainDetail(shared_ptr<DescribeVsDomainDetailRequest> request);
  DescribeVsDomainPvDataResponse describeVsDomainPvDataWithOptions(shared_ptr<DescribeVsDomainPvDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsDomainPvDataResponse describeVsDomainPvData(shared_ptr<DescribeVsDomainPvDataRequest> request);
  DescribeVsDomainPvUvDataResponse describeVsDomainPvUvDataWithOptions(shared_ptr<DescribeVsDomainPvUvDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsDomainPvUvDataResponse describeVsDomainPvUvData(shared_ptr<DescribeVsDomainPvUvDataRequest> request);
  DescribeVsDomainRecordDataResponse describeVsDomainRecordDataWithOptions(shared_ptr<DescribeVsDomainRecordDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsDomainRecordDataResponse describeVsDomainRecordData(shared_ptr<DescribeVsDomainRecordDataRequest> request);
  DescribeVsDomainRegionDataResponse describeVsDomainRegionDataWithOptions(shared_ptr<DescribeVsDomainRegionDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsDomainRegionDataResponse describeVsDomainRegionData(shared_ptr<DescribeVsDomainRegionDataRequest> request);
  DescribeVsDomainReqBpsDataResponse describeVsDomainReqBpsDataWithOptions(shared_ptr<DescribeVsDomainReqBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsDomainReqBpsDataResponse describeVsDomainReqBpsData(shared_ptr<DescribeVsDomainReqBpsDataRequest> request);
  DescribeVsDomainReqTrafficDataResponse describeVsDomainReqTrafficDataWithOptions(shared_ptr<DescribeVsDomainReqTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsDomainReqTrafficDataResponse describeVsDomainReqTrafficData(shared_ptr<DescribeVsDomainReqTrafficDataRequest> request);
  DescribeVsDomainSnapshotDataResponse describeVsDomainSnapshotDataWithOptions(shared_ptr<DescribeVsDomainSnapshotDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsDomainSnapshotDataResponse describeVsDomainSnapshotData(shared_ptr<DescribeVsDomainSnapshotDataRequest> request);
  DescribeVsDomainTrafficDataResponse describeVsDomainTrafficDataWithOptions(shared_ptr<DescribeVsDomainTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsDomainTrafficDataResponse describeVsDomainTrafficData(shared_ptr<DescribeVsDomainTrafficDataRequest> request);
  DescribeVsDomainUvDataResponse describeVsDomainUvDataWithOptions(shared_ptr<DescribeVsDomainUvDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsDomainUvDataResponse describeVsDomainUvData(shared_ptr<DescribeVsDomainUvDataRequest> request);
  DescribeVsPullStreamInfoConfigResponse describeVsPullStreamInfoConfigWithOptions(shared_ptr<DescribeVsPullStreamInfoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsPullStreamInfoConfigResponse describeVsPullStreamInfoConfig(shared_ptr<DescribeVsPullStreamInfoConfigRequest> request);
  DescribeVsStreamsNotifyUrlConfigResponse describeVsStreamsNotifyUrlConfigWithOptions(shared_ptr<DescribeVsStreamsNotifyUrlConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsStreamsNotifyUrlConfigResponse describeVsStreamsNotifyUrlConfig(shared_ptr<DescribeVsStreamsNotifyUrlConfigRequest> request);
  DescribeVsStreamsOnlineListResponse describeVsStreamsOnlineListWithOptions(shared_ptr<DescribeVsStreamsOnlineListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsStreamsOnlineListResponse describeVsStreamsOnlineList(shared_ptr<DescribeVsStreamsOnlineListRequest> request);
  DescribeVsStreamsPublishListResponse describeVsStreamsPublishListWithOptions(shared_ptr<DescribeVsStreamsPublishListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsStreamsPublishListResponse describeVsStreamsPublishList(shared_ptr<DescribeVsStreamsPublishListRequest> request);
  DescribeVsTopDomainsByFlowResponse describeVsTopDomainsByFlowWithOptions(shared_ptr<DescribeVsTopDomainsByFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsTopDomainsByFlowResponse describeVsTopDomainsByFlow(shared_ptr<DescribeVsTopDomainsByFlowRequest> request);
  DescribeVsUpPeakPublishStreamDataResponse describeVsUpPeakPublishStreamDataWithOptions(shared_ptr<DescribeVsUpPeakPublishStreamDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsUpPeakPublishStreamDataResponse describeVsUpPeakPublishStreamData(shared_ptr<DescribeVsUpPeakPublishStreamDataRequest> request);
  DescribeVsUserResourcePackageResponse describeVsUserResourcePackageWithOptions(shared_ptr<DescribeVsUserResourcePackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsUserResourcePackageResponse describeVsUserResourcePackage(shared_ptr<DescribeVsUserResourcePackageRequest> request);
  DescribeVsVerifyContentResponse describeVsVerifyContentWithOptions(shared_ptr<DescribeVsVerifyContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVsVerifyContentResponse describeVsVerifyContent(shared_ptr<DescribeVsVerifyContentRequest> request);
  ForbidVsStreamResponse forbidVsStreamWithOptions(shared_ptr<ForbidVsStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ForbidVsStreamResponse forbidVsStream(shared_ptr<ForbidVsStreamRequest> request);
  GetRenderingInstanceStreamingInfoResponse getRenderingInstanceStreamingInfoWithOptions(shared_ptr<GetRenderingInstanceStreamingInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRenderingInstanceStreamingInfoResponse getRenderingInstanceStreamingInfo(shared_ptr<GetRenderingInstanceStreamingInfoRequest> request);
  GotoPresetResponse gotoPresetWithOptions(shared_ptr<GotoPresetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GotoPresetResponse gotoPreset(shared_ptr<GotoPresetRequest> request);
  InstallCloudAppResponse installCloudAppWithOptions(shared_ptr<InstallCloudAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallCloudAppResponse installCloudApp(shared_ptr<InstallCloudAppRequest> request);
  ListCloudAppInstallationsResponse listCloudAppInstallationsWithOptions(shared_ptr<ListCloudAppInstallationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCloudAppInstallationsResponse listCloudAppInstallations(shared_ptr<ListCloudAppInstallationsRequest> request);
  ListCloudAppsResponse listCloudAppsWithOptions(shared_ptr<ListCloudAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCloudAppsResponse listCloudApps(shared_ptr<ListCloudAppsRequest> request);
  ListFilePushStatusesResponse listFilePushStatusesWithOptions(shared_ptr<ListFilePushStatusesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFilePushStatusesResponse listFilePushStatuses(shared_ptr<ListFilePushStatusesRequest> request);
  ListFilesResponse listFilesWithOptions(shared_ptr<ListFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFilesResponse listFiles(shared_ptr<ListFilesRequest> request);
  ListPublicKeysResponse listPublicKeysWithOptions(shared_ptr<ListPublicKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPublicKeysResponse listPublicKeys(shared_ptr<ListPublicKeysRequest> request);
  ListRenderingDataPackagesResponse listRenderingDataPackagesWithOptions(shared_ptr<ListRenderingDataPackagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRenderingDataPackagesResponse listRenderingDataPackages(shared_ptr<ListRenderingDataPackagesRequest> request);
  ListRenderingInstanceGatewayResponse listRenderingInstanceGatewayWithOptions(shared_ptr<ListRenderingInstanceGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRenderingInstanceGatewayResponse listRenderingInstanceGateway(shared_ptr<ListRenderingInstanceGatewayRequest> request);
  ListRenderingInstancesResponse listRenderingInstancesWithOptions(shared_ptr<ListRenderingInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRenderingInstancesResponse listRenderingInstances(shared_ptr<ListRenderingInstancesRequest> request);
  ManageLoginResponse manageLoginWithOptions(shared_ptr<ManageLoginRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ManageLoginResponse manageLogin(shared_ptr<ManageLoginRequest> request);
  ModifyDeviceResponse modifyDeviceWithOptions(shared_ptr<ModifyDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDeviceResponse modifyDevice(shared_ptr<ModifyDeviceRequest> request);
  ModifyDeviceAlarmResponse modifyDeviceAlarmWithOptions(shared_ptr<ModifyDeviceAlarmRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDeviceAlarmResponse modifyDeviceAlarm(shared_ptr<ModifyDeviceAlarmRequest> request);
  ModifyDeviceCaptureResponse modifyDeviceCaptureWithOptions(shared_ptr<ModifyDeviceCaptureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDeviceCaptureResponse modifyDeviceCapture(shared_ptr<ModifyDeviceCaptureRequest> request);
  ModifyDeviceChannelsResponse modifyDeviceChannelsWithOptions(shared_ptr<ModifyDeviceChannelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDeviceChannelsResponse modifyDeviceChannels(shared_ptr<ModifyDeviceChannelsRequest> request);
  ModifyDirectoryResponse modifyDirectoryWithOptions(shared_ptr<ModifyDirectoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDirectoryResponse modifyDirectory(shared_ptr<ModifyDirectoryRequest> request);
  ModifyGroupResponse modifyGroupWithOptions(shared_ptr<ModifyGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyGroupResponse modifyGroup(shared_ptr<ModifyGroupRequest> request);
  ModifyParentPlatformResponse modifyParentPlatformWithOptions(shared_ptr<ModifyParentPlatformRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyParentPlatformResponse modifyParentPlatform(shared_ptr<ModifyParentPlatformRequest> request);
  ModifyRenderingInstanceResponse modifyRenderingInstanceWithOptions(shared_ptr<ModifyRenderingInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRenderingInstanceResponse modifyRenderingInstance(shared_ptr<ModifyRenderingInstanceRequest> request);
  ModifyRenderingInstanceBandwidthResponse modifyRenderingInstanceBandwidthWithOptions(shared_ptr<ModifyRenderingInstanceBandwidthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRenderingInstanceBandwidthResponse modifyRenderingInstanceBandwidth(shared_ptr<ModifyRenderingInstanceBandwidthRequest> request);
  ModifyTemplateResponse modifyTemplateWithOptions(shared_ptr<ModifyTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTemplateResponse modifyTemplate(shared_ptr<ModifyTemplateRequest> request);
  OpenVsServiceResponse openVsServiceWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenVsServiceResponse openVsService();
  PushFileResponse pushFileWithOptions(shared_ptr<PushFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushFileResponse pushFile(shared_ptr<PushFileRequest> request);
  RebootRenderingInstanceResponse rebootRenderingInstanceWithOptions(shared_ptr<RebootRenderingInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebootRenderingInstanceResponse rebootRenderingInstance(shared_ptr<RebootRenderingInstanceRequest> request);
  RecoverRenderingDataPackageResponse recoverRenderingDataPackageWithOptions(shared_ptr<RecoverRenderingDataPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecoverRenderingDataPackageResponse recoverRenderingDataPackage(shared_ptr<RecoverRenderingDataPackageRequest> request);
  RefreshRenderingInstanceStreamingResponse refreshRenderingInstanceStreamingWithOptions(shared_ptr<RefreshRenderingInstanceStreamingRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshRenderingInstanceStreamingResponse refreshRenderingInstanceStreaming(shared_ptr<RefreshRenderingInstanceStreamingRequest> request);
  ReleaseRenderingDataPackageResponse releaseRenderingDataPackageWithOptions(shared_ptr<ReleaseRenderingDataPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseRenderingDataPackageResponse releaseRenderingDataPackage(shared_ptr<ReleaseRenderingDataPackageRequest> request);
  ReleaseRenderingInstanceResponse releaseRenderingInstanceWithOptions(shared_ptr<ReleaseRenderingInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseRenderingInstanceResponse releaseRenderingInstance(shared_ptr<ReleaseRenderingInstanceRequest> request);
  RenewRenderingInstanceResponse renewRenderingInstanceWithOptions(shared_ptr<RenewRenderingInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewRenderingInstanceResponse renewRenderingInstance(shared_ptr<RenewRenderingInstanceRequest> request);
  ResetRenderingInstanceResponse resetRenderingInstanceWithOptions(shared_ptr<ResetRenderingInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetRenderingInstanceResponse resetRenderingInstance(shared_ptr<ResetRenderingInstanceRequest> request);
  ResumeVsStreamResponse resumeVsStreamWithOptions(shared_ptr<ResumeVsStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeVsStreamResponse resumeVsStream(shared_ptr<ResumeVsStreamRequest> request);
  SendRenderingInstanceCommandsResponse sendRenderingInstanceCommandsWithOptions(shared_ptr<SendRenderingInstanceCommandsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendRenderingInstanceCommandsResponse sendRenderingInstanceCommands(shared_ptr<SendRenderingInstanceCommandsRequest> request);
  SetPresetResponse setPresetWithOptions(shared_ptr<SetPresetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetPresetResponse setPreset(shared_ptr<SetPresetRequest> request);
  SetVsDomainCertificateResponse setVsDomainCertificateWithOptions(shared_ptr<SetVsDomainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetVsDomainCertificateResponse setVsDomainCertificate(shared_ptr<SetVsDomainCertificateRequest> request);
  SetVsStreamsNotifyUrlConfigResponse setVsStreamsNotifyUrlConfigWithOptions(shared_ptr<SetVsStreamsNotifyUrlConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetVsStreamsNotifyUrlConfigResponse setVsStreamsNotifyUrlConfig(shared_ptr<SetVsStreamsNotifyUrlConfigRequest> request);
  StartDeviceResponse startDeviceWithOptions(shared_ptr<StartDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartDeviceResponse startDevice(shared_ptr<StartDeviceRequest> request);
  StartParentPlatformResponse startParentPlatformWithOptions(shared_ptr<StartParentPlatformRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartParentPlatformResponse startParentPlatform(shared_ptr<StartParentPlatformRequest> request);
  StartPublishStreamResponse startPublishStreamWithOptions(shared_ptr<StartPublishStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartPublishStreamResponse startPublishStream(shared_ptr<StartPublishStreamRequest> request);
  StartRecordStreamResponse startRecordStreamWithOptions(shared_ptr<StartRecordStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartRecordStreamResponse startRecordStream(shared_ptr<StartRecordStreamRequest> request);
  StartStreamResponse startStreamWithOptions(shared_ptr<StartStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartStreamResponse startStream(shared_ptr<StartStreamRequest> request);
  StartTransferStreamResponse startTransferStreamWithOptions(shared_ptr<StartTransferStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartTransferStreamResponse startTransferStream(shared_ptr<StartTransferStreamRequest> request);
  StopAdjustResponse stopAdjustWithOptions(shared_ptr<StopAdjustRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopAdjustResponse stopAdjust(shared_ptr<StopAdjustRequest> request);
  StopDeviceResponse stopDeviceWithOptions(shared_ptr<StopDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopDeviceResponse stopDevice(shared_ptr<StopDeviceRequest> request);
  StopMoveResponse stopMoveWithOptions(shared_ptr<StopMoveRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopMoveResponse stopMove(shared_ptr<StopMoveRequest> request);
  StopPublishStreamResponse stopPublishStreamWithOptions(shared_ptr<StopPublishStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopPublishStreamResponse stopPublishStream(shared_ptr<StopPublishStreamRequest> request);
  StopRecordStreamResponse stopRecordStreamWithOptions(shared_ptr<StopRecordStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopRecordStreamResponse stopRecordStream(shared_ptr<StopRecordStreamRequest> request);
  StopStreamResponse stopStreamWithOptions(shared_ptr<StopStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopStreamResponse stopStream(shared_ptr<StopStreamRequest> request);
  StopTransferStreamResponse stopTransferStreamWithOptions(shared_ptr<StopTransferStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopTransferStreamResponse stopTransferStream(shared_ptr<StopTransferStreamRequest> request);
  SyncCatalogsResponse syncCatalogsWithOptions(shared_ptr<SyncCatalogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncCatalogsResponse syncCatalogs(shared_ptr<SyncCatalogsRequest> request);
  UnbindDirectoryResponse unbindDirectoryWithOptions(shared_ptr<UnbindDirectoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindDirectoryResponse unbindDirectory(shared_ptr<UnbindDirectoryRequest> request);
  UnbindParentPlatformDeviceResponse unbindParentPlatformDeviceWithOptions(shared_ptr<UnbindParentPlatformDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindParentPlatformDeviceResponse unbindParentPlatformDevice(shared_ptr<UnbindParentPlatformDeviceRequest> request);
  UnbindPurchasedDeviceResponse unbindPurchasedDeviceWithOptions(shared_ptr<UnbindPurchasedDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindPurchasedDeviceResponse unbindPurchasedDevice(shared_ptr<UnbindPurchasedDeviceRequest> request);
  UnbindTemplateResponse unbindTemplateWithOptions(shared_ptr<UnbindTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindTemplateResponse unbindTemplate(shared_ptr<UnbindTemplateRequest> request);
  UninstallCloudAppResponse uninstallCloudAppWithOptions(shared_ptr<UninstallCloudAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UninstallCloudAppResponse uninstallCloudApp(shared_ptr<UninstallCloudAppRequest> request);
  UnlockDeviceResponse unlockDeviceWithOptions(shared_ptr<UnlockDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnlockDeviceResponse unlockDevice(shared_ptr<UnlockDeviceRequest> request);
  UpdateCloudAppInfoResponse updateCloudAppInfoWithOptions(shared_ptr<UpdateCloudAppInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCloudAppInfoResponse updateCloudAppInfo(shared_ptr<UpdateCloudAppInfoRequest> request);
  UpdateFileInfoResponse updateFileInfoWithOptions(shared_ptr<UpdateFileInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFileInfoResponse updateFileInfo(shared_ptr<UpdateFileInfoRequest> request);
  UpdateRenderingInstanceConfigurationResponse updateRenderingInstanceConfigurationWithOptions(shared_ptr<UpdateRenderingInstanceConfigurationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRenderingInstanceConfigurationResponse updateRenderingInstanceConfiguration(shared_ptr<UpdateRenderingInstanceConfigurationRequest> request);
  UpdateRenderingInstanceSettingsResponse updateRenderingInstanceSettingsWithOptions(shared_ptr<UpdateRenderingInstanceSettingsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRenderingInstanceSettingsResponse updateRenderingInstanceSettings(shared_ptr<UpdateRenderingInstanceSettingsRequest> request);
  UpdateVsPullStreamInfoConfigResponse updateVsPullStreamInfoConfigWithOptions(shared_ptr<UpdateVsPullStreamInfoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateVsPullStreamInfoConfigResponse updateVsPullStreamInfoConfig(shared_ptr<UpdateVsPullStreamInfoConfigRequest> request);
  UploadCloudAppResponse uploadCloudAppWithOptions(shared_ptr<UploadCloudAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadCloudAppResponse uploadCloudApp(shared_ptr<UploadCloudAppRequest> request);
  UploadFileResponse uploadFileWithOptions(shared_ptr<UploadFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadFileResponse uploadFile(shared_ptr<UploadFileRequest> request);
  UploadPublicKeyResponse uploadPublicKeyWithOptions(shared_ptr<UploadPublicKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadPublicKeyResponse uploadPublicKey(shared_ptr<UploadPublicKeyRequest> request);
  VerifyVsDomainOwnerResponse verifyVsDomainOwnerWithOptions(shared_ptr<VerifyVsDomainOwnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyVsDomainOwnerResponse verifyVsDomainOwner(shared_ptr<VerifyVsDomainOwnerRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Vs20181212

#endif
